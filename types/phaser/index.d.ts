// Type definitions for Phaser 3.16
// Project: http://phaser.io
// Definitions by: Richard Davey <https://github.com/photonstorm>
//                 Eirik <https://github.com/ampled>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.8

// PLEASE READ:
// This typings file is a modified version of the official typings file
// modified to comply with DefinitelyTyped guidelines.
// Before submitting a pull request to fix issues or improve this version of the type definitions,
// please consider also submitting a pull request to improve the jsdocs of the library itself at https://github.com/photonstorm/phaser.
// You can also help improve the official typings generation and parsing at the Phaser 3 documentation repository at https://github.com/photonstorm/phaser3-docs
// Further details in the readme-file included with these typings.

type CallCallback = (item: Phaser.GameObjects.GameObject) => void;

interface GridAlignConfig {
    /**
     * The width of the grid in items (not pixels). -1 means lay all items out horizontally, regardless of quantity.
     *                                  If both this value and height are set to -1 then this value overrides it and the `height` value is ignored.
     */
    width?: integer;
    /**
     * The height of the grid in items (not pixels). -1 means lay all items out vertically, regardless of quantity.
     *                                   If both this value and `width` are set to -1 then `width` overrides it and this value is ignored.
     */
    height?: integer;
    /**
     * The width of the cell, in pixels, in which the item is positioned.
     */
    cellWidth?: integer;
    /**
     * The height of the cell, in pixels, in which the item is positioned.
     */
    cellHeight?: integer;
    /**
     * The alignment position. One of the Phaser.Display.Align consts such as `TOP_LEFT` or `RIGHT_CENTER`.
     */
    position?: integer;
    /**
     * Optionally place the top-left of the final grid at this coordinate.
     */
    x?: number;
    /**
     * Optionally place the top-left of the final grid at this coordinate.
     */
    y?: number;
}

interface JSONCameraBounds {
    /**
     * The horizontal position of camera
     */
    x: number;
    /**
     * The vertical position of camera
     */
    y: number;
    /**
     * The width size of camera
     */
    width: number;
    /**
     * The height size of camera
     */
    height: number;
}

interface JSONCamera {
    /**
     * The name of the camera
     */
    name: string;
    /**
     * The horizontal position of camera
     */
    x: number;
    /**
     * The vertical position of camera
     */
    y: number;
    /**
     * The width size of camera
     */
    width: number;
    /**
     * The height size of camera
     */
    height: number;
    /**
     * The zoom of camera
     */
    zoom: number;
    /**
     * The rotation of camera
     */
    rotation: number;
    /**
     * The round pixels st status of camera
     */
    roundPixels: boolean;
    /**
     * The horizontal scroll of camera
     */
    scrollX: number;
    /**
     * The vertical scroll of camera
     */
    scrollY: number;
    /**
     * The background color of camera
     */
    backgroundColor: string;
    /**
     * The bounds of camera
     */
    bounds?: JSONCameraBounds;
}

interface InputJSONCameraObject {
    /**
     * The name of the Camera.
     */
    name?: string;
    /**
     * The horizontal position of the Camera viewport.
     */
    x?: integer;
    /**
     * The vertical position of the Camera viewport.
     */
    y?: integer;
    /**
     * The width of the Camera viewport.
     */
    width?: integer;
    /**
     * The height of the Camera viewport.
     */
    height?: integer;
    /**
     * The default zoom level of the Camera.
     */
    zoom?: number;
    /**
     * The rotation of the Camera, in radians.
     */
    rotation?: number;
    /**
     * Should the Camera round pixels before rendering?
     */
    roundPixels?: boolean;
    /**
     * The horizontal scroll position of the Camera.
     */
    scrollX?: number;
    /**
     * The vertical scroll position of the Camera.
     */
    scrollY?: number;
    /**
     * A CSS color string controlling the Camera background color.
     */
    backgroundColor?: false | string;
    /**
     * Defines the Camera bounds.
     */
    bounds?: object;
    /**
     * The top-left extent of the Camera bounds.
     */
    "bounds.x"?: number;
    /**
     * The top-left extent of the Camera bounds.
     */
    "bounds.y"?: number;
    /**
     * The width of the Camera bounds.
     */
    "bounds.width"?: number;
    /**
     * The height of the Camera bounds.
     */
    "bounds.height"?: number;
}

type CameraFadeCallback = (camera: Phaser.Cameras.Scene2D.Camera, progress: number) => void;

type CameraFlashCallback = (camera: Phaser.Cameras.Scene2D.Camera, progress: number) => void;

type CameraPanCallback = (camera: Phaser.Cameras.Scene2D.Camera, progress: number, x: number, y: number) => void;

type CameraShakeCallback = (camera: Phaser.Cameras.Scene2D.Camera, progress: number) => void;

type CameraZoomCallback = (camera: Phaser.Cameras.Scene2D.Camera, progress: number, zoom: number) => void;

interface FixedKeyControlConfig {
    /**
     * The Camera that this Control will update.
     */
    camera?: Phaser.Cameras.Scene2D.Camera;
    /**
     * The Key to be pressed that will move the Camera left.
     */
    left?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will move the Camera right.
     */
    right?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will move the Camera up.
     */
    up?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will move the Camera down.
     */
    down?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will zoom the Camera in.
     */
    zoomIn?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will zoom the Camera out.
     */
    zoomOut?: Phaser.Input.Keyboard.Key;
    /**
     * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.
     */
    zoomSpeed?: number;
    /**
     * The horizontal and vertical speed the camera will move.
     */
    speed?: number | object;
}

interface SmoothedKeyControlConfig {
    /**
     * The Camera that this Control will update.
     */
    camera?: Phaser.Cameras.Scene2D.Camera;
    /**
     * The Key to be pressed that will move the Camera left.
     */
    left?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will move the Camera right.
     */
    right?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will move the Camera up.
     */
    up?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will zoom the Camera in.
     */
    zoomIn?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will zoom the Camera out.
     */
    zoomOut?: Phaser.Input.Keyboard.Key;
    /**
     * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.
     */
    zoomSpeed?: number;
    /**
     * The horizontal and vertical acceleration the camera will move.
     */
    acceleration?: number | object;
    /**
     * The horizontal and vertical drag applied to the camera when it is moving.
     */
    drag?: number | object;
    /**
     * The maximum horizontal and vertical speed the camera will move.
     */
    maxSpeed?: number | object;
}

/**
 * This callback interface is completely empty, a no-operation.
 */
type NOOP = () => void;

type BootCallback = (game: Phaser.Game) => void;

/**
 * Config object containing various sound settings.
 */
interface AudioConfig {
    /**
     * Use HTML5 Audio instead of Web Audio.
     */
    disableWebAudio?: boolean;
    /**
     * An existing Web Audio context.
     */
    context?: AudioContext;
    /**
     * Disable all audio output.
     */
    noAudio?: boolean;
}

interface InputConfig {
    /**
     * Keyboard input configuration. `true` uses the default configuration and `false` disables keyboard input.
     */
    keyboard?: boolean | KeyboardInputConfig;
    /**
     * Mouse input configuration. `true` uses the default configuration and `false` disables mouse input.
     */
    mouse?: boolean | MouseInputConfig;
    /**
     * Touch input configuration. `true` uses the default configuration and `false` disables touch input.
     */
    touch?: boolean | TouchInputConfig;
    /**
     * Gamepad input configuration. `true` enables gamepad input.
     */
    gamepad?: boolean | GamepadInputConfig;
    /**
     * The maximum number of touch pointers. See {@link Phaser.Input.InputManager#pointers}.
     */
    activePointers?: integer;
    /**
     * The smoothing factor to apply during Pointer movement. See {@link Phaser.Input.Pointer#smoothFactor}.
     */
    smoothFactor?: number;
    /**
     * Should Phaser use a queued input system for native DOM Events or not?
     */
    inputQueue?: boolean;
}

interface MouseInputConfig {
    /**
     * Where the Mouse Manager listens for mouse input events. The default is the game canvas.
     */
    target?: any;
    /**
     * Whether mouse input events have `preventDefault` called on them.
     */
    capture?: boolean;
}

interface KeyboardInputConfig {
    /**
     * Where the Keyboard Manager listens for keyboard input events.
     */
    target?: any;
    /**
     * `preventDefault` will be called on every non-modified key which has a key code in this array. By default it is empty.
     */
    capture?: integer;
}

interface TouchInputConfig {
    /**
     * Where the Touch Manager listens for touch input events. The default is the game canvas.
     */
    target?: any;
    /**
     * Whether touch input events have preventDefault() called on them.
     */
    capture?: boolean;
}

interface GamepadInputConfig {
    /**
     * Where the Gamepad Manager listens for gamepad input events.
     */
    target?: any;
}

interface BannerConfig {
    /**
     * Omit Phaser's name and version from the banner.
     */
    hidePhaser?: boolean;
    /**
     * The color of the banner text.
     */
    text?: string;
    /**
     * The background colors of the banner.
     */
    background?: string[];
}

interface FPSConfig {
    /**
     * The minimum acceptable rendering rate, in frames per second.
     */
    min?: integer;
    /**
     * The optimum rendering rate, in frames per second.
     */
    target?: integer;
    /**
     * Use setTimeout instead of requestAnimationFrame to run the game loop.
     */
    forceSetTimeOut?: boolean;
    /**
     * Calculate the average frame delta from this many consecutive frame intervals.
     */
    deltaHistory?: integer;
    /**
     * The amount of frames the time step counts before we trust the delta values again.
     */
    panicMax?: integer;
}

interface RenderConfig {
    /**
     * When set to `true`, WebGL uses linear interpolation to draw scaled or rotated textures, giving a smooth appearance.
     * When set to `false`,WebGL uses nearest-neighbor interpolation, giving a crisper appearance.
     * `false` also disables antialiasing of the game canvas itself, if the browser supports it, when the game canvas is scaled.
     */
    antialias?: boolean;
    /**
     * Sets `antialias` and `roundPixels` to true. This is the best setting for pixel-art games.
     */
    pixelArt?: boolean;
    /**
     * Draw texture-based Game Objects at only whole-integer positions. Game Objects without textures, like Graphics, ignore this property.
     */
    roundPixels?: boolean;
    /**
     * Whether the game canvas will be transparent.
     */
    transparent?: boolean;
    /**
     * Whether the game canvas will be cleared between each rendering frame.
     */
    clearBeforeRender?: boolean;
    /**
     * In WebGL mode, the drawing buffer contains colors with pre-multiplied alpha.
     */
    premultipliedAlpha?: boolean;
    /**
     * Let the browser abort creating a WebGL context if it judges performance would be unacceptable.
     */
    failIfMajorPerformanceCaveat?: boolean;
    /**
     * "high-performance", "low-power" or "default". A hint to the browser on how much device power the game might use.
     */
    powerPreference?: string;
    /**
     * The default WebGL batch size.
     */
    batchSize?: integer;
    /**
     * The maximum number of lights allowed to be visible within range of a single Camera in the LightManager.
     */
    maxLights?: integer;
}

interface WidthHeight {
    /**
     * The width.
     */
    width?: integer;
    /**
     * The height.
     */
    height?: integer;
}

interface ScaleConfig {
    /**
     * The base width of your game. Can be an integer or a string: '100%'. If a string it will only work if you have set a parent element that has a size.
     */
    width?: integer | string;
    /**
     * The base height of your game. Can be an integer or a string: '100%'. If a string it will only work if you have set a parent element that has a size.
     */
    height?: integer | string;
    /**
     * The zoom value of the game canvas.
     */
    zoom?: Phaser.Scale.Zoominterface | integer;
    /**
     * The rendering resolution of the canvas. This is reserved for future use and is currently ignored.
     */
    resolution?: number;
    /**
     * The DOM element that will contain the game canvas, or its `id`.
     * If undefined, or if the named element doesn't exist, the game canvas is inserted directly into the document body.
     * If `null` no parent will be used and you are responsible for adding the canvas to your environment.
     */
    parent?: HTMLElement | string;
    /**
     * Is the Scale Manager allowed to adjust the CSS height property of the parent and/or document body to be 100%?
     */
    expandParent?: boolean;
    /**
     * The scale mode.
     */
    mode?: Phaser.Scale.ScaleModeinterface;
    /**
     * The minimum width and height the canvas can be scaled down to.
     */
    min?: WidthHeight;
    /**
     * The maximum width the canvas can be scaled up to.
     */
    max?: WidthHeight;
    /**
     * Automatically round the display and style sizes of the canvas. This can help with performance in lower-powered devices.
     */
    autoRound?: boolean;
    /**
     * Automatically center the canvas within the parent?
     */
    autoCenter?: Phaser.Scale.Centerinterface;
    /**
     * How many ms should elapse before checking if the browser size has changed?
     */
    resizeInterval?: integer;
    /**
     * The DOM element that will be sent into full screen mode, or its `id`. If undefined Phaser will create its own div and insert the canvas into it when entering fullscreen mode.
     */
    fullscreenTarget?: HTMLElement | string;
}

interface CallbacksConfig {
    /**
     * A function to run at the start of the boot sequence.
     */
    preBoot?: BootCallback;
    /**
     * A function to run at the end of the boot sequence. At this point, all the game systems have started and plugins have been loaded.
     */
    postBoot?: BootCallback;
}

interface LoaderConfig {
    /**
     * A URL used to resolve paths given to the loader. Example: 'http://labs.phaser.io/assets/'.
     */
    baseURL?: string;
    /**
     * A URL path used to resolve relative paths given to the loader. Example: 'images/sprites/'.
     */
    path?: string;
    /**
     * The maximum number of resources the loader will start loading at once.
     */
    maxParallelDownloads?: integer;
    /**
     * 'anonymous', 'use-credentials', or `undefined`.
     * If you're not making cross-origin requests, leave this as `undefined`. See {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes}.
     */
    crossOrigin?: string;
    /**
     * The response interface of the XHR request, e.g. `blob`, `text`, etc.
     */
    responseinterface?: string;
    /**
     * Should the XHR request use async or not?
     */
    async?: boolean;
    /**
     * Optional username for all XHR requests.
     */
    user?: string;
    /**
     * Optional password for all XHR requests.
     */
    password?: string;
    /**
     * Optional XHR timeout value, in ms.
     */
    timeout?: integer;
}

interface DOMContainerConfig {
    /**
     * Create a div element in which DOM Elements will be contained. You must also provide a parent.
     */
    createContainer?: boolean;
    /**
     * Place the DOM Container behind the Phaser Canvas. The default is to place it over the Canvas.
     */
    behindCanvas?: boolean;
}

interface ImagesConfig {
    /**
     * URL to use for the 'default' texture.
     */
    default?: string;
    /**
     * URL to use for the 'missing' texture.
     */
    missing?: string;
}

interface PhysicsConfig {
    /**
     * The default physics system. It will be started for each scene. Phaser provides 'arcade', 'impact', and 'matter'.
     */
    default?: string;
    /**
     * Arcade Physics configuration.
     */
    arcade?: ArcadeWorldConfig;
    /**
     * Impact Physics configuration.
     */
    impact?: Phaser.Physics.Impact.WorldConfig;
    /**
     * Matter Physics configuration.
     */
    matter?: object;
}

interface PluginObjectItem {
    /**
     * A key to identify the plugin in the Plugin Manager.
     */
    key?: string;
    /**
     * The plugin itself. Usually a class/constructor.
     */
    plugin?: any;
    /**
     * Whether the plugin should be started automatically.
     */
    start?: boolean;
    /**
     * For a scene plugin, add the plugin to the scene's systems object under this key (`this.sys.KEY`, from the scene).
     */
    systemKey?: string;
    /**
     * For a scene plugin, add the plugin to the scene object under this key (`this.KEY`, from the scene).
     */
    sceneKey?: string;
    /**
     * If this plugin is to be injected into the Scene Systems, this is the property key map used.
     */
    mapping?: string;
    /**
     * Arbitrary data passed to the plugin's init() method.
     */
    data?: any;
}

interface PluginObject {
    /**
     * Global plugins to install.
     */
    global?: PluginObjectItem[];
    /**
     * Scene plugins to install.
     */
    scene?: PluginObjectItem[];
    /**
     * The default set of scene plugins (names).
     */
    default?: string[];
    /**
     * Plugins to *add* to the default set of scene plugins.
     */
    defaultMerge?: string[];
}

interface GameConfig {
    /**
     * The width of the game, in game pixels.
     */
    width?: integer | string;
    /**
     * The height of the game, in game pixels.
     */
    height?: integer | string;
    /**
     * Simple scale applied to the game canvas. 2 is double size, 0.5 is half size, etc.
     */
    zoom?: number;
    /**
     * The size of each game pixel, in canvas pixels. Values larger than 1 are "high" resolution.
     */
    resolution?: number;
    /**
     * Which renderer to use. Phaser.AUTO, Phaser.CANVAS, Phaser.HEADLESS, or Phaser.WEBGL. AUTO picks WEBGL if available, otherwise CANVAS.
     */
    interface?: number;
    /**
     * The DOM element that will contain the game canvas, or its `id`. If undefined or if the named element doesn't exist, the game canvas is inserted directly into the document body.
     * If `null` no parent will be used and you are responsible for adding the canvas to your environment.
     */
    parent?: HTMLElement | string;
    /**
     * Provide your own Canvas element for Phaser to use instead of creating one.
     */
    canvas?: HTMLCanvasElement;
    /**
     * CSS styles to apply to the game canvas instead of Phaser's default styles.
     */
    canvasStyle?: string;
    /**
     * Provide your own Canvas Context for Phaser to use, instead of creating one.
     */
    context?: CanvasRenderingContext2D;
    /**
     * A scene or scenes to add to the game. If several are given, the first is started; the remainder are started only if they have { active: true }.
     */
    scene?: object;
    /**
     * Seed for the random number generator.
     */
    seed?: string[];
    /**
     * The title of the game. Shown in the browser console.
     */
    title?: string;
    /**
     * The URL of the game. Shown in the browser console.
     */
    url?: string;
    /**
     * The version of the game. Shown in the browser console.
     */
    version?: string;
    /**
     * Automatically call window.focus() when the game boots. Usually necessary to capture input events if the game is in a separate frame.
     */
    autoFocus?: boolean;
    /**
     * Input configuration, or `false` to disable all game input.
     */
    input?: boolean | InputConfig;
    /**
     * Disable the browser's default 'contextmenu' event (usually triggered by a right-button mouse click).
     */
    disableContextMenu?: boolean;
    /**
     * Configuration for the banner printed in the browser console when the game starts.
     */
    banner?: boolean | BannerConfig;
    /**
     * The DOM Container configuration object.
     */
    dom?: DOMContainerConfig;
    /**
     * Game loop configuration.
     */
    fps?: FPSConfig;
    /**
     * Game renderer configuration.
     */
    render?: RenderConfig;
    /**
     * The background color of the game canvas. The default is black.
     */
    backgroundColor?: string | number;
    /**
     * Optional callbacks to run before or after game boot.
     */
    callbacks?: CallbacksConfig;
    /**
     * Loader configuration.
     */
    loader?: LoaderConfig;
    /**
     * Images configuration.
     */
    images?: ImagesConfig;
    /**
     * Physics configuration.
     */
    physics?: object;
    /**
     * Plugins to install.
     */
    plugins?: PluginObject | PluginObjectItem[];
    /**
     * The Scale Manager configuration.
     */
    scale?: ScaleConfig;
}

declare namespace module {
    /**
     * "Computers are good at following instructions, but not at reading your mind." - Donald Knuth
     */
    const exports: any;
}

type TimeStepCallback = (time: number, average: number, interpolation: number) => void;

type GenerateTextureRendererCallback = (canvas: HTMLCanvasElement, context: CanvasRenderingContext2D) => void;

interface GenerateTextureConfig {
    /**
     * [description]
     */
    data?: any[];
    /**
     * [description]
     */
    canvas?: HTMLCanvasElement;
    /**
     * [description]
     */
    palette?: Palette;
    /**
     * The width of each 'pixel' in the generated texture.
     */
    pixelWidth?: number;
    /**
     * The height of each 'pixel' in the generated texture.
     */
    pixelHeight?: number;
    /**
     * [description]
     */
    resizeCanvas?: boolean;
    /**
     * [description]
     */
    clearCanvas?: boolean;
    /**
     * [description]
     */
    preRender?: GenerateTextureRendererCallback;
    /**
     * [description]
     */
    postRender?: GenerateTextureRendererCallback;
}

interface Palette {
    /**
     * Color value 1.
     */
    "0": string;
    /**
     * Color value 2.
     */
    "1": string;
    /**
     * Color value 3.
     */
    "2": string;
    /**
     * Color value 4.
     */
    "3": string;
    /**
     * Color value 5.
     */
    "4": string;
    /**
     * Color value 6.
     */
    "5": string;
    /**
     * Color value 7.
     */
    "6": string;
    /**
     * Color value 8.
     */
    "7": string;
    /**
     * Color value 9.
     */
    "8": string;
    /**
     * Color value 10.
     */
    "9": string;
    /**
     * Color value 11.
     */
    A: string;
    /**
     * Color value 12.
     */
    B: string;
    /**
     * Color value 13.
     */
    C: string;
    /**
     * Color value 14.
     */
    D: string;
    /**
     * Color value 15.
     */
    E: string;
    /**
     * Color value 16.
     */
    F: string;
}

interface JSONEllipseCurve {
    /**
     * The of the curve.
     */
    interface: string;
    /**
     * The x coordinate of the ellipse.
     */
    x: number;
    /**
     * The y coordinate of the ellipse.
     */
    y: number;
    /**
     * The horizontal radius of ellipse.
     */
    xRadius: number;
    /**
     * The vertical radius of ellipse.
     */
    yRadius: number;
    /**
     * The start angle of the ellipse, in degrees.
     */
    startAngle: integer;
    /**
     * The end angle of the ellipse, in degrees.
     */
    endAngle: integer;
    /**
     * Sets if the the ellipse rotation is clockwise (true) or anti-clockwise (false)
     */
    clockwise: boolean;
    /**
     * The rotation of ellipse, in degrees.
     */
    rotation: integer;
}

interface EllipseCurveConfig {
    /**
     * The x coordinate of the ellipse.
     */
    x?: number;
    /**
     * The y coordinate of the ellipse.
     */
    y?: number;
    /**
     * The horizontal radius of the ellipse.
     */
    xRadius?: number;
    /**
     * The vertical radius of the ellipse.
     */
    yRadius?: number;
    /**
     * The start angle of the ellipse, in degrees.
     */
    startAngle?: integer;
    /**
     * The end angle of the ellipse, in degrees.
     */
    endAngle?: integer;
    /**
     * Sets if the the ellipse rotation is clockwise (true) or anti-clockwise (false)
     */
    clockwise?: boolean;
    /**
     * The rotation of the ellipse, in degrees.
     */
    rotation?: integer;
}

interface JSONCurve {
    /**
     * The of the curve
     */
    interface: string;
    /**
     * The arrays of points like `[x1, y1, x2, y2]`
     */
    points: number[];
}

interface JSONPath {
    /**
     * The of the curve.
     */
    interface: string;
    /**
     * The X coordinate of the curve's starting point.
     */
    x: number;
    /**
     * The Y coordinate of the path's starting point.
     */
    y: number;
    /**
     * The path is auto closed.
     */
    autoClose: boolean;
    /**
     * The list of the curves
     */
    curves: JSONCurve[];
}

type DataEachCallback = (parent: any, key: string, value: any, ...args: any[]) => void;

/**
 * Checks for support of the Full Screen API.
 */
declare function init(): void;

interface InputColorObject {
    /**
     * The red color value in the range 0 to 255.
     */
    r?: number;
    /**
     * The green color value in the range 0 to 255.
     */
    g?: number;
    /**
     * The blue color value in the range 0 to 255.
     */
    b?: number;
    /**
     * The alpha color value in the range 0 to 255.
     */
    a?: number;
}

interface ColorObject {
    /**
     * The red color value in the range 0 to 255.
     */
    r: number;
    /**
     * The green color value in the range 0 to 255.
     */
    g: number;
    /**
     * The blue color value in the range 0 to 255.
     */
    b: number;
    /**
     * The alpha color value in the range 0 to 255.
     */
    a: number;
}

interface HSVColorObject {
    /**
     * The hue color value. A number between 0 and 1
     */
    h: number;
    /**
     * The saturation color value. A number between 0 and 1
     */
    s: number;
    /**
     * The lightness color value. A number between 0 and 1
     */
    v: number;
}

type ContentLoadedCallback = () => void;

interface DisplayCallbackConfig {
    /**
     * The Dynamic Bitmap Text object that owns this character being rendered.
     */
    parent: Phaser.GameObjects.DynamicBitmapText;
    /**
     * The tint of the character being rendered. Always zero in Canvas.
     */
    tint: object;
    /**
     * The index of the character being rendered.
     */
    index: number;
    /**
     * The character code of the character being rendered.
     */
    charCode: number;
    /**
     * The x position of the character being rendered.
     */
    x: number;
    /**
     * The y position of the character being rendered.
     */
    y: number;
    /**
     * The scale of the character being rendered.
     */
    scale: number;
    /**
     * The rotation of the character being rendered.
     */
    rotation: number;
    /**
     * Custom data stored with the character being rendered.
     */
    data: any;
}

type DisplayCallback = (display: DisplayCallbackConfig) => void;

interface BitmapTextConfig extends GameObjectConfig {
    /**
     * The key of the font to use from the BitmapFont cache.
     */
    font?: string;
    /**
     * The string, or array of strings, to be set as the content of this Bitmap Text.
     */
    text?: string;
    /**
     * The font size to set.
     */
    size?: number | false;
}

interface BitmapTextSize {
    /**
     * The position and size of the BitmapText, taking into account the position and scale of the Game Object.
     */
    global: GlobalBitmapTextSize;
    /**
     * The position and size of the BitmapText, taking just the font size into account.
     */
    local: LocalBitmapTextSize;
}

/**
 * The position and size of the Bitmap Text in global space, taking into account the Game Object's scale and world position.
 */
interface GlobalBitmapTextSize {
    /**
     * The x position of the BitmapText, taking into account the x position and scale of the Game Object.
     */
    x: number;
    /**
     * The y position of the BitmapText, taking into account the y position and scale of the Game Object.
     */
    y: number;
    /**
     * The width of the BitmapText, taking into account the x scale of the Game Object.
     */
    width: number;
    /**
     * The height of the BitmapText, taking into account the y scale of the Game Object.
     */
    height: number;
}

/**
 * The position and size of the Bitmap Text in local space, taking just the font size into account.
 */
interface LocalBitmapTextSize {
    /**
     * The x position of the BitmapText.
     */
    x: number;
    /**
     * The y position of the BitmapText.
     */
    y: number;
    /**
     * The width of the BitmapText.
     */
    width: number;
    /**
     * The height of the BitmapText.
     */
    height: number;
}

/**
 * The font data for an individual character of a Bitmap Font.
 *
 * Describes the character's position, size, offset and kerning.
 */
interface BitmapFontCharacterData {
    /**
     * The x position of the character.
     */
    x: number;
    /**
     * The y position of the character.
     */
    y: number;
    /**
     * The width of the character.
     */
    width: number;
    /**
     * The height of the character.
     */
    height: number;
    /**
     * The center x position of the character.
     */
    centerX: number;
    /**
     * The center y position of the character.
     */
    centerY: number;
    /**
     * The x offset of the character.
     */
    xOffset: number;
    /**
     * The y offset of the character.
     */
    yOffset: number;
    /**
     * Extra data for the character.
     */
    data: object;
    /**
     * Kerning values, keyed by character code.
     */
    kerning: {[key: string]: number};
}

/**
 * Bitmap Font data that can be used by a BitmapText Game Object.
 */
interface BitmapFontData {
    /**
     * The name of the font.
     */
    font: string;
    /**
     * The size of the font.
     */
    size: number;
    /**
     * The line height of the font.
     */
    lineHeight: number;
    /**
     * Whether this font is a retro font (monospace).
     */
    retroFont: boolean;
    /**
     * The character data of the font, keyed by character code. Each character datum includes a position, size, offset and more.
     */
    chars: {[key: number]: BitmapFontCharacterData};
}

interface JSONBitmapText extends JSONGameObject {
    /**
     * The name of the font.
     */
    font: string;
    /**
     * The text that this Bitmap Text displays.
     */
    text: string;
    /**
     * The size of the font.
     */
    fontSize: number;
    /**
     * Adds / Removes spacing between characters.
     */
    letterSpacing: number;
    /**
     * The alignment of the text in a multi-line BitmapText object.
     */
    align: integer;
}

type CreateCallback = (bob: Phaser.GameObjects.Bob, index: integer) => void;

interface GameObjectConfig {
    /**
     * The x position of the Game Object.
     */
    x?: number;
    /**
     * The y position of the Game Object.
     */
    y?: number;
    /**
     * The depth of the GameObject.
     */
    depth?: number;
    /**
     * The horizontally flipped state of the Game Object.
     */
    flipX?: boolean;
    /**
     * The vertically flipped state of the Game Object.
     */
    flipY?: boolean;
    /**
     * The scale of the GameObject.
     */
    scale?: number | object;
    /**
     * The scroll factor of the GameObject.
     */
    scrollFactor?: number | object;
    /**
     * The rotation angle of the Game Object, in radians.
     */
    rotation?: number;
    /**
     * The rotation angle of the Game Object, in degrees.
     */
    angle?: number;
    /**
     * The alpha (opacity) of the Game Object.
     */
    alpha?: number;
    /**
     * The origin of the Game Object.
     */
    origin?: number | object;
    /**
     * The scale mode of the GameObject.
     */
    scaleMode?: number;
    /**
     * The blend mode of the GameObject.
     */
    blendMode?: number;
    /**
     * The visible state of the Game Object.
     */
    visible?: boolean;
    /**
     * Add the GameObject to the scene.
     */
    add?: boolean;
}

interface JSONGameObject {
    /**
     * The name of this Game Object.
     */
    name: string;
    /**
     * A textual representation of this Game Object, i.e. `sprite`.
     */
    interface: string;
    /**
     * The x position of this Game Object.
     */
    x: number;
    /**
     * The y position of this Game Object.
     */
    y: number;
    /**
     * The scale of this Game Object
     */
    scale: object;
    /**
     * The horizontal scale of this Game Object.
     */
    "scale.x": number;
    /**
     * The vertical scale of this Game Object.
     */
    "scale.y": number;
    /**
     * The origin of this Game Object.
     */
    origin: object;
    /**
     * The horizontal origin of this Game Object.
     */
    "origin.x": number;
    /**
     * The vertical origin of this Game Object.
     */
    "origin.y": number;
    /**
     * The horizontally flipped state of the Game Object.
     */
    flipX: boolean;
    /**
     * The vertically flipped state of the Game Object.
     */
    flipY: boolean;
    /**
     * The angle of this Game Object in radians.
     */
    rotation: number;
    /**
     * The alpha value of the Game Object.
     */
    alpha: number;
    /**
     * The visible state of the Game Object.
     */
    visible: boolean;
    /**
     * The Scale Mode being used by this Game Object.
     */
    scaleMode: integer;
    /**
     * Sets the Blend Mode being used by this Game Object.
     */
    blendMode: integer | string;
    /**
     * The texture key of this Game Object.
     */
    textureKey: string;
    /**
     * The frame key of this Game Object.
     */
    frameKey: string;
    /**
     * The data of this Game Object.
     */
    data: object;
}

type EachContainerCallback<I> = (item: any, ...args: any[]) => void;

/**
 * Graphics line style (or stroke style) settings.
 */
interface GraphicsLineStyle {
    /**
     * The stroke width.
     */
    width?: number;
    /**
     * The stroke color.
     */
    color?: number;
    /**
     * The stroke alpha.
     */
    alpha?: number;
}

/**
 * Graphics fill style settings.
 */
interface GraphicsFillStyle {
    /**
     * The fill color.
     */
    color?: number;
    /**
     * The fill alpha.
     */
    alpha?: number;
}

/**
 * Graphics style settings.
 */
interface GraphicsStyles {
    /**
     * The style applied to shape outlines.
     */
    lineStyle?: GraphicsLineStyle;
    /**
     * The style applied to shape areas.
     */
    fillStyle?: GraphicsFillStyle;
}

/**
 * Options for the Graphics game Object.
 */
interface GraphicsOptions extends GraphicsStyles {
    /**
     * The x coordinate of the Graphics.
     */
    x?: number;
    /**
     * The y coordinate of the Graphics.
     */
    y?: number;
}

interface RoundedRectRadius {
    /**
     * Top left
     */
    tl?: number;
    /**
     * Top right
     */
    tr?: number;
    /**
     * Bottom right
     */
    br?: number;
    /**
     * Bottom left
     */
    bl?: number;
}

type GroupCallback = (item: Phaser.GameObjects.GameObject) => void;

type GroupMultipleCreateCallback = (items: Phaser.GameObjects.GameObject[]) => void;

interface GroupConfig {
    /**
     * Sets {@link Phaser.GameObjects.Group#classinterface}.
     */
    classinterface?: GroupClassinterfaceConstructor;
    /**
     * Sets {@link Phaser.GameObjects.Group#active}.
     */
    active?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Group#maxSize}.
     */
    maxSize?: number;
    /**
     * Sets {@link Phaser.GameObjects.Group#defaultKey}.
     */
    defaultKey?: string;
    /**
     * Sets {@link Phaser.GameObjects.Group#defaultFrame}.
     */
    defaultFrame?: string | integer;
    /**
     * Sets {@link Phaser.GameObjects.Group#runChildUpdate}.
     */
    runChildUpdate?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Group#createCallback}.
     */
    createCallback?: GroupCallback;
    /**
     * Sets {@link Phaser.GameObjects.Group#removeCallback}.
     */
    removeCallback?: GroupCallback;
    /**
     * Sets {@link Phaser.GameObjects.Group#createMultipleCallback}.
     */
    createMultipleCallback?: GroupMultipleCreateCallback;
}

/**
 * The total number of objects created will be
 *
 *     key.length * frame.length * frameQuantity * (yoyo ? 2 : 1) * (1 + repeat)
 *
 * In the simplest case, 1 + `repeat` objects will be created.
 *
 * If `max` is positive, then the total created will not exceed `max`.
 *
 * `key` is required. {@link Phaser.GameObjects.Group#defaultKey} is not used.
 */
interface GroupCreateConfig {
    /**
     * The class of each new Game Object.
     */
    classinterface?: GroupClassinterfaceConstructor;
    /**
     * The texture key of each new Game Object.
     */
    key?: string;
    /**
     * The texture frame of each new Game Object.
     */
    frame?: string | integer;
    /**
     * The visible state of each new Game Object.
     */
    visible?: boolean;
    /**
     * The active state of each new Game Object.
     */
    active?: boolean;
    /**
     * The number of times each `key` × `frame` combination will be *repeated* (after the first combination).
     */
    repeat?: number;
    /**
     * Select a `key` at random.
     */
    randomKey?: boolean;
    /**
     * Select a `frame` at random.
     */
    randomFrame?: boolean;
    /**
     * Select keys and frames by moving forward then backward through `key` and `frame`.
     */
    yoyo?: boolean;
    /**
     * The number of times each `frame` should be combined with one `key`.
     */
    frameQuantity?: number;
    /**
     * The maximum number of new Game Objects to create. 0 is no maximum.
     */
    max?: number;
    setXY?: object;
    /**
     * The horizontal position of each new Game Object.
     */
    "setXY.x"?: number;
    /**
     * The vertical position of each new Game Object.
     */
    "setXY.y"?: number;
    /**
     * Increment each Game Object's horizontal position from the previous by this amount, starting from `setXY.x`.
     */
    "setXY.stepX"?: number;
    /**
     * Increment each Game Object's vertical position from the previous by this amount, starting from `setXY.y`.
     */
    "setXY.stepY"?: number;
    setRotation?: object;
    /**
     * Rotation of each new Game Object.
     */
    "setRotation.value"?: number;
    /**
     * Increment each Game Object's rotation from the previous by this amount, starting at `setRotation.value`.
     */
    "setRotation.step"?: number;
    setScale?: object;
    /**
     * The horizontal scale of each new Game Object.
     */
    "setScale.x"?: number;
    /**
     * The vertical scale of each new Game Object.
     */
    "setScale.y"?: number;
    /**
     * Increment each Game Object's horizontal scale from the previous by this amount, starting from `setScale.x`.
     */
    "setScale.stepX"?: number;
    /**
     * Increment each Game object's vertical scale from the previous by this amount, starting from `setScale.y`.
     */
    "setScale.stepY"?: number;
    setAlpha?: object;
    /**
     * The alpha value of each new Game Object.
     */
    "setAlpha.value"?: number;
    /**
     * Increment each Game Object's alpha from the previous by this amount, starting from `setAlpha.value`.
     */
    "setAlpha.step"?: number;
    /**
     * A geometric shape that defines the hit area for the Game Object.
     */
    hitArea?: any;
    /**
     * A callback to be invoked when the Game Object is interacted with.
     */
    hitAreaCallback?: HitAreaCallback;
    /**
     * Align the new Game Objects in a grid using these settings.
     */
    gridAlign?: false | GridAlignConfig;
}

/**
 * A constructor function (class) that can be assigned to `classinterface`.
 */
type GroupClassinterfaceConstructor = (scene: Phaser.Scene, x: number, y: number, texture: string, frame?: string | integer) => void;

type LightForEach = (light: Phaser.GameObjects.Light) => void;

/**
 * The returned value sets what the property will be at the START of the particle's life, on emit.
 */
type EmitterOpOnEmitCallback = (particle: Phaser.GameObjects.Particles.Particle, key: string, value: number) => void;

/**
 * The returned value updates the property for the duration of the particle's life.
 */
type EmitterOpOnUpdateCallback = (particle: Phaser.GameObjects.Particles.Particle, key: string, t: number, value: number) => void;

/**
 * Defines an operation yielding a random value within a range.
 */
interface EmitterOpRandomConfig {
    /**
     * The minimum and maximum values, as [min, max].
     */
    random: number[];
}

/**
 * Defines an operation yielding a random value within a range.
 */
interface EmitterOpRandomMinMaxConfig {
    /**
     * The minimum value.
     */
    min: number;
    /**
     * The maximum value.
     */
    max: number;
}

/**
 * Defines an operation yielding a random value within a range.
 */
interface EmitterOpRandomStartEndConfig {
    /**
     * The starting value.
     */
    start: number;
    /**
     * The ending value.
     */
    end: number;
    /**
     * If false, this becomes {@link EmitterOpEaseConfig}.
     */
    random: boolean;
}

/**
 * Defines an operation yielding a value incremented continuously across a range.
 */
interface EmitterOpEaseConfig {
    /**
     * The starting value.
     */
    start: number;
    /**
     * The ending value.
     */
    end: number;
    /**
     * The name of the easing function.
     */
    ease?: string;
}

/**
 * Defines an operation yielding a value incremented by steps across a range.
 */
interface EmitterOpSteppedConfig {
    /**
     * The starting value.
     */
    start: number;
    /**
     * The ending value.
     */
    end: number;
    /**
     * The number of steps between start and end.
     */
    steps: number;
}

interface EmitterOpCustomEmitConfig {
    /**
     * A callback that is invoked each time the emitter emits a particle.
     */
    onEmit: EmitterOpOnEmitCallback;
}

interface EmitterOpCustomUpdateConfig {
    /**
     * A callback that is invoked each time the emitter emits a particle.
     */
    onEmit?: EmitterOpOnEmitCallback;
    /**
     * A callback that is invoked each time the emitter updates.
     */
    onUpdate: EmitterOpOnUpdateCallback;
}

interface GravityWellConfig {
    /**
     * The x coordinate of the Gravity Well, in world space.
     */
    x?: number;
    /**
     * The y coordinate of the Gravity Well, in world space.
     */
    y?: number;
    /**
     * The strength of the gravity force - larger numbers produce a stronger force.
     */
    power?: number;
    /**
     * The minimum distance for which the gravity force is calculated.
     */
    epsilon?: number;
    /**
     * The gravitational force of this Gravity Well.
     */
    gravity?: number;
}

type ParticleEmitterCallback = (particle: Phaser.GameObjects.Particles.Particle, emitter: Phaser.GameObjects.Particles.ParticleEmitter) => void;

type ParticleDeathCallback = (particle: Phaser.GameObjects.Particles.Particle) => void;

interface ParticleEmitterBounds {
    /**
     * The left edge of the rectangle.
     */
    x: number;
    /**
     * The top edge of the rectangle.
     */
    y: number;
    /**
     * The width of the rectangle.
     */
    width: number;
    /**
     * The height of the rectangle.
     */
    height: number;
}

interface ParticleEmitterBoundsAlt {
    /**
     * The left edge of the rectangle.
     */
    x: number;
    /**
     * The top edge of the rectangle.
     */
    y: number;
    /**
     * The width of the rectangle.
     */
    w: number;
    /**
     * The height of the rectangle.
     */
    h: number;
}

interface ParticleEmitterDeathZoneConfig {
    /**
     * A shape representing the zone. See {@link Phaser.GameObjects.Particles.Zones.DeathZone#source}.
     */
    source: DeathZoneSource;
    /**
     * 'onEnter' or 'onLeave'.
     */
    interface?: string;
}

interface ParticleEmitterEdgeZoneConfig {
    /**
     * A shape representing the zone. See {@link Phaser.GameObjects.Particles.Zones.EdgeZone#source}.
     */
    source: EdgeZoneSource;
    /**
     * 'edge'.
     */
    interface: string;
    /**
     * The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.
     */
    quantity: integer;
    /**
     * The distance between each particle. When set, `quantity` is implied and should be set to 0.
     */
    stepRate?: number;
    /**
     * Whether particles are placed from start to end and then end to start.
     */
    yoyo?: boolean;
    /**
     * Whether one endpoint will be removed if it's identical to the other.
     */
    seamless?: boolean;
}

interface ParticleEmitterRandomZoneConfig {
    /**
     * A shape representing the zone. See {@link Phaser.GameObjects.Particles.Zones.RandomZone#source}.
     */
    source: RandomZoneSource;
    /**
     * 'random'.
     */
    interface?: string;
}

interface ParticleEmitterConfig {
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#active}.
     */
    active?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#blendMode}.
     */
    blendMode?: integer;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#deathCallbackScope} and {@link Phaser.GameObjects.Particles.ParticleEmitter#emitCallbackScope}.
     */
    callbackScope?: any;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#collideBottom}.
     */
    collideBottom?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#collideLeft}.
     */
    collideLeft?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#collideRight}.
     */
    collideRight?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#collideTop}.
     */
    collideTop?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#deathCallback}.
     */
    deathCallback?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#deathCallbackScope}.
     */
    deathCallbackScope?: any;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#emitCallback}.
     */
    emitCallback?: CallbackFn;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#emitCallbackScope}.
     */
    emitCallbackScope?: any;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#follow}.
     */
    follow?: Phaser.GameObjects.GameObject;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#frequency}.
     */
    frequency?: number;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#gravityX}.
     */
    gravityX?: number;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#gravityY}.
     */
    gravityY?: number;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#maxParticles}.
     */
    maxParticles?: integer;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#name}.
     */
    name?: string;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#on}.
     */
    on?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#particleBringToTop}.
     */
    particleBringToTop?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#particleClass}.
     */
    particleClass?: Phaser.GameObjects.Particles.Particle;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#radial}.
     */
    radial?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#timeScale}.
     */
    timeScale?: number;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#trackVisible}.
     */
    trackVisible?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#visible}.
     */
    visible?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#accelerationX} (emit only).
     */
    accelerationX?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#accelerationY} (emit only).
     */
    accelerationY?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#alpha}.
     */
    alpha?: number | number[] | EmitterOpOnUpdateCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#angle} (emit only)
     */
    angle?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#bounce} (emit only).
     */
    bounce?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#delay} (emit only).
     */
    delay?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#lifespan} (emit only).
     */
    lifespan?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#maxVelocityX} (emit only).
     */
    maxVelocityX?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#maxVelocityY} (emit only).
     */
    maxVelocityY?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#moveToX} (emit only).
     */
    moveToX?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#moveToY} (emit only).
     */
    moveToY?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity} (emit only).
     */
    quantity?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#rotate}.
     */
    rotate?: number | number[] | EmitterOpOnUpdateCallback | object;
    /**
     * As {@link Phaser.GameObjects.Particles.ParticleEmitter#setScale}.
     */
    scale?: number | number[] | EmitterOpOnUpdateCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#scaleX}.
     */
    scaleX?: number | number[] | EmitterOpOnUpdateCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#scaleY}.
     */
    scaleY?: number | number[] | EmitterOpOnUpdateCallback | object;
    /**
     * As {@link Phaser.GameObjects.Particles.ParticleEmitter#setSpeed} (emit only).
     */
    speed?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#speedX} (emit only).
     */
    speedX?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#speedY} (emit only).
     */
    speedY?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#tint}.
     */
    tint?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#x} (emit only).
     */
    x?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#y} (emit only).
     */
    y?: number | number[] | EmitterOpOnEmitCallback | object;
    /**
     * As {@link Phaser.GameObjects.Particles.ParticleEmitter#setEmitZone}.
     */
    emitZone?: object;
    /**
     * As {@link Phaser.GameObjects.Particles.ParticleEmitter#setBounds}.
     */
    bounds?: ParticleEmitterBounds | ParticleEmitterBoundsAlt;
    /**
     * Assigns to {@link Phaser.GameObjects.Particles.ParticleEmitter#followOffset}.
     */
    followOffset?: object;
    /**
     * x-coordinate of the offset.
     */
    "followOffset.x"?: number;
    /**
     * y-coordinate of the offset.
     */
    "followOffset.y"?: number;
    /**
     * Sets {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.
     */
    frame?: number | number[] | string | string[] | Phaser.Textures.Frame | Phaser.Textures.Frame[] | ParticleEmitterFrameConfig;
}

interface ParticleEmitterFrameConfig {
    /**
     * One or more texture frames.
     */
    frames?: number | number[] | string | string[] | Phaser.Textures.Frame | Phaser.Textures.Frame[];
    /**
     * Whether texture frames will be assigned consecutively (true) or at random (false).
     */
    cycle?: boolean;
    /**
     * The number of consecutive particles receiving each texture frame, when `cycle` is true.
     */
    quantity?: integer;
}

type DeathZoneSourceCallback = (x: number, y: number) => void;

interface DeathZoneSource {
    contains: DeathZoneSourceCallback;
}

type EdgeZoneSourceCallback = (quantity: integer, stepRate?: number) => void;

interface EdgeZoneSource {
    /**
     * A function placing points on the source's edge or edges.
     */
    getPoints: EdgeZoneSourceCallback;
}

type RandomZoneSourceCallback = (point: Phaser.Math.Vector2) => void;

interface RandomZoneSource {
    /**
     * A function modifying its point argument.
     */
    getRandomPoint: RandomZoneSourceCallback;
}

/**
 * Settings for a PathFollower.
 */
interface PathConfig {
    /**
     * The duration of the path follow.
     */
    duration: number;
    /**
     * The start position of the path follow, between 0 and 1.
     */
    from: number;
    /**
     * The end position of the path follow, between 0 and 1.
     */
    to: number;
    /**
     * Whether to position the PathFollower on the Path using its path offset.
     */
    positionOnPath?: boolean;
    /**
     * Should the PathFollower automatically rotate to point in the direction of the Path?
     */
    rotateToPath?: boolean;
    /**
     * If the PathFollower is rotating to match the Path, this value is added to the rotation value. This allows you to rotate objects to a path but control the angle of the rotation as well.
     */
    rotationOffset?: number;
    /**
     * Current start position of the path follow, between 0 and 1.
     */
    startAt?: number;
}

interface RenderTextureConfig {
    /**
     * The x coordinate of the RenderTexture's position.
     */
    x?: number;
    /**
     * The y coordinate of the RenderTexture's position.
     */
    y?: number;
    /**
     * The width of the RenderTexture.
     */
    width?: number;
    /**
     * The height of the RenderTexture.
     */
    height?: number;
}

interface SpriteConfig extends GameObjectConfig {
    /**
     * The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
     */
    key?: string;
    /**
     * An optional frame from the Texture this Game Object is rendering with.
     */
    frame?: number | string;
}

/**
 * A custom function that will be responsible for wrapping the text.
 */
type TextStyleWordWrapCallback = (text: string, textObject: Phaser.GameObjects.Text) => void;

/**
 * Font metrics for a Text Style object.
 */
interface BitmapTextMetrics {
    /**
     * The ascent of the font.
     */
    ascent: number;
    /**
     * The descent of the font.
     */
    descent: number;
    /**
     * The size of the font.
     */
    fontSize: number;
}

interface TileSprite extends GameObjectConfig {
    /**
     * The x coordinate of the Tile Sprite.
     */
    x?: number;
    /**
     * The y coordinate of the Tile Sprite.
     */
    y?: number;
    /**
     * The width of the Tile Sprite. If zero it will use the size of the texture frame.
     */
    width?: integer;
    /**
     * The height of the Tile Sprite. If zero it will use the size of the texture frame.
     */
    height?: integer;
    /**
     * The key of the Texture this Tile Sprite will use to render with, as stored in the Texture Manager.
     */
    key?: string;
    /**
     * An optional frame from the Texture this Tile Sprite is rendering with.
     */
    frame?: string;
}

type CenterFunction = (triangle: Phaser.Geom.Triangle) => void;

type HitAreaCallback = (hitArea: any, x: number, y: number, gameObject: Phaser.GameObjects.GameObject) => void;

interface Pad {
    /**
     * The ID of the Gamepad.
     */
    id: string;
    /**
     * The index of the Gamepad.
     */
    index: integer;
}

interface InputPluginContainer {
    /**
     * The unique name of this plugin in the input plugin cache.
     */
    key: string;
    /**
     * The plugin to be stored. Should be the source object, not instantiated.
     */
    plugin: CallbackFn;
    /**
     * If this plugin is to be injected into the Input Plugin, this is the property key map used.
     */
    mapping?: string;
}

type KeyboardKeydownCallback = (event: KeyboardEvent) => void;

interface KeyComboConfig {
    /**
     * If they press the wrong key do we reset the combo?
     */
    resetOnWrongKey?: boolean;
    /**
     * The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.
     */
    maxKeyDelay?: number;
    /**
     * If previously matched and they press the first key of the combo again, will it reset?
     */
    resetOnMatch?: boolean;
    /**
     * If the combo matches, will it delete itself?
     */
    deleteOnMatch?: boolean;
}

interface FileConfig {
    /**
     * The file interface string (image, json, etc) for sorting within the Loader.
     */
    interface: string;
    /**
     * Unique cache key (unique within its file interface)
     */
    key: string;
    /**
     * The URL of the file, not including baseURL.
     */
    url?: string;
    /**
     * The path of the file, not including the baseURL.
     */
    path?: string;
    /**
     * The default extension this file uses.
     */
    extension?: string;
    /**
     * The responseinterface to be used by the XHR request.
     */
    responseinterface?: XMLHttpRequestResponseType;
    /**
     * Custom XHR Settings specific to this file and merged with the Loader defaults.
     */
    xhrSettings?: XHRSettingsObject | false;
    /**
     * A config object that can be used by file types to store transitional data.
     */
    config?: any;
}

interface XHRSettingsObject {
    /**
     * The response interface of the XHR request, i.e. `blob`, `text`, etc.
     */
    responseinterface: XMLHttpRequestResponseType;
    /**
     * Should the XHR request use async or not?
     */
    async?: boolean;
    /**
     * Optional username for the XHR request.
     */
    user?: string;
    /**
     * Optional password for the XHR request.
     */
    password?: string;
    /**
     * Optional XHR timeout value.
     */
    timeout?: integer;
    /**
     * This value is used to populate the XHR `setRequestHeader` and is undefined by default.
     */
    header?: string;
    /**
     * This value is used to populate the XHR `setRequestHeader` and is undefined by default.
     */
    headerValue?: string;
    /**
     * This value is used to populate the XHR `setRequestHeader` and is undefined by default.
     */
    requestedWith?: string;
    /**
     * Provide a custom mime-interface to use instead of the default.
     */
    overrideMimeinterface?: string;
}

interface SinCosTable {
    /**
     * The sine value.
     */
    sin: number;
    /**
     * The cosine value.
     */
    cos: number;
    /**
     * The length.
     */
    length: number;
}

interface Vector2Like {
    /**
     * The x component.
     */
    x: number;
    /**
     * The y component.
     */
    y: number;
}

declare namespace Phaser {
    namespace FacebookInstantGamesPlugin {
        /**
         * This class represents one single Leaderboard that belongs to a Facebook Instant Game.
         *
         * You do not need to instantiate this class directly, it will be created when you use the
         * `getLeaderboard()` method of the main plugin.
         */
        class Leaderboard {
            /**
             *
             * @param plugin A reference to the Facebook Instant Games Plugin.
             * @param data An Instant Game leaderboard instance.
             */
            constructor(plugin: FacebookInstantGamesPlugin, data: any);

            /**
             * A reference to the Facebook Instant Games Plugin.
             */
            plugin: FacebookInstantGamesPlugin;

            /**
             * An Instant Game leaderboard instance.
             */
            ref: any;

            /**
             * The name of the leaderboard.
             */
            name: string;

            /**
             * The ID of the context that the leaderboard is associated with, or null if the leaderboard is not tied to a particular context.
             */
            contextID: string;

            /**
             * The total number of player entries in the leaderboard.
             * This value defaults to zero. Populate it via the `getEntryCount()` method.
             */
            entryCount: integer;

            /**
             * The players score object.
             * This value defaults to `null`. Populate it via the `getPlayerScore()` method.
             */
            playerScore: LeaderboardScore;

            /**
             * The scores in the Leaderboard from the currently requested range.
             * This value defaults to an empty array. Populate it via the `getScores()` method.
             * The contents of this array are reset each time `getScores()` is called.
             */
            scores: LeaderboardScore[];

            /**
             * Fetches the total number of player entries in the leaderboard.
             *
             * The data is requested in an async call, so the result isn't available immediately.
             *
             * When the call completes this Leaderboard will emit the `getentrycount` event along with the count and name of the Leaderboard.
             */
            getEntryCount(): this;

            /**
             * Updates the player's score. If the player has an existing score, the old score will only be replaced if the new score is better than it.
             * NOTE: If the leaderboard is associated with a specific context, the game must be in that context to set a score for the player.
             *
             * The data is requested in an async call, so the result isn't available immediately.
             *
             * When the call completes this Leaderboard will emit the `setscore` event along with the LeaderboardScore object and the name of the Leaderboard.
             *
             * If the save fails the event will send `null` as the score value.
             * @param score The new score for the player. Must be a 64-bit integer number.
             * @param data Metadata to associate with the stored score. Must be less than 2KB in size. If an object is given it will be passed to `JSON.stringify`.
             */
            setScore(score: integer, data?: string | object): this;

            /**
             * Gets the players leaderboard entry and stores it in the `playerScore` property.
             *
             * The data is requested in an async call, so the result isn't available immediately.
             *
             * When the call completes this Leaderboard will emit the `getplayerscore` event along with the score and the name of the Leaderboard.
             *
             * If the player has not yet saved a score, the event will send `null` as the score value, and `playerScore` will be set to `null` as well.
             */
            getPlayerScore(): this;

            /**
             * Retrieves a set of leaderboard entries, ordered by score ranking in the leaderboard.
             *
             * The data is requested in an async call, so the result isn't available immediately.
             *
             * When the call completes this Leaderboard will emit the `getscores` event along with an array of LeaderboardScore entries and the name of the Leaderboard.
             * @param count The number of entries to attempt to fetch from the leaderboard. Currently, up to a maximum of 100 entries may be fetched per query. Default 10.
             * @param offset The offset from the top of the leaderboard that entries will be fetched from. Default 0.
             */
            getScores(count?: integer, offset?: integer): this;

            /**
             * Retrieves a set of leaderboard entries, based on the current player's connected players (including the current player), ordered by local rank within the set of connected players.
             *
             * The data is requested in an async call, so the result isn't available immediately.
             *
             * When the call completes this Leaderboard will emit the `getconnectedscores` event along with an array of LeaderboardScore entries and the name of the Leaderboard.
             * @param count The number of entries to attempt to fetch from the leaderboard. Currently, up to a maximum of 100 entries may be fetched per query. Default 10.
             * @param offset The offset from the top of the leaderboard that entries will be fetched from. Default 0.
             */
            getConnectedScores(count?: integer, offset?: integer): this;
        }
    }

    namespace Actions {
        /**
         * Takes an array of Game Objects, or any objects that have a public `angle` property,
         * and then adds the given value to each of their `angle` properties.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `Angle(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `angle` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function Angle<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of objects and passes each of them to the given callback.
         * @param items The array of items to be updated by this action.
         * @param callback The callback to be invoked. It will be passed just one argument: the item from the array.
         * @param context The scope in which the callback will be invoked.
         */
        function Call<G extends GameObjects.GameObject[]>(items: G, callback: CallCallback, context: any): G;

        /**
         * Takes an array of objects and returns the first element in the array that has properties which match
         * all of those specified in the `compare` object. For example, if the compare object was: `{ scaleX: 0.5, alpha: 1 }`
         * then it would return the first item which had the property `scaleX` set to 0.5 and `alpha` set to 1.
         *
         * To use this with a Group: `GetFirst(group.getChildren(), compare, index)`
         * @param items The array of items to be searched by this action.
         * @param compare The comparison object. Each property in this object will be checked against the items of the array.
         * @param index An optional offset to start searching from within the items array. Default 0.
         */
        function GetFirst<G extends GameObjects.GameObject>(items: G[], compare: object, index?: integer): G | GameObjects.GameObject;

        /**
         * Takes an array of objects and returns the last element in the array that has properties which match
         * all of those specified in the `compare` object. For example, if the compare object was: `{ scaleX: 0.5, alpha: 1 }`
         * then it would return the last item which had the property `scaleX` set to 0.5 and `alpha` set to 1.
         *
         * To use this with a Group: `GetLast(group.getChildren(), compare, index)`
         * @param items The array of items to be searched by this action.
         * @param compare The comparison object. Each property in this object will be checked against the items of the array.
         * @param index An optional offset to start searching from within the items array. Default 0.
         */
        function GetLast<G extends GameObjects.GameObject>(items: G[], compare: object, index?: integer): G | GameObjects.GameObject;

        /**
         * Takes an array of Game Objects, or any objects that have public `x` and `y` properties,
         * and then aligns them based on the grid configuration given to this action.
         * @param items The array of items to be updated by this action.
         * @param options The GridAlign Configuration object.
         */
        function GridAlign<G extends GameObjects.GameObject>(items: G[], options: GridAlignConfig): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `alpha` property,
         * and then adds the given value to each of their `alpha` properties.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `IncAlpha(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `alpha` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function IncAlpha<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `x` property,
         * and then adds the given value to each of their `x` properties.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `IncX(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `x` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function IncX<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have public `x` and `y` properties,
         * and then adds the given value to each of them.
         *
         * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `IncXY(group.getChildren(), x, y, stepX, stepY)`
         * @param items The array of items to be updated by this action.
         * @param x The amount to be added to the `x` property.
         * @param y The amount to be added to the `y` property. If `undefined` or `null` it uses the `x` value. Default x.
         * @param stepX This is added to the `x` amount, multiplied by the iteration counter. Default 0.
         * @param stepY This is added to the `y` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function IncXY<G extends GameObjects.GameObject[]>(items: G, x: number, y?: number, stepX?: number, stepY?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `y` property,
         * and then adds the given value to each of their `y` properties.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `IncY(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `y` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function IncY<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects and positions them on evenly spaced points around the perimeter of a Circle.
         *
         * If you wish to pass a `Phaser.GameObjects.Circle` Shape to this function, you should pass its `geom` property.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param circle The Circle to position the Game Objects on.
         * @param startAngle Optional angle to start position from, in radians. Default 0.
         * @param endAngle Optional angle to stop position at, in radians. Default 6.28.
         */
        function PlaceOnCircle<G extends GameObjects.GameObject[]>(items: G, circle: Geom.Circle, startAngle?: number, endAngle?: number): G;

        /**
         * Takes an array of Game Objects and positions them on evenly spaced points around the perimeter of an Ellipse.
         *
         * If you wish to pass a `Phaser.GameObjects.Ellipse` Shape to this function, you should pass its `geom` property.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param ellipse The Ellipse to position the Game Objects on.
         * @param startAngle Optional angle to start position from, in radians. Default 0.
         * @param endAngle Optional angle to stop position at, in radians. Default 6.28.
         */
        function PlaceOnEllipse<G extends GameObjects.GameObject[]>(items: G, ellipse: Geom.Ellipse, startAngle?: number, endAngle?: number): G;

        /**
         * Positions an array of Game Objects on evenly spaced points of a Line.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param line The Line to position the Game Objects on.
         */
        function PlaceOnLine<G extends GameObjects.GameObject[]>(items: G, line: Geom.Line): G;

        /**
         * Takes an array of Game Objects and positions them on evenly spaced points around the perimeter of a Rectangle.
         *
         * Placement starts from the top-left of the rectangle, and proceeds in a clockwise direction.
         * If the `shift` parameter is given you can offset where placement begins.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param rect The Rectangle to position the Game Objects on.
         * @param shift An optional positional offset. Default 1.
         */
        function PlaceOnRectangle<G extends GameObjects.GameObject[]>(items: G, rect: Geom.Rectangle, shift?: integer): G;

        /**
         * Takes an array of Game Objects and positions them on evenly spaced points around the edges of a Triangle.
         *
         * If you wish to pass a `Phaser.GameObjects.Triangle` Shape to this function, you should pass its `geom` property.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param triangle The Triangle to position the Game Objects on.
         * @param stepRate An optional step rate, to increase or decrease the packing of the Game Objects on the lines. Default 1.
         */
        function PlaceOnTriangle<G extends GameObjects.GameObject[]>(items: G, triangle: Geom.Triangle, stepRate?: number): G;

        /**
         * Play an animation with the given key, starting at the given startFrame on all Game Objects in items.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param key The name of the animation to play.
         * @param startFrame The starting frame of the animation with the given key.
         */
        function PlayAnimation<G extends GameObjects.GameObject[]>(items: G, key: string, startFrame?: string | integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public property as defined in `key`,
         * and then adds the given value to it.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `PropertyValueInc(group.getChildren(), key, value, step)`
         * @param items The array of items to be updated by this action.
         * @param key The property to be updated.
         * @param value The amount to be added to the property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function PropertyValueInc<G extends GameObjects.GameObject[]>(items: G, key: string, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public property as defined in `key`,
         * and then sets it to the given value.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `PropertyValueSet(group.getChildren(), key, value, step)`
         * @param items The array of items to be updated by this action.
         * @param key The property to be updated.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function PropertyValueSet<G extends GameObjects.GameObject[]>(items: G, key: string, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects and positions them at random locations within the Circle.
         *
         * If you wish to pass a `Phaser.GameObjects.Circle` Shape to this function, you should pass its `geom` property.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param circle The Circle to position the Game Objects within.
         */
        function RandomCircle<G extends GameObjects.GameObject[]>(items: G, circle: Geom.Circle): G;

        /**
         * Takes an array of Game Objects and positions them at random locations within the Ellipse.
         *
         * If you wish to pass a `Phaser.GameObjects.Ellipse` Shape to this function, you should pass its `geom` property.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param ellipse The Ellipse to position the Game Objects within.
         */
        function RandomEllipse<G extends GameObjects.GameObject[]>(items: G, ellipse: Geom.Ellipse): G;

        /**
         * Takes an array of Game Objects and positions them at random locations on the Line.
         *
         * If you wish to pass a `Phaser.GameObjects.Line` Shape to this function, you should pass its `geom` property.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param line The Line to position the Game Objects randomly on.
         */
        function RandomLine<G extends GameObjects.GameObject[]>(items: G, line: Geom.Line): G;

        /**
         * Takes an array of Game Objects and positions them at random locations within the Ellipse.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param rect The Rectangle to position the Game Objects within.
         */
        function RandomRectangle<G extends GameObjects.GameObject[]>(items: G, rect: Geom.Rectangle): G;

        /**
         * Takes an array of Game Objects and positions them at random locations within the Triangle.
         *
         * If you wish to pass a `Phaser.GameObjects.Triangle` Shape to this function, you should pass its `geom` property.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param triangle The Triangle to position the Game Objects within.
         */
        function RandomTriangle<G extends GameObjects.GameObject[]>(items: G, triangle: Geom.Triangle): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `rotation` property,
         * and then adds the given value to each of their `rotation` properties.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `Rotate(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `rotation` property (in radians).
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function Rotate<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Rotates each item around the given point by the given angle.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param point Any object with public `x` and `y` properties.
         * @param angle The angle to rotate by, in radians.
         */
        function RotateAround<G extends GameObjects.GameObject[]>(items: G, point: object, angle: number): G;

        /**
         * Rotates an array of Game Objects around a point by the given angle and distance.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param point Any object with public `x` and `y` properties.
         * @param angle The angle to rotate by, in radians.
         * @param distance The distance from the point of rotation in pixels.
         */
        function RotateAroundDistance<G extends GameObjects.GameObject[]>(items: G, point: object, angle: number, distance: number): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `scaleX` property,
         * and then adds the given value to each of their `scaleX` properties.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `ScaleX(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `scaleX` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function ScaleX<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have public `scaleX` and `scaleY` properties,
         * and then adds the given value to each of them.
         *
         * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `ScaleXY(group.getChildren(), scaleX, scaleY, stepX, stepY)`
         * @param items The array of items to be updated by this action.
         * @param scaleX The amount to be added to the `scaleX` property.
         * @param scaleY The amount to be added to the `scaleY` property. If `undefined` or `null` it uses the `scaleX` value.
         * @param stepX This is added to the `scaleX` amount, multiplied by the iteration counter. Default 0.
         * @param stepY This is added to the `y` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function ScaleXY<G extends GameObjects.GameObject[]>(items: G, scaleX: number, scaleY?: number, stepX?: number, stepY?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `scaleY` property,
         * and then adds the given value to each of their `scaleY` properties.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `ScaleY(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `scaleY` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function ScaleY<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `alpha`
         * and then sets it to the given value.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetAlpha(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetAlpha<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `blendMode`
         * and then sets it to the given value.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetBlendMode(group.getChildren(), value)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetBlendMode<G extends GameObjects.GameObject[]>(items: G, value: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `depth`
         * and then sets it to the given value.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetDepth(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetDepth<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Passes all provided Game Objects to the Input Manager to enable them for input with identical areas and callbacks.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param hitArea Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
         * @param hitAreaCallback A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.
         */
        function SetHitArea<G extends GameObjects.GameObject[]>(items: G, hitArea: any, hitAreaCallback: HitAreaCallback): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public properties `originX` and `originY`
         * and then sets them to the given values.
         *
         * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetOrigin(group.getChildren(), originX, originY, stepX, stepY)`
         * @param items The array of items to be updated by this action.
         * @param originX The amount to set the `originX` property to.
         * @param originY The amount to set the `originY` property to. If `undefined` or `null` it uses the `originX` value.
         * @param stepX This is added to the `originX` amount, multiplied by the iteration counter. Default 0.
         * @param stepY This is added to the `originY` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetOrigin<G extends GameObjects.GameObject[]>(items: G, originX: number, originY?: number, stepX?: number, stepY?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `rotation`
         * and then sets it to the given value.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetRotation(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetRotation<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public properties `scaleX` and `scaleY`
         * and then sets them to the given values.
         *
         * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetScale(group.getChildren(), scaleX, scaleY, stepX, stepY)`
         * @param items The array of items to be updated by this action.
         * @param scaleX The amount to set the `scaleX` property to.
         * @param scaleY The amount to set the `scaleY` property to. If `undefined` or `null` it uses the `scaleX` value.
         * @param stepX This is added to the `scaleX` amount, multiplied by the iteration counter. Default 0.
         * @param stepY This is added to the `scaleY` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetScale<G extends GameObjects.GameObject[]>(items: G, scaleX: number, scaleY?: number, stepX?: number, stepY?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `scaleX`
         * and then sets it to the given value.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetScaleX(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetScaleX<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `scaleY`
         * and then sets it to the given value.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetScaleY(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetScaleY<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public method setTint() and then updates it to the given value(s).
         * You can specify tint color per corner or provide only one color value for `topLeft` parameter, in which case whole item will be tinted with that color.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param topLeft The tint being applied to top-left corner of item. If other parameters are given no value, this tint will be applied to whole item.
         * @param topRight The tint to be applied to top-right corner of item.
         * @param bottomLeft The tint to be applied to the bottom-left corner of item.
         * @param bottomRight The tint to be applied to the bottom-right corner of item.
         */
        function SetTint<G extends GameObjects.GameObject[]>(items: G, topLeft: number, topRight?: number, bottomLeft?: number, bottomRight?: number): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `visible`
         * and then sets it to the given value.
         *
         * To use this with a Group: `SetVisible(group.getChildren(), value)`
         * @param items The array of items to be updated by this action.
         * @param value The value to set the property to.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetVisible<G extends GameObjects.GameObject[]>(items: G, value: boolean, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `x`
         * and then sets it to the given value.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetX(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetX<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public properties `x` and `y`
         * and then sets them to the given values.
         *
         * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetXY(group.getChildren(), x, y, stepX, stepY)`
         * @param items The array of items to be updated by this action.
         * @param x The amount to set the `x` property to.
         * @param y The amount to set the `y` property to. If `undefined` or `null` it uses the `x` value. Default x.
         * @param stepX This is added to the `x` amount, multiplied by the iteration counter. Default 0.
         * @param stepY This is added to the `y` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetXY<G extends GameObjects.GameObject[]>(items: G, x: number, y?: number, stepX?: number, stepY?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `y`
         * and then sets it to the given value.
         *
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         *
         * To use this with a Group: `SetY(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetY<G extends GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Iterate through the items array changing the position of each element to be that of the element that came before
         * it in the array (or after it if direction = 1)
         *
         * The first items position is set to x/y.
         *
         * The final x/y coords are returned
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param x The x coordinate to place the first item in the array at.
         * @param y The y coordinate to place the first item in the array at.
         * @param direction The iteration direction. 0 = first to last and 1 = last to first. Default 0.
         * @param output An optional objec to store the final objects position in.
         */
        function ShiftPosition<O = Math.Vector2>(items: GameObjects.GameObject, x: number, y: number, direction?: integer, output?: O): O;

        /**
         * Shuffles the array in place. The shuffled array is both modified and returned.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         */
        function Shuffle<G extends GameObjects.GameObject[]>(items: G): G;

        /**
         * Smootherstep is a sigmoid-like interpolation and clamping function.
         *
         * The function depends on three parameters, the input x, the "left edge" and the "right edge", with the left edge being assumed smaller than the right edge.
         * The function receives a real number x as an argument and returns 0 if x is less than or equal to the left edge, 1 if x is greater than or equal to the right edge,
         * and smoothly interpolates, using a Hermite polynomial, between 0 and 1 otherwise. The slope of the smoothstep function is zero at both edges.
         * This is convenient for creating a sequence of transitions using smoothstep to interpolate each segment as an alternative to using more sophisticated or expensive interpolation techniques.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param property The property of the Game Object to interpolate.
         * @param min The minimum interpolation value.
         * @param max The maximum interpolation value.
         * @param inc Should the values be incremented? `true` or set (`false`) Default false.
         */
        function SmootherStep<G extends GameObjects.GameObject[]>(items: G, property: string, min: number, max: number, inc?: boolean): G;

        /**
         * Smoothstep is a sigmoid-like interpolation and clamping function.
         *
         * The function depends on three parameters, the input x, the "left edge" and the "right edge", with the left edge being assumed smaller than the right edge.
         * The function receives a real number x as an argument and returns 0 if x is less than or equal to the left edge, 1 if x is greater than or equal to the right edge,
         * and smoothly interpolates, using a Hermite polynomial, between 0 and 1 otherwise. The slope of the smoothstep function is zero at both edges.
         * This is convenient for creating a sequence of transitions using smoothstep to interpolate each segment as an alternative to using more sophisticated or expensive interpolation techniques.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param property The property of the Game Object to interpolate.
         * @param min The minimum interpolation value.
         * @param max The maximum interpolation value.
         * @param inc Should the values be incremented? `true` or set (`false`) Default false.
         */
        function SmoothStep<G extends GameObjects.GameObject[]>(items: G, property: string, min: number, max: number, inc?: boolean): G;

        /**
         * Takes an array of Game Objects and then modifies their `property` so the value equals, or is incremented, the
         * calculated spread value.
         *
         * The spread value is derived from the given `min` and `max` values and the total number of items in the array.//#endregion
         *
         * For example, to cause an array of Sprites to change in alpha from 0 to 1 you could call:
         *
         * ```javascript
         * Phaser.Actions.Spread(itemsArray, 'alpha', 0, 1);
         * ```
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param property The property of the Game Object to spread.
         * @param min The minimum value.
         * @param max The maximum value.
         * @param inc Should the values be incremented? `true` or set (`false`) Default false.
         */
        function Spread<G extends GameObjects.GameObject[]>(items: G, property: string, min: number, max: number, inc?: boolean): G;

        /**
         * Takes an array of Game Objects and toggles the visibility of each one.
         * Those previously `visible = false` will become `visible = true`, and vice versa.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         */
        function ToggleVisible<G extends GameObjects.GameObject[]>(items: G): G;

        /**
         * Wrap each item's coordinates within a rectangle's area.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param rect The rectangle.
         * @param padding An amount added to each side of the rectangle during the operation. Default 0.
         */
        function WrapInRectangle<G extends GameObjects.GameObject[]>(items: G, rect: Geom.Rectangle, padding?: number): G;
    }

    namespace Animations {
        /**
         * A Frame based Animation.
         *
         * This consists of a key, some default values (like the frame rate) and a bunch of Frame objects.
         *
         * The Animation Manager creates these. Game Objects don't own an instance of these directly.
         * Game Objects have the Animation Component, which are like playheads to global Animations (these objects)
         * So multiple Game Objects can have playheads all pointing to this one Animation instance.
         */
        class Animation extends Phaser.Events.EventEmitter {
            /**
             *
             * @param manager A reference to the global Animation Manager
             * @param key The unique identifying string for this animation.
             * @param config The Animation configuration.
             */
            constructor(manager: AnimationManager, key: string, config: types.Animation);

            /**
             * A reference to the global Animation Manager.
             */
            manager: AnimationManager;

            /**
             * The unique identifying string for this animation.
             */
            key: string;

            /**
             * A frame based animation (as opposed to a bone based animation)
             */
            interface: string;

            /**
             * Extract all the frame data into the frames array.
             */
            frames: AnimationFrame[];

            /**
             * The frame rate of playback in frames per second (default 24 if duration is null)
             */
            frameRate: integer;

            /**
             * How long the animation should play for, in milliseconds.
             * If the `frameRate` property has been set then it overrides this value,
             * otherwise the `frameRate` is derived from `duration`.
             */
            duration: integer;

            /**
             * How many ms per frame, not including frame specific modifiers.
             */
            msPerFrame: integer;

            /**
             * Skip frames if the time lags, or always advanced anyway?
             */
            skipMissedFrames: boolean;

            /**
             * The delay in ms before the playback will begin.
             */
            delay: integer;

            /**
             * Number of times to repeat the animation. Set to -1 to repeat forever.
             */
            repeat: integer;

            /**
             * The delay in ms before the a repeat play starts.
             */
            repeatDelay: integer;

            /**
             * Should the animation yoyo (reverse back down to the start) before repeating?
             */
            yoyo: boolean;

            /**
             * Should the GameObject's `visible` property be set to `true` when the animation starts to play?
             */
            showOnStart: boolean;

            /**
             * Should the GameObject's `visible` property be set to `false` when the animation finishes?
             */
            hideOnComplete: boolean;

            /**
             * Global pause. All Game Objects using this Animation instance are impacted by this property.
             */
            paused: boolean;

            /**
             * Add frames to the end of the animation.
             * @param config [description]
             */
            addFrame(config: string | types.AnimationFrame[]): Animation;

            /**
             * Add frame/s into the animation.
             * @param index The index to insert the frame at within the animation.
             * @param config [description]
             */
            addFrameAt(index: integer, config: string | types.AnimationFrame[]): Animation;

            /**
             * Check if the given frame index is valid.
             * @param index The index to be checked.
             */
            checkFrame(index: integer): boolean;

            /**
             * [description]
             * @param component [description]
             */
            protected completeAnimation(component: GameObjects.Components.Animation): void;

            /**
             * [description]
             * @param component [description]
             * @param includeDelay [description] Default true.
             */
            protected getFirstTick(component: GameObjects.Components.Animation, includeDelay?: boolean): void;

            /**
             * Returns the AnimationFrame at the provided index
             * @param index The index in the AnimationFrame array
             */
            protected getFrameAt(index: integer): AnimationFrame;

            /**
             * [description]
             * @param textureManager [description]
             * @param frames [description]
             * @param defaultTextureKey [description]
             */
            getFrames(textureManager: Textures.TextureManager, frames: string | types.AnimationFrame[], defaultTextureKey?: string): AnimationFrame[];

            /**
             * [description]
             * @param component [description]
             */
            getNextTick(component: GameObjects.Components.Animation): void;

            /**
             * Returns the frame closest to the given progress value between 0 and 1.
             * @param value A value between 0 and 1.
             */
            getFrameByProgress(value: number): AnimationFrame;

            /**
             * Advance the animation frame.
             * @param component The Animation Component to advance.
             */
            nextFrame(component: GameObjects.Components.Animation): void;

            /**
             * Returns the animation last frame.
             */
            getLastFrame(): AnimationFrame;

            /**
             * [description]
             * @param component [description]
             */
            previousFrame(component: GameObjects.Components.Animation): void;

            /**
             * [description]
             * @param frame [description]
             */
            removeFrame(frame: AnimationFrame): Animation;

            /**
             * Removes a frame from the AnimationFrame array at the provided index
             * and updates the animation accordingly.
             * @param index The index in the AnimationFrame array
             */
            removeFrameAt(index: integer): Animation;

            /**
             * [description]
             * @param component [description]
             */
            repeatAnimation(component: GameObjects.Components.Animation): void;

            /**
             * Sets the texture frame the animation uses for rendering.
             * @param component [description]
             */
            setFrame(component: GameObjects.Components.Animation): void;

            /**
             * Converts the animation data to JSON.
             */
            toJSON(): types.JSONAnimation;

            /**
             * [description]
             */
            updateFrameSequence(): Animation;

            /**
             * [description]
             */
            pause(): Animation;

            /**
             * [description]
             */
            resume(): Animation;

            /**
             * [description]
             */
            destroy(): void;
        }

        /**
         * A single frame in an Animation sequence.
         *
         * An AnimationFrame consists of a reference to the Texture it uses for rendering, references to other
         * frames in the animation, and index data. It also has the ability to modify the animation timing.
         *
         * AnimationFrames are generated automatically by the Animation class.
         */
        class AnimationFrame {
            /**
             *
             * @param textureKey The key of the Texture this AnimationFrame uses.
             * @param textureFrame The key of the Frame within the Texture that this AnimationFrame uses.
             * @param index The index of this AnimationFrame within the Animation sequence.
             * @param frame A reference to the Texture Frame this AnimationFrame uses for rendering.
             */
            constructor(textureKey: string, textureFrame: string | integer, index: integer, frame: Textures.Frame);

            /**
             * The key of the Texture this AnimationFrame uses.
             */
            textureKey: string;

            /**
             * The key of the Frame within the Texture that this AnimationFrame uses.
             */
            textureFrame: string | integer;

            /**
             * The index of this AnimationFrame within the Animation sequence.
             */
            index: integer;

            /**
             * A reference to the Texture Frame this AnimationFrame uses for rendering.
             */
            frame: Textures.Frame;

            /**
             * Is this the first frame in an animation sequence?
             */
            readonly isFirst: boolean;

            /**
             * Is this the last frame in an animation sequence?
             */
            readonly isLast: boolean;

            /**
             * A reference to the AnimationFrame that comes before this one in the animation, if any.
             */
            readonly prevFrame: AnimationFrame;

            /**
             * A reference to the AnimationFrame that comes after this one in the animation, if any.
             */
            readonly nextFrame: AnimationFrame;

            /**
             * Additional time (in ms) that this frame should appear for during playback.
             * The value is added onto the msPerFrame set by the animation.
             */
            duration: number;

            /**
             * What % through the animation does this frame come?
             * This value is generated when the animation is created and cached here.
             */
            readonly progress: number;

            /**
             * Generates a JavaScript object suitable for converting to JSON.
             */
            toJSON(): types.JSONAnimationFrame;

            /**
             * Destroys this object by removing references to external resources and callbacks.
             */
            destroy(): void;
        }

        /**
         * The Animation Manager.
         *
         * Animations are managed by the global Animation Manager. This is a singleton class that is
         * responsible for creating and delivering animations and their corresponding data to all Game Objects.
         * Unlike plugins it is owned by the Game instance, not the Scene.
         *
         * Sprites and other Game Objects get the data they need from the AnimationManager.
         */
        class AnimationManager extends Phaser.Events.EventEmitter {
            /**
             *
             * @param game A reference to the Phaser.Game instance.
             */
            constructor(game: Game);

            /**
             * A reference to the Phaser.Game instance.
             */
            protected game: Game;

            /**
             * A reference to the Texture Manager.
             */
            protected textureManager: Textures.TextureManager;

            /**
             * The global time scale of the Animation Manager.
             *
             * This scales the time delta between two frames, thus influencing the speed of time for the Animation Manager.
             */
            globalTimeScale: number;

            /**
             * The Animations registered in the Animation Manager.
             *
             * This map should be modified with the {@link #add} and {@link #create} methods of the Animation Manager.
             */
            protected anims: Structs.Map<string, Animation>;

            /**
             * Whether the Animation Manager is paused along with all of its Animations.
             */
            paused: boolean;

            /**
             * The name of this Animation Manager.
             */
            name: string;

            /**
             * Registers event listeners after the Game boots.
             */
            boot(): void;

            /**
             * Adds an existing Animation to the Animation Manager.
             * @param key The key under which the Animation should be added. The Animation will be updated with it. Must be unique.
             * @param animation The Animation which should be added to the Animation Manager.
             */
            add(key: string, animation: Animation): AnimationManager;

            /**
             * Checks to see if the given key is already in use within the Animation Manager or not.
             *
             * Animations are global. Keys created in one scene can be used from any other Scene in your game. They are not Scene specific.
             * @param key The key of the Animation to check.
             */
            exists(key: string): boolean;

            /**
             * Creates a new Animation and adds it to the Animation Manager.
             *
             * Animations are global. Once created, you can use them in any Scene in your game. They are not Scene specific.
             *
             * If an invalid key is given this method will return `false`.
             *
             * If you pass the key of an animation that already exists in the Animation Manager, that animation will be returned.
             *
             * A brand new animation is only created if the key is valid and not already in use.
             *
             * If you wish to re-use an existing key, call `AnimationManager.remove` first, then this method.
             * @param config The configuration settings for the Animation.
             */
            create(config: types.Animation): Animation | false;

            /**
             * Loads this Animation Manager's Animations and settings from a JSON object.
             * @param data The JSON object to parse.
             * @param clearCurrentAnimations If set to `true`, the current animations will be removed (`anims.clear()`). If set to `false` (default), the animations in `data` will be added.
             * Default false.
             */
            fromJSON(data: string | types.JSONAnimations | types.JSONAnimation, clearCurrentAnimations?: boolean): Animation[];

            /**
             * [description]
             * @param key The key for the texture containing the animation frames.
             * @param config The configuration object for the animation frame names.
             */
            generateFrameNames(key: string, config?: types.GenerateFrameNames): types.AnimationFrame[];

            /**
             * Generate an array of {@link Phaser.Animations.types.AnimationFrame} objects from a texture key and configuration object.
             *
             * Generates objects with numbered frame names, as configured by the given {@link Phaser.Animations.types.GenerateFrameNumbers}.
             * @param key The key for the texture containing the animation frames.
             * @param config The configuration object for the animation frames.
             */
            generateFrameNumbers(key: string, config: types.GenerateFrameNumbers): types.AnimationFrame[];

            /**
             * Get an Animation.
             * @param key The key of the Animation to retrieve.
             */
            get(key: string): Animation;

            /**
             * Load an Animation into a Game Object's Animation Component.
             * @param child The Game Object to load the animation into.
             * @param key The key of the animation to load.
             * @param startFrame The name of a start frame to set on the loaded animation.
             */
            load(child: GameObjects.GameObject, key: string, startFrame?: string | integer): GameObjects.GameObject;

            /**
             * Pause all animations.
             */
            pauseAll(): AnimationManager;

            /**
             * Play an animation on the given Game Objects that have an Animation Component.
             * @param key The key of the animation to play on the Game Object.
             * @param child The Game Objects to play the animation on.
             */
            play(key: string, child: GameObjects.GameObject | GameObjects.GameObject[]): AnimationManager;

            /**
             * Remove an animation.
             * @param key The key of the animation to remove.
             */
            remove(key: string): Animation;

            /**
             * Resume all paused animations.
             */
            resumeAll(): AnimationManager;

            /**
             * Takes an array of Game Objects that have an Animation Component and then
             * starts the given animation playing on them, each one offset by the
             * `stagger` amount given to this method.
             * @param key The key of the animation to play on the Game Objects.
             * @param children An array of Game Objects to play the animation on. They must have an Animation Component.
             * @param stagger The amount of time, in milliseconds, to offset each play time by. Default 0.
             */
            staggerPlay<G extends GameObjects.GameObject>(key: string, children: G | G[], stagger?: number): G;

            /**
             * Get the animation data as javascript object by giving key, or get the data of all animations as array of objects, if key wasn't provided.
             * @param key [description]
             */
            toJSON(key: string): types.JSONAnimations;

            /**
             * Destroy this Animation Manager and clean up animation definitions and references to other objects.
             * This method should not be called directly. It will be called automatically as a response to a `destroy` event from the Phaser.Game instance.
             */
            destroy(): void;
        }

        namespace Events {
            /**
             * The Add Animation Event.
             *
             * This event is dispatched when a new animation is added to the global Animation Manager.
             *
             * This can happen either as a result of an animation instance being added to the Animation Manager,
             * or the Animation Manager creating a new animation directly.
             */
            const ADD_ANIMATION: any;

            /**
             * The Animation Complete Event.
             *
             * This event is dispatched by an Animation instance when it completes, i.e. finishes playing or is manually stopped.
             *
             * Be careful with the volume of events this could generate. If a group of Sprites all complete the same
             * animation at the same time, this event will invoke its handler for each one of them.
             */
            const ANIMATION_COMPLETE: any;

            /**
             * The Animation Repeat Event.
             *
             * This event is dispatched when a currently playing animation repeats.
             *
             * The event is dispatched directly from the Animation object itself. Which means that listeners
             * bound to this event will be invoked every time the Animation repeats, for every Game Object that may have it.
             */
            const ANIMATION_REPEAT: any;

            /**
             * The Animation Restart Event.
             *
             * This event is dispatched by an Animation instance when it restarts.
             *
             * Be careful with the volume of events this could generate. If a group of Sprites all restart the same
             * animation at the same time, this event will invoke its handler for each one of them.
             */
            const ANIMATION_RESTART: any;

            /**
             * The Animation Start Event.
             *
             * This event is dispatched by an Animation instance when it starts playing.
             *
             * Be careful with the volume of events this could generate. If a group of Sprites all play the same
             * animation at the same time, this event will invoke its handler for each one of them.
             */
            const ANIMATION_START: any;

            /**
             * The Pause All Animations Event.
             *
             * This event is dispatched when the global Animation Manager is told to pause.
             *
             * When this happens all current animations will stop updating, although it doesn't necessarily mean
             * that the game has paused as well.
             */
            const PAUSE_ALL: any;

            /**
             * The Remove Animation Event.
             *
             * This event is dispatched when an animation is removed from the global Animation Manager.
             */
            const REMOVE_ANIMATION: any;

            /**
             * The Resume All Animations Event.
             *
             * This event is dispatched when the global Animation Manager resumes, having been previously paused.
             *
             * When this happens all current animations will continue updating again.
             */
            const RESUME_ALL: any;

            /**
             * The Sprite Animation Complete Event.
             *
             * This event is dispatched by a Sprite when an animation finishes playing on it.
             *
             * Listen for it on the Sprite using `sprite.on('animationcomplete', listener)`
             *
             * This same event is dispatched for all animations. To listen for a specific animation, use the `SPRITE_ANIMATION_KEY_COMPLETE` event.
             */
            const SPRITE_ANIMATION_COMPLETE: any;

            /**
             * The Sprite Animation Key Complete Event.
             *
             * This event is dispatched by a Sprite when a specific animation finishes playing on it.
             *
             * Listen for it on the Sprite using `sprite.on('animationcomplete-key', listener)` where `key` is the key of
             * the animation. For example, if you had an animation with the key 'explode' you should listen for `animationcomplete-explode`.
             */
            const SPRITE_ANIMATION_KEY_COMPLETE: any;

            /**
             * The Sprite Animation Key Repeat Event.
             *
             * This event is dispatched by a Sprite when a specific animation repeats playing on it.
             *
             * Listen for it on the Sprite using `sprite.on('animationrepeat-key', listener)` where `key` is the key of
             * the animation. For example, if you had an animation with the key 'explode' you should listen for `animationrepeat-explode`.
             */
            const SPRITE_ANIMATION_KEY_REPEAT: any;

            /**
             * The Sprite Animation Key Restart Event.
             *
             * This event is dispatched by a Sprite when a specific animation restarts playing on it.
             *
             * Listen for it on the Sprite using `sprite.on('animationrestart-key', listener)` where `key` is the key of
             * the animation. For example, if you had an animation with the key 'explode' you should listen for `animationrestart-explode`.
             */
            const SPRITE_ANIMATION_KEY_RESTART: any;

            /**
             * The Sprite Animation Key Start Event.
             *
             * This event is dispatched by a Sprite when a specific animation starts playing on it.
             *
             * Listen for it on the Sprite using `sprite.on('animationstart-key', listener)` where `key` is the key of
             * the animation. For example, if you had an animation with the key 'explode' you should listen for `animationstart-explode`.
             */
            const SPRITE_ANIMATION_KEY_START: any;

            /**
             * The Sprite Animation Key Update Event.
             *
             * This event is dispatched by a Sprite when a specific animation playing on it updates. This happens when the animation changes frame,
             * based on the animation frame rate and other factors like `timeScale` and `delay`.
             *
             * Listen for it on the Sprite using `sprite.on('animationupdate-key', listener)` where `key` is the key of
             * the animation. For example, if you had an animation with the key 'explode' you should listen for `animationupdate-explode`.
             */
            const SPRITE_ANIMATION_KEY_UPDATE: any;

            /**
             * The Sprite Animation Repeat Event.
             *
             * This event is dispatched by a Sprite when an animation repeats playing on it.
             *
             * Listen for it on the Sprite using `sprite.on('animationrepeat', listener)`
             *
             * This same event is dispatched for all animations. To listen for a specific animation, use the `SPRITE_ANIMATION_KEY_REPEAT` event.
             */
            const SPRITE_ANIMATION_REPEAT: any;

            /**
             * The Sprite Animation Restart Event.
             *
             * This event is dispatched by a Sprite when an animation restarts playing on it.
             *
             * Listen for it on the Sprite using `sprite.on('animationrestart', listener)`
             *
             * This same event is dispatched for all animations. To listen for a specific animation, use the `SPRITE_ANIMATION_KEY_RESTART` event.
             */
            const SPRITE_ANIMATION_RESTART: any;

            /**
             * The Sprite Animation Start Event.
             *
             * This event is dispatched by a Sprite when an animation starts playing on it.
             *
             * Listen for it on the Sprite using `sprite.on('animationstart', listener)`
             *
             * This same event is dispatched for all animations. To listen for a specific animation, use the `SPRITE_ANIMATION_KEY_START` event.
             */
            const SPRITE_ANIMATION_START: any;

            /**
             * The Sprite Animation Update Event.
             *
             * This event is dispatched by a Sprite when an animation playing on it updates. This happens when the animation changes frame,
             * based on the animation frame rate and other factors like `timeScale` and `delay`.
             *
             * Listen for it on the Sprite using `sprite.on('animationupdate', listener)`
             *
             * This same event is dispatched for all animations. To listen for a specific animation, use the `SPRITE_ANIMATION_KEY_UPDATE` event.
             */
            const SPRITE_ANIMATION_UPDATE: any;
        }

        namespace types {
            interface Animation {
                /**
                 * The key that the animation will be associated with. i.e. sprite.animations.play(key)
                 */
                key?: string;
                /**
                 * An object containing data used to generate the frames for the animation
                 */
                frames?: AnimationFrame[];
                /**
                 * The key of the texture all frames of the animation will use. Can be overridden on a per frame basis.
                 */
                defaultTextureKey?: string;
                /**
                 * The frame rate of playback in frames per second (default 24 if duration is null)
                 */
                frameRate?: integer;
                /**
                 * How long the animation should play for in milliseconds. If not given its derived from frameRate.
                 */
                duration?: integer;
                /**
                 * Skip frames if the time lags, or always advanced anyway?
                 */
                skipMissedFrames?: boolean;
                /**
                 * Delay before starting playback. Value given in milliseconds.
                 */
                delay?: integer;
                /**
                 * Number of times to repeat the animation (-1 for infinity)
                 */
                repeat?: integer;
                /**
                 * Delay before the animation repeats. Value given in milliseconds.
                 */
                repeatDelay?: integer;
                /**
                 * Should the animation yoyo? (reverse back down to the start) before repeating?
                 */
                yoyo?: boolean;
                /**
                 * Should sprite.visible = true when the animation starts to play?
                 */
                showOnStart?: boolean;
                /**
                 * Should sprite.visible = false when the animation finishes?
                 */
                hideOnComplete?: boolean;
            }

            interface AnimationFrame {
                /**
                 * The key that the animation will be associated with. i.e. sprite.animations.play(key)
                 */
                key: string;
                /**
                 * [description]
                 */
                frame: string | number;
                /**
                 * [description]
                 */
                duration?: number;
                /**
                 * [description]
                 */
                visible?: boolean;
            }

            interface GenerateFrameNames {
                /**
                 * The string to append to every resulting frame name if using a range or an array of `frames`.
                 */
                prefix?: string;
                /**
                 * If `frames` is not provided, the number of the first frame to return.
                 */
                start?: integer;
                /**
                 * If `frames` is not provided, the number of the last frame to return.
                 */
                end?: integer;
                /**
                 * The string to append to every resulting frame name if using a range or an array of `frames`.
                 */
                suffix?: string;
                /**
                 * The minimum expected lengths of each resulting frame's number.
                 * Numbers will be left-padded with zeroes until they are this long, then prepended and appended to create the resulting frame name.
                 */
                zeroPad?: integer;
                /**
                 * The array to append the created configuration objects to.
                 */
                outputArray?: AnimationFrame[];
                /**
                 * If provided as an array, the range defined by `start` and `end` will be ignored and these frame numbers will be used.
                 */
                frames?: boolean;
            }

            interface GenerateFrameNumbers {
                /**
                 * The starting frame of the animation.
                 */
                start?: integer;
                /**
                 * The ending frame of the animation.
                 */
                end?: integer;
                /**
                 * A frame to put at the beginning of the animation, before `start` or `outputArray` or `frames`.
                 */
                first?: boolean | integer;
                /**
                 * An array to concatenate the output onto.
                 */
                outputArray?: AnimationFrame[];
                /**
                 * A custom sequence of frames.
                 */
                frames?: boolean | integer[];
            }

            interface JSONAnimation {
                /**
                 * The key that the animation will be associated with. i.e. sprite.animations.play(key)
                 */
                key: string;
                /**
                 * A frame based animation (as opposed to a bone based animation)
                 */
                interface: string;
                /**
                 * [description]
                 */
                frames: JSONAnimationFrame[];
                /**
                 * The frame rate of playback in frames per second (default 24 if duration is null)
                 */
                frameRate: integer;
                /**
                 * How long the animation should play for in milliseconds. If not given its derived from frameRate.
                 */
                duration: integer;
                /**
                 * Skip frames if the time lags, or always advanced anyway?
                 */
                skipMissedFrames: boolean;
                /**
                 * Delay before starting playback. Value given in milliseconds.
                 */
                delay: integer;
                /**
                 * Number of times to repeat the animation (-1 for infinity)
                 */
                repeat: integer;
                /**
                 * Delay before the animation repeats. Value given in milliseconds.
                 */
                repeatDelay: integer;
                /**
                 * Should the animation yoyo? (reverse back down to the start) before repeating?
                 */
                yoyo: boolean;
                /**
                 * Should sprite.visible = true when the animation starts to play?
                 */
                showOnStart: boolean;
                /**
                 * Should sprite.visible = false when the animation finishes?
                 */
                hideOnComplete: boolean;
            }

            interface JSONAnimationFrame {
                /**
                 * The key of the Texture this AnimationFrame uses.
                 */
                key: string;
                /**
                 * The key of the Frame within the Texture that this AnimationFrame uses.
                 */
                frame: string | integer;
                /**
                 * Additional time (in ms) that this frame should appear for during playback.
                 */
                duration: number;
            }

            interface JSONAnimations {
                /**
                 * An array of all Animations added to the Animation Manager.
                 */
                anims: JSONAnimation[];
                /**
                 * The global time scale of the Animation Manager.
                 */
                globalTimeScale: number;
            }
        }
    }

    namespace Cache {
        /**
         * The BaseCache is a base Cache class that can be used for storing references to any kind of data.
         *
         * Data can be added, retrieved and removed based on the given keys.
         *
         * Keys are string-based.
         */
        class BaseCache {
            /**
             * The Map in which the cache objects are stored.
             *
             * You can query the Map directly or use the BaseCache methods.
             */
            entries: Structs.Map<string, any>;

            /**
             * An instance of EventEmitter used by the cache to emit related events.
             */
            events: Phaser.Events.EventEmitter;

            /**
             * Adds an item to this cache. The item is referenced by a unique string, which you are responsible
             * for setting and keeping track of. The item can only be retrieved by using this string.
             * @param key The unique key by which the data added to the cache will be referenced.
             * @param data The data to be stored in the cache.
             */
            add(key: string, data: any): BaseCache;

            /**
             * Checks if this cache contains an item matching the given key.
             * This performs the same action as `BaseCache.exists`.
             * @param key The unique key of the item to be checked in this cache.
             */
            has(key: string): boolean;

            /**
             * Checks if this cache contains an item matching the given key.
             * This performs the same action as `BaseCache.has` and is called directly by the Loader.
             * @param key The unique key of the item to be checked in this cache.
             */
            exists(key: string): boolean;

            /**
             * Gets an item from this cache based on the given key.
             * @param key The unique key of the item to be retrieved from this cache.
             */
            get(key: string): any;

            /**
             * Removes and item from this cache based on the given key.
             *
             * If an entry matching the key is found it is removed from the cache and a `remove` event emitted.
             * No additional checks are done on the item removed. If other systems or parts of your game code
             * are relying on this item, it is up to you to sever those relationships prior to removing the item.
             * @param key The unique key of the item to remove from the cache.
             */
            remove(key: string): BaseCache;

            /**
             * Destroys this cache and all items within it.
             */
            destroy(): void;
        }

        /**
         * The Cache Manager is the global cache owned and maintained by the Game instance.
         *
         * Various systems, such as the file Loader, rely on this cache in order to store the files
         * it has loaded. The manager itself doesn't store any files, but instead owns multiple BaseCache
         * instances, one per interface of file. You can also add your own custom caches.
         */
        class CacheManager {
            /**
             *
             * @param game A reference to the Phaser.Game instance that owns this CacheManager.
             */
            constructor(game: Game);

            /**
             * A reference to the Phaser.Game instance that owns this CacheManager.
             */
            protected game: Game;

            /**
             * A Cache storing all binary files, typically added via the Loader.
             */
            binary: BaseCache;

            /**
             * A Cache storing all bitmap font data files, typically added via the Loader.
             * Only the font data is stored in this cache, the textures are part of the Texture Manager.
             */
            bitmapFont: BaseCache;

            /**
             * A Cache storing all JSON data files, typically added via the Loader.
             */
            json: BaseCache;

            /**
             * A Cache storing all physics data files, typically added via the Loader.
             */
            physics: BaseCache;

            /**
             * A Cache storing all shader source files, typically added via the Loader.
             */
            shader: BaseCache;

            /**
             * A Cache storing all non-streaming audio files, typically added via the Loader.
             */
            audio: BaseCache;

            /**
             * A Cache storing all text files, typically added via the Loader.
             */
            text: BaseCache;

            /**
             * A Cache storing all html files, typically added via the Loader.
             */
            html: BaseCache;

            /**
             * A Cache storing all WaveFront OBJ files, typically added via the Loader.
             */
            obj: BaseCache;

            /**
             * A Cache storing all tilemap data files, typically added via the Loader.
             * Only the data is stored in this cache, the textures are part of the Texture Manager.
             */
            tilemap: BaseCache;

            /**
             * A Cache storing all xml data files, typically added via the Loader.
             */
            xml: BaseCache;

            /**
             * An object that contains your own custom BaseCache entries.
             * Add to this via the `addCustom` method.
             */
            custom: {[key: string]: BaseCache};

            /**
             * Add your own custom Cache for storing your own files.
             * The cache will be available under `Cache.custom.key`.
             * The cache will only be created if the key is not already in use.
             * @param key The unique key of your custom cache.
             */
            addCustom(key: string): BaseCache;

            /**
             * Removes all entries from all BaseCaches and destroys all custom caches.
             */
            destroy(): void;
        }

        namespace Events {
            /**
             * The Cache Add Event.
             *
             * This event is dispatched by any Cache that extends the BaseCache each time a new object is added to it.
             */
            const ADD: any;

            /**
             * The Cache Remove Event.
             *
             * This event is dispatched by any Cache that extends the BaseCache each time an object is removed from it.
             */
            const REMOVE: any;
        }
    }

    namespace Cameras {
        namespace Scene2D {
            /**
             * A Base Camera class.
             *
             * The Camera is the way in which all games are rendered in Phaser. They provide a view into your game world,
             * and can be positioned, rotated, zoomed and scrolled accordingly.
             *
             * A Camera consists of two elements: The viewport and the scroll values.
             *
             * The viewport is the physical position and size of the Camera within your game. Cameras, by default, are
             * created the same size as your game, but their position and size can be set to anything. This means if you
             * wanted to create a camera that was 320x200 in size, positioned in the bottom-right corner of your game,
             * you'd adjust the viewport to do that (using methods like `setViewport` and `setSize`).
             *
             * If you wish to change where the Camera is looking in your game, then you scroll it. You can do this
             * via the properties `scrollX` and `scrollY` or the method `setScroll`. Scrolling has no impact on the
             * viewport, and changing the viewport has no impact on the scrolling.
             *
             * By default a Camera will render all Game Objects it can see. You can change this using the `ignore` method,
             * allowing you to filter Game Objects out on a per-Camera basis.
             *
             * The Base Camera is extended by the Camera class, which adds in special effects including Fade,
             * Flash and Camera Shake, as well as the ability to follow Game Objects.
             *
             * The Base Camera was introduced in Phaser 3.12. It was split off from the Camera class, to allow
             * you to isolate special effects as needed. Therefore the 'since' values for properties of this class relate
             * to when they were added to the Camera class.
             */
            class BaseCamera extends Phaser.Events.EventEmitter implements GameObjects.Components.Alpha, GameObjects.Components.Visible {
                /**
                 *
                 * @param x The x position of the Camera, relative to the top-left of the game canvas.
                 * @param y The y position of the Camera, relative to the top-left of the game canvas.
                 * @param width The width of the Camera, in pixels.
                 * @param height The height of the Camera, in pixels.
                 */
                constructor(x: number, y: number, width: number, height: number);

                /**
                 * A reference to the Scene this camera belongs to.
                 */
                scene: Scene;

                /**
                 * A reference to the Game Scene Manager.
                 */
                sceneManager: Scenes.SceneManager;

                /**
                 * A reference to the Game Scale Manager.
                 */
                scaleManager: Scale.ScaleManager;

                /**
                 * The Camera ID. Assigned by the Camera Manager and used to handle camera exclusion.
                 * This value is a bitmask.
                 */
                readonly id: integer;

                /**
                 * The name of the Camera. This is left empty for your own use.
                 */
                name: string;

                /**
                 * This property is un-used in v3.16.
                 *
                 * The resolution of the Game, used in most Camera calculations.
                 */
                readonly resolution: number;

                /**
                 * Should this camera round its pixel values to integers?
                 */
                roundPixels: boolean;

                /**
                 * Is this Camera visible or not?
                 *
                 * A visible camera will render and perform input tests.
                 * An invisible camera will not render anything and will skip input tests.
                 */
                visible: boolean;

                /**
                 * Is this Camera using a bounds to restrict scrolling movement?
                 *
                 * Set this property along with the bounds via `Camera.setBounds`.
                 */
                useBounds: boolean;

                /**
                 * The World View is a Rectangle that defines the area of the 'world' the Camera is currently looking at.
                 * This factors in the Camera viewport size, zoom and scroll position and is updated in the Camera preRender step.
                 * If you have enabled Camera bounds the worldview will be clamped to those bounds accordingly.
                 * You can use it for culling or intersection checks.
                 */
                readonly worldView: Geom.Rectangle;

                /**
                 * Is this Camera dirty?
                 *
                 * A dirty Camera has had either its viewport size, bounds, scroll, rotation or zoom levels changed since the last frame.
                 *
                 * This flag is cleared during the `postRenderCamera` method of the renderer.
                 */
                dirty: boolean;

                /**
                 * Does this Camera have a transparent background?
                 */
                transparent: boolean;

                /**
                 * The background color of this Camera. Only used if `transparent` is `false`.
                 */
                backgroundColor: Display.Color;

                /**
                 * The Camera alpha value. Setting this property impacts every single object that this Camera
                 * renders. You can either set the property directly, i.e. via a Tween, to fade a Camera in or out,
                 * or via the chainable `setAlpha` method instead.
                 */
                alpha: number;

                /**
                 * Should the camera cull Game Objects before checking them for input hit tests?
                 * In some special cases it may be beneficial to disable this.
                 */
                disableCull: boolean;

                /**
                 * The mid-point of the Camera in 'world' coordinates.
                 *
                 * Use it to obtain exactly where in the world the center of the camera is currently looking.
                 *
                 * This value is updated in the preRender method, after the scroll values and follower
                 * have been processed.
                 */
                readonly midPoint: Math.Vector2;

                /**
                 * The horizontal origin of rotation for this Camera.
                 *
                 * By default the camera rotates around the center of the viewport.
                 *
                 * Changing the origin allows you to adjust the point in the viewport from which rotation happens.
                 * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.
                 *
                 * See `setOrigin` to set both origins in a single, chainable call.
                 */
                originX: number;

                /**
                 * The vertical origin of rotation for this Camera.
                 *
                 * By default the camera rotates around the center of the viewport.
                 *
                 * Changing the origin allows you to adjust the point in the viewport from which rotation happens.
                 * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.
                 *
                 * See `setOrigin` to set both origins in a single, chainable call.
                 */
                originY: number;

                /**
                 * Set the Alpha level of this Camera. The alpha controls the opacity of the Camera as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 * @param value The Camera alpha value. Default 1.
                 */
                setAlpha(value?: number): this;

                /**
                 * Sets the rotation origin of this Camera.
                 *
                 * The values are given in the range 0 to 1 and are only used when calculating Camera rotation.
                 *
                 * By default the camera rotates around the center of the viewport.
                 *
                 * Changing the origin allows you to adjust the point in the viewport from which rotation happens.
                 * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): this;

                /**
                 * Calculates what the Camera.scrollX and scrollY values would need to be in order to move
                 * the Camera so it is centered on the given x and y coordinates, without actually moving
                 * the Camera there. The results are clamped based on the Camera bounds, if set.
                 * @param x The horizontal coordinate to center on.
                 * @param y The vertical coordinate to center on.
                 * @param out A Vec2 to store the values in. If not given a new Vec2 is created.
                 */
                getScroll(x: number, y: number, out?: Math.Vector2): Math.Vector2;

                /**
                 * Moves the Camera horizontally so that it is centered on the given x coordinate, bounds allowing.
                 * Calling this does not change the scrollY value.
                 * @param x The horizontal coordinate to center on.
                 */
                centerOnX(x: number): BaseCamera;

                /**
                 * Moves the Camera vertically so that it is centered on the given y coordinate, bounds allowing.
                 * Calling this does not change the scrollX value.
                 * @param y The vertical coordinate to center on.
                 */
                centerOnY(y: number): BaseCamera;

                /**
                 * Moves the Camera so that it is centered on the given coordinates, bounds allowing.
                 * @param x The horizontal coordinate to center on.
                 * @param y The vertical coordinate to center on.
                 */
                centerOn(x: number, y: number): BaseCamera;

                /**
                 * Moves the Camera so that it is looking at the center of the Camera Bounds, if enabled.
                 */
                centerToBounds(): BaseCamera;

                /**
                 * Moves the Camera so that it is re-centered based on its viewport size.
                 */
                centerToSize(): BaseCamera;

                /**
                 * Takes an array of Game Objects and returns a new array featuring only those objects
                 * visible by this camera.
                 * @param renderableObjects An array of Game Objects to cull.
                 */
                cull<G extends GameObjects.GameObject[]>(renderableObjects: G): G;

                /**
                 * Converts the given `x` and `y` coordinates into World space, based on this Cameras transform.
                 * You can optionally provide a Vector2, or similar object, to store the results in.
                 * @param x The x position to convert to world space.
                 * @param y The y position to convert to world space.
                 * @param output An optional object to store the results in. If not provided a new Vector2 will be created.
                 */
                getWorldPoint<O extends Math.Vector2>(x: number, y: number, output?: O): O;

                /**
                 * Given a Game Object, or an array of Game Objects, it will update all of their camera filter settings
                 * so that they are ignored by this Camera. This means they will not be rendered by this Camera.
                 * @param entries The Game Object, or array of Game Objects, to be ignored by this Camera.
                 */
                ignore(entries: GameObjects.GameObject | GameObjects.GameObject[] | GameObjects.Group): BaseCamera;

                /**
                 * Internal preRender step.
                 * @param resolution The game resolution, as set in the Scale Manager.
                 */
                protected preRender(resolution: number): void;

                /**
                 * Takes an x value and checks it's within the range of the Camera bounds, adjusting if required.
                 * Do not call this method if you are not using camera bounds.
                 * @param x The value to horizontally scroll clamp.
                 */
                clampX(x: number): number;

                /**
                 * Takes a y value and checks it's within the range of the Camera bounds, adjusting if required.
                 * Do not call this method if you are not using camera bounds.
                 * @param y The value to vertically scroll clamp.
                 */
                clampY(y: number): number;

                /**
                 * If this Camera has previously had movement bounds set on it, this will remove them.
                 */
                removeBounds(): BaseCamera;

                /**
                 * Set the rotation of this Camera. This causes everything it renders to appear rotated.
                 *
                 * Rotating a camera does not rotate the viewport itself, it is applied during rendering.
                 * @param value The cameras angle of rotation, given in degrees. Default 0.
                 */
                setAngle(value?: number): BaseCamera;

                /**
                 * Sets the background color for this Camera.
                 *
                 * By default a Camera has a transparent background but it can be given a solid color, with any level
                 * of transparency, via this method.
                 *
                 * The color value can be specified using CSS color notation, hex or numbers.
                 * @param color The color value. In CSS, hex or numeric color notation. Default 'rgba(0,0,0,0)'.
                 */
                setBackgroundColor(color?: string | number | InputColorObject): BaseCamera;

                /**
                 * Set the bounds of the Camera. The bounds are an axis-aligned rectangle.
                 *
                 * The Camera bounds controls where the Camera can scroll to, stopping it from scrolling off the
                 * edges and into blank space. It does not limit the placement of Game Objects, or where
                 * the Camera viewport can be positioned.
                 *
                 * Temporarily disable the bounds by changing the boolean `Camera.useBounds`.
                 *
                 * Clear the bounds entirely by calling `Camera.removeBounds`.
                 *
                 * If you set bounds that are smaller than the viewport it will stop the Camera from being
                 * able to scroll. The bounds can be positioned where-ever you wish. By default they are from
                 * 0x0 to the canvas width x height. This means that the coordinate 0x0 is the top left of
                 * the Camera bounds. However, you can position them anywhere. So if you wanted a game world
                 * that was 2048x2048 in size, with 0x0 being the center of it, you can set the bounds x/y
                 * to be -1024, -1024, with a width and height of 2048. Depending on your game you may find
                 * it easier for 0x0 to be the top-left of the bounds, or you may wish 0x0 to be the middle.
                 * @param x The top-left x coordinate of the bounds.
                 * @param y The top-left y coordinate of the bounds.
                 * @param width The width of the bounds, in pixels.
                 * @param height The height of the bounds, in pixels.
                 * @param centerOn If `true` the Camera will automatically be centered on the new bounds. Default false.
                 */
                setBounds(x: integer, y: integer, width: integer, height: integer, centerOn?: boolean): BaseCamera;

                /**
                 * Returns a rectangle containing the bounds of the Camera.
                 *
                 * If the Camera does not have any bounds the rectangle will be empty.
                 *
                 * The rectangle is a copy of the bounds, so is safe to modify.
                 * @param out An optional Rectangle to store the bounds in. If not given, a new Rectangle will be created.
                 */
                getBounds(out?: Geom.Rectangle): Geom.Rectangle;

                /**
                 * Sets the name of this Camera.
                 * This value is for your own use and isn't used internally.
                 * @param value The name of the Camera. Default ''.
                 */
                setName(value?: string): BaseCamera;

                /**
                 * Set the position of the Camera viewport within the game.
                 *
                 * This does not change where the camera is 'looking'. See `setScroll` to control that.
                 * @param x The top-left x coordinate of the Camera viewport.
                 * @param y The top-left y coordinate of the Camera viewport. Default x.
                 */
                setPosition(x: number, y?: number): BaseCamera;

                /**
                 * Set the rotation of this Camera. This causes everything it renders to appear rotated.
                 *
                 * Rotating a camera does not rotate the viewport itself, it is applied during rendering.
                 * @param value The rotation of the Camera, in radians. Default 0.
                 */
                setRotation(value?: number): BaseCamera;

                /**
                 * Should the Camera round pixel values to whole integers when rendering Game Objects?
                 *
                 * In some types of game, especially with pixel art, this is required to prevent sub-pixel aliasing.
                 * @param value `true` to round Camera pixels, `false` to not.
                 */
                setRoundPixels(value: boolean): BaseCamera;

                /**
                 * Sets the Scene the Camera is bound to.
                 *
                 * Also populates the `resolution` property and updates the internal size values.
                 * @param scene The Scene the camera is bound to.
                 */
                setScene(scene: Scene): BaseCamera;

                /**
                 * Set the position of where the Camera is looking within the game.
                 * You can also modify the properties `Camera.scrollX` and `Camera.scrollY` directly.
                 * Use this method, or the scroll properties, to move your camera around the game world.
                 *
                 * This does not change where the camera viewport is placed. See `setPosition` to control that.
                 * @param x The x coordinate of the Camera in the game world.
                 * @param y The y coordinate of the Camera in the game world. Default x.
                 */
                setScroll(x: number, y?: number): BaseCamera;

                /**
                 * Set the size of the Camera viewport.
                 *
                 * By default a Camera is the same size as the game, but can be made smaller via this method,
                 * allowing you to create mini-cam style effects by creating and positioning a smaller Camera
                 * viewport within your game.
                 * @param width The width of the Camera viewport.
                 * @param height The height of the Camera viewport. Default width.
                 */
                setSize(width: integer, height?: integer): BaseCamera;

                /**
                 * This method sets the position and size of the Camera viewport in a single call.
                 *
                 * If you're trying to change where the Camera is looking at in your game, then see
                 * the method `Camera.setScroll` instead. This method is for changing the viewport
                 * itself, not what the camera can see.
                 *
                 * By default a Camera is the same size as the game, but can be made smaller via this method,
                 * allowing you to create mini-cam style effects by creating and positioning a smaller Camera
                 * viewport within your game.
                 * @param x The top-left x coordinate of the Camera viewport.
                 * @param y The top-left y coordinate of the Camera viewport.
                 * @param width The width of the Camera viewport.
                 * @param height The height of the Camera viewport. Default width.
                 */
                setViewport(x: number, y: number, width: integer, height?: integer): BaseCamera;

                /**
                 * Set the zoom value of the Camera.
                 *
                 * Changing to a smaller value, such as 0.5, will cause the camera to 'zoom out'.
                 * Changing to a larger value, such as 2, will cause the camera to 'zoom in'.
                 *
                 * A value of 1 means 'no zoom' and is the default.
                 *
                 * Changing the zoom does not impact the Camera viewport in any way, it is only applied during rendering.
                 * @param value The zoom value of the Camera. The minimum it can be is 0.001. Default 1.
                 */
                setZoom(value?: number): BaseCamera;

                /**
                 * Sets the visibility of this Camera.
                 *
                 * An invisible Camera will skip rendering and input tests of everything it can see.
                 * @param value The visible state of the Camera.
                 */
                setVisible(value: boolean): this;

                /**
                 * Returns an Object suitable for JSON storage containing all of the Camera viewport and rendering properties.
                 */
                toJSON(): JSONCamera;

                /**
                 * Internal method called automatically by the Camera Manager.
                 * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                protected update(time: integer, delta: number): void;

                /**
                 * Destroys this Camera instance and its internal properties and references.
                 * Once destroyed you cannot use this Camera again, even if re-added to a Camera Manager.
                 *
                 * This method is called automatically by `CameraManager.remove` if that methods `runDestroy` argument is `true`, which is the default.
                 *
                 * Unless you have a specific reason otherwise, always use `CameraManager.remove` and allow it to handle the camera destruction,
                 * rather than calling this method directly.
                 */
                destroy(): void;

                /**
                 * The x position of the Camera viewport, relative to the top-left of the game canvas.
                 * The viewport is the area into which the camera renders.
                 * To adjust the position the camera is looking at in the game world, see the `scrollX` value.
                 */
                x: number;

                /**
                 * The y position of the Camera viewport, relative to the top-left of the game canvas.
                 * The viewport is the area into which the camera renders.
                 * To adjust the position the camera is looking at in the game world, see the `scrollY` value.
                 */
                y: number;

                /**
                 * The width of the Camera viewport, in pixels.
                 *
                 * The viewport is the area into which the Camera renders. Setting the viewport does
                 * not restrict where the Camera can scroll to.
                 */
                width: number;

                /**
                 * The height of the Camera viewport, in pixels.
                 *
                 * The viewport is the area into which the Camera renders. Setting the viewport does
                 * not restrict where the Camera can scroll to.
                 */
                height: number;

                /**
                 * The horizontal scroll position of this Camera.
                 *
                 * Change this value to cause the Camera to scroll around your Scene.
                 *
                 * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,
                 * will automatically adjust the Camera scroll values accordingly.
                 *
                 * You can set the bounds within which the Camera can scroll via the `setBounds` method.
                 */
                scrollX: number;

                /**
                 * The vertical scroll position of this Camera.
                 *
                 * Change this value to cause the Camera to scroll around your Scene.
                 *
                 * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,
                 * will automatically adjust the Camera scroll values accordingly.
                 *
                 * You can set the bounds within which the Camera can scroll via the `setBounds` method.
                 */
                scrollY: number;

                /**
                 * The Camera zoom value. Change this value to zoom in, or out of, a Scene.
                 *
                 * A value of 0.5 would zoom the Camera out, so you can now see twice as much
                 * of the Scene as before. A value of 2 would zoom the Camera in, so every pixel
                 * now takes up 2 pixels when rendered.
                 *
                 * Set to 1 to return to the default zoom level.
                 *
                 * Be careful to never set this value to zero.
                 */
                zoom: number;

                /**
                 * The horizontal position of the center of the Camera's viewport, relative to the left of the game canvas.
                 */
                readonly centerX: number;

                /**
                 * The vertical position of the center of the Camera's viewport, relative to the top of the game canvas.
                 */
                readonly centerY: number;

                /**
                 * The displayed width of the camera viewport, factoring in the camera zoom level.
                 *
                 * If a camera has a viewport width of 800 and a zoom of 0.5 then its display width
                 * would be 1600, as it's displaying twice as many pixels as zoom level 1.
                 *
                 * Equally, a camera with a width of 800 and zoom of 2 would have a display width
                 * of 400 pixels.
                 */
                readonly displayWidth: number;

                /**
                 * The displayed height of the camera viewport, factoring in the camera zoom level.
                 *
                 * If a camera has a viewport height of 600 and a zoom of 0.5 then its display height
                 * would be 1200, as it's displaying twice as many pixels as zoom level 1.
                 *
                 * Equally, a camera with a height of 600 and zoom of 2 would have a display height
                 * of 300 pixels.
                 */
                readonly displayHeight: number;

                /**
                 * Clears all alpha values associated with this Game Object.
                 *
                 * Immediately sets the alpha levels back to 1 (fully opaque).
                 */
                clearAlpha(): this;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;
            }

            /**
             * A Camera.
             *
             * The Camera is the way in which all games are rendered in Phaser. They provide a view into your game world,
             * and can be positioned, rotated, zoomed and scrolled accordingly.
             *
             * A Camera consists of two elements: The viewport and the scroll values.
             *
             * The viewport is the physical position and size of the Camera within your game. Cameras, by default, are
             * created the same size as your game, but their position and size can be set to anything. This means if you
             * wanted to create a camera that was 320x200 in size, positioned in the bottom-right corner of your game,
             * you'd adjust the viewport to do that (using methods like `setViewport` and `setSize`).
             *
             * If you wish to change where the Camera is looking in your game, then you scroll it. You can do this
             * via the properties `scrollX` and `scrollY` or the method `setScroll`. Scrolling has no impact on the
             * viewport, and changing the viewport has no impact on the scrolling.
             *
             * By default a Camera will render all Game Objects it can see. You can change this using the `ignore` method,
             * allowing you to filter Game Objects out on a per-Camera basis.
             *
             * A Camera also has built-in special effects including Fade, Flash and Camera Shake.
             */
            class Camera extends BaseCamera implements GameObjects.Components.Flip, GameObjects.Components.Tint {
                /**
                 *
                 * @param x The x position of the Camera, relative to the top-left of the game canvas.
                 * @param y The y position of the Camera, relative to the top-left of the game canvas.
                 * @param width The width of the Camera, in pixels.
                 * @param height The height of the Camera, in pixels.
                 */
                constructor(x: number, y: number, width: number, height: number);

                /**
                 * Does this Camera allow the Game Objects it renders to receive input events?
                 */
                inputEnabled: boolean;

                /**
                 * The Camera Fade effect handler.
                 * To fade this camera see the `Camera.fade` methods.
                 */
                fadeEffect: Effects.Fade;

                /**
                 * The Camera Flash effect handler.
                 * To flash this camera see the `Camera.flash` method.
                 */
                flashEffect: Effects.Flash;

                /**
                 * The Camera Shake effect handler.
                 * To shake this camera see the `Camera.shake` method.
                 */
                shakeEffect: Effects.Shake;

                /**
                 * The Camera Pan effect handler.
                 * To pan this camera see the `Camera.pan` method.
                 */
                panEffect: Effects.Pan;

                /**
                 * The Camera Zoom effect handler.
                 * To zoom this camera see the `Camera.zoom` method.
                 */
                zoomEffect: Effects.Zoom;

                /**
                 * The linear interpolation value to use when following a target.
                 *
                 * Can also be set via `setLerp` or as part of the `startFollow` call.
                 *
                 * The default values of 1 means the camera will instantly snap to the target coordinates.
                 * A lower value, such as 0.1 means the camera will more slowly track the target, giving
                 * a smooth transition. You can set the horizontal and vertical values independently, and also
                 * adjust this value in real-time during your game.
                 *
                 * Be sure to keep the value between 0 and 1. A value of zero will disable tracking on that axis.
                 */
                lerp: Math.Vector2;

                /**
                 * The values stored in this property are subtracted from the Camera targets position, allowing you to
                 * offset the camera from the actual target x/y coordinates by this amount.
                 * Can also be set via `setFollowOffset` or as part of the `startFollow` call.
                 */
                followOffset: Math.Vector2;

                /**
                 * The Camera dead zone.
                 *
                 * The deadzone is only used when the camera is following a target.
                 *
                 * It defines a rectangular region within which if the target is present, the camera will not scroll.
                 * If the target moves outside of this area, the camera will begin scrolling in order to follow it.
                 *
                 * The `lerp` values that you can set for a follower target also apply when using a deadzone.
                 *
                 * You can directly set this property to be an instance of a Rectangle. Or, you can use the
                 * `setDeadzone` method for a chainable approach.
                 *
                 * The rectangle you provide can have its dimensions adjusted dynamically, however, please
                 * note that its position is updated every frame, as it is constantly re-centered on the cameras mid point.
                 *
                 * Calling `setDeadzone` with no arguments will reset an active deadzone, as will setting this property
                 * to `null`.
                 */
                deadzone: Geom.Rectangle;

                /**
                 * Is this Camera rendering directly to the canvas or to a texture?
                 *
                 * Enable rendering to texture with the method `setRenderToTexture` (just enabling this boolean won't be enough)
                 *
                 * Once enabled you can toggle it by switching this property.
                 *
                 * To properly remove a render texture you should call the `clearRenderToTexture()` method.
                 */
                renderToTexture: boolean;

                /**
                 * If this Camera has been set to render to a texture then this holds a reference
                 * to the HTML Canvas Element that the Camera is drawing to.
                 *
                 * Enable texture rendering using the method `setRenderToTexture`.
                 *
                 * This is only populated if Phaser is running with the Canvas Renderer.
                 */
                canvas: HTMLCanvasElement;

                /**
                 * If this Camera has been set to render to a texture then this holds a reference
                 * to the Rendering Context belonging to the Canvas element the Camera is drawing to.
                 *
                 * Enable texture rendering using the method `setRenderToTexture`.
                 *
                 * This is only populated if Phaser is running with the Canvas Renderer.
                 */
                context: CanvasRenderingContext2D;

                /**
                 * If this Camera has been set to render to a texture then this holds a reference
                 * to the GL Texture belonging the Camera is drawing to.
                 *
                 * Enable texture rendering using the method `setRenderToTexture`.
                 *
                 * This is only set if Phaser is running with the WebGL Renderer.
                 */
                glTexture: WebGLTexture;

                /**
                 * If this Camera has been set to render to a texture then this holds a reference
                 * to the GL Frame Buffer belonging the Camera is drawing to.
                 *
                 * Enable texture rendering using the method `setRenderToTexture`.
                 *
                 * This is only set if Phaser is running with the WebGL Renderer.
                 */
                framebuffer: WebGLFramebuffer;

                /**
                 * If this Camera has been set to render to a texture and to use a custom pipeline,
                 * then this holds a reference to the pipeline the Camera is drawing with.
                 *
                 * Enable texture rendering using the method `setRenderToTexture`.
                 *
                 * This is only set if Phaser is running with the WebGL Renderer.
                 */
                pipeline: any;

                /**
                 * Sets the Camera to render to a texture instead of to the main canvas.
                 *
                 * The Camera will redirect all Game Objects it's asked to render to this texture.
                 *
                 * During the render sequence, the texture itself will then be rendered to the main canvas.
                 *
                 * Doing this gives you the ability to modify the texture before this happens,
                 * allowing for special effects such as Camera specific shaders, or post-processing
                 * on the texture.
                 *
                 * If running under Canvas the Camera will render to its `canvas` property.
                 *
                 * If running under WebGL the Camera will create a frame buffer, which is stored in its `framebuffer` and `glTexture` properties.
                 *
                 * If you set a camera to render to a texture then it will emit 2 events during the render loop:
                 *
                 * First, it will emit the event `prerender`. This happens right before any Game Object's are drawn to the Camera texture.
                 *
                 * Then, it will emit the event `postrender`. This happens after all Game Object's have been drawn, but right before the
                 * Camera texture is rendered to the main game canvas. It's the final point at which you can manipulate the texture before
                 * it appears in-game.
                 *
                 * You should not enable this unless you plan on actually using the texture it creates
                 * somehow, otherwise you're just doubling the work required to render your game.
                 *
                 * To temporarily disable rendering to a texture, toggle the `renderToTexture` boolean.
                 *
                 * If you no longer require the Camera to render to a texture, call the `clearRenderToTexture` method,
                 * which will delete the respective textures and free-up resources.
                 * @param pipeline An optional WebGL Pipeline to render with, can be either a string which is the name of the pipeline, or a pipeline reference.
                 */
                setRenderToTexture(pipeline?: string | Renderer.WebGL.WebGLPipeline): Camera;

                /**
                 * Sets the WebGL pipeline this Camera is using when rendering to a texture.
                 *
                 * You can pass either the string-based name of the pipeline, or a reference to the pipeline itself.
                 *
                 * Call this method with no arguments to clear any previously set pipeline.
                 * @param pipeline The WebGL Pipeline to render with, can be either a string which is the name of the pipeline, or a pipeline reference. Or if left empty it will clear the pipeline.
                 */
                setPipeline(pipeline?: string | Renderer.WebGL.WebGLPipeline): Camera;

                /**
                 * If this Camera was set to render to a texture, this will clear the resources it was using and
                 * redirect it to render back to the primary Canvas again.
                 *
                 * If you only wish to temporarily disable rendering to a texture then you can toggle the
                 * property `renderToTexture` instead.
                 */
                clearRenderToTexture(): Camera;

                /**
                 * Sets the Camera dead zone.
                 *
                 * The deadzone is only used when the camera is following a target.
                 *
                 * It defines a rectangular region within which if the target is present, the camera will not scroll.
                 * If the target moves outside of this area, the camera will begin scrolling in order to follow it.
                 *
                 * The deadzone rectangle is re-positioned every frame so that it is centered on the mid-point
                 * of the camera. This allows you to use the object for additional game related checks, such as
                 * testing if an object is within it or not via a Rectangle.contains call.
                 *
                 * The `lerp` values that you can set for a follower target also apply when using a deadzone.
                 *
                 * Calling this method with no arguments will reset an active deadzone.
                 * @param width The width of the deadzone rectangle in pixels. If not specified the deadzone is removed.
                 * @param height The height of the deadzone rectangle in pixels.
                 */
                setDeadzone(width?: number, height?: number): Camera;

                /**
                 * Fades the Camera in from the given color over the duration specified.
                 * @param duration The duration of the effect in milliseconds. Default 1000.
                 * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
                 * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
                 * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                fadeIn(duration?: integer, red?: integer, green?: integer, blue?: integer, callback?: CallbackFn, context?: any): Camera;

                /**
                 * Fades the Camera out to the given color over the duration specified.
                 * This is an alias for Camera.fade that forces the fade to start, regardless of existing fades.
                 * @param duration The duration of the effect in milliseconds. Default 1000.
                 * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
                 * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
                 * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                fadeOut(duration?: integer, red?: integer, green?: integer, blue?: integer, callback?: CallbackFn, context?: any): Camera;

                /**
                 * Fades the Camera from the given color to transparent over the duration specified.
                 * @param duration The duration of the effect in milliseconds. Default 1000.
                 * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
                 * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
                 * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
                 * @param force Force the effect to start immediately, even if already running. Default false.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                fadeFrom(duration?: integer, red?: integer, green?: integer, blue?: integer, force?: boolean, callback?: CallbackFn, context?: any): Camera;

                /**
                 * Fades the Camera from transparent to the given color over the duration specified.
                 * @param duration The duration of the effect in milliseconds. Default 1000.
                 * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
                 * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
                 * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
                 * @param force Force the effect to start immediately, even if already running. Default false.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                fade(duration?: integer, red?: integer, green?: integer, blue?: integer, force?: boolean, callback?: CallbackFn, context?: any): Camera;

                /**
                 * Flashes the Camera by setting it to the given color immediately and then fading it away again quickly over the duration specified.
                 * @param duration The duration of the effect in milliseconds. Default 250.
                 * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 255.
                 * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 255.
                 * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 255.
                 * @param force Force the effect to start immediately, even if already running. Default false.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                flash(duration?: integer, red?: integer, green?: integer, blue?: integer, force?: boolean, callback?: CallbackFn, context?: any): Camera;

                /**
                 * Shakes the Camera by the given intensity over the duration specified.
                 * @param duration The duration of the effect in milliseconds. Default 100.
                 * @param intensity The intensity of the shake. Default 0.05.
                 * @param force Force the shake effect to start immediately, even if already running. Default false.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                shake(duration?: integer, intensity?: number, force?: boolean, callback?: CallbackFn, context?: any): Camera;

                /**
                 * This effect will scroll the Camera so that the center of its viewport finishes at the given destination,
                 * over the duration and with the ease specified.
                 * @param x The destination x coordinate to scroll the center of the Camera viewport to.
                 * @param y The destination y coordinate to scroll the center of the Camera viewport to.
                 * @param duration The duration of the effect in milliseconds. Default 1000.
                 * @param ease The ease to use for the pan. Can be any of the Phaser Easing constants or a custom function. Default 'Linear'.
                 * @param force Force the pan effect to start immediately, even if already running. Default false.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
                 * the current camera scroll x coordinate and the current camera scroll y coordinate.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                pan(x: number, y: number, duration?: integer, ease?: string | CallbackFn, force?: boolean, callback?: CameraPanCallback, context?: any): Camera;

                /**
                 * This effect will zoom the Camera to the given scale, over the duration and with the ease specified.
                 * @param zoom The target Camera zoom value.
                 * @param duration The duration of the effect in milliseconds. Default 1000.
                 * @param ease The ease to use for the pan. Can be any of the Phaser Easing constants or a custom function. Default 'Linear'.
                 * @param force Force the pan effect to start immediately, even if already running. Default false.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
                 * the current camera scroll x coordinate and the current camera scroll y coordinate.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                zoomTo(zoom: number, duration?: integer, ease?: string | CallbackFn, force?: boolean, callback?: CameraPanCallback, context?: any): Camera;

                /**
                 * Internal preRender step.
                 * @param resolution The game resolution, as set in the Scale Manager.
                 */
                protected preRender(resolution: number): void;

                /**
                 * Sets the linear interpolation value to use when following a target.
                 *
                 * The default values of 1 means the camera will instantly snap to the target coordinates.
                 * A lower value, such as 0.1 means the camera will more slowly track the target, giving
                 * a smooth transition. You can set the horizontal and vertical values independently, and also
                 * adjust this value in real-time during your game.
                 *
                 * Be sure to keep the value between 0 and 1. A value of zero will disable tracking on that axis.
                 * @param x The amount added to the horizontal linear interpolation of the follow target. Default 1.
                 * @param y The amount added to the vertical linear interpolation of the follow target. Default 1.
                 */
                setLerp(x?: number, y?: number): this;

                /**
                 * Sets the horizontal and vertical offset of the camera from its follow target.
                 * The values are subtracted from the targets position during the Cameras update step.
                 * @param x The horizontal offset from the camera follow target.x position. Default 0.
                 * @param y The vertical offset from the camera follow target.y position. Default 0.
                 */
                setFollowOffset(x?: number, y?: number): this;

                /**
                 * Sets the Camera to follow a Game Object.
                 *
                 * When enabled the Camera will automatically adjust its scroll position to keep the target Game Object
                 * in its center.
                 *
                 * You can set the linear interpolation value used in the follow code.
                 * Use low lerp values (such as 0.1) to automatically smooth the camera motion.
                 *
                 * If you find you're getting a slight "jitter" effect when following an object it's probably to do with sub-pixel
                 * rendering of the targets position. This can be rounded by setting the `roundPixels` argument to `true` to
                 * force full pixel rounding rendering. Note that this can still be broken if you have specified a non-integer zoom
                 * value on the camera. So be sure to keep the camera zoom to integers.
                 * @param target The target for the Camera to follow.
                 * @param roundPixels Round the camera position to whole integers to avoid sub-pixel rendering? Default false.
                 * @param lerpX A value between 0 and 1. This value specifies the amount of linear interpolation to use when horizontally tracking the target.
                 * The closer the value to 1, the faster the camera will track. Default 1.
                 * @param lerpY A value between 0 and 1. This value specifies the amount of linear interpolation to use when vertically tracking the target.
                 * The closer the value to 1, the faster the camera will track. Default 1.
                 * @param offsetX The horizontal offset from the camera follow target.x position. Default 0.
                 * @param offsetY The vertical offset from the camera follow target.y position. Default 0.
                 */
                startFollow(target: GameObjects.GameObject | object, roundPixels?: boolean, lerpX?: number, lerpY?: number, offsetX?: number, offsetY?: number): this;

                /**
                 * Stops a Camera from following a Game Object, if previously set via `Camera.startFollow`.
                 */
                stopFollow(): Camera;

                /**
                 * Resets any active FX, such as a fade, flash or shake. Useful to call after a fade in order to
                 * remove the fade.
                 */
                resetFX(): Camera;

                /**
                 * Internal method called automatically by the Camera Manager.
                 * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                protected update(time: integer, delta: number): void;

                /**
                 * Destroys this Camera instance. You rarely need to call this directly.
                 *
                 * Called by the Camera Manager. If you wish to destroy a Camera please use `CameraManager.remove` as
                 * cameras are stored in a pool, ready for recycling later, and calling this directly will prevent that.
                 */
                destroy(): void;

                /**
                 * Clears all alpha values associated with this Game Object.
                 *
                 * Immediately sets the alpha levels back to 1 (fully opaque).
                 */
                clearAlpha(): this;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): this;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): this;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): this;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): this;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): this;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): this;

                /**
                 * Fill or additive?
                 */
                tintFill: boolean;

                /**
                 * Clears all tint values associated with this Game Object.
                 *
                 * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
                 * which results in no visible change to the texture.
                 */
                clearTint(): this;

                /**
                 * Sets an additive tint on this Game Object.
                 *
                 * The tint works by taking the pixel color values from the Game Objects texture, and then
                 * multiplying it by the color value of the tint. You can provide either one color value,
                 * in which case the whole Game Object will be tinted in that color. Or you can provide a color
                 * per corner. The colors are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
                 * @param topLeft The tint being applied to the top-left of the Game Object.
                 * If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * Sets a fill-based tint on this Game Object.
                 *
                 * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
                 * with those in the tint. You can use this for effects such as making a player flash 'white'
                 * if hit by something. You can provide either one color value, in which case the whole
                 * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
                 * are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
                 * @param topLeft The tint being applied to the top-left of the Game Object.
                 * If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * Does this Game Object have a tint applied to it or not?
                 */
                readonly isTinted: boolean;
            }

            /**
             * The Camera Manager is a plugin that belongs to a Scene and is responsible for managing all of the Scene Cameras.
             *
             * By default you can access the Camera Manager from within a Scene using `this.cameras`, although this can be changed
             * in your game config.
             *
             * Create new Cameras using the `add` method. Or extend the Camera class with your own addition code and then add
             * the new Camera in using the `addExisting` method.
             *
             * Cameras provide a view into your game world, and can be positioned, rotated, zoomed and scrolled accordingly.
             *
             * A Camera consists of two elements: The viewport and the scroll values.
             *
             * The viewport is the physical position and size of the Camera within your game. Cameras, by default, are
             * created the same size as your game, but their position and size can be set to anything. This means if you
             * wanted to create a camera that was 320x200 in size, positioned in the bottom-right corner of your game,
             * you'd adjust the viewport to do that (using methods like `setViewport` and `setSize`).
             *
             * If you wish to change where the Camera is looking in your game, then you scroll it. You can do this
             * via the properties `scrollX` and `scrollY` or the method `setScroll`. Scrolling has no impact on the
             * viewport, and changing the viewport has no impact on the scrolling.
             *
             * By default a Camera will render all Game Objects it can see. You can change this using the `ignore` method,
             * allowing you to filter Game Objects out on a per-Camera basis. The Camera Manager can manage up to 31 unique
             * 'Game Object ignore capable' Cameras. Any Cameras beyond 31 that you create will all be given a Camera ID of
             * zero, meaning that they cannot be used for Game Object exclusion. This means if you need your Camera to ignore
             * Game Objects, make sure it's one of the first 31 created.
             *
             * A Camera also has built-in special effects including Fade, Flash, Camera Shake, Pan and Zoom.
             */
            class CameraManager {
                /**
                 *
                 * @param scene The Scene that owns the Camera Manager plugin.
                 */
                constructor(scene: Scene);

                /**
                 * The Scene that owns the Camera Manager plugin.
                 */
                scene: Scene;

                /**
                 * A reference to the Scene.Systems handler for the Scene that owns the Camera Manager.
                 */
                systems: Scenes.Systems;

                /**
                 * All Cameras created by, or added to, this Camera Manager, will have their `roundPixels`
                 * property set to match this value. By default it is set to match the value set in the
                 * game configuration, but can be changed at any point. Equally, individual cameras can
                 * also be changed as needed.
                 */
                roundPixels: boolean;

                /**
                 * An Array of the Camera objects being managed by this Camera Manager.
                 * The Cameras are updated and rendered in the same order in which they appear in this array.
                 * Do not directly add or remove entries to this array. However, you can move the contents
                 * around the array should you wish to adjust the display order.
                 */
                cameras: Camera[];

                /**
                 * A handy reference to the 'main' camera. By default this is the first Camera the
                 * Camera Manager creates. You can also set it directly, or use the `makeMain` argument
                 * in the `add` and `addExisting` methods. It allows you to access it from your game:
                 *
                 * ```javascript
                 * var cam = this.cameras.main;
                 * ```
                 *
                 * Also see the properties `camera1`, `camera2` and so on.
                 */
                main: Camera;

                /**
                 * Adds a new Camera into the Camera Manager. The Camera Manager can support up to 31 different Cameras.
                 *
                 * Each Camera has its own viewport, which controls the size of the Camera and its position within the canvas.
                 *
                 * Use the `Camera.scrollX` and `Camera.scrollY` properties to change where the Camera is looking, or the
                 * Camera methods such as `centerOn`. Cameras also have built in special effects, such as fade, flash, shake,
                 * pan and zoom.
                 *
                 * By default Cameras are transparent and will render anything that they can see based on their `scrollX`
                 * and `scrollY` values. Game Objects can be set to be ignored by a Camera by using the `Camera.ignore` method.
                 *
                 * The Camera will have its `roundPixels` property set to whatever `CameraManager.roundPixels` is. You can change
                 * it after creation if required.
                 *
                 * See the Camera class documentation for more details.
                 * @param x The horizontal position of the Camera viewport. Default 0.
                 * @param y The vertical position of the Camera viewport. Default 0.
                 * @param width The width of the Camera viewport. If not given it'll be the game config size.
                 * @param height The height of the Camera viewport. If not given it'll be the game config size.
                 * @param makeMain Set this Camera as being the 'main' camera. This just makes the property `main` a reference to it. Default false.
                 * @param name The name of the Camera. Default ''.
                 */
                add(x?: integer, y?: integer, width?: integer, height?: integer, makeMain?: boolean, name?: string): Camera;

                /**
                 * Adds an existing Camera into the Camera Manager.
                 *
                 * The Camera should either be a `Phaser.Cameras.Scene2D.Camera` instance, or a class that extends from it.
                 *
                 * The Camera will have its `roundPixels` property set to whatever `CameraManager.roundPixels` is. You can change
                 * it after addition if required.
                 *
                 * The Camera will be assigned an ID, which is used for Game Object exclusion and then added to the
                 * manager. As long as it doesn't already exist in the manager it will be added then returned.
                 *
                 * If this method returns `null` then the Camera already exists in this Camera Manager.
                 * @param camera The Camera to be added to the Camera Manager.
                 * @param makeMain Set this Camera as being the 'main' camera. This just makes the property `main` a reference to it. Default false.
                 */
                addExisting(camera: Camera, makeMain?: boolean): Camera;

                /**
                 * Gets the total number of Cameras in this Camera Manager.
                 *
                 * If the optional `isVisible` argument is set it will only count Cameras that are currently visible.
                 * @param isVisible Set the `true` to only include visible Cameras in the total. Default false.
                 */
                getTotal(isVisible?: boolean): integer;

                /**
                 * Populates this Camera Manager based on the given configuration object, or an array of config objects.
                 *
                 * See the `InputJSONCameraObject` documentation for details of the object structure.
                 * @param config A Camera configuration object, or an array of them, to be added to this Camera Manager.
                 */
                fromJSON(config: InputJSONCameraObject | InputJSONCameraObject[]): CameraManager;

                /**
                 * Gets a Camera based on its name.
                 *
                 * Camera names are optional and don't have to be set, so this method is only of any use if you
                 * have given your Cameras unique names.
                 * @param name The name of the Camera.
                 */
                getCamera(name: string): Camera;

                /**
                 * Returns an array of all cameras below the given Pointer.
                 *
                 * The first camera in the array is the top-most camera in the camera list.
                 * @param pointer The Pointer to check against.
                 */
                getCamerasBelowPointer(pointer: Input.Pointer): Camera[];

                /**
                 * Removes the given Camera, or an array of Cameras, from this Camera Manager.
                 *
                 * If found in the Camera Manager it will be immediately removed from the local cameras array.
                 * If also currently the 'main' camera, 'main' will be reset to be camera 0.
                 *
                 * The removed Cameras are automatically destroyed if the `runDestroy` argument is `true`, which is the default.
                 * If you wish to re-use the cameras then set this to `false`, but know that they will retain their references
                 * and internal data until destroyed or re-added to a Camera Manager.
                 * @param camera The Camera, or an array of Cameras, to be removed from this Camera Manager.
                 * @param runDestroy Automatically call `Camera.destroy` on each Camera removed from this Camera Manager. Default true.
                 */
                remove(camera: Camera | Camera[], runDestroy?: boolean): integer;

                /**
                 * The internal render method. This is called automatically by the Scene and should not be invoked directly.
                 *
                 * It will iterate through all local cameras and render them in turn, as long as they're visible and have
                 * an alpha level > 0.
                 * @param renderer The Renderer that will render the children to this camera.
                 * @param children An array of renderable Game Objects.
                 * @param interpolation Interpolation value. Reserved for future use.
                 */
                protected render(renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer, children: GameObjects.GameObject[], interpolation: number): void;

                /**
                 * Resets this Camera Manager.
                 *
                 * This will iterate through all current Cameras, destroying them all, then it will reset the
                 * cameras array, reset the ID counter and create 1 new single camera using the default values.
                 */
                resetAll(): Camera;

                /**
                 * The main update loop. Called automatically when the Scene steps.
                 * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                protected update(time: integer, delta: number): void;

                /**
                 * Resizes all cameras to the given dimensions.
                 * @param width The new width of the camera.
                 * @param height The new height of the camera.
                 */
                resize(width: number, height: number): void;
            }

            namespace Effects {
                /**
                 * A Camera Fade effect.
                 *
                 * This effect will fade the camera viewport to the given color, over the duration specified.
                 *
                 * Only the camera viewport is faded. None of the objects it is displaying are impacted, i.e. their colors do
                 * not change.
                 *
                 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
                 * which is invoked each frame for the duration of the effect, if required.
                 */
                class Fade {
                    /**
                     *
                     * @param camera The camera this effect is acting upon.
                     */
                    constructor(camera: Camera);

                    /**
                     * The Camera this effect belongs to.
                     */
                    readonly camera: Camera;

                    /**
                     * Is this effect actively running?
                     */
                    readonly isRunning: boolean;

                    /**
                     * Has this effect finished running?
                     *
                     * This is different from `isRunning` because it remains set to `true` when the effect is over,
                     * until the effect is either reset or started again.
                     */
                    readonly isComplete: boolean;

                    /**
                     * The direction of the fade.
                     * `true` = fade out (transparent to color), `false` = fade in (color to transparent)
                     */
                    readonly direction: boolean;

                    /**
                     * The duration of the effect, in milliseconds.
                     */
                    readonly duration: integer;

                    /**
                     * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
                     */
                    progress: number;

                    /**
                     * Fades the Camera to or from the given color over the duration specified.
                     * @param direction The direction of the fade. `true` = fade out (transparent to color), `false` = fade in (color to transparent) Default true.
                     * @param duration The duration of the effect in milliseconds. Default 1000.
                     * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
                     * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
                     * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
                     * @param force Force the effect to start immediately, even if already running. Default false.
                     * @param callback This callback will be invoked every frame for the duration of the effect.
                     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                     * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                     */
                    start(
                        direction?: boolean,
                        duration?: integer,
                        red?: integer,
                        green?: integer,
                        blue?: integer,
                        force?: boolean,
                        callback?: CameraFadeCallback,
                        context?: any
                    ): Camera;

                    /**
                     * The main update loop for this effect. Called automatically by the Camera.
                     * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                     * @param delta The delta time, in ms, elapsed since the last frame.
                     */
                    update(time: integer, delta: number): void;

                    /**
                     * Called internally by the Canvas Renderer.
                     * @param ctx The Canvas context to render to.
                     */
                    postRenderCanvas(ctx: CanvasRenderingContext2D): boolean;

                    /**
                     * Called internally by the WebGL Renderer.
                     * @param pipeline The WebGL Pipeline to render to.
                     * @param getTintFunction A function that will return the gl safe tint colors.
                     */
                    postRenderWebGL(pipeline: Renderer.WebGL.Pipelines.TextureTintPipeline, getTintFunction: CallbackFn): boolean;

                    /**
                     * Called internally when the effect completes.
                     */
                    effectComplete(): void;

                    /**
                     * Resets this camera effect.
                     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
                     */
                    reset(): void;

                    /**
                     * Destroys this effect, releasing it from the Camera.
                     */
                    destroy(): void;
                }

                /**
                 * A Camera Flash effect.
                 *
                 * This effect will flash the camera viewport to the given color, over the duration specified.
                 *
                 * Only the camera viewport is flashed. None of the objects it is displaying are impacted, i.e. their colors do
                 * not change.
                 *
                 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
                 * which is invoked each frame for the duration of the effect, if required.
                 */
                class Flash {
                    /**
                     *
                     * @param camera The camera this effect is acting upon.
                     */
                    constructor(camera: Camera);

                    /**
                     * The Camera this effect belongs to.
                     */
                    readonly camera: Camera;

                    /**
                     * Is this effect actively running?
                     */
                    readonly isRunning: boolean;

                    /**
                     * The duration of the effect, in milliseconds.
                     */
                    readonly duration: integer;

                    /**
                     * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
                     */
                    progress: number;

                    /**
                     * Flashes the Camera to or from the given color over the duration specified.
                     * @param duration The duration of the effect in milliseconds. Default 250.
                     * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 255.
                     * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 255.
                     * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 255.
                     * @param force Force the effect to start immediately, even if already running. Default false.
                     * @param callback This callback will be invoked every frame for the duration of the effect.
                     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                     * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                     */
                    start(duration?: integer, red?: integer, green?: integer, blue?: integer, force?: boolean, callback?: CameraFlashCallback, context?: any): Camera;

                    /**
                     * The main update loop for this effect. Called automatically by the Camera.
                     * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                     * @param delta The delta time, in ms, elapsed since the last frame.
                     */
                    update(time: integer, delta: number): void;

                    /**
                     * Called internally by the Canvas Renderer.
                     * @param ctx The Canvas context to render to.
                     */
                    postRenderCanvas(ctx: CanvasRenderingContext2D): boolean;

                    /**
                     * Called internally by the WebGL Renderer.
                     * @param pipeline The WebGL Pipeline to render to.
                     * @param getTintFunction A function that will return the gl safe tint colors.
                     */
                    postRenderWebGL(pipeline: Renderer.WebGL.Pipelines.TextureTintPipeline, getTintFunction: CallbackFn): boolean;

                    /**
                     * Called internally when the effect completes.
                     */
                    effectComplete(): void;

                    /**
                     * Resets this camera effect.
                     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
                     */
                    reset(): void;

                    /**
                     * Destroys this effect, releasing it from the Camera.
                     */
                    destroy(): void;
                }

                /**
                 * A Camera Pan effect.
                 *
                 * This effect will scroll the Camera so that the center of its viewport finishes at the given destination,
                 * over the duration and with the ease specified.
                 *
                 * Only the camera scroll is moved. None of the objects it is displaying are impacted, i.e. their positions do
                 * not change.
                 *
                 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
                 * which is invoked each frame for the duration of the effect if required.
                 */
                class Pan {
                    /**
                     *
                     * @param camera The camera this effect is acting upon.
                     */
                    constructor(camera: Camera);

                    /**
                     * The Camera this effect belongs to.
                     */
                    readonly camera: Camera;

                    /**
                     * Is this effect actively running?
                     */
                    readonly isRunning: boolean;

                    /**
                     * The duration of the effect, in milliseconds.
                     */
                    readonly duration: integer;

                    /**
                     * The starting scroll coordinates to pan the camera from.
                     */
                    source: Math.Vector2;

                    /**
                     * The constantly updated value based on zoom.
                     */
                    current: Math.Vector2;

                    /**
                     * The destination scroll coordinates to pan the camera to.
                     */
                    destination: Math.Vector2;

                    /**
                     * The ease function to use during the pan.
                     */
                    ease: CallbackFn;

                    /**
                     * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
                     */
                    progress: number;

                    /**
                     * This effect will scroll the Camera so that the center of its viewport finishes at the given destination,
                     * over the duration and with the ease specified.
                     * @param x The destination x coordinate to scroll the center of the Camera viewport to.
                     * @param y The destination y coordinate to scroll the center of the Camera viewport to.
                     * @param duration The duration of the effect in milliseconds. Default 1000.
                     * @param ease The ease to use for the pan. Can be any of the Phaser Easing constants or a custom function. Default 'Linear'.
                     * @param force Force the pan effect to start immediately, even if already running. Default false.
                     * @param callback This callback will be invoked every frame for the duration of the effect.
                     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
                     * the current camera scroll x coordinate and the current camera scroll y coordinate.
                     * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                     */
                    start(x: number, y: number, duration?: integer, ease?: string | CallbackFn, force?: boolean, callback?: CameraPanCallback, context?: any): Camera;

                    /**
                     * The main update loop for this effect. Called automatically by the Camera.
                     * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                     * @param delta The delta time, in ms, elapsed since the last frame.
                     */
                    update(time: integer, delta: number): void;

                    /**
                     * Called internally when the effect completes.
                     */
                    effectComplete(): void;

                    /**
                     * Resets this camera effect.
                     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
                     */
                    reset(): void;

                    /**
                     * Destroys this effect, releasing it from the Camera.
                     */
                    destroy(): void;
                }

                /**
                 * A Camera Shake effect.
                 *
                 * This effect will shake the camera viewport by a random amount, bounded by the specified intensity, each frame.
                 *
                 * Only the camera viewport is moved. None of the objects it is displaying are impacted, i.e. their positions do
                 * not change.
                 *
                 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
                 * which is invoked each frame for the duration of the effect if required.
                 */
                class Shake {
                    /**
                     *
                     * @param camera The camera this effect is acting upon.
                     */
                    constructor(camera: Camera);

                    /**
                     * The Camera this effect belongs to.
                     */
                    readonly camera: Camera;

                    /**
                     * Is this effect actively running?
                     */
                    readonly isRunning: boolean;

                    /**
                     * The duration of the effect, in milliseconds.
                     */
                    readonly duration: integer;

                    /**
                     * The intensity of the effect. Use small float values. The default when the effect starts is 0.05.
                     * This is a Vector2 object, allowing you to control the shake intensity independently across x and y.
                     * You can modify this value while the effect is active to create more varied shake effects.
                     */
                    intensity: Math.Vector2;

                    /**
                     * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
                     */
                    progress: number;

                    /**
                     * Shakes the Camera by the given intensity over the duration specified.
                     * @param duration The duration of the effect in milliseconds. Default 100.
                     * @param intensity The intensity of the shake. Default 0.05.
                     * @param force Force the shake effect to start immediately, even if already running. Default false.
                     * @param callback This callback will be invoked every frame for the duration of the effect.
                     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                     * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                     */
                    start(duration?: integer, intensity?: number, force?: boolean, callback?: CameraShakeCallback, context?: any): Camera;

                    /**
                     * The pre-render step for this effect. Called automatically by the Camera.
                     */
                    preRender(): void;

                    /**
                     * The main update loop for this effect. Called automatically by the Camera.
                     * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                     * @param delta The delta time, in ms, elapsed since the last frame.
                     */
                    update(time: integer, delta: number): void;

                    /**
                     * Called internally when the effect completes.
                     */
                    effectComplete(): void;

                    /**
                     * Resets this camera effect.
                     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
                     */
                    reset(): void;

                    /**
                     * Destroys this effect, releasing it from the Camera.
                     */
                    destroy(): void;
                }

                /**
                 * A Camera Zoom effect.
                 *
                 * This effect will zoom the Camera to the given scale, over the duration and with the ease specified.
                 *
                 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
                 * which is invoked each frame for the duration of the effect if required.
                 */
                class Zoom {
                    /**
                     *
                     * @param camera The camera this effect is acting upon.
                     */
                    constructor(camera: Camera);

                    /**
                     * The Camera this effect belongs to.
                     */
                    readonly camera: Camera;

                    /**
                     * Is this effect actively running?
                     */
                    readonly isRunning: boolean;

                    /**
                     * The duration of the effect, in milliseconds.
                     */
                    readonly duration: integer;

                    /**
                     * The starting zoom value;
                     */
                    source: number;

                    /**
                     * The destination zoom value.
                     */
                    destination: number;

                    /**
                     * The ease function to use during the zoom.
                     */
                    ease: CallbackFn;

                    /**
                     * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
                     */
                    progress: number;

                    /**
                     * This effect will zoom the Camera to the given scale, over the duration and with the ease specified.
                     * @param zoom The target Camera zoom value.
                     * @param duration The duration of the effect in milliseconds. Default 1000.
                     * @param ease The ease to use for the Zoom. Can be any of the Phaser Easing constants or a custom function. Default 'Linear'.
                     * @param force Force the zoom effect to start immediately, even if already running. Default false.
                     * @param callback This callback will be invoked every frame for the duration of the effect.
                     * It is sent three arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
                     * and the current camera zoom value.
                     * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                     */
                    start(zoom: number, duration?: integer, ease?: string | CallbackFn, force?: boolean, callback?: CameraZoomCallback, context?: any): Camera;

                    /**
                     * The main update loop for this effect. Called automatically by the Camera.
                     * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                     * @param delta The delta time, in ms, elapsed since the last frame.
                     */
                    update(time: integer, delta: number): void;

                    /**
                     * Called internally when the effect completes.
                     */
                    effectComplete(): void;

                    /**
                     * Resets this camera effect.
                     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
                     */
                    reset(): void;

                    /**
                     * Destroys this effect, releasing it from the Camera.
                     */
                    destroy(): void;
                }
            }

            namespace Events {
                /**
                 * The Destroy Camera Event.
                 *
                 * This event is dispatched by a Camera instance when it is destroyed by the Camera Manager.
                 */
                const DESTROY: any;

                /**
                 * The Camera Fade In Complete Event.
                 *
                 * This event is dispatched by a Camera instance when the Fade In Effect completes.
                 *
                 * Listen to it from a Camera instance using `Camera.on('camerafadeincomplete', listener)`.
                 */
                const FADE_IN_COMPLETE: any;

                /**
                 * The Camera Fade In Start Event.
                 *
                 * This event is dispatched by a Camera instance when the Fade In Effect starts.
                 *
                 * Listen to it from a Camera instance using `Camera.on('camerafadeinstart', listener)`.
                 */
                const FADE_IN_START: any;

                /**
                 * The Camera Fade Out Complete Event.
                 *
                 * This event is dispatched by a Camera instance when the Fade Out Effect completes.
                 *
                 * Listen to it from a Camera instance using `Camera.on('camerafadeoutcomplete', listener)`.
                 */
                const FADE_OUT_COMPLETE: any;

                /**
                 * The Camera Fade Out Start Event.
                 *
                 * This event is dispatched by a Camera instance when the Fade Out Effect starts.
                 *
                 * Listen to it from a Camera instance using `Camera.on('camerafadeoutstart', listener)`.
                 */
                const FADE_OUT_START: any;

                /**
                 * The Camera Flash Complete Event.
                 *
                 * This event is dispatched by a Camera instance when the Flash Effect completes.
                 */
                const FLASH_COMPLETE: any;

                /**
                 * The Camera Flash Start Event.
                 *
                 * This event is dispatched by a Camera instance when the Flash Effect starts.
                 */
                const FLASH_START: any;

                /**
                 * The Camera Pan Complete Event.
                 *
                 * This event is dispatched by a Camera instance when the Pan Effect completes.
                 */
                const PAN_COMPLETE: any;

                /**
                 * The Camera Pan Start Event.
                 *
                 * This event is dispatched by a Camera instance when the Pan Effect starts.
                 */
                const PAN_START: any;

                /**
                 * The Camera Post-Render Event.
                 *
                 * This event is dispatched by a Camera instance after is has finished rendering.
                 * It is only dispatched if the Camera is rendering to a texture.
                 *
                 * Listen to it from a Camera instance using: `camera.on('postrender', listener)`.
                 */
                const POST_RENDER: any;

                /**
                 * The Camera Pre-Render Event.
                 *
                 * This event is dispatched by a Camera instance when it is about to render.
                 * It is only dispatched if the Camera is rendering to a texture.
                 *
                 * Listen to it from a Camera instance using: `camera.on('prerender', listener)`.
                 */
                const PRE_RENDER: any;

                /**
                 * The Camera Shake Complete Event.
                 *
                 * This event is dispatched by a Camera instance when the Shake Effect completes.
                 */
                const SHAKE_COMPLETE: any;

                /**
                 * The Camera Shake Start Event.
                 *
                 * This event is dispatched by a Camera instance when the Shake Effect starts.
                 */
                const SHAKE_START: any;

                /**
                 * The Camera Zoom Complete Event.
                 *
                 * This event is dispatched by a Camera instance when the Zoom Effect completes.
                 */
                const ZOOM_COMPLETE: any;

                /**
                 * The Camera Zoom Start Event.
                 *
                 * This event is dispatched by a Camera instance when the Zoom Effect starts.
                 */
                const ZOOM_START: any;
            }
        }

        namespace Controls {
            /**
             * A Fixed Key Camera Control.
             *
             * This allows you to control the movement and zoom of a camera using the defined keys.
             *
             * ```javascript
             * var camControl = new FixedKeyControl({
             *     camera: this.cameras.main,
             *     left: cursors.left,
             *     right: cursors.right,
             *     speed: float OR { x: 0, y: 0 }
             * });
             * ```
             *
             * Movement is precise and has no 'smoothing' applied to it.
             *
             * You must call the `update` method of this controller every frame.
             */
            class FixedKeyControl {
                /**
                 *
                 * @param config The Fixed Key Control configuration object.
                 */
                constructor(config: FixedKeyControlConfig);

                /**
                 * The Camera that this Control will update.
                 */
                camera: Scene2D.Camera;

                /**
                 * The Key to be pressed that will move the Camera left.
                 */
                left: Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera right.
                 */
                right: Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera up.
                 */
                up: Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera down.
                 */
                down: Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will zoom the Camera in.
                 */
                zoomIn: Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will zoom the Camera out.
                 */
                zoomOut: Input.Keyboard.Key;

                /**
                 * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.
                 */
                zoomSpeed: number;

                /**
                 * The horizontal speed the camera will move.
                 */
                speedX: number;

                /**
                 * The vertical speed the camera will move.
                 */
                speedY: number;

                /**
                 * A flag controlling if the Controls will update the Camera or not.
                 */
                active: boolean;

                /**
                 * Starts the Key Control running, providing it has been linked to a camera.
                 */
                start(): FixedKeyControl;

                /**
                 * Stops this Key Control from running. Call `start` to start it again.
                 */
                stop(): FixedKeyControl;

                /**
                 * Binds this Key Control to a camera.
                 * @param camera The camera to bind this Key Control to.
                 */
                setCamera(camera: Scene2D.Camera): FixedKeyControl;

                /**
                 * Applies the results of pressing the control keys to the Camera.
                 *
                 * You must call this every step, it is not called automatically.
                 * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
                 */
                update(delta: number): void;

                /**
                 * Destroys this Key Control.
                 */
                destroy(): void;
            }

            /**
             * A Smoothed Key Camera Control.
             *
             * This allows you to control the movement and zoom of a camera using the defined keys.
             * Unlike the Fixed Camera Control you can also provide physics values for acceleration, drag and maxSpeed for smoothing effects.
             *
             * ```javascript
             *
             * var controlConfig {
             *     camera: this.cameras.main,
             *     left: cursors.left,
             *     right: cursors.right,
             *     up: cursors.up,
             *     down: cursors.down,
             *     zoomIn: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),
             *     zoomOut: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E),
             *     zoomSpeed: 0.02,
             *     acceleration: 0.06,
             *     drag: 0.0005,
             *     maxSpeed: 1.0
             * }
             * ```
             *
             * You must call the `update` method of this controller every frame.
             */
            class SmoothedKeyControl {
                /**
                 *
                 * @param config The Smoothed Key Control configuration object.
                 */
                constructor(config: SmoothedKeyControlConfig);

                /**
                 * The Camera that this Control will update.
                 */
                camera: Scene2D.Camera;

                /**
                 * The Key to be pressed that will move the Camera left.
                 */
                left: Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera right.
                 */
                right: Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera up.
                 */
                up: Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera down.
                 */
                down: Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will zoom the Camera in.
                 */
                zoomIn: Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will zoom the Camera out.
                 */
                zoomOut: Input.Keyboard.Key;

                /**
                 * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.
                 */
                zoomSpeed: number;

                /**
                 * The horizontal acceleration the camera will move.
                 */
                accelX: number;

                /**
                 * The vertical acceleration the camera will move.
                 */
                accelY: number;

                /**
                 * The horizontal drag applied to the camera when it is moving.
                 */
                dragX: number;

                /**
                 * The vertical drag applied to the camera when it is moving.
                 */
                dragY: number;

                /**
                 * The maximum horizontal speed the camera will move.
                 */
                maxSpeedX: number;

                /**
                 * The maximum vertical speed the camera will move.
                 */
                maxSpeedY: number;

                /**
                 * A flag controlling if the Controls will update the Camera or not.
                 */
                active: boolean;

                /**
                 * Starts the Key Control running, providing it has been linked to a camera.
                 */
                start(): SmoothedKeyControl;

                /**
                 * Stops this Key Control from running. Call `start` to start it again.
                 */
                stop(): SmoothedKeyControl;

                /**
                 * Binds this Key Control to a camera.
                 * @param camera The camera to bind this Key Control to.
                 */
                setCamera(camera: Scene2D.Camera): SmoothedKeyControl;

                /**
                 * Applies the results of pressing the control keys to the Camera.
                 *
                 * You must call this every step, it is not called automatically.
                 * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
                 */
                update(delta: number): void;

                /**
                 * Destroys this Key Control.
                 */
                destroy(): void;
            }
        }
    }

    /**
     * Phaser Release Version
     */
    const VERSION: string;

    /**
     * AUTO Detect Renderer.
     */
    const AUTO: integer;

    /**
     * Canvas Renderer.
     */
    const CANVAS: integer;

    /**
     * WebGL Renderer.
     */
    const WEBGL: integer;

    /**
     * Headless Renderer.
     */
    const HEADLESS: integer;

    /**
     * In Phaser the value -1 means 'forever' in lots of cases, this const allows you to use it instead
     * to help you remember what the value is doing in your code.
     */
    const FOREVER: integer;

    /**
     * Direction constant.
     */
    const NONE: integer;

    /**
     * Direction constant.
     */
    const UP: integer;

    /**
     * Direction constant.
     */
    const DOWN: integer;

    /**
     * Direction constant.
     */
    const LEFT: integer;

    /**
     * Direction constant.
     */
    const RIGHT: integer;

    /**
     * The Phaser.Game instance is the main controller for the entire Phaser game. It is responsible
     * for handling the boot process, parsing the configuration values, creating the renderer,
     * and setting-up all of the global Phaser systems, such as sound and input.
     * Once that is complete it will start the Scene Manager and then begin the main game loop.
     *
     * You should generally avoid accessing any of the systems created by Game, and instead use those
     * made available to you via the Phaser.Scene Systems class instead.
     */
    class Game {
        /**
         *
         * @param GameConfig The configuration object for your Phaser Game instance.
         */
        constructor(GameConfig?: GameConfig);

        /**
         * The parsed Game Configuration object.
         *
         * The values stored within this object are read-only and should not be changed at run-time.
         */
        readonly config: Core.Config;

        /**
         * A reference to either the Canvas or WebGL Renderer that this Game is using.
         */
        renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer;

        /**
         * A reference to an HTML Div Element used as a DOM Element Container.
         *
         * Only set if `createDOMContainer` is `true` in the game config (by default it is `false`) and
         * if you provide a parent element to insert the Phaser Game inside.
         *
         * See the DOM Element Game Object for more details.
         */
        domContainer: HTMLDivElement;

        /**
         * A reference to the HTML Canvas Element that Phaser uses to render the game.
         * This is created automatically by Phaser unless you provide a `canvas` property
         * in your Game Config.
         */
        canvas: HTMLCanvasElement;

        /**
         * A reference to the Rendering Context belonging to the Canvas Element this game is rendering to.
         * If the game is running under Canvas it will be a 2d Canvas Rendering Context.
         * If the game is running under WebGL it will be a WebGL Rendering Context.
         * This context is created automatically by Phaser unless you provide a `context` property
         * in your Game Config.
         */
        context: CanvasRenderingContext2D | WebGLRenderingContext;

        /**
         * A flag indicating when this Game instance has finished its boot process.
         */
        readonly isBooted: boolean;

        /**
         * A flag indicating if this Game is currently running its game step or not.
         */
        readonly isRunning: boolean;

        /**
         * An Event Emitter which is used to broadcast game-level events from the global systems.
         */
        events: Events.EventEmitter;

        /**
         * An instance of the Animation Manager.
         *
         * The Animation Manager is a global system responsible for managing all animations used within your game.
         */
        anims: Animations.AnimationManager;

        /**
         * An instance of the Texture Manager.
         *
         * The Texture Manager is a global system responsible for managing all textures being used by your game.
         */
        textures: Textures.TextureManager;

        /**
         * An instance of the Cache Manager.
         *
         * The Cache Manager is a global system responsible for caching, accessing and releasing external game assets.
         */
        cache: Cache.CacheManager;

        /**
         * An instance of the Data Manager
         */
        registry: Data.DataManager;

        /**
         * An instance of the Input Manager.
         *
         * The Input Manager is a global system responsible for the capture of browser-level input events.
         */
        input: Input.InputManager;

        /**
         * An instance of the Scene Manager.
         *
         * The Scene Manager is a global system responsible for creating, modifying and updating the Scenes in your game.
         */
        scene: Scenes.SceneManager;

        /**
         * A reference to the Device inspector.
         *
         * Contains information about the device running this game, such as OS, browser vendor and feature support.
         * Used by various systems to determine capabilities and code paths.
         */
        device: DeviceConf;

        /**
         * An instance of the Scale Manager.
         *
         * The Scale Manager is a global system responsible for handling scaling of the game canvas.
         */
        scale: Scale.ScaleManager;

        /**
         * An instance of the base Sound Manager.
         *
         * The Sound Manager is a global system responsible for the playback and updating of all audio in your game.
         */
        sound: Sound.BaseSoundManager;

        /**
         * An instance of the Time Step.
         *
         * The Time Step is a global system responsible for setting-up and responding to the browser frame events, processing
         * them and calculating delta values. It then automatically calls the game step.
         */
        loop: Core.TimeStep;

        /**
         * An instance of the Plugin Manager.
         *
         * The Plugin Manager is a global system that allows plugins to register themselves with it, and can then install
         * those plugins into Scenes as required.
         */
        plugins: Plugins.PluginManager;

        /**
         * An instance of the Facebook Instant Games Plugin.
         *
         * This will only be available if the plugin has been built into Phaser,
         * or you're using the special Facebook Instant Games custom build.
         */
        facebook: FacebookInstantGamesPlugin;

        /**
         * Does the window the game is running in currently have focus or not?
         * This is modified by the VisibilityHandler.
         */
        readonly hasFocus: boolean;

        /**
         * This method is called automatically when the DOM is ready. It is responsible for creating the renderer,
         * displaying the Debug Header, adding the game canvas to the DOM and emitting the 'boot' event.
         * It listens for a 'ready' event from the base systems and once received it will call `Game.start`.
         */
        protected boot(): void;

        /**
         * Called automatically by Game.boot once all of the global systems have finished setting themselves up.
         * By this point the Game is now ready to start the main loop running.
         * It will also enable the Visibility Handler.
         */
        protected start(): void;

        /**
         * The main Game Step. Called automatically by the Time Step, once per browser frame (typically as a result of
         * Request Animation Frame, or Set Timeout on very old browsers.)
         *
         * The step will update the global managers first, then proceed to update each Scene in turn, via the Scene Manager.
         *
         * It will then render each Scene in turn, via the Renderer. This process emits `prerender` and `postrender` events.
         * @param time The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
         * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
         */
        step(time: number, delta: number): void;

        /**
         * A special version of the Game Step for the HEADLESS renderer only.
         *
         * The main Game Step. Called automatically by the Time Step, once per browser frame (typically as a result of
         * Request Animation Frame, or Set Timeout on very old browsers.)
         *
         * The step will update the global managers first, then proceed to update each Scene in turn, via the Scene Manager.
         *
         * This process emits `prerender` and `postrender` events, even though nothing actually displays.
         * @param time The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
         * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
         */
        headlessStep(time: number, delta: number): void;

        /**
         * Called automatically by the Visibility Handler.
         * This will pause the main loop and then emit a pause event.
         */
        protected onHidden(): void;

        /**
         * Called automatically by the Visibility Handler.
         * This will resume the main loop and then emit a resume event.
         */
        protected onVisible(): void;

        /**
         * Called automatically by the Visibility Handler.
         * This will set the main loop into a 'blurred' state, which pauses it.
         */
        protected onBlur(): void;

        /**
         * Called automatically by the Visibility Handler.
         * This will set the main loop into a 'focused' state, which resumes it.
         */
        protected onFocus(): void;

        /**
         * Returns the current game frame.
         * When the game starts running, the frame is incremented every time Request Animation Frame, or Set Timeout, fires.
         */
        getFrame(): number;

        /**
         * Returns the current game timestamp.
         * When the game starts running, the frame is incremented every time Request Animation Frame, or Set Timeout, fires.
         */
        getTime(): number;

        /**
         * Flags this Game instance as needing to be destroyed on the next frame.
         * It will wait until the current frame has completed and then call `runDestroy` internally.
         *
         * If you **do not** need to run Phaser again on the same web page you can set the `noReturn` argument to `true` and it will free-up
         * memory being held by the core Phaser plugins. If you do need to create another game instance on the same page, leave this as `false`.
         * @param removeCanvas Set to `true` if you would like the parent canvas element removed from the DOM, or `false` to leave it in place.
         * @param noReturn If `true` all the core Phaser plugins are destroyed. You cannot create another instance of Phaser on the same web page if you do this. Default false.
         */
        destroy(removeCanvas: boolean, noReturn?: boolean): void;
    }

    namespace Core {
        /**
         * The active game configuration settings, parsed from a {@link GameConfig} object.
         */
        class Config {
            /**
             *
             * @param GameConfig The configuration object for your Phaser Game instance.
             */
            constructor(GameConfig?: GameConfig);

            /**
             * The width of the underlying canvas, in pixels.
             */
            readonly width: integer | string;

            /**
             * The height of the underlying canvas, in pixels.
             */
            readonly height: integer | string;

            /**
             * The zoom factor, as used by the Scale Manager.
             */
            readonly zoom: Scale.Zoominterface | integer;

            /**
             * The canvas device pixel resolution. Currently un-used.
             */
            readonly resolution: number;

            /**
             * A parent DOM element into which the canvas created by the renderer will be injected.
             */
            readonly parent: any;

            /**
             * The scale mode as used by the Scale Manager. The default is zero, which is no scaling.
             */
            readonly scaleMode: Scale.ScaleModeinterface;

            /**
             * Is the Scale Manager allowed to adjust the CSS height property of the parent to be 100%?
             */
            readonly expandParent: boolean;

            /**
             * Automatically round the display and style sizes of the canvas. This can help with performance in lower-powered devices.
             */
            readonly autoRound: integer;

            /**
             * Automatically center the canvas within the parent?
             */
            readonly autoCenter: Scale.Centerinterface;

            /**
             * How many ms should elapse before checking if the browser size has changed?
             */
            readonly resizeInterval: integer;

            /**
             * The DOM element that will be sent into full screen mode, or its `id`. If undefined Phaser will create its own div and insert the canvas into it when entering fullscreen mode.
             */
            readonly fullscreenTarget: HTMLElement | string;

            /**
             * The minimum width, in pixels, the canvas will scale down to. A value of zero means no minimum.
             */
            readonly minWidth: integer;

            /**
             * The maximum width, in pixels, the canvas will scale up to. A value of zero means no maximum.
             */
            readonly maxWidth: integer;

            /**
             * The minimum height, in pixels, the canvas will scale down to. A value of zero means no minimum.
             */
            readonly minHeight: integer;

            /**
             * The maximum height, in pixels, the canvas will scale up to. A value of zero means no maximum.
             */
            readonly maxHeight: integer;

            /**
             * Force Phaser to use a specific renderer. Can be `CONST.CANVAS`, `CONST.WEBGL`, `CONST.HEADLESS` or `CONST.AUTO` (default)
             */
            readonly renderinterface: number;

            /**
             * Force Phaser to use your own Canvas element instead of creating one.
             */
            readonly canvas: HTMLCanvasElement;

            /**
             * Force Phaser to use your own Canvas context instead of creating one.
             */
            readonly context: CanvasRenderingContext2D | WebGLRenderingContext;

            /**
             * Optional CSS attributes to be set on the canvas object created by the renderer.
             */
            readonly canvasStyle: string;

            /**
             * Is Phaser running under a custom (non-native web) environment? If so, set this to `true` to skip internal Feature detection. If `true` the `renderinterface` cannot be left as `AUTO`.
             */
            readonly customEnvironment: boolean;

            /**
             * The default Scene configuration object.
             */
            readonly sceneConfig: object;

            /**
             * A seed which the Random Data Generator will use. If not given, a dynamic seed based on the time is used.
             */
            readonly seed: string[];

            /**
             * The title of the game.
             */
            readonly gameTitle: string;

            /**
             * The URL of the game.
             */
            readonly gameURL: string;

            /**
             * The version of the game.
             */
            readonly gameVersion: string;

            /**
             * If `true` the window will automatically be given focus immediately and on any future mousedown event.
             */
            readonly autoFocus: boolean;

            /**
             * EXPERIMENTAL: Do not currently use.
             */
            readonly domCreateContainer: boolean;

            /**
             * EXPERIMENTAL: Do not currently use.
             */
            readonly domBehindCanvas: boolean;

            /**
             * Enable the Keyboard Plugin. This can be disabled in games that don't need keyboard input.
             */
            readonly inputKeyboard: boolean;

            /**
             * The DOM Target to listen for keyboard events on. Defaults to `window` if not specified.
             */
            readonly inputKeyboardEventTarget: any;

            /**
             * `preventDefault` will be called on every non-modified key which has a key code in this array. By default, it is empty.
             */
            readonly inputKeyboardCapture: integer[];

            /**
             * Enable the Mouse Plugin. This can be disabled in games that don't need mouse input.
             */
            readonly inputMouse: boolean | object;

            /**
             * The DOM Target to listen for mouse events on. Defaults to the game canvas if not specified.
             */
            readonly inputMouseEventTarget: any;

            /**
             * Should mouse events be captured? I.e. have prevent default called on them.
             */
            readonly inputMouseCapture: boolean;

            /**
             * Enable the Touch Plugin. This can be disabled in games that don't need touch input.
             */
            readonly inputTouch: boolean;

            /**
             * The DOM Target to listen for touch events on. Defaults to the game canvas if not specified.
             */
            readonly inputTouchEventTarget: any;

            /**
             * Should touch events be captured? I.e. have prevent default called on them.
             */
            readonly inputTouchCapture: boolean;

            /**
             * The number of Pointer objects created by default. In a mouse-only, or non-multi touch game, you can leave this as 1.
             */
            readonly inputActivePointers: integer;

            /**
             * The smoothing factor to apply during Pointer movement. See {@link Phaser.Input.Pointer#smoothFactor}.
             */
            readonly inputSmoothFactor: integer;

            /**
             * Should Phaser use a queued input system for native DOM Events or not?
             */
            readonly inputQueue: boolean;

            /**
             * Enable the Gamepad Plugin. This can be disabled in games that don't need gamepad input.
             */
            readonly inputGamepad: boolean;

            /**
             * The DOM Target to listen for gamepad events on. Defaults to `window` if not specified.
             */
            readonly inputGamepadEventTarget: any;

            /**
             * Set to `true` to disable the right-click context menu.
             */
            readonly disableContextMenu: boolean;

            /**
             * The Audio Configuration object.
             */
            readonly audio: AudioConfig;

            /**
             * Don't write the banner line to the console.log.
             */
            readonly hideBanner: boolean;

            /**
             * Omit Phaser's name and version from the banner.
             */
            readonly hidePhaser: boolean;

            /**
             * The color of the banner text.
             */
            readonly bannerTextColor: string;

            /**
             * The background colors of the banner.
             */
            readonly bannerBackgroundColor: string[];

            /**
             * The Frame Rate Configuration object, as parsed by the Timestep class.
             */
            readonly fps: FPSConfig;

            /**
             * When set to `true`, WebGL uses linear interpolation to draw scaled or rotated textures, giving a smooth appearance.
             * When set to `false`, WebGL uses nearest-neighbor interpolation, giving a crisper appearance.
             * `false` also disables antialiasing of the game canvas itself, if the browser supports it, when the game canvas is scaled.
             */
            readonly antialias: boolean;

            /**
             * Draw texture-based Game Objects at only whole-integer positions. Game Objects without textures, like Graphics, ignore this property.
             */
            readonly roundPixels: boolean;

            /**
             * Prevent pixel art from becoming blurred when scaled. It will remain crisp (tells the WebGL renderer to automatically create textures using a linear filter mode).
             */
            readonly pixelArt: boolean;

            /**
             * Whether the game canvas will have a transparent background.
             */
            readonly transparent: boolean;

            /**
             * Whether the game canvas will be cleared between each rendering frame. You can disable this if you have a full-screen background image or game object.
             */
            readonly clearBeforeRender: boolean;

            /**
             * In WebGL mode, sets the drawing buffer to contain colors with pre-multiplied alpha.
             */
            readonly premultipliedAlpha: boolean;

            /**
             * Let the browser abort creating a WebGL context if it judges performance would be unacceptable.
             */
            readonly failIfMajorPerformanceCaveat: boolean;

            /**
             * "high-performance", "low-power" or "default". A hint to the browser on how much device power the game might use.
             */
            readonly powerPreference: string;

            /**
             * The default WebGL Batch size.
             */
            readonly batchSize: integer;

            /**
             * The maximum number of lights allowed to be visible within range of a single Camera in the LightManager.
             */
            readonly maxLights: integer;

            /**
             * The background color of the game canvas. The default is black. This value is ignored if `transparent` is set to `true`.
             */
            readonly backgroundColor: Display.Color;

            /**
             * Called before Phaser boots. Useful for initializing anything not related to Phaser that Phaser may require while booting.
             */
            readonly preBoot: BootCallback;

            /**
             * A function to run at the end of the boot sequence. At this point, all the game systems have started and plugins have been loaded.
             */
            readonly postBoot: BootCallback;

            /**
             * The Physics Configuration object.
             */
            readonly physics: PhysicsConfig;

            /**
             * The default physics system. It will be started for each scene. Either 'arcade', 'impact' or 'matter'.
             */
            readonly defaultPhysicsSystem: boolean | string;

            /**
             * A URL used to resolve paths given to the loader. Example: 'http://labs.phaser.io/assets/'.
             */
            readonly loaderBaseURL: string;

            /**
             * A URL path used to resolve relative paths given to the loader. Example: 'images/sprites/'.
             */
            readonly loaderPath: string;

            /**
             * Maximum parallel downloads allowed for resources (Default to 32).
             */
            readonly loaderMaxParallelDownloads: integer;

            /**
             * 'anonymous', 'use-credentials', or `undefined`. If you're not making cross-origin requests, leave this as `undefined`.
             * See {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes}.
             */
            readonly loaderCrossOrigin: string | undefined;

            /**
             * The response interface of the XHR request, e.g. `blob`, `text`, etc.
             */
            readonly loaderResponseinterface: string;

            /**
             * Should the XHR request use async or not?
             */
            readonly loaderAsync: boolean;

            /**
             * Optional username for all XHR requests.
             */
            readonly loaderUser: string;

            /**
             * Optional password for all XHR requests.
             */
            readonly loaderPassword: string;

            /**
             * Optional XHR timeout value, in ms.
             */
            readonly loaderTimeout: integer;

            /**
             * An array of global plugins to be installed.
             */
            readonly installGlobalPlugins: any;

            /**
             * An array of Scene level plugins to be installed.
             */
            readonly installScenePlugins: any;

            /**
             * The plugins installed into every Scene (in addition to CoreScene and Global).
             */
            readonly defaultPlugins: any;

            /**
             * A base64 encoded PNG that will be used as the default blank texture.
             */
            readonly defaultImage: string;

            /**
             * A base64 encoded PNG that will be used as the default texture when a texture is assigned that is missing or not loaded.
             */
            readonly missingImage: string;
        }

        /**
         * Called automatically by Phaser.Game and responsible for creating the renderer it will use.
         *
         * Relies upon two webpack global flags to be defined: `WEBGL_RENDERER` and `CANVAS_RENDERER` during build time, but not at run-time.
         * @param game The Phaser.Game instance on which the renderer will be set.
         */
        function CreateRenderer(game: Game): void;

        /**
         * Called automatically by Phaser.Game and responsible for creating the console.log debug header.
         *
         * You can customize or disable the header via the Game Config object.
         * @param game The Phaser.Game instance which will output this debug header.
         */
        function DebugHeader(game: Game): void;

        namespace Events {
            /**
             * The Game Blur Event.
             *
             * This event is dispatched by the Game Visibility Handler when the window in which the Game instance is embedded
             * enters a blurred state. The blur event is raised when the window loses focus. This can happen if a user swaps
             * tab, or if they simply remove focus from the browser to another app.
             */
            const BLUR: any;

            /**
             * The Game Boot Event.
             *
             * This event is dispatched when the Phaser Game instance has finished booting, but before it is ready to start running.
             * The global systems use this event to know when to set themselves up, dispatching their own `ready` events as required.
             */
            const BOOT: any;

            /**
             * The Game Destroy Event.
             *
             * This event is dispatched when the game instance has been told to destroy itself.
             * Lots of internal systems listen to this event in order to clear themselves out.
             * Custom plugins and game code should also do the same.
             */
            const DESTROY: any;

            /**
             * The Game Focus Event.
             *
             * This event is dispatched by the Game Visibility Handler when the window in which the Game instance is embedded
             * enters a focused state. The focus event is raised when the window re-gains focus, having previously lost it.
             */
            const FOCUS: any;

            /**
             * The Game Hidden Event.
             *
             * This event is dispatched by the Game Visibility Handler when the document in which the Game instance is embedded
             * enters a hidden state. Only browsers that support the Visibility API will cause this event to be emitted.
             *
             * In most modern browsers, when the document enters a hidden state, the Request Animation Frame and setTimeout, which
             * control the main game loop, will automatically pause. There is no way to stop this from happening. It is something
             * your game should account for in its own code, should the pause be an issue (i.e. for multiplayer games)
             */
            const HIDDEN: any;

            /**
             * The Game Pause Event.
             *
             * This event is dispatched when the Game loop enters a paused state, usually as a result of the Visibility Handler.
             */
            const PAUSE: any;

            /**
             * The Game Post-Render Event.
             *
             * This event is dispatched right at the end of the render process.
             *
             * Every Scene will have rendered and been drawn to the canvas by the time this event is fired.
             * Use it for any last minute post-processing before the next game step begins.
             */
            const POST_RENDER: any;

            /**
             * The Game Post-Step Event.
             *
             * This event is dispatched after the Scene Manager has updated.
             * Hook into it from plugins or systems that need to do things before the render starts.
             */
            const POST_STEP: any;

            /**
             * The Game Pre-Render Event.
             *
             * This event is dispatched immediately before any of the Scenes have started to render.
             *
             * The renderer will already have been initialized this frame, clearing itself and preparing to receive the Scenes for rendering, but it won't have actually drawn anything yet.
             */
            const PRE_RENDER: any;

            /**
             * The Game Pre-Step Event.
             *
             * This event is dispatched before the main Game Step starts. By this point in the game cycle none of the Scene updates have yet happened.
             * Hook into it from plugins or systems that need to update before the Scene Manager does.
             */
            const PRE_STEP: any;

            /**
             * The Game Ready Event.
             *
             * This event is dispatched when the Phaser Game instance has finished booting, the Texture Manager is fully ready,
             * and all local systems are now able to start.
             */
            const READY: any;

            /**
             * The Game Resume Event.
             *
             * This event is dispatched when the game loop leaves a paused state and resumes running.
             */
            const RESUME: any;

            /**
             * The Game Step Event.
             *
             * This event is dispatched after the Game Pre-Step and before the Scene Manager steps.
             * Hook into it from plugins or systems that need to update before the Scene Manager does, but after the core Systems have.
             */
            const STEP: any;

            /**
             * The Game Visible Event.
             *
             * This event is dispatched by the Game Visibility Handler when the document in which the Game instance is embedded
             * enters a visible state, previously having been hidden.
             *
             * Only browsers that support the Visibility API will cause this event to be emitted.
             */
            const VISIBLE: any;
        }

        /**
         * [description]
         */
        class TimeStep {
            /**
             *
             * @param game A reference to the Phaser.Game instance that owns this Time Step.
             */
            constructor(game: Game, config: FPSConfig);

            /**
             * A reference to the Phaser.Game instance.
             */
            readonly game: Game;

            /**
             * [description]
             */
            readonly raf: DOM.RequestAnimationFrame;

            /**
             * A flag that is set once the TimeStep has started running and toggled when it stops.
             */
            readonly started: boolean;

            /**
             * A flag that is set once the TimeStep has started running and toggled when it stops.
             * The difference between this value and `started` is that `running` is toggled when
             * the TimeStep is sent to sleep, where-as `started` remains `true`, only changing if
             * the TimeStep is actually stopped, not just paused.
             */
            readonly running: boolean;

            /**
             * The minimum fps rate you want the Time Step to run at.
             */
            minFps: integer;

            /**
             * The target fps rate for the Time Step to run at.
             *
             * Setting this value will not actually change the speed at which the browser runs, that is beyond
             * the control of Phaser. Instead, it allows you to determine performance issues and if the Time Step
             * is spiraling out of control.
             */
            targetFps: integer;

            /**
             * An exponential moving average of the frames per second.
             */
            readonly actualFps: integer;

            /**
             * [description]
             */
            readonly nextFpsUpdate: integer;

            /**
             * The number of frames processed this second.
             */
            readonly framesThisSecond: integer;

            /**
             * A callback to be invoked each time the Time Step steps.
             */
            callback: TimeStepCallback;

            /**
             * You can force the Time Step to use Set Timeout instead of Request Animation Frame by setting
             * the `forceSetTimeOut` property to `true` in the Game Configuration object. It cannot be changed at run-time.
             */
            readonly forceSetTimeOut: boolean;

            /**
             * [description]
             */
            time: integer;

            /**
             * [description]
             */
            startTime: integer;

            /**
             * [description]
             */
            lastTime: integer;

            /**
             * [description]
             */
            readonly frame: integer;

            /**
             * [description]
             */
            readonly inFocus: boolean;

            /**
             * [description]
             */
            delta: integer;

            /**
             * [description]
             */
            deltaIndex: integer;

            /**
             * [description]
             */
            deltaHistory: integer[];

            /**
             * [description]
             */
            deltaSmoothingMax: integer;

            /**
             * [description]
             */
            panicMax: integer;

            /**
             * The actual elapsed time in ms between one update and the next.
             * Unlike with `delta` no smoothing, capping, or averaging is applied to this value.
             * So please be careful when using this value in calculations.
             */
            rawDelta: number;

            /**
             * Called when the DOM window.onBlur event triggers.
             */
            blur(): void;

            /**
             * Called when the DOM window.onFocus event triggers.
             */
            focus(): void;

            /**
             * Called when the visibility API says the game is 'hidden' (tab switch out of view, etc)
             */
            pause(): void;

            /**
             * Called when the visibility API says the game is 'visible' again (tab switch back into view, etc)
             */
            resume(): void;

            /**
             * [description]
             */
            resetDelta(): void;

            /**
             * Starts the Time Step running, if it is not already doing so.
             * Called automatically by the Game Boot process.
             * @param callback The callback to be invoked each time the Time Step steps.
             */
            start(callback: TimeStepCallback): void;

            /**
             * The main step method. This is called each time the browser updates, either by Request Animation Frame,
             * or by Set Timeout. It is responsible for calculating the delta values, frame totals, cool down history and more.
             * You generally should never call this method directly.
             * @param time The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
             */
            step(time: number): void;

            /**
             * Manually calls TimeStep.step, passing in the performance.now value to it.
             */
            tick(): void;

            /**
             * Sends the TimeStep to sleep, stopping Request Animation Frame (or SetTimeout) and toggling the `running` flag to false.
             */
            sleep(): void;

            /**
             * Wakes-up the TimeStep, restarting Request Animation Frame (or SetTimeout) and toggling the `running` flag to true.
             * The `seamless` argument controls if the wake-up should adjust the start time or not.
             * @param seamless Adjust the startTime based on the lastTime values. Default false.
             */
            wake(seamless?: boolean): void;

            /**
             * Stops the TimeStep running.
             */
            stop(): TimeStep;

            /**
             * Destroys the TimeStep. This will stop Request Animation Frame, stop the step, clear the callbacks and null
             * any objects.
             */
            destroy(): void;
        }

        /**
         * The Visibility Handler is responsible for listening out for document level visibility change events.
         * This includes `visibilitychange` if the browser supports it, and blur and focus events. It then uses
         * the provided Event Emitter and fires the related events.
         * @param game The Game instance this Visibility Handler is working on.
         */
        function VisibilityHandler(game: Game): void;
    }

    namespace Create {
        /**
         * [description]
         * @param config [description]
         */
        function GenerateTexture(config: GenerateTextureConfig): HTMLCanvasElement;

        namespace Palettes {
            /**
             * A 16 color palette by [Arne](http://androidarts.com/palette/16pal.htm)
             */
            const ARNE16: Palette;

            /**
             * A 16 color palette inspired by the Commodore 64.
             */
            const C64: Palette;

            /**
             * A 16 color CGA inspired palette by [Arne](http://androidarts.com/palette/16pal.htm)
             */
            const CGA: Palette;

            /**
             * A 16 color JMP palette by [Arne](http://androidarts.com/palette/16pal.htm)
             */
            const JMP: Palette;

            /**
             * A 16 color palette inspired by Japanese computers like the MSX.
             */
            const MSX: Palette;
        }
    }

    namespace Curves {
        /**
         * A higher-order Bézier curve constructed of four points.
         */
        class CubicBezier extends Curve {
            /**
             *
             * @param p0 Start point, or an array of point pairs.
             * @param p1 Control Point 1.
             * @param p2 Control Point 2.
             * @param p3 End Point.
             */
            constructor(p0: Math.Vector2 | Math.Vector2[], p1: Math.Vector2, p2: Math.Vector2, p3: Math.Vector2);

            /**
             * The start point of this curve.
             */
            p0: Math.Vector2;

            /**
             * The first control point of this curve.
             */
            p1: Math.Vector2;

            /**
             * The second control point of this curve.
             */
            p2: Math.Vector2;

            /**
             * The end point of this curve.
             */
            p3: Math.Vector2;

            /**
             * Gets the starting point on the curve.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getStartPoint<O extends Math.Vector2>(out?: O): O;

            /**
             * Returns the resolution of this curve.
             * @param divisions The amount of divisions used by this curve.
             */
            getResolution(divisions: number): number;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Math.Vector2>(t: number, out?: O): O;

            /**
             * Draws this curve to the specified graphics object.
             * @param graphics The graphics object this curve should be drawn to.
             * @param pointsTotal The number of intermediary points that make up this curve. A higher number of points will result in a smoother curve. Default 32.
             */
            draw<G extends GameObjects.Graphics>(graphics: G, pointsTotal?: integer): G;

            /**
             * Returns a JSON object that describes this curve.
             */
            toJSON(): JSONCurve;

            /**
             * Generates a curve from a JSON object.
             * @param data The JSON object containing this curve data.
             */
            static fromJSON(data: JSONCurve): CubicBezier;
        }

        /**
         * A Base Curve class, which all other curve types extend.
         *
         * Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)
         */
        class Curve {
            /**
             *
             * @param interface [description]
             */
            constructor(interface: string);

            /**
             * String based identifier for the interface of curve.
             */
            interface: string;

            /**
             * The default number of divisions within the curve.
             */
            defaultDivisions: integer;

            /**
             * The quantity of arc length divisions within the curve.
             */
            arcLengthDivisions: integer;

            /**
             * An array of cached arc length values.
             */
            cacheArcLengths: number[];

            /**
             * Does the data of this curve need updating?
             */
            needsUpdate: boolean;

            /**
             * [description]
             */
            active: boolean;

            /**
             * Draws this curve on the given Graphics object.
             *
             * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.
             * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.
             * @param graphics The Graphics instance onto which this curve will be drawn.
             * @param pointsTotal The resolution of the curve. The higher the value the smoother it will render, at the cost of rendering performance. Default 32.
             */
            draw<G extends GameObjects.Graphics>(graphics: G, pointsTotal?: integer): G;

            /**
             * Returns a Rectangle where the position and dimensions match the bounds of this Curve.
             *
             * You can control the accuracy of the bounds. The value given is used to work out how many points
             * to plot across the curve. Higher values are more accurate at the cost of calculation speed.
             * @param out The Rectangle to store the bounds in. If falsey a new object will be created.
             * @param accuracy The accuracy of the bounds calculations. Default 16.
             */
            getBounds(out?: Geom.Rectangle, accuracy?: integer): Geom.Rectangle;

            /**
             * Returns an array of points, spaced out X distance pixels apart.
             * The smaller the distance, the larger the array will be.
             * @param distance The distance, in pixels, between each point along the curve.
             */
            getDistancePoints(distance: integer): Geom.Point[];

            /**
             * [description]
             * @param out Optional Vector object to store the result in.
             */
            getEndPoint(out?: Math.Vector2): Math.Vector2;

            /**
             * [description]
             */
            getLength(): number;

            /**
             * [description]
             * @param divisions [description]
             */
            getLengths(divisions?: integer): number[];

            /**
             * [description]
             * @param u [description]
             * @param out [description]
             */
            getPointAt<O extends Math.Vector2>(u: number, out?: O): O;

            /**
             * [description]
             * @param divisions [description]
             */
            getPoints(divisions?: integer): Math.Vector2[];

            /**
             * [description]
             * @param out [description]
             */
            getRandomPoint<O extends Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions [description]
             */
            getSpacedPoints(divisions?: integer): Math.Vector2[];

            /**
             * [description]
             * @param out [description]
             */
            getStartPoint<O extends Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param t [description]
             * @param out [description]
             */
            getTangent<O extends Math.Vector2>(t: number, out?: O): O;

            /**
             * [description]
             * @param u [description]
             * @param out [description]
             */
            getTangentAt<O extends Math.Vector2>(u: number, out?: O): O;

            /**
             * [description]
             * @param distance [description]
             * @param divisions [description]
             */
            getTFromDistance(distance: integer, divisions?: integer): number;

            /**
             * [description]
             * @param u [description]
             * @param distance [description]
             * @param divisions [description]
             */
            getUtoTmapping(u: number, distance: integer, divisions?: integer): number;

            /**
             * [description]
             */
            updateArcLengths(): void;
        }

        /**
         * An Elliptical Curve derived from the Base Curve class.
         *
         * See https://en.wikipedia.org/wiki/Elliptic_curve for more details.
         */
        class Ellipse extends Curve {
            /**
             *
             * @param x The x coordinate of the ellipse, or an Ellipse Curve configuration object. Default 0.
             * @param y The y coordinate of the ellipse. Default 0.
             * @param xRadius The horizontal radius of ellipse. Default 0.
             * @param yRadius The vertical radius of ellipse. Default 0.
             * @param startAngle The start angle of the ellipse, in degrees. Default 0.
             * @param endAngle The end angle of the ellipse, in degrees. Default 360.
             * @param clockwise Sets if the the ellipse rotation is clockwise (true) or anti-clockwise (false) Default false.
             * @param rotation The rotation of the ellipse, in degrees. Default 0.
             */
            constructor(x?: number | EllipseCurveConfig, y?: number, xRadius?: number, yRadius?: number, startAngle?: integer, endAngle?: integer, clockwise?: boolean, rotation?: integer);

            /**
             * The center point of the ellipse. Used for calculating rotation.
             */
            p0: Math.Vector2;

            /**
             * Gets the starting point on the curve.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getStartPoint<O extends Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions [description]
             */
            getResolution(divisions: number): number;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Math.Vector2>(t: number, out?: O): O;

            /**
             * Sets the horizontal radius of this curve.
             * @param value The horizontal radius of this curve.
             */
            setXRadius(value: number): Ellipse;

            /**
             * Sets the vertical radius of this curve.
             * @param value The vertical radius of this curve.
             */
            setYRadius(value: number): Ellipse;

            /**
             * Sets the width of this curve.
             * @param value The width of this curve.
             */
            setWidth(value: number): Ellipse;

            /**
             * Sets the height of this curve.
             * @param value The height of this curve.
             */
            setHeight(value: number): Ellipse;

            /**
             * Sets the start angle of this curve.
             * @param value The start angle of this curve, in radians.
             */
            setStartAngle(value: number): Ellipse;

            /**
             * Sets the end angle of this curve.
             * @param value The end angle of this curve, in radians.
             */
            setEndAngle(value: number): Ellipse;

            /**
             * Sets if this curve extends clockwise or anti-clockwise.
             * @param value The clockwise state of this curve.
             */
            setClockwise(value: boolean): Ellipse;

            /**
             * Sets the rotation of this curve.
             * @param value The rotation of this curve, in radians.
             */
            setRotation(value: number): Ellipse;

            /**
             * The x coordinate of the center of the ellipse.
             */
            x: number;

            /**
             * The y coordinate of the center of the ellipse.
             */
            y: number;

            /**
             * The horizontal radius of the ellipse.
             */
            xRadius: number;

            /**
             * The vertical radius of the ellipse.
             */
            yRadius: number;

            /**
             * The start angle of the ellipse in degrees.
             */
            startAngle: number;

            /**
             * The end angle of the ellipse in degrees.
             */
            endAngle: number;

            /**
             * `true` if the ellipse rotation is clockwise or `false` if anti-clockwise.
             */
            clockwise: boolean;

            /**
             * The rotation of the ellipse, relative to the center, in degrees.
             */
            angle: number;

            /**
             * The rotation of the ellipse, relative to the center, in radians.
             */
            rotation: number;

            /**
             * JSON serialization of the curve.
             */
            toJSON(): JSONEllipseCurve;

            /**
             * Creates a curve from the provided Ellipse Curve Configuration object.
             * @param data The JSON object containing this curve data.
             */
            static fromJSON(data: JSONEllipseCurve): Ellipse;
        }

        /**
         * A LineCurve is a "curve" comprising exactly two points (a line segment).
         */
        class Line extends Curve {
            /**
             *
             * @param p0 The first endpoint.
             * @param p1 The second endpoint.
             */
            constructor(p0: Math.Vector2 | number[], p1?: Math.Vector2);

            /**
             * The first endpoint.
             */
            p0: Math.Vector2;

            /**
             * The second endpoint.
             */
            p1: Math.Vector2;

            /**
             * Returns a Rectangle where the position and dimensions match the bounds of this Curve.
             * @param out A Rectangle object to store the bounds in. If not given a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(out?: O): O;

            /**
             * Gets the starting point on the curve.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getStartPoint<O extends Math.Vector2>(out?: O): O;

            /**
             * Gets the resolution of the line.
             * @param divisions The number of divisions to consider. Default 1.
             */
            getResolution(divisions?: number): number;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Math.Vector2>(t: number, out?: O): O;

            /**
             * Gets a point at a given position on the line.
             * @param u The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPointAt<O extends Math.Vector2>(u: number, out?: O): O;

            /**
             * Gets the slope of the line as a unit vector.
             */
            getTangent<O extends Math.Vector2>(t: number, out?: O): O;

            /**
             * Draws this curve on the given Graphics object.
             *
             * The curve is drawn using `Graphics.lineBetween` so will be drawn at whatever the present Graphics line color is.
             * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.
             * @param graphics The Graphics instance onto which this curve will be drawn.
             */
            draw<G extends GameObjects.Graphics>(graphics: G): G;

            /**
             * Gets a JSON representation of the line.
             */
            toJSON(): JSONCurve;

            /**
             * Configures this line from a JSON representation.
             * @param data The JSON object containing this curve data.
             */
            static fromJSON(data: JSONCurve): Line;
        }

        /**
         * A MoveTo Curve is a very simple curve consisting of only a single point. Its intended use is to move the ending point in a Path.
         */
        class MoveTo {
            /**
             *
             * @param x `x` pixel coordinate.
             * @param y `y` pixel coordinate.
             */
            constructor(x?: number, y?: number);

            /**
             * Denotes that this Curve does not influence the bounds, points, and drawing of its parent Path. Must be `false` or some methods in the parent Path will throw errors.
             */
            active: boolean;

            /**
             * The lone point which this curve consists of.
             */
            p0: Math.Vector2;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Math.Vector2>(t: number, out?: O): O;

            /**
             * Retrieves the point at given position in the curve. This will always return this curve's only point.
             * @param u The position in the path to retrieve, between 0 and 1. Not used.
             * @param out An optional vector in which to store the point.
             */
            getPointAt<O extends Math.Vector2>(u: number, out?: O): O;

            /**
             * Gets the resolution of this curve.
             */
            getResolution(): number;

            /**
             * Gets the length of this curve.
             */
            getLength(): number;

            /**
             * Converts this curve into a JSON-serializable object.
             */
            toJSON(): JSONCurve;
        }

        /**
         * A Path combines multiple Curves into one continuous compound curve. It does not matter how many Curves are in the Path or what interface they are.
         *
         * A Curve in a Path does not have to start where the previous Curve ends - that is to say, a Path does not have to be an uninterrupted curve.
         * Only the order of the Curves influences the actual points on the Path.
         */
        class Path {
            /**
             *
             * @param x The X coordinate of the Path's starting point or a {@link JSONPath}. Default 0.
             * @param y The Y coordinate of the Path's starting point. Default 0.
             */
            constructor(x?: number, y?: number);

            /**
             * The name of this Path.
             * Empty by default and never populated by Phaser, this is left for developers to use.
             */
            name: string;

            /**
             * The list of Curves which make up this Path.
             */
            curves: Curve[];

            /**
             * The cached length of each Curve in the Path.
             *
             * Used internally by {@link #getCurveLengths}.
             */
            cacheLengths: number[];

            /**
             * Automatically closes the path.
             */
            autoClose: boolean;

            /**
             * The starting point of the Path.
             *
             * This is not necessarily equivalent to the starting point of the first Curve in the Path. In an empty Path, it's also treated as the ending point.
             */
            startPoint: Math.Vector2;

            /**
             * Appends a Curve to the end of the Path.
             *
             * The Curve does not have to start where the Path ends or, for an empty Path, at its defined starting point.
             * @param curve The Curve to append.
             */
            add(curve: Curve): Path;

            /**
             * Creates a circular Ellipse Curve positioned at the end of the Path.
             * @param radius The radius of the circle.
             * @param clockwise `true` to create a clockwise circle as opposed to a counter-clockwise circle. Default false.
             * @param rotation The rotation of the circle in degrees. Default 0.
             */
            circleTo(radius: number, clockwise?: boolean, rotation?: number): Path;

            /**
             * Ensures that the Path is closed.
             *
             * A closed Path starts and ends at the same point. If the Path is not closed, a straight Line Curve will be created from the ending point directly to the starting point.
             * During the check, the actual starting point of the Path, i.e. the starting point of the first Curve,
             * will be used as opposed to the Path's defined {@link startPoint}, which could differ.
             *
             * Calling this method on an empty Path will result in an error.
             */
            closePath(): Path;

            /**
             * Creates a cubic bezier curve starting at the previous end point and ending at p3, using p1 and p2 as control points.
             * @param x The x coordinate of the end point. Or, if a Vec2, the p1 value.
             * @param y The y coordinate of the end point. Or, if a Vec2, the p2 value.
             * @param control1X The x coordinate of the first control point. Or, if a Vec2, the p3 value.
             * @param control1Y The y coordinate of the first control point. Not used if vec2s are provided as the first 3 arguments.
             * @param control2X The x coordinate of the second control point. Not used if vec2s are provided as the first 3 arguments.
             * @param control2Y The y coordinate of the second control point. Not used if vec2s are provided as the first 3 arguments.
             */
            cubicBezierTo(
                x: number | Math.Vector2,
                y: number | Math.Vector2,
                control1X: number | Math.Vector2,
                control1Y?: number,
                control2X?: number,
                control2Y?: number
            ): Path;

            /**
             * Creates a Quadratic Bezier Curve starting at the ending point of the Path.
             * @param x The X coordinate of the second control point or, if it's a `Vector2`, the first control point.
             * @param y The Y coordinate of the second control point or, if `x` is a `Vector2`, the second control point.
             * @param controlX If `x` is not a `Vector2`, the X coordinate of the first control point.
             * @param controlY If `x` is not a `Vector2`, the Y coordinate of the first control point.
             */
            quadraticBezierTo(x: number | Math.Vector2[], y?: number, controlX?: number, controlY?: number): Path;

            /**
             * Draws all Curves in the Path to a Graphics Game Object.
             * @param graphics The Graphics Game Object to draw to.
             * @param pointsTotal The number of points to draw for each Curve. Higher numbers result in a smoother curve but require more processing. Default 32.
             */
            draw<G extends GameObjects.Graphics>(graphics: G, pointsTotal?: integer): G;

            /**
             * Creates an ellipse curve positioned at the previous end point, using the given parameters.
             * @param xRadius The horizontal radius of the ellipse.
             * @param yRadius The vertical radius of the ellipse.
             * @param startAngle The start angle of the ellipse, in degrees.
             * @param endAngle The end angle of the ellipse, in degrees.
             * @param clockwise Whether the ellipse should be rotated clockwise (`true`) or counter-clockwise (`false`).
             * @param rotation The rotation of the ellipse, in degrees.
             */
            ellipseTo(xRadius: number, yRadius: number, startAngle: number, endAngle: number, clockwise: boolean, rotation: number): Path;

            /**
             * Creates a Path from a Path Configuration object.
             *
             * The provided object should be a {@link JSONPath}, as returned by {@link #toJSON}. Providing a malformed object may cause errors.
             * @param data The JSON object containing the Path data.
             */
            fromJSON(data: object): Path;

            /**
             * Returns a Rectangle with a position and size matching the bounds of this Path.
             * @param out The Rectangle to store the bounds in.
             * @param accuracy The accuracy of the bounds calculations. Higher values are more accurate at the cost of calculation speed. Default 16.
             */
            getBounds<O extends Math.Vector2>(out?: O, accuracy?: integer): O;

            /**
             * Returns an array containing the length of the Path at the end of each Curve.
             *
             * The result of this method will be cached to avoid recalculating it in subsequent calls. The cache is only invalidated when the {@link #curves} array changes in length,
             * leading to potential inaccuracies if a Curve in the Path is changed, or if a Curve is removed and another is added in its place.
             */
            getCurveLengths(): number[];

            /**
             * Returns the ending point of the Path.
             *
             * A Path's ending point is equivalent to the ending point of the last Curve in the Path. For an empty Path, the ending point is at the Path's defined {@link #startPoint}.
             * @param out The object to store the point in.
             */
            getEndPoint<O extends Math.Vector2>(out?: O): O;

            /**
             * Returns the total length of the Path.
             */
            getLength(): number;

            /**
             * Calculates the coordinates of the point at the given normalized location (between 0 and 1) on the Path.
             *
             * The location is relative to the entire Path, not to an individual Curve.
             * A location of 0.5 is always in the middle of the Path and is thus an equal distance away from both its starting and ending points.
             * In a Path with one Curve, it would be in the middle of the Curve; in a Path with two Curves, it could be anywhere on either one of them depending on their lengths.
             * @param t The location of the point to return, between 0 and 1.
             * @param out The object in which to store the calculated point.
             */
            getPoint<O extends Math.Vector2>(t: number, out?: O): O;

            /**
             * Returns the defined starting point of the Path.
             *
             * This is not necessarily equal to the starting point of the first Curve if it differs from {@link startPoint}.
             * @param divisions The number of points to divide the path in to. Default 12.
             */
            getPoints(divisions?: integer): Math.Vector2[];

            /**
             * [description]
             * @param out `Vector2` instance that should be used for storing the result. If `undefined` a new `Vector2` will be created.
             */
            getRandomPoint<O extends Math.Vector2>(out?: O): O;

            /**
             * Creates a straight Line Curve from the ending point of the Path to the given coordinates.
             * @param divisions The X coordinate of the line's ending point, or the line's ending point as a `Vector2`. Default 40.
             */
            getSpacedPoints(divisions?: integer): Math.Vector2[];

            /**
             * [description]
             * @param out [description]
             */
            getStartPoint<O extends Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            lineTo(x: number | Math.Vector2, y?: number): Path;

            /**
             * [description]
             * @param points [description]
             */
            splineTo(points: Math.Vector2[]): Path;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            moveTo(x: number, y: number): Path;

            /**
             * [description]
             */
            toJSON(): JSONPath;

            /**
             * [description]
             */
            updateArcLengths(): void;

            /**
             * [description]
             */
            destroy(): void;
        }

        /**
         * [description]
         */
        class QuadraticBezier extends Curve {
            /**
             *
             * @param p0 Start point, or an array of point pairs.
             * @param p1 Control Point 1.
             * @param p2 Control Point 2.
             */
            constructor(p0: Math.Vector2 | number[], p1: Math.Vector2, p2: Math.Vector2);

            /**
             * [description]
             */
            p0: Math.Vector2;

            /**
             * [description]
             */
            p1: Math.Vector2;

            /**
             * [description]
             */
            p2: Math.Vector2;

            /**
             * Gets the starting point on the curve.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getStartPoint<O extends Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions [description]
             */
            getResolution(divisions: number): number;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Math.Vector2>(t: number, out?: O): O;

            /**
             * [description]
             * @param graphics `Graphics` object to draw onto.
             * @param pointsTotal Number of points to be used for drawing the curve. Higher numbers result in smoother curve but require more processing. Default 32.
             */
            draw<G extends GameObjects.Graphics>(graphics: G, pointsTotal?: integer): G;

            /**
             * Converts the curve into a JSON compatible object.
             */
            toJSON(): JSONCurve;

            /**
             * Creates a curve from a JSON object, e. g. created by `toJSON`.
             * @param data The JSON object containing this curve data.
             */
            static fromJSON(data: JSONCurve): QuadraticBezier;
        }

        /**
         * [description]
         */
        class Spline extends Curve {
            /**
             *
             * @param points [description]
             */
            constructor(points?: Math.Vector2[]);

            /**
             * [description]
             */
            points: Math.Vector2[];

            /**
             * [description]
             * @param points [description]
             */
            addPoints(points: Math.Vector2[] | number[] | number[][]): Spline;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            addPoint(x: number, y: number): Math.Vector2;

            /**
             * Gets the starting point on the curve.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getStartPoint<O extends Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions [description]
             */
            getResolution(divisions: number): number;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Math.Vector2>(t: number, out?: O): O;

            /**
             * [description]
             */
            toJSON(): JSONCurve;

            /**
             * [description]
             * @param data The JSON object containing this curve data.
             */
            static fromJSON(data: JSONCurve): Spline;
        }
    }

    namespace Data {
        /**
         * The Data Manager Component features a means to store pieces of data specific to a Game Object, System or Plugin.
         * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,
         * or have a property called `events` that is an instance of it.
         */
        class DataManager {
            /**
             *
             * @param parent The object that this DataManager belongs to.
             * @param eventEmitter The DataManager's event emitter.
             */
            constructor(parent: object, eventEmitter: Phaser.Events.EventEmitter);

            /**
             * The object that this DataManager belongs to.
             */
            parent: any;

            /**
             * The DataManager's event emitter.
             */
            events: Phaser.Events.EventEmitter;

            /**
             * The data list.
             */
            list: {[key: string]: any};

            /**
             * The public values list. You can use this to access anything you have stored
             * in this Data Manager. For example, if you set a value called `gold` you can
             * access it via:
             *
             * ```javascript
             * this.data.values.gold;
             * ```
             *
             * You can also modify it directly:
             *
             * ```javascript
             * this.data.values.gold += 1000;
             * ```
             *
             * Doing so will emit a `setdata` event from the parent of this Data Manager.
             *
             * Do not modify this object directly. Adding properties directly to this object will not
             * emit any events. Always use `DataManager.set` to create new items the first time around.
             */
            values: {[key: string]: any};

            /**
             * Retrieves the value for the given key, or undefined if it doesn't exist.
             *
             * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:
             *
             * ```javascript
             * this.data.get('gold');
             * ```
             *
             * Or access the value directly:
             *
             * ```javascript
             * this.data.values.gold;
             * ```
             *
             * You can also pass in an array of keys, in which case an array of values will be returned:
             *
             * ```javascript
             * this.data.get([ 'gold', 'armor', 'health' ]);
             * ```
             *
             * This approach is useful for destructuring arrays in ES6.
             * @param key The key of the value to retrieve, or an array of keys.
             */
            get(key: string | string[]): any;

            /**
             * Retrieves all data values in a new object.
             */
            getAll(): {[key: string]: any};

            /**
             * Queries the DataManager for the values of keys matching the given regular expression.
             * @param search A regular expression object. If a non-RegExp object obj is passed, it is implicitly converted to a RegExp by using new RegExp(obj).
             */
            query(search: RegExp): {[key: string]: any};

            /**
             * Sets a value for the given key. If the key doesn't already exist in the Data Manager then it is created.
             *
             * ```javascript
             * data.set('name', 'Red Gem Stone');
             * ```
             *
             * You can also pass in an object of key value pairs as the first argument:
             *
             * ```javascript
             * data.set({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });
             * ```
             *
             * To get a value back again you can call `get`:
             *
             * ```javascript
             * data.get('gold');
             * ```
             *
             * Or you can access the value directly via the `values` property, where it works like any other variable:
             *
             * ```javascript
             * data.values.gold += 50;
             * ```
             *
             * When the value is first set, a `setdata` event is emitted.
             *
             * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.
             * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.
             * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.
             *
             * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.
             * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.
             * @param key The key to set the value for. Or an object or key value pairs. If an object the `data` argument is ignored.
             * @param data The value to set for the given key. If an object is provided as the key this argument is ignored.
             */
            set(key: string | object, data: any): DataManager;

            /**
             * Passes all data entries to the given callback.
             * @param callback The function to call.
             * @param context Value to use as `this` when executing callback.
             * @param args Additional arguments that will be passed to the callback, after the game object, key, and data.
             */
            each(callback: DataEachCallback, context?: any, ...args: any[]): DataManager;

            /**
             * Merge the given object of key value pairs into this DataManager.
             *
             * Any newly created values will emit a `setdata` event. Any updated values (see the `overwrite` argument)
             * will emit a `changedata` event.
             * @param data The data to merge.
             * @param overwrite Whether to overwrite existing data. Defaults to true. Default true.
             */
            merge(data: {[key: string]: any}, overwrite?: boolean): DataManager;

            /**
             * Remove the value for the given key.
             *
             * If the key is found in this Data Manager it is removed from the internal lists and a
             * `removedata` event is emitted.
             *
             * You can also pass in an array of keys, in which case all keys in the array will be removed:
             *
             * ```javascript
             * this.data.remove([ 'gold', 'armor', 'health' ]);
             * ```
             * @param key The key to remove, or an array of keys to remove.
             */
            remove(key: string | string[]): DataManager;

            /**
             * Retrieves the data associated with the given 'key', deletes it from this Data Manager, then returns it.
             * @param key The key of the value to retrieve and delete.
             */
            pop(key: string): any;

            /**
             * Determines whether the given key is set in this Data Manager.
             *
             * Please note that the keys are case-sensitive and must be valid JavaScript Object property strings.
             * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.
             * @param key The key to check.
             */
            has(key: string): boolean;

            /**
             * Freeze or unfreeze this Data Manager. A frozen Data Manager will block all attempts
             * to create new values or update existing ones.
             * @param value Whether to freeze or unfreeze the Data Manager.
             */
            setFreeze(value: boolean): DataManager;

            /**
             * Delete all data in this Data Manager and unfreeze it.
             */
            reset(): DataManager;

            /**
             * Destroy this data manager.
             */
            destroy(): void;

            /**
             * Gets or sets the frozen state of this Data Manager.
             * A frozen Data Manager will block all attempts to create new values or update existing ones.
             */
            freeze: boolean;

            /**
             * Return the total number of entries in this Data Manager.
             */
            count: integer;
        }

        /**
         * The Data Component features a means to store pieces of data specific to a Game Object, System or Plugin.
         * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,
         * or have a property called `events` that is an instance of it.
         */
        class DataManagerPlugin extends DataManager {
            /**
             *
             * @param scene A reference to the Scene that this DataManager belongs to.
             */
            constructor(scene: Scene);

            /**
             * A reference to the Scene that this DataManager belongs to.
             */
            scene: Scene;

            /**
             * A reference to the Scene's Systems.
             */
            systems: Scenes.Systems;

            /**
             * The Scene that owns this plugin is being destroyed.
             * We need to shutdown and then kill off all external references.
             */
            destroy(): void;
        }

        namespace Events {
            /**
             * The Change Data Event.
             *
             * This event is dispatched by a Data Manager when an item in the data store is changed.
             *
             * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for
             * a change data event from a Game Object you would use: `sprite.data.on('changedata', listener)`.
             *
             * This event is dispatched for all items that change in the Data Manager.
             * To listen for the change of a specific item, use the `CHANGE_DATA_KEY_EVENT` event.
             */
            const CHANGE_DATA: any;

            /**
             * The Change Data Key Event.
             *
             * This event is dispatched by a Data Manager when an item in the data store is changed.
             *
             * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for
             * the change of a specific data item from a Game Object you would use: `sprite.data.on('changedata-key', listener)`,
             * where `key` is the unique string key of the data item. For example, if you have a data item stored called `gold`
             * then you can listen for `sprite.data.on('changedata-gold')`.
             */
            const CHANGE_DATA_KEY: any;

            /**
             * The Remove Data Event.
             *
             * This event is dispatched by a Data Manager when an item is removed from it.
             *
             * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for
             * the removal of a data item on a Game Object you would use: `sprite.data.on('removedata', listener)`.
             */
            const REMOVE_DATA: any;

            /**
             * The Set Data Event.
             *
             * This event is dispatched by a Data Manager when a new item is added to the data store.
             *
             * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for
             * the addition of a new data item on a Game Object you would use: `sprite.data.on('setdata', listener)`.
             */
            const SET_DATA: any;
        }
    }

    namespace Device {
        /**
         * Determines the audio playback capabilities of the device running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.audio` from within any Scene.
         */
        interface Audio {
            /**
             * Can this device play HTML Audio tags?
             */
            audioData: boolean;
            /**
             * Can this device play EC-3 Dolby Digital Plus files?
             */
            dolby: boolean;
            /**
             * Can this device can play m4a files.
             */
            m4a: boolean;
            /**
             * Can this device play mp3 files?
             */
            mp3: boolean;
            /**
             * Can this device play ogg files?
             */
            ogg: boolean;
            /**
             * Can this device play opus files?
             */
            opus: boolean;
            /**
             * Can this device play wav files?
             */
            wav: boolean;
            /**
             * Does this device have the Web Audio API?
             */
            webAudio: boolean;
            /**
             * Can this device play webm files?
             */
            webm: boolean;
        }

        /**
         * Determines the browser interface and version running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.browser` from within any Scene.
         */
        interface Browser {
            /**
             * Set to true if running in Chrome.
             */
            chrome: boolean;
            /**
             * Set to true if running in Microsoft Edge browser.
             */
            edge: boolean;
            /**
             * Set to true if running in Firefox.
             */
            firefox: boolean;
            /**
             * Set to true if running in Internet Explorer 11 or less (not Edge).
             */
            ie: boolean;
            /**
             * Set to true if running in Mobile Safari.
             */
            mobileSafari: boolean;
            /**
             * Set to true if running in Opera.
             */
            opera: boolean;
            /**
             * Set to true if running in Safari.
             */
            safari: boolean;
            /**
             * Set to true if running in the Silk browser (as used on the Amazon Kindle)
             */
            silk: boolean;
            /**
             * Set to true if running a Trident version of Internet Explorer (IE11+)
             */
            trident: boolean;
            /**
             * If running in Chrome this will contain the major version number.
             */
            chromeVersion: number;
            /**
             * If running in Firefox this will contain the major version number.
             */
            firefoxVersion: number;
            /**
             * If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Browser.trident and Browser.tridentVersion.
             */
            ieVersion: number;
            /**
             * If running in Safari this will contain the major version number.
             */
            safariVersion: number;
            /**
             * If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}
             */
            tridentVersion: number;
        }

        /**
         * Determines the canvas features of the browser running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.canvasFeatures` from within any Scene.
         */
        interface CanvasFeatures {
            /**
             * Set to true if the browser supports inversed alpha.
             */
            supportInverseAlpha: boolean;
            /**
             * Set to true if the browser supports new canvas blend modes.
             */
            supportNewBlendModes: boolean;
        }

        /**
         * Determines the features of the browser running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.features` from within any Scene.
         */
        interface Features {
            /**
             * True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.
             */
            canvasBitBltShift: boolean;
            /**
             * Is canvas available?
             */
            canvas: boolean;
            /**
             * Is file available?
             */
            file: boolean;
            /**
             * Is fileSystem available?
             */
            fileSystem: boolean;
            /**
             * Does the device support the getUserMedia API?
             */
            getUserMedia: boolean;
            /**
             * Is the device big or little endian? (only detected if the browser supports interfacedArrays)
             */
            littleEndian: boolean;
            /**
             * Is localStorage available?
             */
            localStorage: boolean;
            /**
             * Is Pointer Lock available?
             */
            pointerLock: boolean;
            /**
             * Does the device context support 32bit pixel manipulation using array buffer views?
             */
            support32bit: boolean;
            /**
             * Does the device support the Vibration API?
             */
            vibration: boolean;
            /**
             * Is webGL available?
             */
            webGL: boolean;
            /**
             * Is worker available?
             */
            worker: boolean;
        }

        /**
         * Determines the full screen support of the browser running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.fullscreen` from within any Scene.
         */
        interface Fullscreen {
            /**
             * Does the browser support the Full Screen API?
             */
            available: boolean;
            /**
             * Does the browser support access to the Keyboard during Full Screen mode?
             */
            keyboard: boolean;
            /**
             * If the browser supports the Full Screen API this holds the call you need to use to cancel it.
             */
            cancel: string;
            /**
             * If the browser supports the Full Screen API this holds the call you need to use to activate it.
             */
            request: string;
        }

        /**
         * Determines the input support of the browser running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.input` from within any Scene.
         */
        interface Input {
            /**
             * The newest interface of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'
             */
            wheelinterface: string;
            /**
             * Is navigator.getGamepads available?
             */
            gamepads: boolean;
            /**
             * Is mspointer available?
             */
            mspointer: boolean;
            /**
             * Is touch available?
             */
            touch: boolean;
        }

        /**
         * Determines the operating system of the device running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.os` from within any Scene.
         */
        interface OS {
            /**
             * Is running on android?
             */
            android: boolean;
            /**
             * Is running on chromeOS?
             */
            chromeOS: boolean;
            /**
             * Is the game running under CocoonJS?
             */
            cocoonJS: boolean;
            /**
             * Is this game running with CocoonJS.App?
             */
            cocoonJSApp: boolean;
            /**
             * Is the game running under Apache Cordova?
             */
            cordova: boolean;
            /**
             * Is the game running under the Intel Crosswalk XDK?
             */
            crosswalk: boolean;
            /**
             * Is running on a desktop?
             */
            desktop: boolean;
            /**
             * Is the game running under Ejecta?
             */
            ejecta: boolean;
            /**
             * Is the game running under GitHub Electron?
             */
            electron: boolean;
            /**
             * Is running on iOS?
             */
            iOS: boolean;
            /**
             * Is running on iPad?
             */
            iPad: boolean;
            /**
             * Is running on iPhone?
             */
            iPhone: boolean;
            /**
             * Is running on an Amazon Kindle?
             */
            kindle: boolean;
            /**
             * Is running on linux?
             */
            linux: boolean;
            /**
             * Is running on macOS?
             */
            macOS: boolean;
            /**
             * Is the game running under Node.js?
             */
            node: boolean;
            /**
             * Is the game running under Node-Webkit?
             */
            nodeWebkit: boolean;
            /**
             * Set to true if running as a WebApp, i.e. within a WebView
             */
            webApp: boolean;
            /**
             * Is running on windows?
             */
            windows: boolean;
            /**
             * Is running on a Windows Phone?
             */
            windowsPhone: boolean;
            /**
             * If running in iOS this will contain the major version number.
             */
            iOSVersion: number;
            /**
             * PixelRatio of the host device?
             */
            pixelRatio: number;
        }

        /**
         * Determines the video support of the browser running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.video` from within any Scene.
         */
        interface Video {
            /**
             * Can this device play h264 mp4 video files?
             */
            h264Video: boolean;
            /**
             * Can this device play hls video files?
             */
            hlsVideo: boolean;
            /**
             * Can this device play h264 mp4 video files?
             */
            mp4Video: boolean;
            /**
             * Can this device play ogg video files?
             */
            oggVideo: boolean;
            /**
             * Can this device play vp9 video files?
             */
            vp9Video: boolean;
            /**
             * Can this device play webm video files?
             */
            webmVideo: boolean;
        }
    }

    interface DeviceConf {
        /**
         * The OS Device functions.
         */
        os: Device.OS;
        /**
         * The Browser Device functions.
         */
        browser: Device.Browser;
        /**
         * The Features Device functions.
         */
        features: Device.Features;
        /**
         * The Input Device functions.
         */
        input: Device.Input;
        /**
         * The Audio Device functions.
         */
        audio: Device.Audio;
        /**
         * The Video Device functions.
         */
        video: Device.Video;
        /**
         * The Fullscreen Device functions.
         */
        fullscreen: Device.Fullscreen;
        /**
         * The Canvas Device functions.
         */
        canvasFeatures: Device.CanvasFeatures;
    }

    namespace Display {
        namespace Align {
            /**
             * A constant representing a top-left alignment or position.
             */
            const TOP_LEFT: integer;

            /**
             * A constant representing a top-center alignment or position.
             */
            const TOP_CENTER: integer;

            /**
             * A constant representing a top-right alignment or position.
             */
            const TOP_RIGHT: integer;

            /**
             * A constant representing a left-top alignment or position.
             */
            const LEFT_TOP: integer;

            /**
             * A constant representing a left-center alignment or position.
             */
            const LEFT_CENTER: integer;

            /**
             * A constant representing a left-bottom alignment or position.
             */
            const LEFT_BOTTOM: integer;

            /**
             * A constant representing a center alignment or position.
             */
            const CENTER: integer;

            /**
             * A constant representing a right-top alignment or position.
             */
            const RIGHT_TOP: integer;

            /**
             * A constant representing a right-center alignment or position.
             */
            const RIGHT_CENTER: integer;

            /**
             * A constant representing a right-bottom alignment or position.
             */
            const RIGHT_BOTTOM: integer;

            /**
             * A constant representing a bottom-left alignment or position.
             */
            const BOTTOM_LEFT: integer;

            /**
             * A constant representing a bottom-center alignment or position.
             */
            const BOTTOM_CENTER: integer;

            /**
             * A constant representing a bottom-right alignment or position.
             */
            const BOTTOM_RIGHT: integer;

            namespace In {
                /**
                 * Takes given Game Object and aligns it so that it is positioned in the bottom center of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomCenter<G extends GameObjects.GameObject>(gameObject: G, alignIn: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the bottom left of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomLeft<G extends GameObjects.GameObject>(gameObject: G, alignIn: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the bottom right of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomRight<G extends GameObjects.GameObject>(gameObject: G, alignIn: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the center of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function Center<G extends GameObjects.GameObject>(gameObject: G, alignIn: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the left center of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function LeftCenter<G extends GameObjects.GameObject>(gameObject: G, alignIn: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned relative to the other.
                 * The alignment used is based on the `position` argument, which is an `ALIGN_CONST` value, such as `LEFT_CENTER` or `TOP_RIGHT`.
                 * @param child The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param position The position to align the Game Object with. This is an align constant, such as `ALIGN_CONST.LEFT_CENTER`.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function QuickSet<G extends GameObjects.GameObject>(child: G, alignIn: GameObjects.GameObject, position: integer, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the right center of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function RightCenter<G extends GameObjects.GameObject>(gameObject: G, alignIn: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the top center of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopCenter<G extends GameObjects.GameObject>(gameObject: G, alignIn: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the top left of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopLeft<G extends GameObjects.GameObject>(gameObject: G, alignIn: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the top right of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopRight<G extends GameObjects.GameObject>(gameObject: G, alignIn: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;
            }

            namespace To {
                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the bottom center position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomCenter<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the bottom left position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomLeft<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the bottom right position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomRight<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the left bottom position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function LeftBottom<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the left center position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function LeftCenter<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the left top position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function LeftTop<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the right bottom position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function RightBottom<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the right center position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function RightCenter<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the right top position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function RightTop<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the top center position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopCenter<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the top left position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopLeft<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the top right position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopRight<G extends GameObjects.GameObject>(gameObject: G, alignTo: GameObjects.GameObject, offsetX?: number, offsetY?: number): G;
            }
        }

        namespace Bounds {
            /**
             * Positions the Game Object so that it is centered on the given coordinates.
             * @param gameObject The Game Object that will be re-positioned.
             * @param x The horizontal coordinate to position the Game Object on.
             * @param y The vertical coordinate to position the Game Object on.
             */
            function CenterOn<G extends GameObjects.GameObject>(gameObject: G, x: number, y: number): G;

            /**
             * Returns the bottom coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetBottom(gameObject: GameObjects.GameObject): number;

            /**
             * Returns the center x coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetCenterX(gameObject: GameObjects.GameObject): number;

            /**
             * Returns the center y coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetCenterY(gameObject: GameObjects.GameObject): number;

            /**
             * Returns the left coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetLeft(gameObject: GameObjects.GameObject): number;

            /**
             * Returns the amount the Game Object is visually offset from its x coordinate.
             * This is the same as `width * origin.x`.
             * This value will only be > 0 if `origin.x` is not equal to zero.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetOffsetX(gameObject: GameObjects.GameObject): number;

            /**
             * Returns the amount the Game Object is visually offset from its y coordinate.
             * This is the same as `width * origin.y`.
             * This value will only be > 0 if `origin.y` is not equal to zero.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetOffsetY(gameObject: GameObjects.GameObject): number;

            /**
             * Returns the right coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetRight(gameObject: GameObjects.GameObject): number;

            /**
             * Returns the top coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetTop(gameObject: GameObjects.GameObject): number;

            /**
             * Positions the Game Object so that the bottom of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param value The coordinate to position the Game Object bounds on.
             */
            function SetBottom<G extends GameObjects.GameObject>(gameObject: G, value: number): G;

            /**
             * Positions the Game Object so that the center top of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param x The coordinate to position the Game Object bounds on.
             */
            function SetCenterX<G extends GameObjects.GameObject>(gameObject: G, x: number): G;

            /**
             * Positions the Game Object so that the center top of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param y The coordinate to position the Game Object bounds on.
             */
            function SetCenterY<G extends GameObjects.GameObject>(gameObject: G, y: number): G;

            /**
             * Positions the Game Object so that the left of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param value The coordinate to position the Game Object bounds on.
             */
            function SetLeft<G extends GameObjects.GameObject>(gameObject: G, value: number): G;

            /**
             * Positions the Game Object so that the left of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param value The coordinate to position the Game Object bounds on.
             */
            function SetRight<G extends GameObjects.GameObject>(gameObject: G, value: number): G;

            /**
             * Positions the Game Object so that the top of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param value The coordinate to position the Game Object bounds on.
             */
            function SetTop<G extends GameObjects.GameObject>(gameObject: G, value: number): G;
        }

        namespace Canvas {
            namespace CanvasInterpolation {
                /**
                 * Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).
                 * @param canvas The canvas object to have the style set on.
                 */
                function setCrisp(canvas: HTMLCanvasElement): HTMLCanvasElement;

                /**
                 * Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').
                 * @param canvas The canvas object to have the style set on.
                 */
                function setBicubic(canvas: HTMLCanvasElement): HTMLCanvasElement;
            }

            /**
             * The CanvasPool is a global static object, that allows Phaser to recycle and pool 2D Context Canvas DOM elements.
             * It does not pool WebGL Contexts, because once the context options are set they cannot be modified again,
             * which is useless for some of the Phaser pipelines / renderer.
             *
             * This singleton is instantiated as soon as Phaser loads, before a Phaser.Game instance has even been created.
             * Which means all instances of Phaser Games on the same page can share the one single pool.
             */
            namespace CanvasPool {
                /**
                 * Creates a new Canvas DOM element, or pulls one from the pool if free.
                 * @param parent The parent of the Canvas object.
                 * @param width The width of the Canvas. Default 1.
                 * @param height The height of the Canvas. Default 1.
                 * @param canvasinterface The interface of the Canvas. Either `Phaser.CANVAS` or `Phaser.WEBGL`. Default Phaser.CANVAS.
                 * @param selfParent Use the generated Canvas element as the parent? Default false.
                 */
                function create(parent: any, width?: integer, height?: integer, canvasinterface?: integer, selfParent?: boolean): HTMLCanvasElement;

                /**
                 * Creates a new Canvas DOM element, or pulls one from the pool if free.
                 * @param parent The parent of the Canvas object.
                 * @param width The width of the Canvas. Default 1.
                 * @param height The height of the Canvas. Default 1.
                 */
                function create2D(parent: any, width?: integer, height?: integer): HTMLCanvasElement;

                /**
                 * Creates a new Canvas DOM element, or pulls one from the pool if free.
                 * @param parent The parent of the Canvas object.
                 * @param width The width of the Canvas. Default 1.
                 * @param height The height of the Canvas. Default 1.
                 */
                function createWebGL(parent: any, width?: integer, height?: integer): HTMLCanvasElement;

                /**
                 * Gets the first free canvas index from the pool.
                 * @param canvasinterface The interface of the Canvas. Either `Phaser.CANVAS` or `Phaser.WEBGL`. Default Phaser.CANVAS.
                 */
                function first(canvasinterface?: integer): HTMLCanvasElement;

                /**
                 * Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.
                 * The canvas has its width and height set to 1, and its parent attribute nulled.
                 * @param parent The canvas or the parent of the canvas to free.
                 */
                function remove(parent: any): void;

                /**
                 * Gets the total number of used canvas elements in the pool.
                 */
                function total(): integer;

                /**
                 * Gets the total number of free canvas elements in the pool.
                 */
                function free(): integer;

                /**
                 * Disable context smoothing on any new Canvas element created.
                 */
                function disableSmoothing(): void;

                /**
                 * Enable context smoothing on any new Canvas element created.
                 */
                function enableSmoothing(): void;
            }

            namespace Smoothing {
                /**
                 * Gets the Smoothing Enabled vendor prefix being used on the given context, or null if not set.
                 * @param context The canvas context to check.
                 */
                function getPrefix(context: CanvasRenderingContext2D | WebGLRenderingContext): string;

                /**
                 * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.
                 * By default browsers have image smoothing enabled, which isn't always what you visually want, especially
                 * when using pixel art in a game. Note that this sets the property on the context itself, so that any image
                 * drawn to the context will be affected. This sets the property across all current browsers but support is
                 * patchy on earlier browsers, especially on mobile.
                 * @param context The context on which to enable smoothing.
                 */
                function enable(context: CanvasRenderingContext2D | WebGLRenderingContext): CanvasRenderingContext2D | WebGLRenderingContext;

                /**
                 * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.
                 * By default browsers have image smoothing enabled, which isn't always what you visually want, especially
                 * when using pixel art in a game. Note that this sets the property on the context itself, so that any image
                 * drawn to the context will be affected. This sets the property across all current browsers but support is
                 * patchy on earlier browsers, especially on mobile.
                 * @param context The context on which to disable smoothing.
                 */
                function disable(context: CanvasRenderingContext2D | WebGLRenderingContext): CanvasRenderingContext2D | WebGLRenderingContext;

                /**
                 * Returns `true` if the given context has image smoothing enabled, otherwise returns `false`.
                 * Returns null if no smoothing prefix is available.
                 * @param context The context to check.
                 */
                function isEnabled(context: CanvasRenderingContext2D | WebGLRenderingContext): boolean;
            }

            /**
             * Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.
             * @param canvas The canvas element to have the style applied to.
             * @param value The touch action value to set on the canvas. Set to `none` to disable touch actions. Default 'none'.
             */
            function TouchAction(canvas: HTMLCanvasElement, value?: string): HTMLCanvasElement;

            /**
             * Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.
             * @param canvas The canvas element to have the style applied to.
             * @param value The touch callout value to set on the canvas. Set to `none` to disable touch callouts. Default 'none'.
             */
            function UserSelect(canvas: HTMLCanvasElement, value?: string): HTMLCanvasElement;
        }

        namespace Color {
            namespace Interpolate {
                /**
                 * Interpolates between the two given color ranges over the length supplied.
                 * @param r1 Red value.
                 * @param g1 Blue value.
                 * @param b1 Green value.
                 * @param r2 Red value.
                 * @param g2 Blue value.
                 * @param b2 Green value.
                 * @param length Distance to interpolate over. Default 100.
                 * @param index Index to start from. Default 0.
                 */
                function RGBWithRGB(r1: number, g1: number, b1: number, r2: number, g2: number, b2: number, length?: number, index?: number): ColorObject;

                /**
                 * Interpolates between the two given color objects over the length supplied.
                 * @param color1 The first Color object.
                 * @param color2 The second Color object.
                 * @param length Distance to interpolate over. Default 100.
                 * @param index Index to start from. Default 0.
                 */
                function ColorWithColor(color1: Color, color2: Color, length?: number, index?: number): ColorObject;

                /**
                 * Interpolates between the Color object and color values over the length supplied.
                 * @param color1 The first Color object.
                 * @param r Red value.
                 * @param g Blue value.
                 * @param b Green value.
                 * @param length Distance to interpolate over. Default 100.
                 * @param index Index to start from. Default 0.
                 */
                function ColorWithRGB(color1: Color, r: number, g: number, b: number, length?: number, index?: number): ColorObject;
            }
        }

        /**
         * The Color class holds a single color value and allows for easy modification and reading of it.
         */
        class Color {
            /**
             *
             * @param red The red color value. A number between 0 and 255. Default 0.
             * @param green The green color value. A number between 0 and 255. Default 0.
             * @param blue The blue color value. A number between 0 and 255. Default 0.
             * @param alpha The alpha value. A number between 0 and 255. Default 255.
             */
            constructor(red?: integer, green?: integer, blue?: integer, alpha?: integer);

            /**
             * An array containing the calculated color values for WebGL use.
             */
            gl: number[];

            /**
             * Sets this color to be transparent. Sets all values to zero.
             */
            transparent(): Color;

            /**
             * Sets the color of this Color component.
             * @param red The red color value. A number between 0 and 255.
             * @param green The green color value. A number between 0 and 255.
             * @param blue The blue color value. A number between 0 and 255.
             * @param alpha The alpha value. A number between 0 and 255. Default 255.
             * @param updateHSV Update the HSV values after setting the RGB values? Default true.
             */
            setTo(red: integer, green: integer, blue: integer, alpha?: integer, updateHSV?: boolean): Color;

            /**
             * Sets the red, green, blue and alpha GL values of this Color component.
             * @param red The red color value. A number between 0 and 1.
             * @param green The green color value. A number between 0 and 1.
             * @param blue The blue color value. A number between 0 and 1.
             * @param alpha The alpha value. A number between 0 and 1. Default 1.
             */
            setGLTo(red: number, green: number, blue: number, alpha?: number): Color;

            /**
             * Sets the color based on the color object given.
             * @param color An object containing `r`, `g`, `b` and optionally `a` values in the range 0 to 255.
             */
            setFromRGB(color: InputColorObject): Color;

            /**
             * Sets the color based on the hue, saturation and lightness values given.
             * @param h The hue, in the range 0 - 1. This is the base color.
             * @param s The saturation, in the range 0 - 1. This controls how much of the hue will be in the final color, where 1 is fully saturated and 0 will give you white.
             * @param v The value, in the range 0 - 1. This controls how dark the color is. Where 1 is as bright as possible and 0 is black.
             */
            setFromHSV(h: number, s: number, v: number): Color;

            /**
             * Returns a new Color component using the values from this one.
             */
            clone(): Color;

            /**
             * Sets this Color object to be grayscaled based on the shade value given.
             * @param shade A value between 0 and 255.
             */
            gray(shade: integer): Color;

            /**
             * Sets this Color object to be a random color between the `min` and `max` values given.
             * @param min The minimum random color value. Between 0 and 255. Default 0.
             * @param max The maximum random color value. Between 0 and 255. Default 255.
             */
            random(min?: integer, max?: integer): Color;

            /**
             * Sets this Color object to be a random grayscale color between the `min` and `max` values given.
             * @param min The minimum random color value. Between 0 and 255. Default 0.
             * @param max The maximum random color value. Between 0 and 255. Default 255.
             */
            randomGray(min?: integer, max?: integer): Color;

            /**
             * Increase the saturation of this Color by the percentage amount given.
             * The saturation is the amount of the base color in the hue.
             * @param amount The percentage amount to change this color by. A value between 0 and 100.
             */
            saturate(amount: integer): Color;

            /**
             * Decrease the saturation of this Color by the percentage amount given.
             * The saturation is the amount of the base color in the hue.
             * @param amount The percentage amount to change this color by. A value between 0 and 100.
             */
            desaturate(amount: integer): Color;

            /**
             * Increase the lightness of this Color by the percentage amount given.
             * @param amount The percentage amount to change this color by. A value between 0 and 100.
             */
            lighten(amount: integer): Color;

            /**
             * Decrease the lightness of this Color by the percentage amount given.
             * @param amount The percentage amount to change this color by. A value between 0 and 100.
             */
            darken(amount: integer): Color;

            /**
             * Brighten this Color by the percentage amount given.
             * @param amount The percentage amount to change this color by. A value between 0 and 100.
             */
            brighten(amount: integer): Color;

            /**
             * The color of this Color component, not including the alpha channel.
             */
            readonly color: number;

            /**
             * The color of this Color component, including the alpha channel.
             */
            readonly color32: number;

            /**
             * The color of this Color component as a string which can be used in CSS color values.
             */
            readonly rgba: string;

            /**
             * The red color value, normalized to the range 0 to 1.
             */
            redGL: number;

            /**
             * The green color value, normalized to the range 0 to 1.
             */
            greenGL: number;

            /**
             * The blue color value, normalized to the range 0 to 1.
             */
            blueGL: number;

            /**
             * The alpha color value, normalized to the range 0 to 1.
             */
            alphaGL: number;

            /**
             * The red color value, normalized to the range 0 to 255.
             */
            red: number;

            /**
             * The green color value, normalized to the range 0 to 255.
             */
            green: number;

            /**
             * The blue color value, normalized to the range 0 to 255.
             */
            blue: number;

            /**
             * The alpha color value, normalized to the range 0 to 255.
             */
            alpha: number;

            /**
             * The hue color value. A number between 0 and 1.
             * This is the base color.
             */
            h: number;

            /**
             * The saturation color value. A number between 0 and 1.
             * This controls how much of the hue will be in the final color, where 1 is fully saturated and 0 will give you white.
             */
            s: number;

            /**
             * The lightness color value. A number between 0 and 1.
             * This controls how dark the color is. Where 1 is as bright as possible and 0 is black.
             */
            v: number;

            /**
             * Converts the given color value into an Object containing r,g,b and a properties.
             * @param color A color value, optionally including the alpha value.
             */
            static ColorToRGBA(color: number): ColorObject;

            /**
             * Returns a string containing a hex representation of the given color component.
             * @param color The color channel to get the hex value for, must be a value between 0 and 255.
             */
            static ComponentToHex(color: integer): string;

            /**
             * Given 3 separate color values this will return an integer representation of it.
             * @param red The red color value. A number between 0 and 255.
             * @param green The green color value. A number between 0 and 255.
             * @param blue The blue color value. A number between 0 and 255.
             */
            static GetColor(red: integer, green: integer, blue: integer): number;

            /**
             * Given an alpha and 3 color values this will return an integer representation of it.
             * @param red The red color value. A number between 0 and 255.
             * @param green The green color value. A number between 0 and 255.
             * @param blue The blue color value. A number between 0 and 255.
             * @param alpha The alpha color value. A number between 0 and 255.
             */
            static GetColor32(red: integer, green: integer, blue: integer, alpha: integer): number;

            /**
             * Converts a hex string into a Phaser Color object.
             *
             * The hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional "#" or "0x", or be unprefixed.
             *
             * An alpha channel is _not_ supported.
             * @param hex The hex color value to convert, such as `#0033ff` or the short-hand format: `#03f`.
             */
            static HexStringToColor(hex: string): Color;

            /**
             * Converts HSL (hue, saturation and lightness) values to a Phaser Color object.
             * @param h The hue value in the range 0 to 1.
             * @param s The saturation value in the range 0 to 1.
             * @param l The lightness value in the range 0 to 1.
             */
            static HSLToColor(h: number, s: number, l: number): Color;

            /**
             * Get HSV color wheel values in an array which will be 360 elements in size.
             * @param s The saturation, in the range 0 - 1. Default 1.
             * @param v The value, in the range 0 - 1. Default 1.
             */
            static HSVColorWheel(s?: number, v?: number): ColorObject[];

            /**
             * Converts an HSV (hue, saturation and value) color value to RGB.
             * Conversion formula from http://en.wikipedia.org/wiki/HSL_color_space.
             * Assumes HSV values are contained in the set [0, 1].
             * Based on code by Michael Jackson (https://github.com/mjijackson)
             * @param h The hue, in the range 0 - 1. This is the base color.
             * @param s The saturation, in the range 0 - 1. This controls how much of the hue will be in the final color, where 1 is fully saturated and 0 will give you white.
             * @param v The value, in the range 0 - 1. This controls how dark the color is. Where 1 is as bright as possible and 0 is black.
             * @param out A Color object to store the results in. If not given a new ColorObject will be created.
             */
            static HSVToRGB(h: number, s: number, v: number, out?: ColorObject | Color): ColorObject | Color;

            /**
             * Converts a hue to an RGB color.
             * Based on code by Michael Jackson (https://github.com/mjijackson)
             */
            static HueToComponent(p: number, q: number, t: number): number;

            /**
             * Converts the given color value into an instance of a Color object.
             * @param input The color value to convert into a Color object.
             */
            static IntegerToColor(input: integer): Color;

            /**
             * Return the component parts of a color as an Object with the properties alpha, red, green, blue.
             *
             * Alpha will only be set if it exists in the given color (0xAARRGGBB)
             * @param input The color value to convert into a Color object.
             */
            static IntegerToRGB(input: integer): ColorObject;

            /**
             * Converts an object containing `r`, `g`, `b` and `a` properties into a Color class instance.
             * @param input An object containing `r`, `g`, `b` and `a` properties in the range 0 to 255.
             */
            static ObjectToColor(input: InputColorObject): Color;

            /**
             * Creates a new Color object where the r, g, and b values have been set to random values
             * based on the given min max values.
             * @param min The minimum value to set the random range from (between 0 and 255) Default 0.
             * @param max The maximum value to set the random range from (between 0 and 255) Default 255.
             */
            static RandomRGB(min?: integer, max?: integer): Color;

            /**
             * Converts a CSS 'web' string into a Phaser Color object.
             *
             * The web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].
             * @param rgb The CSS format color string, using the `rgb` or `rgba` format.
             */
            static RGBStringToColor(rgb: string): Color;

            /**
             * Converts an RGB color value to HSV (hue, saturation and value).
             * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
             * Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].
             * Based on code by Michael Jackson (https://github.com/mjijackson)
             * @param r The red color value. A number between 0 and 255.
             * @param g The green color value. A number between 0 and 255.
             * @param b The blue color value. A number between 0 and 255.
             * @param out An object to store the color values in. If not given an HSV Color Object will be created.
             */
            static RGBToHSV(r: integer, g: integer, b: integer, out?: HSVColorObject | Color): HSVColorObject | Color;

            /**
             * Converts the color values into an HTML compatible color string, prefixed with either `#` or `0x`.
             * @param r The red color value. A number between 0 and 255.
             * @param g The green color value. A number between 0 and 255.
             * @param b The blue color value. A number between 0 and 255.
             * @param a The alpha value. A number between 0 and 255. Default 255.
             * @param prefix The prefix of the string. Either `#` or `0x`. Default #.
             */
            static RGBToString(r: integer, g: integer, b: integer, a?: integer, prefix?: string): string;

            /**
             * Converts the given source color value into an instance of a Color class.
             * The value can be either a string, prefixed with `rgb` or a hex string, a number or an Object.
             * @param input The source color value to convert.
             */
            static ValueToColor(input: string | number | InputColorObject): Color;
        }

        namespace Masks {
            /**
             * A Bitmap Mask combines the alpha (opacity) of a masked pixel with the alpha of another pixel.
             * Unlike the Geometry Mask, which is a clipping path, a Bitmap Mask behaves like an alpha mask,
             * not a clipping path. It is only available when using the WebGL Renderer.
             *
             * A Bitmap Mask can use any Game Object to determine the alpha of each pixel of the masked Game Object(s).
             * For any given point of a masked Game Object's texture, the pixel's alpha will be multiplied by the alpha
             * of the pixel at the same position in the Bitmap Mask's Game Object. The color of the pixel from the
             * Bitmap Mask doesn't matter.
             *
             * For example, if a pure blue pixel with an alpha of 0.95 is masked with a pure red pixel with an
             * alpha of 0.5, the resulting pixel will be pure blue with an alpha of 0.475. Naturally, this means
             * that a pixel in the mask with an alpha of 0 will hide the corresponding pixel in all masked Game Objects
             *  A pixel with an alpha of 1 in the masked Game Object will receive the same alpha as the
             * corresponding pixel in the mask.
             *
             * The Bitmap Mask's location matches the location of its Game Object, not the location of the
             * masked objects. Moving or transforming the underlying Game Object will change the mask
             * (and affect the visibility of any masked objects), whereas moving or transforming a masked object
             * will not affect the mask.
             *
             * The Bitmap Mask will not render its Game Object by itself. If the Game Object is not in a
             * Scene's display list, it will only be used for the mask and its full texture will not be directly
             * visible. Adding the underlying Game Object to a Scene will not cause any problems - it will
             * render as a normal Game Object and will also serve as a mask.
             */
            class BitmapMask {
                /**
                 *
                 * @param scene The Scene which this Bitmap Mask will be used in.
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                constructor(scene: Scene, renderable: GameObjects.GameObject);

                /**
                 * A reference to either the Canvas or WebGL Renderer that this Mask is using.
                 */
                renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer;

                /**
                 * A renderable Game Object that uses a texture, such as a Sprite.
                 */
                bitmapMask: GameObjects.GameObject;

                /**
                 * The texture used for the mask's framebuffer.
                 */
                maskTexture: WebGLTexture;

                /**
                 * The texture used for the main framebuffer.
                 */
                mainTexture: WebGLTexture;

                /**
                 * Whether the Bitmap Mask is dirty and needs to be updated.
                 */
                dirty: boolean;

                /**
                 * The framebuffer to which a masked Game Object is rendered.
                 */
                mainFramebuffer: WebGLFramebuffer;

                /**
                 * The framebuffer to which the Bitmap Mask's masking Game Object is rendered.
                 */
                maskFramebuffer: WebGLFramebuffer;

                /**
                 * Whether to invert the mask's alpha.
                 *
                 * If `true`, the alpha of the masking pixel will be inverted before it's multiplied with the masked pixel.
                 * Essentially, this means that a masked area will be visible only if the corresponding area in the mask is invisible.
                 */
                invertAlpha: boolean;

                /**
                 * Sets a new masking Game Object for the Bitmap Mask.
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                setBitmap(renderable: GameObjects.GameObject): void;

                /**
                 * Prepares the WebGL Renderer to render a Game Object with this mask applied.
                 *
                 * This renders the masking Game Object to the mask framebuffer and switches to
                 * the main framebuffer so that the masked Game Object will be rendered to it instead of being rendered directly to the frame.
                 * @param renderer The WebGL Renderer to prepare.
                 * @param maskedObject The masked Game Object which will be drawn.
                 * @param camera The Camera to render to.
                 */
                preRenderWebGL(
                    renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer,
                    maskedObject: GameObjects.GameObject,
                    camera: Cameras.Scene2D.Camera
                ): void;

                /**
                 * Finalizes rendering of a masked Game Object.
                 *
                 * This resets the previously bound framebuffer and switches the WebGL Renderer to the Bitmap Mask Pipeline, which uses a special fragment shader to apply the masking effect.
                 * @param renderer The WebGL Renderer to clean up.
                 */
                postRenderWebGL(renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer): void;

                /**
                 * This is a NOOP method. Bitmap Masks are not supported by the Canvas Renderer.
                 * @param renderer The Canvas Renderer which would be rendered to.
                 * @param mask The masked Game Object which would be rendered.
                 * @param camera The Camera to render to.
                 */
                preRenderCanvas(
                    renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer,
                    mask: GameObjects.GameObject,
                    camera: Cameras.Scene2D.Camera
                ): void;

                /**
                 * This is a NOOP method. Bitmap Masks are not supported by the Canvas Renderer.
                 * @param renderer The Canvas Renderer which would be rendered to.
                 */
                postRenderCanvas(renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer): void;

                /**
                 * Destroys this BitmapMask and nulls any references it holds.
                 *
                 * Note that if a Game Object is currently using this mask it will _not_ automatically detect you have destroyed it,
                 * so be sure to call `clearMask` on any Game Object using it, before destroying it.
                 */
                destroy(): void;
            }

            /**
             * A Geometry Mask can be applied to a Game Object to hide any pixels of it which don't intersect
             * a visible pixel from the geometry mask. The mask is essentially a clipping path which can only
             * make a masked pixel fully visible or fully invisible without changing its alpha (opacity).
             *
             * A Geometry Mask uses a Graphics Game Object to determine which pixels of the masked Game Object(s)
             * should be clipped. For any given point of a masked Game Object's texture, the pixel will only be displayed
             * if the Graphics Game Object of the Geometry Mask has a visible pixel at the same position. The color and
             * alpha of the pixel from the Geometry Mask do not matter.
             *
             * The Geometry Mask's location matches the location of its Graphics object, not the location of the masked objects.
             * Moving or transforming the underlying Graphics object will change the mask (and affect the visibility
             * of any masked objects), whereas moving or transforming a masked object will not affect the mask.
             * You can think of the Geometry Mask (or rather, of the its Graphics object) as an invisible curtain placed
             * in front of all masked objects which has its own visual properties and, naturally, respects the camera's
             * visual properties, but isn't affected by and doesn't follow the masked objects by itself.
             */
            class GeometryMask {
                /**
                 *
                 * @param scene This parameter is not used.
                 * @param graphicsGeometry The Graphics Game Object to use for the Geometry Mask. Doesn't have to be in the Display List.
                 */
                constructor(scene: Scene, graphicsGeometry: GameObjects.Graphics);

                /**
                 * The Graphics object which describes the Geometry Mask.
                 */
                geometryMask: GameObjects.Graphics;

                /**
                 * Similar to the BitmapMasks invertAlpha setting this to true will then hide all pixels
                 * drawn to the Geometry Mask.
                 */
                invertAlpha: boolean;

                /**
                 * Sets a new Graphics object for the Geometry Mask.
                 * @param graphicsGeometry The Graphics object which will be used for the Geometry Mask.
                 */
                setShape(graphicsGeometry: GameObjects.Graphics): void;

                /**
                 * Renders the Geometry Mask's underlying Graphics object to the OpenGL stencil buffer and enables the stencil test, which clips rendered pixels according to the mask.
                 * @param renderer The WebGL Renderer instance to draw to.
                 * @param mask The Game Object being rendered.
                 * @param camera The camera the Game Object is being rendered through.
                 */
                preRenderWebGL(renderer: Renderer.WebGL.WebGLRenderer, mask: GameObjects.GameObject, camera: Cameras.Scene2D.Camera): void;

                /**
                 * Flushes all rendered pixels and disables the stencil test of a WebGL context, thus disabling the mask for it.
                 * @param renderer The WebGL Renderer instance to draw flush.
                 */
                postRenderWebGL(renderer: Renderer.WebGL.WebGLRenderer): void;

                /**
                 * Sets the clipping path of a 2D canvas context to the Geometry Mask's underlying Graphics object.
                 * @param renderer The Canvas Renderer instance to set the clipping path on.
                 * @param mask The Game Object being rendered.
                 * @param camera The camera the Game Object is being rendered through.
                 */
                preRenderCanvas(renderer: Renderer.Canvas.CanvasRenderer, mask: GameObjects.GameObject, camera: Cameras.Scene2D.Camera): void;

                /**
                 * Restore the canvas context's previous clipping path, thus turning off the mask for it.
                 * @param renderer The Canvas Renderer instance being restored.
                 */
                postRenderCanvas(renderer: Renderer.Canvas.CanvasRenderer): void;

                /**
                 * Destroys this GeometryMask and nulls any references it holds.
                 *
                 * Note that if a Game Object is currently using this mask it will _not_ automatically detect you have destroyed it,
                 * so be sure to call `clearMask` on any Game Object using it, before destroying it.
                 */
                destroy(): void;
            }
        }
    }

    namespace DOM {
        /**
         * Adds the given element to the DOM. If a parent is provided the element is added as a child of the parent, providing it was able to access it.
         * If no parent was given it falls back to using `document.body`.
         * @param element The element to be added to the DOM. Usually a Canvas object.
         * @param parent The parent in which to add the element. Can be a string which is passed to `getElementById` or an actual DOM object.
         */
        function AddToDOM(element: HTMLElement, parent?: string | HTMLElement): HTMLElement;

        /**
         * Inspects the readyState of the document. If the document is already complete then it invokes the given callback.
         * If not complete it sets up several event listeners such as `deviceready`, and once those fire, it invokes the callback.
         * Called automatically by the Phaser.Game instance. Should not usually be accessed directly.
         * @param callback The callback to be invoked when the device is ready and the DOM content is loaded.
         */
        function DOMContentLoaded(callback: ContentLoadedCallback): void;

        /**
         * Attempts to get the target DOM element based on the given value, which can be either
         * a string, in which case it will be looked-up by ID, or an element node. If nothing
         * can be found it will return a reference to the document.body.
         * @param element The DOM element to look-up.
         */
        function GetTarget(element: HTMLElement): void;

        /**
         * Takes the given data string and parses it as XML.
         * First tries to use the window.DOMParser and reverts to the Microsoft.XMLDOM if that fails.
         * The parsed XML object is returned, or `null` if there was an error while parsing the data.
         * @param data The XML source stored in a string.
         */
        function ParseXML(data: string): DOMParser | ActiveXObject;

        /**
         * Attempts to remove the element from its parentNode in the DOM.
         * @param element The DOM element to remove from its parent node.
         */
        function RemoveFromDOM(element: HTMLElement): void;

        /**
         * Abstracts away the use of RAF or setTimeOut for the core game update loop.
         * This is invoked automatically by the Phaser.Game instance.
         */
        class RequestAnimationFrame {
            /**
             * True if RequestAnimationFrame is running, otherwise false.
             */
            isRunning: boolean;

            /**
             * The callback to be invoked each step.
             */
            callback: FrameRequestCallback;

            /**
             * The most recent timestamp. Either a DOMHighResTimeStamp under RAF or `Date.now` under SetTimeout.
             */
            tick: number;

            /**
             * True if the step is using setTimeout instead of RAF.
             */
            isSetTimeOut: boolean;

            /**
             * The setTimeout or RAF callback ID used when canceling them.
             */
            timeOutID: number;

            /**
             * The previous time the step was called.
             */
            lastTime: number;

            /**
             * The RAF step function.
             * Updates the local tick value, invokes the callback and schedules another call to requestAnimationFrame.
             */
            step: FrameRequestCallback;

            /**
             * The SetTimeout step function.
             * Updates the local tick value, invokes the callback and schedules another call to setTimeout.
             */
            stepTimeout: CallbackFn;

            /**
             * Starts the requestAnimationFrame or setTimeout process running.
             * @param callback The callback to invoke each step.
             * @param forceSetTimeOut Should it use SetTimeout, even if RAF is available?
             */
            start(callback: FrameRequestCallback, forceSetTimeOut: boolean): void;

            /**
             * Stops the requestAnimationFrame or setTimeout from running.
             */
            stop(): void;

            /**
             * Stops the step from running and clears the callback reference.
             */
            destroy(): void;
        }
    }

    namespace Events {
        /**
         * EventEmitter is a Scene Systems plugin compatible version of eventemitter3.
         */
        class EventEmitter {
            /**
             * Removes all listeners.
             */
            shutdown(): void;

            /**
             * Removes all listeners.
             */
            destroy(): void;

            /**
             * Return an array listing the events for which the emitter has registered listeners.
             */
            eventNames(): any[];

            /**
             * Return the listeners registered for a given event.
             * @param event The event name.
             */
            listeners(event: string | symbol): any[];

            /**
             * Return the number of listeners listening to a given event.
             * @param event The event name.
             */
            listenerCount(event: string | symbol): number;

            /**
             * Calls each of the listeners registered for a given event.
             * @param event The event name.
             * @param args Additional arguments that will be passed to the event handler.
             */
            emit(event: string | symbol, ...args: any[]): boolean;

            /**
             * Add a listener for a given event.
             * @param event The event name.
             * @param fn The listener function.
             * @param context The context to invoke the listener with. Default this.
             */
            on(event: string | symbol, fn: CallbackFn, context?: any): EventEmitter;

            /**
             * Add a listener for a given event.
             * @param event The event name.
             * @param fn The listener function.
             * @param context The context to invoke the listener with. Default this.
             */
            addListener(event: string | symbol, fn: CallbackFn, context?: any): EventEmitter;

            /**
             * Add a one-time listener for a given event.
             * @param event The event name.
             * @param fn The listener function.
             * @param context The context to invoke the listener with. Default this.
             */
            once(event: string | symbol, fn: CallbackFn, context?: any): EventEmitter;

            /**
             * Remove the listeners of a given event.
             * @param event The event name.
             * @param fn Only remove the listeners that match this function.
             * @param context Only remove the listeners that have this context.
             * @param once Only remove one-time listeners.
             */
            removeListener(event: string | symbol, fn?: CallbackFn, context?: any, once?: boolean): EventEmitter;

            /**
             * Remove the listeners of a given event.
             * @param event The event name.
             * @param fn Only remove the listeners that match this function.
             * @param context Only remove the listeners that have this context.
             * @param once Only remove one-time listeners.
             */
            off(event: string | symbol, fn?: CallbackFn, context?: any, once?: boolean): EventEmitter;

            /**
             * Remove all listeners, or those of the specified event.
             * @param event The event name.
             */
            removeAllListeners(event?: string | symbol): EventEmitter;
        }
    }

    namespace GameObjects {
        /**
         * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
         *
         * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to
         * match the font structure.
         *
         * Dynamic Bitmap Text objects are different from Static Bitmap Text in that they invoke a callback for each
         * letter being rendered during the render pass. This callback allows you to manipulate the properties of
         * each letter being rendered, such as its position, scale or tint, allowing you to create interesting effects
         * like jiggling text, which can't be done with Static text. This means that Dynamic Text takes more processing
         * time, so only use them if you require the callback ability they have.
         *
         * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
         * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
         * processing the font texture in an image editor, applying fills and any other effects required.
         *
         * To create multi-line text insert \r, \n or \r\n escape codes into the text string.
         *
         * To create a BitmapText data files you need a 3rd party app such as:
         *
         * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
         * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
         * Littera (Web-based, free): http://kvazars.com/littera/
         *
         * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
         * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson
         */
        class DynamicBitmapText extends BitmapText {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.
             * @param x The x coordinate of this Game Object in world space.
             * @param y The y coordinate of this Game Object in world space.
             * @param font The key of the font to use from the Bitmap Font cache.
             * @param text The string, or array of strings, to be set as the content of this Bitmap Text.
             * @param size The font size of this Bitmap Text.
             * @param align The alignment of the text in a multi-line BitmapText object. Default 0.
             */
            constructor(scene: Scene, x: number, y: number, font: string, text?: string | string[], size?: number, align?: integer);

            /**
             * The horizontal scroll position of the Bitmap Text.
             */
            scrollX: number;

            /**
             * The vertical scroll position of the Bitmap Text.
             */
            scrollY: number;

            /**
             * The crop width of the Bitmap Text.
             */
            cropWidth: number;

            /**
             * The crop height of the Bitmap Text.
             */
            cropHeight: number;

            /**
             * A callback that alters how each character of the Bitmap Text is rendered.
             */
            displayCallback: DisplayCallback;

            /**
             * The data object that is populated during rendering, then passed to the displayCallback.
             * You should modify this object then return it back from the callback. It's updated values
             * will be used to render the specific glyph.
             *
             * Please note that if you need a reference to this object locally in your game code then you
             * should shallow copy it, as it's updated and re-used for every glyph in the text.
             */
            callbackData: DisplayCallbackConfig;

            /**
             * Set the crop size of this Bitmap Text.
             * @param width The width of the crop.
             * @param height The height of the crop.
             */
            setSize(width: number, height: number): DynamicBitmapText;

            /**
             * Set a callback that alters how each character of the Bitmap Text is rendered.
             *
             * The callback receives a {@link DisplayCallbackConfig} object that contains information about the character that's
             * about to be rendered.
             *
             * It should return an object with `x`, `y`, `scale` and `rotation` properties that will be used instead of the
             * usual values when rendering.
             * @param callback The display callback to set.
             */
            setDisplayCallback(callback: DisplayCallback): DynamicBitmapText;

            /**
             * Set the horizontal scroll position of this Bitmap Text.
             * @param value The horizontal scroll position to set.
             */
            setScrollX(value: number): DynamicBitmapText;

            /**
             * Set the vertical scroll position of this Bitmap Text.
             * @param value The vertical scroll position to set.
             */
            setScrollY(value: number): DynamicBitmapText;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): this;

            /**
             * Sets the frame this Game Object will use to render with.
             *
             * The Frame has to belong to the current Texture being used.
             *
             * It can be either a string or an index.
             *
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

            /**
             * Fill or additive?
             */
            tintFill: boolean;

            /**
             * Clears all tint values associated with this Game Object.
             *
             * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
             * which results in no visible change to the texture.
             */
            clearTint(): this;

            /**
             * Sets an additive tint on this Game Object.
             *
             * The tint works by taking the pixel color values from the Game Objects texture, and then
             * multiplying it by the color value of the tint. You can provide either one color value,
             * in which case the whole Game Object will be tinted in that color. Or you can provide a color
             * per corner. The colors are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * Sets a fill-based tint on this Game Object.
             *
             * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
             * with those in the tint. You can use this for effects such as making a player flash 'white'
             * if hit by something. You can provide either one color value, in which case the whole
             * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
             * are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * Does this Game Object have a tint applied to it or not?
             */
            readonly isTinted: boolean;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        namespace RetroFont {
            /**
             * Text Set 1 =  !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~
             */
            const TEXT_SET1: string;

            /**
             * Text Set 2 =  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ
             */
            const TEXT_SET2: string;

            /**
             * Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
             */
            const TEXT_SET3: string;

            /**
             * Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789
             */
            const TEXT_SET4: string;

            /**
             * Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789
             */
            const TEXT_SET5: string;

            /**
             * Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.'
             */
            const TEXT_SET6: string;

            /**
             * Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39
             */
            const TEXT_SET7: string;

            /**
             * Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ
             */
            const TEXT_SET8: string;

            /**
             * Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!
             */
            const TEXT_SET9: string;

            /**
             * Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ
             */
            const TEXT_SET10: string;

            /**
             * Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789
             */
            const TEXT_SET11: string;

            /**
             * Parses a Retro Font configuration object so you can pass it to the BitmapText constructor
             * and create a BitmapText object using a fixed-width retro font.
             * @param scene A reference to the Phaser Scene.
             * @param config The font configuration object.
             */
            function Parse(scene: Scene, config: Config): object;

            interface Config {
                /**
                 * The key of the image containing the font.
                 */
                image: string;
                /**
                 * If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
                 */
                "offset.x": number;
                /**
                 * If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.
                 */
                "offset.y": number;
                /**
                 * The width of each character in the font set.
                 */
                width: number;
                /**
                 * The height of each character in the font set.
                 */
                height: number;
                /**
                 * The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.
                 */
                chars: string;
                /**
                 * The number of characters per row in the font set. If not given charsPerRow will be the image width / characterWidth.
                 */
                charsPerRow: number;
                /**
                 * If the characters in the font set have horizontal spacing between them set the required amount here.
                 */
                "spacing.x": number;
                /**
                 * If the characters in the font set have vertical spacing between them set the required amount here.
                 */
                "spacing.y": number;
                /**
                 * The amount of vertical space to add to the line height of the font.
                 */
                lineSpacing: number;
            }
        }

        /**
         * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
         *
         * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to
         * match the font structure.
         *
         * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
         * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
         * processing the font texture in an image editor, applying fills and any other effects required.
         *
         * To create multi-line text insert \r, \n or \r\n escape codes into the text string.
         *
         * To create a BitmapText data files you need a 3rd party app such as:
         *
         * BMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}
         * Glyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}
         * Littera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}
         *
         * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
         * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}
         */
        class BitmapText extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.ScaleMode,
                Components.ScrollFactor,
                Components.Texture,
                Components.Tint,
                Components.Transform,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.
             * @param x The x coordinate of this Game Object in world space.
             * @param y The y coordinate of this Game Object in world space.
             * @param font The key of the font to use from the Bitmap Font cache.
             * @param text The string, or array of strings, to be set as the content of this Bitmap Text.
             * @param size The font size of this Bitmap Text.
             * @param align The alignment of the text in a multi-line BitmapText object. Default 0.
             */
            constructor(scene: Scene, x: number, y: number, font: string, text?: string | string[], size?: number, align?: integer);

            /**
             * The key of the Bitmap Font used by this Bitmap Text.
             * To change the font after creation please use `setFont`.
             */
            readonly font: string;

            /**
             * The data of the Bitmap Font used by this Bitmap Text.
             */
            readonly fontData: BitmapFontData;

            /**
             * Set the lines of text in this BitmapText to be left-aligned.
             * This only has any effect if this BitmapText contains more than one line of text.
             */
            setLeftAlign(): this;

            /**
             * Set the lines of text in this BitmapText to be center-aligned.
             * This only has any effect if this BitmapText contains more than one line of text.
             */
            setCenterAlign(): this;

            /**
             * Set the lines of text in this BitmapText to be right-aligned.
             * This only has any effect if this BitmapText contains more than one line of text.
             */
            setRightAlign(): this;

            /**
             * Set the font size of this Bitmap Text.
             * @param size The font size to set.
             */
            setFontSize(size: number): this;

            /**
             * Sets the letter spacing between each character of this Bitmap Text.
             * Can be a positive value to increase the space, or negative to reduce it.
             * Spacing is applied after the kerning values have been set.
             * @param spacing The amount of horizontal space to add between each character. Default 0.
             */
            setLetterSpacing(spacing?: number): this;

            /**
             * Set the textual content of this BitmapText.
             *
             * An array of strings will be converted into multi-line text. Use the align methods to change multi-line alignment.
             * @param value The string, or array of strings, to be set as the content of this BitmapText.
             */
            setText(value: string | string[]): this;

            /**
             * Calculate the bounds of this Bitmap Text.
             *
             * An object is returned that contains the position, width and height of the Bitmap Text in local and global
             * contexts.
             *
             * Local size is based on just the font size and a [0, 0] position.
             *
             * Global size takes into account the Game Object's scale, world position and display origin.
             *
             * Also in the object is data regarding the length of each line, should this be a multi-line BitmapText.
             * @param round Whether to round the results to the nearest integer.
             */
            getTextBounds(round?: boolean): BitmapTextSize;

            /**
             * Changes the font this BitmapText is using to render.
             *
             * The new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,
             * unless overridden via the arguments.
             * @param font The key of the font to use from the Bitmap Font cache.
             * @param size The font size of this Bitmap Text. If not specified the current size will be used.
             * @param align The alignment of the text in a multi-line BitmapText object. If not specified the current alignment will be used. Default 0.
             */
            setFont(font: string, size?: number, align?: integer): this;

            /**
             * Controls the alignment of each line of text in this BitmapText object.
             *
             * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.
             * Has no effect with single-lines of text.
             *
             * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.
             *
             * 0 = Left aligned (default)
             * 1 = Middle aligned
             * 2 = Right aligned
             *
             * The alignment position is based on the longest line of text.
             */
            align: integer;

            /**
             * The text that this Bitmap Text object displays.
             *
             * You can also use the method `setText` if you want a chainable way to change the text content.
             */
            text: string;

            /**
             * The font size of this Bitmap Text.
             *
             * You can also use the method `setFontSize` if you want a chainable way to change the font size.
             */
            fontSize: number;

            /**
             * Adds / Removes spacing between characters.
             *
             * Can be a negative or positive number.
             *
             * You can also use the method `setLetterSpacing` if you want a chainable way to change the letter spacing.
             */
            letterSpacing: number;

            /**
             * The width of this Bitmap Text.
             */
            readonly width: number;

            /**
             * The height of this bitmap text.
             */
            readonly height: number;

            /**
             * Build a JSON representation of this Bitmap Text.
             */
            toJSON(): JSONBitmapText;

            /**
             * Left align the text characters in a multi-line BitmapText object.
             */
            static ALIGN_LEFT: integer;

            /**
             * Center align the text characters in a multi-line BitmapText object.
             */
            static ALIGN_CENTER: integer;

            /**
             * Right align the text characters in a multi-line BitmapText object.
             */
            static ALIGN_RIGHT: integer;

            /**
             * Parse an XML Bitmap Font from an Atlas.
             *
             * Adds the parsed Bitmap Font data to the cache with the `fontName` key.
             */
            static ParseFromAtlas: any;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): this;

            /**
             * Sets the frame this Game Object will use to render with.
             *
             * The Frame has to belong to the current Texture being used.
             *
             * It can be either a string or an index.
             *
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

            /**
             * Fill or additive?
             */
            tintFill: boolean;

            /**
             * Clears all tint values associated with this Game Object.
             *
             * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
             * which results in no visible change to the texture.
             */
            clearTint(): this;

            /**
             * Sets an additive tint on this Game Object.
             *
             * The tint works by taking the pixel color values from the Game Objects texture, and then
             * multiplying it by the color value of the tint. You can provide either one color value,
             * in which case the whole Game Object will be tinted in that color. Or you can provide a color
             * per corner. The colors are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * Sets a fill-based tint on this Game Object.
             *
             * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
             * with those in the tint. You can use this for effects such as making a player flash 'white'
             * if hit by something. You can provide either one color value, in which case the whole
             * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
             * are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * Does this Game Object have a tint applied to it or not?
             */
            readonly isTinted: boolean;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * A Blitter Game Object.
         *
         * The Blitter Game Object is a special kind of container that creates, updates and manages Bob objects.
         * Bobs are designed for rendering speed rather than flexibility. They consist of a texture, or frame from a texture,
         * a position and an alpha value. You cannot scale or rotate them. They use a batched drawing method for speed
         * during rendering.
         *
         * A Blitter Game Object has one texture bound to it. Bobs created by the Blitter can use any Frame from this
         * Texture to render with, but they cannot use any other Texture. It is this single texture-bind that allows
         * them their speed.
         *
         * If you have a need to blast a large volume of frames around the screen then Blitter objects are well worth
         * investigating. They are especially useful for using as a base for your own special effects systems.
         */
        class Blitter extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Mask,
                Components.Pipeline,
                Components.ScaleMode,
                Components.ScrollFactor,
                Components.Size,
                Components.Texture,
                Components.Transform,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.
             * @param x The x coordinate of this Game Object in world space. Default 0.
             * @param y The y coordinate of this Game Object in world space. Default 0.
             * @param texture The key of the texture this Game Object will use for rendering. The Texture must already exist in the Texture Manager. Default '__DEFAULT'.
             * @param frame The Frame of the Texture that this Game Object will use. Only set if the Texture has multiple frames, such as a Texture Atlas or Sprite Sheet. Default 0.
             */
            constructor(scene: Scene, x?: number, y?: number, texture?: string, frame?: string | integer);

            /**
             * The children of this Blitter.
             * This List contains all of the Bob objects created by the Blitter.
             */
            children: Structs.List<Bob>;

            /**
             * Is the Blitter considered dirty?
             * A 'dirty' Blitter has had its child count changed since the last frame.
             */
            dirty: boolean;

            /**
             * Creates a new Bob in this Blitter.
             *
             * The Bob is created at the given coordinates, relative to the Blitter and uses the given frame.
             * A Bob can use any frame belonging to the texture bound to the Blitter.
             * @param x The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.
             * @param y The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.
             * @param frame The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.
             * @param visible Should the created Bob render or not? Default true.
             * @param index The position in the Blitters Display List to add the new Bob at. Defaults to the top of the list.
             */
            create(x: number, y: number, frame?: string | integer | Textures.Frame, visible?: boolean, index?: integer): Bob;

            /**
             * Creates multiple Bob objects within this Blitter and then passes each of them to the specified callback.
             * @param callback The callback to invoke after creating a bob. It will be sent two arguments: The Bob and the index of the Bob.
             * @param quantity The quantity of Bob objects to create.
             * @param frame The Frame the Bobs will use. It must be part of the Blitter Texture.
             * @param visible Should the created Bob render or not? Default true.
             */
            createFromCallback(
                callback: CreateCallback,
                quantity: integer,
                frame?: string | integer | Textures.Frame | string[] | integer[] | Textures.Frame[],
                visible?: boolean
            ): Bob[];

            /**
             * Creates multiple Bobs in one call.
             *
             * The amount created is controlled by a combination of the `quantity` argument and the number of frames provided.
             *
             * If the quantity is set to 10 and you provide 2 frames, then 20 Bobs will be created. 10 with the first
             * frame and 10 with the second.
             * @param quantity The quantity of Bob objects to create.
             * @param frame The Frame the Bobs will use. It must be part of the Blitter Texture.
             * @param visible Should the created Bob render or not? Default true.
             */
            createMultiple(quantity: integer, frame?: string | integer | Textures.Frame | string[] | integer[] | Textures.Frame[], visible?: boolean): Bob[];

            /**
             * Checks if the given child can render or not, by checking its `visible` and `alpha` values.
             * @param child The Bob to check for rendering.
             */
            childCanRender(child: Bob): boolean;

            /**
             * Returns an array of Bobs to be rendered.
             * If the Blitter is dirty then a new list is generated and stored in `renderList`.
             */
            getRenderList(): Bob[];

            /**
             * Removes all Bobs from the children List and clears the dirty flag.
             */
            clear(): void;

            /**
             * Internal destroy handler, called as part of the destroy process.
             */
            protected preDestroy(): void;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Textures.Frame): this;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): this;

            /**
             * Sets the frame this Game Object will use to render with.
             *
             * The Frame has to belong to the current Texture being used.
             *
             * It can be either a string or an index.
             *
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * A Bob Game Object.
         *
         * A Bob belongs to a Blitter Game Object. The Blitter is responsible for managing and rendering this object.
         *
         * A Bob has a position, alpha value and a frame from a texture that it uses to render with. You can also toggle
         * the flipped and visible state of the Bob. The Frame the Bob uses to render can be changed dynamically, but it
         * must be a Frame within the Texture used by the parent Blitter.
         *
         * Bob positions are relative to the Blitter parent. So if you move the Blitter parent, all Bob children will
         * have their positions impacted by this change as well.
         *
         * You can manipulate Bob objects directly from your game code, but the creation and destruction of them should be
         * handled via the Blitter parent.
         */
        class Bob {
            /**
             *
             * @param blitter The parent Blitter object is responsible for updating this Bob.
             * @param x The horizontal position of this Game Object in the world, relative to the parent Blitter position.
             * @param y The vertical position of this Game Object in the world, relative to the parent Blitter position.
             * @param frame The Frame this Bob will render with, as defined in the Texture the parent Blitter is using.
             * @param visible Should the Bob render visible or not to start with?
             */
            constructor(blitter: Blitter, x: number, y: number, frame: string | integer, visible: boolean);

            /**
             * The Blitter object that this Bob belongs to.
             */
            parent: Blitter;

            /**
             * The x position of this Bob, relative to the x position of the Blitter.
             */
            x: number;

            /**
             * The y position of this Bob, relative to the y position of the Blitter.
             */
            y: number;

            /**
             * The frame that the Bob uses to render with.
             * To change the frame use the `Bob.setFrame` method.
             */
            protected frame: Textures.Frame;

            /**
             * A blank object which can be used to store data related to this Bob in.
             */
            data: object;

            /**
             * The horizontally flipped state of the Bob.
             * A Bob that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Bob.
             * A Bob that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture.
             */
            flipY: boolean;

            /**
             * Changes the Texture Frame being used by this Bob.
             * The frame must be part of the Texture the parent Blitter is using.
             * If no value is given it will use the default frame of the Blitter parent.
             * @param frame The frame to be used during rendering.
             */
            setFrame(frame?: string | integer | Textures.Frame): Bob;

            /**
             * Resets the horizontal and vertical flipped state of this Bob back to their default un-flipped state.
             */
            resetFlip(): Bob;

            /**
             * Resets this Bob.
             *
             * Changes the position to the values given, and optionally changes the frame.
             *
             * Also resets the flipX and flipY values, sets alpha back to 1 and visible to true.
             * @param x The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.
             * @param y The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.
             * @param frame The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.
             */
            reset(x: number, y: number, frame?: string | integer | Textures.Frame): Bob;

            /**
             * Sets the horizontal flipped state of this Bob.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Bob;

            /**
             * Sets the vertical flipped state of this Bob.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Bob;

            /**
             * Sets the horizontal and vertical flipped state of this Bob.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Bob;

            /**
             * Sets the visibility of this Bob.
             *
             * An invisible Bob will skip rendering.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Bob;

            /**
             * Set the Alpha level of this Bob. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * A Bob with alpha 0 will skip rendering.
             * @param value The alpha value used for this Bob. Between 0 and 1.
             */
            setAlpha(value: number): Bob;

            /**
             * Destroys this Bob instance.
             * Removes itself from the Blitter and clears the parent, frame and data properties.
             */
            destroy(): void;

            /**
             * The visible state of the Bob.
             *
             * An invisible Bob will skip rendering.
             */
            visible: boolean;

            /**
             * The alpha value of the Bob, between 0 and 1.
             *
             * A Bob with alpha 0 will skip rendering.
             */
            alpha: number;
        }

        /**
         * Builds a Game Object using the provided configuration object.
         * @param scene A reference to the Scene.
         * @param gameObject The initial GameObject.
         * @param config The config to build the GameObject with.
         */
        function BuildGameObject(scene: Scene, gameObject: GameObject, config: GameObjectConfig): GameObject;

        /**
         * Adds an Animation component to a Sprite and populates it based on the given config.
         * @param sprite The sprite to add an Animation component to.
         * @param config The animation config.
         */
        function BuildGameObjectAnimation(sprite: Sprite, config: object): Sprite;

        namespace Components {
            /**
             * Provides methods used for setting the alpha properties of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface Alpha {
                /**
                 * Clears all alpha values associated with this Game Object.
                 *
                 * Immediately sets the alpha levels back to 1 (fully opaque).
                 */
                clearAlpha(): this;
                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 *
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;
                /**
                 * The alpha value of the Game Object.
                 *
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;
                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;
                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;
                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;
                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;
            }

            interface Animation {
                /**
                 * The Game Object to which this animation controller belongs.
                 */
                parent: GameObject;
                /**
                 * A reference to the global Animation Manager.
                 */
                animationManager: Animations.AnimationManager;
                /**
                 * Is an animation currently playing or not?
                 */
                isPlaying: boolean;
                /**
                 * The current Animation loaded into this Animation Controller.
                 */
                currentAnim: Animations.Animation;
                /**
                 * The current AnimationFrame being displayed by this Animation Controller.
                 */
                currentFrame: Animations.AnimationFrame;
                /**
                 * The key of the next Animation to be loaded into this Animation Controller when the current animation completes.
                 */
                nextAnim: string;
                /**
                 * The frame rate of playback in frames per second.
                 * The default is 24 if the `duration` property is `null`.
                 */
                frameRate: number;
                /**
                 * How long the animation should play for, in milliseconds.
                 * If the `frameRate` property has been set then it overrides this value,
                 * otherwise the `frameRate` is derived from `duration`.
                 */
                duration: number;
                /**
                 * ms per frame, not including frame specific modifiers that may be present in the Animation data.
                 */
                msPerFrame: number;
                /**
                 * Skip frames if the time lags, or always advanced anyway?
                 */
                skipMissedFrames: boolean;
                /**
                 * Will the playhead move forwards (`true`) or in reverse (`false`).
                 */
                forward: boolean;
                /**
                 * Internal time overflow accumulator.
                 */
                accumulator: number;
                /**
                 * The time point at which the next animation frame will change.
                 */
                nextTick: number;
                /**
                 * An internal counter keeping track of how many repeats are left to play.
                 */
                repeatCounter: number;
                /**
                 * An internal flag keeping track of pending repeats.
                 */
                pendingRepeat: boolean;
                /**
                 * Sets an animation to be played immediately after the current one completes.
                 *
                 * The current animation must enter a 'completed' state for this to happen, i.e. finish all of its repeats, delays, etc, or have the `stop` method called directly on it.
                 *
                 * An animation set to repeat forever will never enter a completed state.
                 *
                 * You can chain a new animation at any point, including before the current one starts playing, during it, or when it ends (via its `animationcomplete` callback).
                 * Chained animations are specific to a Game Object, meaning different Game Objects can have different chained animations without impacting the global animation they're playing.
                 *
                 * Call this method with no arguments to reset the chained animation.
                 * @param key The string-based key of the animation to play next, as defined previously in the Animation Manager. Or an Animation instance.
                 */
                chain(key?: string | Animations.Animation): GameObject;
                /**
                 * Sets the amount of time, in milliseconds, that the animation will be delayed before starting playback.
                 * @param value The amount of time, in milliseconds, to wait before starting playback. Default 0.
                 */
                setDelay(value?: integer): GameObject;
                /**
                 * Gets the amount of time, in milliseconds that the animation will be delayed before starting playback.
                 */
                getDelay(): integer;
                /**
                 * Waits for the specified delay, in milliseconds, then starts playback of the requested animation.
                 * @param delay The delay, in milliseconds, to wait before starting the animation playing.
                 * @param key The key of the animation to play.
                 * @param startFrame The frame of the animation to start from. Default 0.
                 */
                delayedPlay(delay: integer, key: string, startFrame?: integer): GameObject;
                /**
                 * Returns the key of the animation currently loaded into this component.
                 */
                getCurrentKey(): string;
                /**
                 * Internal method used to load an animation into this component.
                 * @param key The key of the animation to load.
                 * @param startFrame The start frame of the animation to load. Default 0.
                 */
                load(key: string, startFrame?: integer): GameObject;
                /**
                 * Pause the current animation and set the `isPlaying` property to `false`.
                 * You can optionally pause it at a specific frame.
                 * @param atFrame An optional frame to set after pausing the animation.
                 */
                pause(atFrame?: Animations.AnimationFrame): GameObject;
                /**
                 * Resumes playback of a paused animation and sets the `isPlaying` property to `true`.
                 * You can optionally tell it to start playback from a specific frame.
                 * @param fromFrame An optional frame to set before restarting playback.
                 */
                resume(fromFrame?: Animations.AnimationFrame): GameObject;
                /**
                 * `true` if the current animation is paused, otherwise `false`.
                 */
                readonly isPaused: boolean;
                /**
                 * Plays an Animation on a Game Object that has the Animation component, such as a Sprite.
                 *
                 * Animations are stored in the global Animation Manager and are referenced by a unique string-based key.
                 * @param key The string-based key of the animation to play, as defined previously in the Animation Manager. Or an Animation instance.
                 * @param ignoreIfPlaying If an animation is already playing then ignore this call. Default false.
                 * @param startFrame Optionally start the animation playing from this frame index. Default 0.
                 */
                play(key: string | Animations.Animation, ignoreIfPlaying?: boolean, startFrame?: integer): GameObject;
                /**
                 * Plays an Animation (in reverse mode) on the Game Object that owns this Animation Component.
                 * @param key The string-based key of the animation to play, as defined previously in the Animation Manager. Or an Animation instance.
                 * @param ignoreIfPlaying If an animation is already playing then ignore this call. Default false.
                 * @param startFrame Optionally start the animation playing from this frame index. Default 0.
                 */
                playReverse(key: string | Animations.Animation, ignoreIfPlaying?: boolean, startFrame?: integer): GameObject;
                /**
                 * Load an Animation and fires 'onStartEvent' event, extracted from 'play' method.
                 * @param key The string-based key of the animation to play, as defined previously in the Animation Manager.
                 * @param startFrame Optionally start the animation playing from this frame index. Default 0.
                 */
                _startAnimation(key: string, startFrame?: integer): GameObject;
                /**
                 * Reverse the Animation that is already playing on the Game Object.
                 */
                reverse(): GameObject;
                /**
                 * Returns a value between 0 and 1 indicating how far this animation is through, ignoring repeats and yoyos.
                 * If the animation has a non-zero repeat defined, `getProgress` and `getTotalProgress` will be different
                 * because `getProgress` doesn't include any repeats or repeat delays, whereas `getTotalProgress` does.
                 */
                getProgress(): number;
                /**
                 * Takes a value between 0 and 1 and uses it to set how far this animation is through playback.
                 * Does not factor in repeats or yoyos, but does handle playing forwards or backwards.
                 * @param value The progress value, between 0 and 1. Default 0.
                 */
                setProgress(value?: number): GameObject;
                /**
                 * Handle the removal of an animation from the Animation Manager.
                 * @param key The key of the removed Animation.
                 * @param animation The removed Animation.
                 */
                remove(key?: string, animation?: Animations.Animation): void;
                /**
                 * Gets the number of times that the animation will repeat
                 * after its first iteration. For example, if returns 1, the animation will
                 * play a total of twice (the initial play plus 1 repeat).
                 * A value of -1 means the animation will repeat indefinitely.
                 */
                getRepeat(): integer;
                /**
                 * Sets the number of times that the animation should repeat
                 * after its first iteration. For example, if repeat is 1, the animation will
                 * play a total of twice (the initial play plus 1 repeat).
                 * To repeat indefinitely, use -1. repeat should always be an integer.
                 * @param value The number of times that the animation should repeat.
                 */
                setRepeat(value: integer): GameObject;
                /**
                 * Gets the amount of delay between repeats, if any.
                 */
                getRepeatDelay(): number;
                /**
                 * Sets the amount of time in seconds between repeats.
                 * For example, if `repeat` is 2 and `repeatDelay` is 10, the animation will play initially,
                 * then wait for 10 seconds before repeating, then play again, then wait another 10 seconds
                 * before doing its final repeat.
                 * @param value The delay to wait between repeats, in seconds.
                 */
                setRepeatDelay(value: number): GameObject;
                /**
                 * Restarts the current animation from its beginning, optionally including its delay value.
                 * @param includeDelay Whether to include the delay value of the animation when restarting. Default false.
                 */
                restart(includeDelay?: boolean): GameObject;
                /**
                 * Immediately stops the current animation from playing and dispatches the `animationcomplete` event.
                 *
                 * If no animation is set, no event will be dispatched.
                 *
                 * If there is another animation queued (via the `chain` method) then it will start playing immediately.
                 */
                stop(): GameObject;
                /**
                 * Stops the current animation from playing after the specified time delay, given in milliseconds.
                 * @param delay The number of milliseconds to wait before stopping this animation.
                 */
                stopAfterDelay(delay: integer): GameObject;
                /**
                 * Stops the current animation from playing when it next repeats.
                 */
                stopOnRepeat(): GameObject;
                /**
                 * Stops the current animation from playing when it next sets the given frame.
                 * If this frame doesn't exist within the animation it will not stop it from playing.
                 * @param frame The frame to check before stopping this animation.
                 */
                stopOnFrame(frame: Animations.AnimationFrame): GameObject;
                /**
                 * Sets the Time Scale factor, allowing you to make the animation go go faster or slower than default.
                 * Where 1 = normal speed (the default), 0.5 = half speed, 2 = double speed, etc.
                 * @param value The time scale factor, where 1 is no change, 0.5 is half speed, etc. Default 1.
                 */
                setTimeScale(value?: number): GameObject;
                /**
                 * Gets the Time Scale factor.
                 */
                getTimeScale(): number;
                /**
                 * Returns the total number of frames in this animation.
                 */
                getTotalFrames(): integer;
                /**
                 * The internal update loop for the Animation Component.
                 * @param time The current timestamp.
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                update(time: number, delta: number): void;
                /**
                 * Sets the given Animation Frame as being the current frame
                 * and applies it to the parent Game Object, adjusting its size and origin as needed.
                 * @param animationFrame The Animation Frame to set as being current.
                 */
                setCurrentFrame(animationFrame: Animations.AnimationFrame): GameObject;
                /**
                 * Advances the animation to the next frame, regardless of the time or animation state.
                 * If the animation is set to repeat, or yoyo, this will still take effect.
                 *
                 * Calling this does not change the direction of the animation. I.e. if it was currently
                 * playing in reverse, calling this method doesn't then change the direction to forwards.
                 */
                nextFrame(): GameObject;
                /**
                 * Advances the animation to the previous frame, regardless of the time or animation state.
                 * If the animation is set to repeat, or yoyo, this will still take effect.
                 *
                 * Calling this does not change the direction of the animation. I.e. if it was currently
                 * playing in forwards, calling this method doesn't then change the direction to backwards.
                 */
                previousFrame(): GameObject;
                /**
                 * Sets if the current Animation will yoyo when it reaches the end.
                 * A yoyo'ing animation will play through consecutively, and then reverse-play back to the start again.
                 * @param value `true` if the animation should yoyo, `false` to not. Default false.
                 */
                setYoyo(value?: boolean): GameObject;
                /**
                 * Gets if the current Animation will yoyo when it reaches the end.
                 * A yoyo'ing animation will play through consecutively, and then reverse-play back to the start again.
                 */
                getYoyo(): boolean;
                /**
                 * Destroy this Animation component.
                 *
                 * Unregisters event listeners and cleans up its references.
                 */
                destroy(): void;
            }

            /**
             * Provides methods used for setting the blend mode of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface BlendMode {
                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: BlendModes | string;
                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | BlendModes): this;
            }

            /**
             * Provides methods used for calculating and setting the size of a non-Frame based Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface ComputedSize {
                /**
                 * The native (un-scaled) width of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayWidth` property.
                 */
                width: number;
                /**
                 * The native (un-scaled) height of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayHeight` property.
                 */
                height: number;
                /**
                 * The displayed width of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayWidth: number;
                /**
                 * The displayed height of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayHeight: number;
                /**
                 * Sets the internal size of this Game Object, as used for frame or physics body creation.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): this;
                /**
                 * Sets the display size of this Game Object.
                 *
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): this;
            }

            /**
             * Provides methods used for getting and setting the texture of a Game Object.
             */
            interface Crop {
                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Textures.Texture | Textures.CanvasTexture;
                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Textures.Frame;
                /**
                 * A boolean flag indicating if this Game Object is being cropped or not.
                 * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
                 * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
                 */
                isCropped: boolean;
                /**
                 * Applies a crop to a texture based Game Object, such as a Sprite or Image.
                 *
                 * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
                 *
                 * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
                 * changes what is shown when rendered.
                 *
                 * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
                 *
                 * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
                 * half of it, you could call `setCrop(0, 0, 400, 600)`.
                 *
                 * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
                 * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
                 *
                 * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
                 *
                 * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
                 *
                 * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
                 * the renderer to skip several internal calculations.
                 * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
                 * @param y The y coordinate to start the crop from.
                 * @param width The width of the crop rectangle in pixels.
                 * @param height The height of the crop rectangle in pixels.
                 */
                setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;
            }

            /**
             * Provides methods used for setting the depth of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface Depth {
                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;
                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): this;
            }

            /**
             * Provides methods used for visually flipping a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface Flip {
                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;
                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;
                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): this;
                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): this;
                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): this;
                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): this;
                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): this;
                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): this;
            }

            /**
             * Provides methods used for obtaining the bounds of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface GetBounds {
                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Math.Vector2>(output?: O): O;
                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;
                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;
                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;
                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;
                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Geom.Rectangle>(output?: O): O;
            }

            /**
             * Provides methods used for getting and setting the mask of a Game Object.
             */
            interface Mask {
                /**
                 * The Mask this Game Object is using during render.
                 */
                mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;
                /**
                 * Sets the mask that this Game Object will use to render with.
                 *
                 * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
                 * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
                 *
                 * If a mask is already set on this Game Object it will be immediately replaced.
                 *
                 * Masks are positioned in global space and are not relative to the Game Object to which they
                 * are applied. The reason for this is that multiple Game Objects can all share the same mask.
                 *
                 * Masks have no impact on physics or input detection. They are purely a rendering component
                 * that allows you to limit what is visible during the render pass.
                 * @param mask The mask this Game Object will use when rendering.
                 */
                setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;
                /**
                 * Clears the mask that this Game Object was using.
                 * @param destroyMask Destroy the mask before clearing it? Default false.
                 */
                clearMask(destroyMask?: boolean): this;
                /**
                 * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a renderable Game Object.
                 * A renderable Game Object is one that uses a texture to render with, such as an
                 * Image, Sprite, Render Texture or BitmapText.
                 *
                 * If you do not provide a renderable object, and this Game Object has a texture,
                 * it will use itself as the object. This means you can call this method to create
                 * a Bitmap Mask from any renderable Game Object.
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;
                /**
                 * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a Graphics Game Object.
                 *
                 * If you do not provide a graphics object, and this Game Object is an instance
                 * of a Graphics object, then it will use itself to create the mask.
                 *
                 * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
                 * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
                 */
                createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;
            }

            /**
             * Provides methods used for getting and setting the origin of a Game Object.
             * Values are normalized, given in the range 0 to 1.
             * Display values contain the calculated pixel values.
             * Should be applied as a mixin and not used directly.
             */
            interface Origin {
                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;
                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;
                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;
                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;
                /**
                 * Sets the origin of this Game Object.
                 *
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): this;
                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): this;
                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): this;
                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): this;
            }

            /**
             * Provides methods used for setting the WebGL rendering pipeline of a Game Object.
             */
            interface Pipeline {
                /**
                 * The initial WebGL pipeline of this Game Object.
                 */
                defaultPipeline: Renderer.WebGL.WebGLPipeline;
                /**
                 * The current WebGL pipeline of this Game Object.
                 */
                pipeline: Renderer.WebGL.WebGLPipeline;
                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
                 */
                initPipeline(pipelineName?: string): boolean;
                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): this;
                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;
                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;
            }

            /**
             * Provides methods used for getting and setting the scale of a Game Object.
             */
            interface ScaleMode {
                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: ScaleModes;
                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: ScaleModes): this;
            }

            /**
             * Provides methods used for getting and setting the Scroll Factor of a Game Object.
             */
            interface ScrollFactor {
                /**
                 * The horizontal scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorX: number;
                /**
                 * The vertical scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorY: number;
                /**
                 * Sets the scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): this;
            }

            /**
             * Provides methods used for getting and setting the size of a Game Object.
             */
            interface Size {
                /**
                 * The native (un-scaled) width of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayWidth` property.
                 */
                width: number;
                /**
                 * The native (un-scaled) height of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayHeight` property.
                 */
                height: number;
                /**
                 * The displayed width of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayWidth: number;
                /**
                 * The displayed height of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayHeight: number;
                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Textures.Frame): this;
                /**
                 * Sets the internal size of this Game Object, as used for frame or physics body creation.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): this;
                /**
                 * Sets the display size of this Game Object.
                 *
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): this;
            }

            /**
             * Provides methods used for getting and setting the texture of a Game Object.
             */
            interface Texture {
                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Textures.Texture | Textures.CanvasTexture;
                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Textures.Frame;
                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 *
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): this;
                /**
                 * Sets the frame this Game Object will use to render with.
                 *
                 * The Frame has to belong to the current Texture being used.
                 *
                 * It can be either a string or an index.
                 *
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;
            }

            /**
             * Provides methods used for getting and setting the texture of a Game Object.
             */
            interface TextureCrop {
                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Textures.Texture | Textures.CanvasTexture;
                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Textures.Frame;
                /**
                 * A boolean flag indicating if this Game Object is being cropped or not.
                 * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
                 * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
                 */
                isCropped: boolean;
                /**
                 * Applies a crop to a texture based Game Object, such as a Sprite or Image.
                 *
                 * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
                 *
                 * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
                 * changes what is shown when rendered.
                 *
                 * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
                 *
                 * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
                 * half of it, you could call `setCrop(0, 0, 400, 600)`.
                 *
                 * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
                 * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
                 *
                 * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
                 *
                 * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
                 *
                 * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
                 * the renderer to skip several internal calculations.
                 * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
                 * @param y The y coordinate to start the crop from.
                 * @param width The width of the crop rectangle in pixels.
                 * @param height The height of the crop rectangle in pixels.
                 */
                setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;
                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 *
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): this;
                /**
                 * Sets the frame this Game Object will use to render with.
                 *
                 * The Frame has to belong to the current Texture being used.
                 *
                 * It can be either a string or an index.
                 *
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;
            }

            /**
             * Provides methods used for setting the tint of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface Tint {
                /**
                 * Fill or additive?
                 */
                tintFill: boolean;
                /**
                 * Clears all tint values associated with this Game Object.
                 *
                 * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
                 * which results in no visible change to the texture.
                 */
                clearTint(): this;
                /**
                 * Sets an additive tint on this Game Object.
                 *
                 * The tint works by taking the pixel color values from the Game Objects texture, and then
                 * multiplying it by the color value of the tint. You can provide either one color value,
                 * in which case the whole Game Object will be tinted in that color. Or you can provide a color
                 * per corner. The colors are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;
                /**
                 * Sets a fill-based tint on this Game Object.
                 *
                 * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
                 * with those in the tint. You can use this for effects such as making a player flash 'white'
                 * if hit by something. You can provide either one color value, in which case the whole
                 * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
                 * are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
                 * @param topLeft The tint being applied to the top-left of the Game Object.
                 * If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;
                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;
                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;
                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;
                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;
                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;
                /**
                 * Does this Game Object have a tint applied to it or not?
                 */
                readonly isTinted: boolean;
            }

            /**
             * Build a JSON representation of the given Game Object.
             *
             * This is typically extended further by Game Object specific implementations.
             */
            interface ToJSON {
                (): {[key: string]: any};
            }

            /**
             * Provides methods used for getting and setting the position, scale and rotation of a Game Object.
             */
            interface Transform {
                /**
                 * The x position of this Game Object.
                 */
                x: number;
                /**
                 * The y position of this Game Object.
                 */
                y: number;
                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;
                /**
                 * The w position of this Game Object.
                 */
                w: number;
                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;
                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;
                /**
                 * The angle of this Game Object as expressed in degrees.
                 *
                 * Where 0 is to the right, 90 is down, 180 is left.
                 *
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;
                /**
                 * The angle of this Game Object in radians.
                 *
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;
                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): this;
                /**
                 * Sets the position of this Game Object to be a random position within the confines of
                 * the given area.
                 *
                 * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
                 *
                 * The position does not factor in the size of this Game Object, meaning that only the origin is
                 * guaranteed to be within the area.
                 * @param x The x position of the top-left of the random area. Default 0.
                 * @param y The y position of the top-left of the random area. Default 0.
                 * @param width The width of the random area.
                 * @param height The height of the random area.
                 */
                setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;
                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): this;
                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): this;
                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): this;
                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): this;
                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): this;
                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): this;
                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): this;
                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: TransformMatrix): TransformMatrix;
                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 * @param parentMatrix A temporary matrix to hold parent values during the calculations.
                 */
                getWorldTransformMatrix(
                    tempMatrix?: TransformMatrix,
                    parentMatrix?: TransformMatrix
                ): TransformMatrix;
            }

            /**
             * A Matrix used for display transformations for rendering.
             *
             * It is represented like so:
             *
             * ```
             * | a | c | tx |
             * | b | d | ty |
             * | 0 | 0 | 1  |
             * ```
             */
            class TransformMatrix {
                /**
                 *
                 * @param a The Scale X value. Default 1.
                 * @param b The Shear Y value. Default 0.
                 * @param c The Shear X value. Default 0.
                 * @param d The Scale Y value. Default 1.
                 * @param tx The Translate X value. Default 0.
                 * @param ty The Translate Y value. Default 0.
                 */
                constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);

                /**
                 * The matrix values.
                 */
                matrix: Float32Array;

                /**
                 * The decomposed matrix.
                 */
                decomposedMatrix: object;

                /**
                 * The Scale X value.
                 */
                a: number;

                /**
                 * The Shear Y value.
                 */
                b: number;

                /**
                 * The Shear X value.
                 */
                c: number;

                /**
                 * The Scale Y value.
                 */
                d: number;

                /**
                 * The Translate X value.
                 */
                e: number;

                /**
                 * The Translate Y value.
                 */
                f: number;

                /**
                 * The Translate X value.
                 */
                tx: number;

                /**
                 * The Translate Y value.
                 */
                ty: number;

                /**
                 * The rotation of the Matrix.
                 */
                readonly rotation: number;

                /**
                 * The horizontal scale of the Matrix.
                 */
                readonly scaleX: number;

                /**
                 * The vertical scale of the Matrix.
                 */
                readonly scaleY: number;

                /**
                 * Reset the Matrix to an identity matrix.
                 */
                loadIdentity(): this;

                /**
                 * Translate the Matrix.
                 * @param x The horizontal translation value.
                 * @param y The vertical translation value.
                 */
                translate(x: number, y: number): this;

                /**
                 * Scale the Matrix.
                 * @param x The horizontal scale value.
                 * @param y The vertical scale value.
                 */
                scale(x: number, y: number): this;

                /**
                 * Rotate the Matrix.
                 * @param angle The angle of rotation in radians.
                 */
                rotate(angle: number): this;

                /**
                 * Multiply this Matrix by the given Matrix.
                 *
                 * If an `out` Matrix is given then the results will be stored in it.
                 * If it is not given, this matrix will be updated in place instead.
                 * Use an `out` Matrix if you do not wish to mutate this matrix.
                 * @param rhs The Matrix to multiply by.
                 * @param out An optional Matrix to store the results in.
                 */
                multiply(rhs: TransformMatrix, out?: TransformMatrix): TransformMatrix;

                /**
                 * Multiply this Matrix by the matrix given, including the offset.
                 *
                 * The offsetX is added to the tx value: `offsetX * a + offsetY * c + tx`.
                 * The offsetY is added to the ty value: `offsetY * b + offsetY * d + ty`.
                 * @param src The source Matrix to copy from.
                 * @param offsetX Horizontal offset to factor in to the multiplication.
                 * @param offsetY Vertical offset to factor in to the multiplication.
                 */
                multiplyWithOffset(src: TransformMatrix, offsetX: number, offsetY: number): this;

                /**
                 * Transform the Matrix.
                 * @param a The Scale X value.
                 * @param b The Shear Y value.
                 * @param c The Shear X value.
                 * @param d The Scale Y value.
                 * @param tx The Translate X value.
                 * @param ty The Translate Y value.
                 */
                transform(a: number, b: number, c: number, d: number, tx: number, ty: number): this;

                /**
                 * Transform a point using this Matrix.
                 * @param x The x coordinate of the point to transform.
                 * @param y The y coordinate of the point to transform.
                 * @param point The Point object to store the transformed coordinates.
                 */
                transformPoint(x: number, y: number, point: Geom.Point | Math.Vector2 | object): Geom.Point | Math.Vector2 | object;

                /**
                 * Invert the Matrix.
                 */
                invert(): this;

                /**
                 * Set the values of this Matrix to copy those of the matrix given.
                 * @param src The source Matrix to copy from.
                 */
                copyFrom(src: TransformMatrix): this;

                /**
                 * Set the values of this Matrix to copy those of the array given.
                 * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.
                 * @param src The array of values to set into this matrix.
                 */
                copyFromArray(src: any[]): this;

                /**
                 * Copy the values from this Matrix to the given Canvas Rendering Context.
                 * This will use the Context.transform method.
                 * @param ctx The Canvas Rendering Context to copy the matrix values to.
                 */
                copyToContext(ctx: CanvasRenderingContext2D): CanvasRenderingContext2D;

                /**
                 * Copy the values from this Matrix to the given Canvas Rendering Context.
                 * This will use the Context.setTransform method.
                 * @param ctx The Canvas Rendering Context to copy the matrix values to.
                 */
                setToContext(ctx: CanvasRenderingContext2D): CanvasRenderingContext2D;

                /**
                 * Copy the values in this Matrix to the array given.
                 *
                 * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.
                 * @param out The array to copy the matrix values in to.
                 */
                copyToArray(out?: any[]): any[];

                /**
                 * Set the values of this Matrix.
                 * @param a The Scale X value.
                 * @param b The Shear Y value.
                 * @param c The Shear X value.
                 * @param d The Scale Y value.
                 * @param tx The Translate X value.
                 * @param ty The Translate Y value.
                 */
                setTransform(a: number, b: number, c: number, d: number, tx: number, ty: number): this;

                /**
                 * Decompose this Matrix into its translation, scale and rotation values using QR decomposition.
                 *
                 * The result must be applied in the following order to reproduce the current matrix:
                 *
                 * translate -> rotate -> scale
                 */
                decomposeMatrix(): object;

                /**
                 * Apply the identity, translate, rotate and scale operations on the Matrix.
                 * @param x The horizontal translation.
                 * @param y The vertical translation.
                 * @param rotation The angle of rotation in radians.
                 * @param scaleX The horizontal scale.
                 * @param scaleY The vertical scale.
                 */
                applyITRS(x: number, y: number, rotation: number, scaleX: number, scaleY: number): this;

                /**
                 * Takes the `x` and `y` values and returns a new position in the `output` vector that is the inverse of
                 * the current matrix with its transformation applied.
                 *
                 * Can be used to translate points from world to local space.
                 * @param x The x position to translate.
                 * @param y The y position to translate.
                 * @param output A Vector2, or point-like object, to store the results in.
                 */
                applyInverse(x: number, y: number, output?: Math.Vector2): Math.Vector2;

                /**
                 * Returns the X component of this matrix multiplied by the given values.
                 * This is the same as `x * a + y * c + e`.
                 * @param x The x value.
                 * @param y The y value.
                 */
                getX(x: number, y: number): number;

                /**
                 * Returns the Y component of this matrix multiplied by the given values.
                 * This is the same as `x * b + y * d + f`.
                 * @param x The x value.
                 * @param y The y value.
                 */
                getY(x: number, y: number): number;

                /**
                 * Returns a string that can be used in a CSS Transform call as a `matrix` property.
                 */
                getCSSMatrix(): string;

                /**
                 * Destroys this Transform Matrix.
                 */
                destroy(): void;
            }

            /**
             * Provides methods used for setting the visibility of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface Visible {
                /**
                 * The visible state of the Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;
                /**
                 * Sets the visibility of this Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): this;
            }
        }

        /**
         * A Container Game Object.
         *
         * A Container, as the name implies, can 'contain' other types of Game Object.
         * When a Game Object is added to a Container, the Container becomes responsible for the rendering of it.
         * By default it will be removed from the Display List and instead added to the Containers own internal list.
         *
         * The position of the Game Object automatically becomes relative to the position of the Container.
         *
         * When the Container is rendered, all of its children are rendered as well, in the order in which they exist
         * within the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.
         *
         * If you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will
         * automatically influence all children as well.
         *
         * Containers can include other Containers for deeply nested transforms.
         *
         * Containers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.
         * The masks do not 'stack up'. Only a Container on the root of the display list will use its mask.
         *
         * Containers can be enabled for input. Because they do not have a texture you need to provide a shape for them
         * to use as their hit area. Container children can also be enabled for input, independent of the Container.
         *
         * Containers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,
         * if Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,
         * if the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children
         * with physics do not factor in the Container due to the excessive extra calculations needed. Please structure
         * your game to work around this.
         *
         * It's important to understand the impact of using Containers. They add additional processing overhead into
         * every one of their children. The deeper you nest them, the more the cost escalates. This is especially true
         * for input events. You also loose the ability to set the display depth of Container children in the same
         * flexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost
         * every time you create one, try to structure your game around avoiding that where possible.
         */
        class Container extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.ComputedSize,
                Components.Depth,
                Components.Mask,
                Components.ScrollFactor,
                Components.Transform,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param children An optional array of Game Objects to add to this Container.
             */
            constructor(scene: Scene, x?: number, y?: number, children?: GameObject[]);

            /**
             * An array holding the children of this Container.
             */
            list: GameObject[];

            /**
             * Does this Container exclusively manage its children?
             *
             * The default is `true` which means a child added to this Container cannot
             * belong in another Container, which includes the Scene display list.
             *
             * If you disable this then this Container will no longer exclusively manage its children.
             * This allows you to create all kinds of interesting graphical effects, such as replicating
             * Game Objects without reparenting them all over the Scene.
             * However, doing so will prevent children from receiving any kind of input event or have
             * their physics bodies work by default, as they're no longer a single entity on the
             * display list, but are being replicated where-ever this Container is.
             */
            exclusive: boolean;

            /**
             * Containers can have an optional maximum size. If set to anything above 0 it
             * will constrict the addition of new Game Objects into the Container, capping off
             * the maximum limit the Container can grow in size to.
             */
            maxSize: integer;

            /**
             * The cursor position.
             */
            position: integer;

            /**
             * Internal Transform Matrix used for local space conversion.
             */
            localTransform: Components.TransformMatrix;

            /**
             * Internal value to allow Containers to be used for input and physics.
             * Do not change this value. It has no effect other than to break things.
             */
            readonly originX: number;

            /**
             * Internal value to allow Containers to be used for input and physics.
             * Do not change this value. It has no effect other than to break things.
             */
            readonly originY: number;

            /**
             * Internal value to allow Containers to be used for input and physics.
             * Do not change this value. It has no effect other than to break things.
             */
            readonly displayOriginX: number;

            /**
             * Internal value to allow Containers to be used for input and physics.
             * Do not change this value. It has no effect other than to break things.
             */
            readonly displayOriginY: number;

            /**
             * Does this Container exclusively manage its children?
             *
             * The default is `true` which means a child added to this Container cannot
             * belong in another Container, which includes the Scene display list.
             *
             * If you disable this then this Container will no longer exclusively manage its children.
             * This allows you to create all kinds of interesting graphical effects, such as replicating
             * Game Objects without reparenting them all over the Scene.
             * However, doing so will prevent children from receiving any kind of input event or have
             * their physics bodies work by default, as they're no longer a single entity on the
             * display list, but are being replicated where-ever this Container is.
             * @param value The exclusive state of this Container. Default true.
             */
            setExclusive(value?: boolean): Container;

            /**
             * Gets the bounds of this Container. It works by iterating all children of the Container,
             * getting their respective bounds, and then working out a min-max rectangle from that.
             * It does not factor in if the children render or not, all are included.
             *
             * Some children are unable to return their bounds, such as Graphics objects, in which case
             * they are skipped.
             *
             * Depending on the quantity of children in this Container it could be a really expensive call,
             * so cache it and only poll it as needed.
             *
             * The values are stored and returned in a Rectangle object.
             * @param output A Geom.Rectangle object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds(output?: Geom.Rectangle): Geom.Rectangle;

            /**
             * Takes a Point-like object, such as a Vector2, Geom.Point or object with public x and y properties,
             * and transforms it into the space of this Container, then returns it in the output object.
             * @param source The Source Point to be transformed.
             * @param output A destination object to store the transformed point in. If none given a Vector2 will be created and returned.
             */
            pointToContainer(source: object | Geom.Point | Math.Vector2, output?: object | Geom.Point | Math.Vector2): object | Geom.Point | Math.Vector2;

            /**
             * Returns the world transform matrix as used for Bounds checks.
             *
             * The returned matrix is temporal and shouldn't be stored.
             */
            getBoundsTransformMatrix(): Components.TransformMatrix;

            /**
             * Adds the given Game Object, or array of Game Objects, to this Container.
             *
             * Each Game Object must be unique within the Container.
             * @param child The Game Object, or array of Game Objects, to add to the Container.
             */
            add(child: GameObject | GameObject[]): Container;

            /**
             * Adds the given Game Object, or array of Game Objects, to this Container at the specified position.
             *
             * Existing Game Objects in the Container are shifted up.
             *
             * Each Game Object must be unique within the Container.
             * @param child The Game Object, or array of Game Objects, to add to the Container.
             * @param index The position to insert the Game Object/s at. Default 0.
             */
            addAt(child: GameObject | GameObject[], index?: integer): Container;

            /**
             * Returns the Game Object at the given position in this Container.
             * @param index The position to get the Game Object from.
             */
            getAt(index: integer): GameObject;

            /**
             * Returns the index of the given Game Object in this Container.
             * @param child The Game Object to search for in this Container.
             */
            getIndex(child: GameObject): integer;

            /**
             * Sort the contents of this Container so the items are in order based on the given property.
             * For example: `sort('alpha')` would sort the elements based on the value of their `alpha` property.
             * @param property The property to lexically sort by.
             * @param handler Provide your own custom handler function. Will receive 2 children which it should compare and return a boolean.
             */
            sort(property: string, handler?: CallbackFn): Container;

            /**
             * Searches for the first instance of a child with its `name` property matching the given argument.
             * Should more than one child have the same name only the first is returned.
             * @param name The name to search for.
             */
            getByName(name: string): GameObject;

            /**
             * Returns a random Game Object from this Container.
             * @param startIndex An optional start index. Default 0.
             * @param length An optional length, the total number of elements (from the startIndex) to choose from.
             */
            getRandom(startIndex?: integer, length?: integer): GameObject;

            /**
             * Gets the first Game Object in this Container.
             *
             * You can also specify a property and value to search for, in which case it will return the first
             * Game Object in this Container with a matching property and / or value.
             *
             * For example: `getFirst('visible', true)` would return the first Game Object that had its `visible` property set.
             *
             * You can limit the search to the `startIndex` - `endIndex` range.
             * @param property The property to test on each Game Object in the Container.
             * @param value The value to test the property against. Must pass a strict (`===`) comparison check.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default Container.length.
             */
            getFirst(property: string, value: any, startIndex?: integer, endIndex?: integer): GameObject;

            /**
             * Returns all Game Objects in this Container.
             *
             * You can optionally specify a matching criteria using the `property` and `value` arguments.
             *
             * For example: `getAll('body')` would return only Game Objects that have a body property.
             *
             * You can also specify a value to compare the property to:
             *
             * `getAll('visible', true)` would return only Game Objects that have their visible property set to `true`.
             *
             * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
             * the first 50 Game Objects.
             * @param property The property to test on each Game Object in the Container.
             * @param value If property is set then the `property` must strictly equal this value to be included in the results.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default Container.length.
             */
            getAll(property?: string, value?: any, startIndex?: integer, endIndex?: integer): GameObject[];

            /**
             * Returns the total number of Game Objects in this Container that have a property
             * matching the given value.
             *
             * For example: `count('visible', true)` would count all the elements that have their visible property set.
             *
             * You can optionally limit the operation to the `startIndex` - `endIndex` range.
             * @param property The property to check.
             * @param value The value to check.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default Container.length.
             */
            count(property: string, value: any, startIndex?: integer, endIndex?: integer): integer;

            /**
             * Swaps the position of two Game Objects in this Container.
             * Both Game Objects must belong to this Container.
             * @param child1 The first Game Object to swap.
             * @param child2 The second Game Object to swap.
             */
            swap(child1: GameObject, child2: GameObject): Container;

            /**
             * Moves a Game Object to a new position within this Container.
             *
             * The Game Object must already be a child of this Container.
             *
             * The Game Object is removed from its old position and inserted into the new one.
             * Therefore the Container size does not change. Other children will change position accordingly.
             * @param child The Game Object to move.
             * @param index The new position of the Game Object in this Container.
             */
            moveTo(child: GameObject, index: integer): Container;

            /**
             * Removes the given Game Object, or array of Game Objects, from this Container.
             *
             * The Game Objects must already be children of this Container.
             *
             * You can also optionally call `destroy` on each Game Object that is removed from the Container.
             * @param child The Game Object, or array of Game Objects, to be removed from the Container.
             * @param destroyChild Optionally call `destroy` on each child successfully removed from this Container. Default false.
             */
            remove(child: GameObject | GameObject[], destroyChild?: boolean): Container;

            /**
             * Removes the Game Object at the given position in this Container.
             *
             * You can also optionally call `destroy` on the Game Object, if one is found.
             * @param index The index of the Game Object to be removed.
             * @param destroyChild Optionally call `destroy` on the Game Object if successfully removed from this Container. Default false.
             */
            removeAt(index: integer, destroyChild?: boolean): Container;

            /**
             * Removes the Game Objects between the given positions in this Container.
             *
             * You can also optionally call `destroy` on each Game Object that is removed from the Container.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default Container.length.
             * @param destroyChild Optionally call `destroy` on each Game Object successfully removed from this Container. Default false.
             */
            removeBetween(startIndex?: integer, endIndex?: integer, destroyChild?: boolean): Container;

            /**
             * Removes all Game Objects from this Container.
             *
             * You can also optionally call `destroy` on each Game Object that is removed from the Container.
             * @param destroyChild Optionally call `destroy` on each Game Object successfully removed from this Container. Default false.
             */
            removeAll(destroyChild?: boolean): Container;

            /**
             * Brings the given Game Object to the top of this Container.
             * This will cause it to render on-top of any other objects in the Container.
             * @param child The Game Object to bring to the top of the Container.
             */
            bringToTop(child: GameObject): Container;

            /**
             * Sends the given Game Object to the bottom of this Container.
             * This will cause it to render below any other objects in the Container.
             * @param child The Game Object to send to the bottom of the Container.
             */
            sendToBack(child: GameObject): Container;

            /**
             * Moves the given Game Object up one place in this Container, unless it's already at the top.
             * @param child The Game Object to be moved in the Container.
             */
            moveUp(child: GameObject): Container;

            /**
             * Moves the given Game Object down one place in this Container, unless it's already at the bottom.
             * @param child The Game Object to be moved in the Container.
             */
            moveDown(child: GameObject): Container;

            /**
             * Reverses the order of all Game Objects in this Container.
             */
            reverse(): Container;

            /**
             * Shuffles the all Game Objects in this Container using the Fisher-Yates implementation.
             */
            shuffle(): Container;

            /**
             * Replaces a Game Object in this Container with the new Game Object.
             * The new Game Object cannot already be a child of this Container.
             * @param oldChild The Game Object in this Container that will be replaced.
             * @param newChild The Game Object to be added to this Container.
             * @param destroyChild Optionally call `destroy` on the Game Object if successfully removed from this Container. Default false.
             */
            replace(oldChild: GameObject, newChild: GameObject, destroyChild?: boolean): Container;

            /**
             * Returns `true` if the given Game Object is a direct child of this Container.
             *
             * This check does not scan nested Containers.
             * @param child The Game Object to check for within this Container.
             */
            exists(child: GameObject): boolean;

            /**
             * Sets the property to the given value on all Game Objects in this Container.
             *
             * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
             * the first 50 Game Objects.
             * @param property The property that must exist on the Game Object.
             * @param value The value to get the property to.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default Container.length.
             */
            setAll(property: string, value: any, startIndex?: integer, endIndex?: integer): Container;

            /**
             * Passes all Game Objects in this Container to the given callback.
             *
             * A copy of the Container is made before passing each entry to your callback.
             * This protects against the callback itself modifying the Container.
             *
             * If you know for sure that the callback will not change the size of this Container
             * then you can use the more performant `Container.iterate` method instead.
             * @param callback The function to call.
             * @param context Value to use as `this` when executing callback.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            each(callback: CallbackFn, context?: object, ...args: any[]): Container;

            /**
             * Passes all Game Objects in this Container to the given callback.
             *
             * Only use this method when you absolutely know that the Container will not be modified during
             * the iteration, i.e. by removing or adding to its contents.
             * @param callback The function to call.
             * @param context Value to use as `this` when executing callback.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            iterate(callback: CallbackFn, context?: object, ...args: any[]): Container;

            /**
             * The number of Game Objects inside this Container.
             */
            readonly length: integer;

            /**
             * Returns the first Game Object within the Container, or `null` if it is empty.
             *
             * You can move the cursor by calling `Container.next` and `Container.previous`.
             */
            readonly first: GameObject;

            /**
             * Returns the last Game Object within the Container, or `null` if it is empty.
             *
             * You can move the cursor by calling `Container.next` and `Container.previous`.
             */
            readonly last: GameObject;

            /**
             * Returns the next Game Object within the Container, or `null` if it is empty.
             *
             * You can move the cursor by calling `Container.next` and `Container.previous`.
             */
            readonly next: GameObject;

            /**
             * Returns the previous Game Object within the Container, or `null` if it is empty.
             *
             * You can move the cursor by calling `Container.next` and `Container.previous`.
             */
            readonly previous: GameObject;

            /**
             * Internal destroy handler, called as part of the destroy process.
             */
            protected preDestroy(): void;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Display List plugin.
         *
         * Display Lists belong to a Scene and maintain the list of Game Objects to render every frame.
         *
         * Some of these Game Objects may also be part of the Scene's [Update List]{@link Phaser.GameObjects.UpdateList}, for updating.
         */
        class DisplayList extends Structs.List<GameObject> {
            /**
             *
             * @param scene The Scene that this Display List belongs to.
             */
            constructor(scene: Scene);

            /**
             * The flag the determines whether Game Objects should be sorted when `depthSort()` is called.
             */
            sortChildrenFlag: boolean;

            /**
             * The Scene that this Display List belongs to.
             */
            scene: Scene;

            /**
             * The Scene's Systems.
             */
            systems: Scenes.Systems;

            /**
             * Force a sort of the display list on the next call to depthSort.
             */
            queueDepthSort(): void;

            /**
             * Immediately sorts the display list if the flag is set.
             */
            depthSort(): void;

            /**
             * Compare the depth of two Game Objects.
             * @param childA The first Game Object.
             * @param childB The second Game Object.
             */
            sortByDepth(childA: GameObject, childB: GameObject): integer;

            /**
             * Returns an array which contains all objects currently on the Display List.
             * This is a reference to the main list array, not a copy of it, so be careful not to modify it.
             */
            getChildren(): GameObject[];
        }

        namespace Events {
            /**
             * The Game Object Destroy Event.
             *
             * This event is dispatched when a Game Object instance is being destroyed.
             *
             * Listen for it on a Game Object instance using `GameObject.on('destroy', listener)`.
             */
            const DESTROY: any;
        }

        /**
         * An Extern Game Object is a special interface of Game Object that allows you to pass
         * rendering off to a 3rd party.
         *
         * When you create an Extern and place it in the display list of a Scene, the renderer will
         * process the list as usual. When it finds an Extern it will flush the current batch,
         * clear down the pipeline and prepare a transform matrix which your render function can
         * take advantage of, if required.
         *
         * The WebGL context is then left is a 'clean' state, ready for you to bind your own shaders,
         * or draw to it, whatever you wish to do. Once you've finished, you should free-up any
         * of your resources. The Extern will then rebind the Phaser pipeline and carry on
         * rendering the display list.
         *
         * Although this object has lots of properties such as Alpha, Blend Mode and Tint, none of
         * them are used during rendering unless you take advantage of them in your own render code.
         */
        class Extern extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Flip,
                Components.Origin,
                Components.ScaleMode,
                Components.ScrollFactor,
                Components.Size,
                Components.Texture,
                Components.Tint,
                Components.Transform,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             */
            constructor(scene: Scene);

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): this;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): this;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): this;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): this;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): this;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): this;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Textures.Frame): this;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): this;

            /**
             * Sets the frame this Game Object will use to render with.
             *
             * The Frame has to belong to the current Texture being used.
             *
             * It can be either a string or an index.
             *
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

            /**
             * Fill or additive?
             */
            tintFill: boolean;

            /**
             * Clears all tint values associated with this Game Object.
             *
             * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
             * which results in no visible change to the texture.
             */
            clearTint(): this;

            /**
             * Sets an additive tint on this Game Object.
             *
             * The tint works by taking the pixel color values from the Game Objects texture, and then
             * multiplying it by the color value of the tint. You can provide either one color value,
             * in which case the whole Game Object will be tinted in that color. Or you can provide a color
             * per corner. The colors are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * Sets a fill-based tint on this Game Object.
             *
             * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
             * with those in the tint. You can use this for effects such as making a player flash 'white'
             * if hit by something. You can provide either one color value, in which case the whole
             * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
             * are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * Does this Game Object have a tint applied to it or not?
             */
            readonly isTinted: boolean;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The base class that all Game Objects extend.
         * You don't create GameObjects directly and they cannot be added to the display list.
         * Instead, use them as the base for your own custom classes.
         */
        class GameObject extends Phaser.Events.EventEmitter {
            /**
             *
             * @param scene The Scene to which this Game Object belongs.
             * @param interface A textual representation of the interface of Game Object, i.e. `sprite`.
             */
            constructor(scene: Scene, interface: string);

            /**
             * The Scene to which this Game Object belongs.
             * Game Objects can only belong to one Scene.
             */
            protected scene: Scene;

            /**
             * A textual representation of this Game Object, i.e. `sprite`.
             * Used internally by Phaser but is available for your own custom classes to populate.
             */
            interface: string;

            /**
             * The current state of this Game Object.
             *
             * Phaser itself will never modify this value, although plugins may do so.
             *
             * Use this property to track the state of a Game Object during its lifetime. For example, it could move from
             * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant
             * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.
             * If you need to store complex data about your Game Object, look at using the Data Component instead.
             */
            state: integer | string;

            /**
             * The parent Container of this Game Object, if it has one.
             */
            parentContainer: Container;

            /**
             * The name of this Game Object.
             * Empty by default and never populated by Phaser, this is left for developers to use.
             */
            name: string;

            /**
             * The active state of this Game Object.
             * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.
             * An active object is one which is having its logic and internal systems updated.
             */
            active: boolean;

            /**
             * The Tab Index of the Game Object.
             * Reserved for future use by plugins and the Input Manager.
             */
            tabIndex: integer;

            /**
             * A Data Manager.
             * It allows you to store, query and get key/value paired information specific to this Game Object.
             * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.
             */
            data: Data.DataManager;

            /**
             * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.
             * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.
             * If those components are not used by your custom class then you can use this bitmask as you wish.
             */
            renderFlags: integer;

            /**
             * A bitmask that controls if this Game Object is drawn by a Camera or not.
             * Not usually set directly, instead call `Camera.ignore`, however you can
             * set this property directly using the Camera.id property:
             */
            cameraFilter: number;

            /**
             * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.
             * Not usually set directly. Instead call `GameObject.setInteractive()`.
             */
            input: Input.InteractiveObject;

            /**
             * If this Game Object is enabled for physics then this property will contain a reference to a Physics Body.
             */
            body: object | Physics.Arcade.Body | Physics.Impact.Body;

            /**
             * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.
             * This includes calls that may come from a Group, Container or the Scene itself.
             * While it allows you to persist a Game Object across Scenes, please understand you are entirely
             * responsible for managing references to and from this Game Object.
             */
            ignoreDestroy: boolean;

            /**
             * Sets the `active` property of this Game Object and returns this Game Object for further chaining.
             * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.
             * @param value True if this Game Object should be set as active, false if not.
             */
            setActive(value: boolean): this;

            /**
             * Sets the `name` property of this Game Object and returns this Game Object for further chaining.
             * The `name` property is not populated by Phaser and is presented for your own use.
             * @param value The name to be given to this Game Object.
             */
            setName(value: string): this;

            /**
             * Sets the current state of this Game Object.
             *
             * Phaser itself will never modify the State of a Game Object, although plugins may do so.
             *
             * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.
             * The state value should typically be an integer (ideally mapped to a constant
             * in your game code), but could also be a string. It is recommended to keep it light and simple.
             * If you need to store complex data about your Game Object, look at using the Data Component instead.
             * @param value The state of the Game Object.
             */
            setState(value: integer | string): this;

            /**
             * Adds a Data Manager component to this Game Object.
             */
            setDataEnabled(): this;

            /**
             * Allows you to store a key value pair within this Game Objects Data Manager.
             *
             * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled
             * before setting the value.
             *
             * If the key doesn't already exist in the Data Manager then it is created.
             *
             * ```javascript
             * sprite.setData('name', 'Red Gem Stone');
             * ```
             *
             * You can also pass in an object of key value pairs as the first argument:
             *
             * ```javascript
             * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });
             * ```
             *
             * To get a value back again you can call `getData`:
             *
             * ```javascript
             * sprite.getData('gold');
             * ```
             *
             * Or you can access the value directly via the `values` property, where it works like any other variable:
             *
             * ```javascript
             * sprite.data.values.gold += 50;
             * ```
             *
             * When the value is first set, a `setdata` event is emitted from this Game Object.
             *
             * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.
             * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.
             * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.
             *
             * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.
             * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.
             * @param key The key to set the value for. Or an object or key value pairs. If an object the `data` argument is ignored.
             * @param data The value to set for the given key. If an object is provided as the key this argument is ignored.
             */
            setData(key: string | object, data: any): this;

            /**
             * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.
             *
             * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:
             *
             * ```javascript
             * sprite.getData('gold');
             * ```
             *
             * Or access the value directly:
             *
             * ```javascript
             * sprite.data.values.gold;
             * ```
             *
             * You can also pass in an array of keys, in which case an array of values will be returned:
             *
             * ```javascript
             * sprite.getData([ 'gold', 'armor', 'health' ]);
             * ```
             *
             * This approach is useful for destructuring arrays in ES6.
             * @param key The key of the value to retrieve, or an array of keys.
             */
            getData(key: string | string[]): any;

            /**
             * Pass this Game Object to the Input Manager to enable it for Input.
             *
             * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area
             * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced
             * input detection.
             *
             * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If
             * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific
             * shape for it to use.
             *
             * You can also provide an Input Configuration Object as the only argument to this method.
             * @param shape Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
             * @param callback A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.
             * @param dropZone Should this Game Object be treated as a drop zone target? Default false.
             */
            setInteractive(shape?: Input.InputConfiguration, callback?: HitAreaCallback, dropZone?: boolean): this;

            /**
             * If this Game Object has previously been enabled for input, this will disable it.
             *
             * An object that is disabled for input stops processing or being considered for
             * input events, but can be turned back on again at any time by simply calling
             * `setInteractive()` with no arguments provided.
             *
             * If want to completely remove interaction from this Game Object then use `removeInteractive` instead.
             */
            disableInteractive(): this;

            /**
             * If this Game Object has previously been enabled for input, this will queue it
             * for removal, causing it to no longer be interactive. The removal happens on
             * the next game step, it is not immediate.
             *
             * The Interactive Object that was assigned to this Game Object will be destroyed,
             * removed from the Input Manager and cleared from this Game Object.
             *
             * If you wish to re-enable this Game Object at a later date you will need to
             * re-create its InteractiveObject by calling `setInteractive` again.
             *
             * If you wish to only temporarily stop an object from receiving input then use
             * `disableInteractive` instead, as that toggles the interactive state, where-as
             * this erases it completely.
             *
             * If you wish to resize a hit area, don't remove and then set it as being
             * interactive. Instead, access the hitarea object directly and resize the shape
             * being used. I.e.: `sprite.input.hitArea.setSize(width, height)` (assuming the
             * shape is a Rectangle, which it is by default.)
             */
            removeInteractive(): this;

            /**
             * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.
             * @param args args
             */
            update(...args: any[]): void;

            /**
             * Returns a JSON representation of the Game Object.
             */
            toJSON(): JSONGameObject;

            /**
             * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
             * Also checks the Game Object against the given Cameras exclusion list.
             * @param camera The Camera to check against this Game Object.
             */
            willRender(camera: Cameras.Scene2D.Camera): boolean;

            /**
             * Returns an array containing the display list index of either this Game Object, or if it has one,
             * its parent Container. It then iterates up through all of the parent containers until it hits the
             * root of the display list (which is index 0 in the returned array).
             *
             * Used internally by the InputPlugin but also useful if you wish to find out the display depth of
             * this Game Object and all of its ancestors.
             */
            getIndexList(): integer[];

            /**
             * Destroys this Game Object removing it from the Display List and Update List and
             * severing all ties to parent resources.
             *
             * Also removes itself from the Input Manager and Physics Manager if previously enabled.
             *
             * Use this to remove a Game Object from your game if you don't ever plan to use it again.
             * As long as no reference to it exists within your own code it should become free for
             * garbage collection by the browser.
             *
             * If you just want to temporarily disable an object then look at using the
             * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.
             * @param fromScene Is this Game Object being destroyed as the result of a Scene shutdown? Default false.
             */
            destroy(fromScene?: boolean): void;

            /**
             * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.
             */
            static readonly RENDER_MASK: integer;
        }

        /**
         * The Game Object Creator is a Scene plugin that allows you to quickly create many common
         * types of Game Objects and return them. Unlike the Game Object Factory, they are not automatically
         * added to the Scene.
         *
         * Game Objects directly register themselves with the Creator and inject their own creation
         * methods into the class.
         */
        class GameObjectCreator {
            /**
             *
             * @param scene The Scene to which this Game Object Factory belongs.
             */
            constructor(scene: Scene);

            /**
             * Creates a new Dynamic Bitmap Text Game Object and returns it.
             *
             * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            dynamicBitmapText(config: BitmapTextConfig, addToScene?: boolean): DynamicBitmapText;

            /**
             * Creates a new Bitmap Text Game Object and returns it.
             *
             * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            bitmapText(config: BitmapTextConfig, addToScene?: boolean): BitmapText;

            /**
             * Creates a new Blitter Game Object and returns it.
             *
             * Note: This method will only be available if the Blitter Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            blitter(config: object, addToScene?: boolean): Blitter;

            /**
             * Creates a new Container Game Object and returns it.
             *
             * Note: This method will only be available if the Container Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            container(config: object, addToScene?: boolean): Container;

            /**
             * The Scene to which this Game Object Creator belongs.
             */
            protected scene: Scene;

            /**
             * A reference to the Scene.Systems.
             */
            protected systems: Scenes.Systems;

            /**
             * A reference to the Scene Display List.
             */
            protected displayList: DisplayList;

            /**
             * A reference to the Scene Update List.
             */
            protected "updateList;": UpdateList;

            /**
             * Creates a new Graphics Game Object and returns it.
             *
             * Note: This method will only be available if the Graphics Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            graphics(config: object, addToScene?: boolean): Graphics;

            /**
             * Creates a new Group Game Object and returns it.
             *
             * Note: This method will only be available if the Group Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             */
            group(config: GroupConfig | GroupCreateConfig): Group;

            /**
             * Creates a new Image Game Object and returns it.
             *
             * Note: This method will only be available if the Image Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            image(config: object, addToScene?: boolean): Image;

            /**
             * Creates a new Mesh Game Object and returns it.
             *
             * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            mesh(config: object, addToScene?: boolean): Mesh;

            /**
             * Creates a new Particle Emitter Manager Game Object and returns it.
             *
             * Note: This method will only be available if the Particles Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            particles(config: object, addToScene?: boolean): Particles.ParticleEmitterManager;

            /**
             * Creates a new Quad Game Object and returns it.
             *
             * Note: This method will only be available if the Quad Game Object and WebGL support have been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            quad(config: object, addToScene?: boolean): Quad;

            /**
             * Creates a new Render Texture Game Object and returns it.
             *
             * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            renderTexture(config: RenderTextureConfig, addToScene?: boolean): RenderTexture;

            /**
             * Creates a new Sprite Game Object and returns it.
             *
             * Note: This method will only be available if the Sprite Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            sprite(config: SpriteConfig, addToScene?: boolean): Sprite;

            /**
             * Creates a new Text Game Object and returns it.
             *
             * Note: This method will only be available if the Text Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            text(config: object, addToScene?: boolean): Text;

            /**
             * Creates a new TileSprite Game Object and returns it.
             *
             * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             * @param addToScene Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.
             */
            tileSprite(config: TileSprite, addToScene?: boolean): TileSprite;

            /**
             * Creates a new Zone Game Object and returns it.
             *
             * Note: This method will only be available if the Zone Game Object has been built into Phaser.
             * @param config The configuration object this Game Object will use to create itself.
             */
            zone(config: object): Zone;

            /**
             * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.
             * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing
             * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map
             * data. For an empty map, you should specify tileWidth, tileHeight, width & height.
             * @param config The config options for the Tilemap.
             */
            tilemap(config?: TilemapConfig): Tilemaps.Tilemap;

            /**
             * Creates a new Tween object and returns it.
             *
             * Note: This method will only be available if Tweens have been built into Phaser.
             * @param config The Tween configuration.
             */
            tween(config: object): Tweens.Tween;
        }

        /**
         * The Game Object Factory is a Scene plugin that allows you to quickly create many common
         * types of Game Objects and have them automatically registered with the Scene.
         *
         * Game Objects directly register themselves with the Factory and inject their own creation
         * methods into the class.
         */
        class GameObjectFactory {
            /**
             *
             * @param scene The Scene to which this Game Object Factory belongs.
             */
            constructor(scene: Scene);

            /**
             * Creates a new Path Object.
             * @param x The horizontal position of this Path.
             * @param y The vertical position of this Path.
             */
            path(x: number, y: number): Curves.Path;

            /**
             * Creates a new Dynamic Bitmap Text Game Object and adds it to the Scene.
             *
             * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
             *
             * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to
             * match the font structure.
             *
             * Dynamic Bitmap Text objects are different from Static Bitmap Text in that they invoke a callback for each
             * letter being rendered during the render pass. This callback allows you to manipulate the properties of
             * each letter being rendered, such as its position, scale or tint, allowing you to create interesting effects
             * like jiggling text, which can't be done with Static text. This means that Dynamic Text takes more processing
             * time, so only use them if you require the callback ability they have.
             *
             * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
             * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
             * processing the font texture in an image editor, applying fills and any other effects required.
             *
             * To create multi-line text insert \r, \n or \r\n escape codes into the text string.
             *
             * To create a BitmapText data files you need a 3rd party app such as:
             *
             * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
             * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
             * Littera (Web-based, free): http://kvazars.com/littera/
             *
             * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
             * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson
             *
             * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.
             * @param x The x position of the Game Object.
             * @param y The y position of the Game Object.
             * @param font The key of the font to use from the BitmapFont cache.
             * @param text The string, or array of strings, to be set as the content of this Bitmap Text.
             * @param size The font size to set.
             */
            dynamicBitmapText(x: number, y: number, font: string, text?: string | string[], size?: number): DynamicBitmapText;

            /**
             * Creates a new Bitmap Text Game Object and adds it to the Scene.
             *
             * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
             *
             * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to
             * match the font structure.
             *
             * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
             * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
             * processing the font texture in an image editor, applying fills and any other effects required.
             *
             * To create multi-line text insert \r, \n or \r\n escape codes into the text string.
             *
             * To create a BitmapText data files you need a 3rd party app such as:
             *
             * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
             * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
             * Littera (Web-based, free): http://kvazars.com/littera/
             *
             * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
             * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson
             *
             * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.
             * @param x The x position of the Game Object.
             * @param y The y position of the Game Object.
             * @param font The key of the font to use from the BitmapFont cache.
             * @param text The string, or array of strings, to be set as the content of this Bitmap Text.
             * @param size The font size to set.
             * @param align The alignment of the text in a multi-line BitmapText object. Default 0.
             */
            bitmapText(x: number, y: number, font: string, text?: string | string[], size?: number, align?: integer): BitmapText;

            /**
             * Creates a new Blitter Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Blitter Game Object has been built into Phaser.
             * @param x The x position of the Game Object.
             * @param y The y position of the Game Object.
             * @param key The key of the Texture the Blitter object will use.
             * @param frame The default Frame children of the Blitter will use.
             */
            blitter(x: number, y: number, key: string, frame?: string | integer): Blitter;

            /**
             * Creates a new Container Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Container Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param children An optional array of Game Objects to add to this Container.
             */
            container(x: number, y: number, children?: GameObject | GameObject[]): Container;

            /**
             * Creates a new Extern Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Extern Game Object has been built into Phaser.
             */
            extern(): Extern;

            /**
             * The Scene to which this Game Object Factory belongs.
             */
            protected scene: Scene;

            /**
             * A reference to the Scene.Systems.
             */
            protected systems: Scenes.Systems;

            /**
             * A reference to the Scene Display List.
             */
            protected displayList: DisplayList;

            /**
             * A reference to the Scene Update List.
             */
            protected "updateList;": UpdateList;

            /**
             * Adds an existing Game Object to this Scene.
             *
             * If the Game Object renders, it will be added to the Display List.
             * If it has a `preUpdate` method, it will be added to the Update List.
             * @param child The child to be added to this Scene.
             */
            existing(child: GameObject): GameObject;

            /**
             * Creates a new Graphics Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Graphics Game Object has been built into Phaser.
             * @param config The Graphics configuration.
             */
            graphics(config?: GraphicsOptions): Graphics;

            /**
             * Creates a new Group Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Group Game Object has been built into Phaser.
             * @param children Game Objects to add to this Group; or the `config` argument.
             * @param config A Group Configuration object.
             */
            group(children?: GameObject[] | GroupConfig | GroupConfig[], config?: GroupConfig | GroupCreateConfig): Group;

            /**
             * Creates a new Image Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Image Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            image(x: number, y: number, texture: string, frame?: string | integer): Image;

            /**
             * Creates a new Mesh Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param vertices An array containing the vertices data for this Mesh.
             * @param uv An array containing the uv data for this Mesh.
             * @param colors An array containing the color data for this Mesh.
             * @param alphas An array containing the alpha data for this Mesh.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            mesh(x: number, y: number, vertices: number[], uv: number[], colors: number[], alphas: number[], texture: string, frame?: string | integer): Mesh;

            /**
             * Creates a new Particle Emitter Manager Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Particles Game Object has been built into Phaser.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             * @param emitters Configuration settings for one or more emitters to create.
             */
            particles(texture: string, frame?: string | integer | object, emitters?: ParticleEmitterConfig | ParticleEmitterConfig[]): Particles.ParticleEmitterManager;

            /**
             * Creates a new PathFollower Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the PathFollower Game Object has been built into Phaser.
             * @param path The Path this PathFollower is connected to.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            follower(path: Curves.Path, x: number, y: number, texture: string, frame?: string | integer): PathFollower;

            /**
             * Creates a new Quad Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Quad Game Object and WebGL support have been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            quad(x: number, y: number, texture: string, frame?: string | integer): Quad;

            /**
             * Creates a new Render Texture Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.
             *
             * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and
             * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic
             * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Render Texture. Default 32.
             * @param height The height of the Render Texture. Default 32.
             */
            renderTexture(x: number, y: number, width?: integer, height?: integer): RenderTexture;

            /**
             * Creates a new Arc Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Arc Game Object has been built into Phaser.
             *
             * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports both fill and stroke colors.
             *
             * When it renders it displays an arc shape. You can control the start and end angles of the arc,
             * as well as if the angles are winding clockwise or anti-clockwise. With the default settings
             * it renders as a complete circle. By changing the angles you can create other arc shapes,
             * such as half-circles.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param radius The radius of the arc. Default 128.
             * @param startAngle The start angle of the arc, in degrees. Default 0.
             * @param endAngle The end angle of the arc, in degrees. Default 360.
             * @param anticlockwise The winding order of the start and end angles. Default false.
             * @param fillColor The color the arc will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            arc(x?: number, y?: number, radius?: number, startAngle?: integer, endAngle?: integer, anticlockwise?: boolean, fillColor?: number, fillAlpha?: number): Arc;

            /**
             * Creates a new Circle Shape Game Object and adds it to the Scene.
             *
             * A Circle is an Arc with no defined start and end angle, making it render as a complete circle.
             *
             * Note: This method will only be available if the Arc Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param radius The radius of the circle. Default 128.
             * @param fillColor The color the circle will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the circle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            circle(x?: number, y?: number, radius?: number, fillColor?: number, fillAlpha?: number): Arc;

            /**
             * Creates a new Curve Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Curve Game Object has been built into Phaser.
             *
             * The Curve Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports both fill and stroke colors.
             *
             * To render a Curve Shape you must first create a `Phaser.Curves.Curve` object, then pass it to
             * the Curve Shape in the constructor.
             *
             * The Curve shape also has a `smoothness` property and corresponding `setSmoothness` method.
             * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations
             * that take place during construction. Increase and decrease the default value for smoother, or more
             * jagged, shapes.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param curve The Curve object to use to create the Shape.
             * @param fillColor The color the curve will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the curve will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            curve(x?: number, y?: number, curve?: Curves.Curve, fillColor?: number, fillAlpha?: number): Curve;

            /**
             * Creates a new Ellipse Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Ellipse Game Object has been built into Phaser.
             *
             * The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports both fill and stroke colors.
             *
             * When it renders it displays an ellipse shape. You can control the width and height of the ellipse.
             * If the width and height match it will render as a circle. If the width is less than the height,
             * it will look more like an egg shape.
             *
             * The Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.
             * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations
             * that take place during construction. Increase and decrease the default value for smoother, or more
             * jagged, shapes.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param width The width of the ellipse. An ellipse with equal width and height renders as a circle. Default 128.
             * @param height The height of the ellipse. An ellipse with equal width and height renders as a circle. Default 128.
             * @param fillColor The color the ellipse will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the ellipse will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            ellipse(x?: number, y?: number, width?: number, height?: number, fillColor?: number, fillAlpha?: number): Ellipse;

            /**
             * Creates a new Grid Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Grid Game Object has been built into Phaser.
             *
             * The Grid Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports only fill colors and cannot be stroked.
             *
             * A Grid Shape allows you to display a grid in your game, where you can control the size of the
             * grid as well as the width and height of the grid cells. You can set a fill color for each grid
             * cell as well as an alternate fill color. When the alternate fill color is set then the grid
             * cells will alternate the fill colors as they render, creating a chess-board effect. You can
             * also optionally have an outline fill color. If set, this draws lines between the grid cells
             * in the given color. If you specify an outline color with an alpha of zero, then it will draw
             * the cells spaced out, but without the lines between them.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param width The width of the grid. Default 128.
             * @param height The height of the grid. Default 128.
             * @param cellWidth The width of one cell in the grid. Default 32.
             * @param cellHeight The height of one cell in the grid. Default 32.
             * @param fillColor The color the grid cells will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             * @param outlineFillColor The color of the lines between the grid cells.
             * @param outlineFillAlpha The alpha of the lines between the grid cells.
             */
            grid(
                x?: number,
                y?: number,
                width?: number,
                height?: number,
                cellWidth?: number,
                cellHeight?: number,
                fillColor?: number,
                fillAlpha?: number,
                outlineFillColor?: number,
                outlineFillAlpha?: number
            ): Grid;

            /**
             * Creates a new IsoBox Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the IsoBox Game Object has been built into Phaser.
             *
             * The IsoBox Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports only fill colors and cannot be stroked.
             *
             * An IsoBox is an 'isometric' rectangle. Each face of it has a different fill color. You can set
             * the color of the top, left and right faces of the rectangle respectively. You can also choose
             * which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.
             *
             * You cannot view an IsoBox from under-neath, however you can change the 'angle' by setting
             * the `projection` property.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param size The width of the iso box in pixels. The left and right faces will be exactly half this value. Default 48.
             * @param height The height of the iso box. The left and right faces will be this tall. The overall height of the isobox will be this value plus half the `size` value. Default 32.
             * @param fillTop The fill color of the top face of the iso box. Default 0xeeeeee.
             * @param fillLeft The fill color of the left face of the iso box. Default 0x999999.
             * @param fillRight The fill color of the right face of the iso box. Default 0xcccccc.
             */
            isobox(x?: number, y?: number, size?: number, height?: number, fillTop?: number, fillLeft?: number, fillRight?: number): IsoBox;

            /**
             * Creates a new IsoTriangle Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the IsoTriangle Game Object has been built into Phaser.
             *
             * The IsoTriangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports only fill colors and cannot be stroked.
             *
             * An IsoTriangle is an 'isometric' triangle. Think of it like a pyramid. Each face has a different
             * fill color. You can set the color of the top, left and right faces of the triangle respectively
             * You can also choose which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.
             *
             * You cannot view an IsoTriangle from under-neath, however you can change the 'angle' by setting
             * the `projection` property. The `reversed` property controls if the IsoTriangle is rendered upside
             * down or not.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param size The width of the iso triangle in pixels. The left and right faces will be exactly half this value. Default 48.
             * @param height The height of the iso triangle. The left and right faces will be this tall.
             * The overall height of the iso triangle will be this value plus half the `size` value. Default 32.
             * @param reversed Is the iso triangle upside down? Default false.
             * @param fillTop The fill color of the top face of the iso triangle. Default 0xeeeeee.
             * @param fillLeft The fill color of the left face of the iso triangle. Default 0x999999.
             * @param fillRight The fill color of the right face of the iso triangle. Default 0xcccccc.
             */
            isotriangle(x?: number, y?: number, size?: number, height?: number, reversed?: boolean, fillTop?: number, fillLeft?: number, fillRight?: number): IsoTriangle;

            /**
             * Creates a new Line Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Line Game Object has been built into Phaser.
             *
             * The Line Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports only stroke colors and cannot be filled.
             *
             * A Line Shape allows you to draw a line between two points in your game. You can control the
             * stroke color and thickness of the line. In WebGL only you can also specify a different
             * thickness for the start and end of the line, allowing you to render lines that taper-off.
             *
             * If you need to draw multiple lines in a sequence you may wish to use the Polygon Shape instead.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param x1 The horizontal position of the start of the line. Default 0.
             * @param y1 The vertical position of the start of the line. Default 0.
             * @param x2 The horizontal position of the end of the line. Default 128.
             * @param y2 The vertical position of the end of the line. Default 0.
             * @param strokeColor The color the line will be drawn in, i.e. 0xff0000 for red.
             * @param strokeAlpha The alpha the line will be drawn in. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            line(x?: number, y?: number, x1?: number, y1?: number, x2?: number, y2?: number, strokeColor?: number, strokeAlpha?: number): Line;

            /**
             * Creates a new Polygon Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Polygon Game Object has been built into Phaser.
             *
             * The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports both fill and stroke colors.
             *
             * The Polygon Shape is created by providing a list of points, which are then used to create an
             * internal Polygon geometry object. The points can be set from a variety of formats:
             *
             * - An array of Point or Vector2 objects: `[new Phaser.Math.Vec2(x1, y1), ...]`
             * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
             * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
             * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
             *
             * By default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending
             * on the coordinates of the points provided, the final shape may be rendered offset from its origin.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param points The points that make up the polygon.
             * @param fillColor The color the polygon will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the polygon will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            polygon(x?: number, y?: number, points?: any, fillColor?: number, fillAlpha?: number): Polygon;

            /**
             * Creates a new Rectangle Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Rectangle Game Object has been built into Phaser.
             *
             * The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports both fill and stroke colors.
             *
             * You can change the size of the rectangle by changing the `width` and `height` properties.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param width The width of the rectangle. Default 128.
             * @param height The height of the rectangle. Default 128.
             * @param fillColor The color the rectangle will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the rectangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            rectangle(x?: number, y?: number, width?: number, height?: number, fillColor?: number, fillAlpha?: number): Rectangle;

            /**
             * Creates a new Star Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Star Game Object has been built into Phaser.
             *
             * The Star Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports both fill and stroke colors.
             *
             * As the name implies, the Star shape will display a star in your game. You can control several
             * aspects of it including the number of points that constitute the star. The default is 5. If
             * you change it to 4 it will render as a diamond. If you increase them, you'll get a more spiky
             * star shape.
             *
             * You can also control the inner and outer radius, which is how 'long' each point of the star is.
             * Modify these values to create more interesting shapes.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param points The number of points on the star. Default 5.
             * @param innerRadius The inner radius of the star. Default 32.
             * @param outerRadius The outer radius of the star. Default 64.
             * @param fillColor The color the star will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the star will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            star(x?: number, y?: number, points?: number, innerRadius?: number, outerRadius?: number, fillColor?: number, fillAlpha?: number): Star;

            /**
             * Creates a new Triangle Shape Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Triangle Game Object has been built into Phaser.
             *
             * The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
             * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
             * it for input or physics. It provides a quick and easy way for you to render this shape in your
             * game without using a texture, while still taking advantage of being fully batched in WebGL.
             *
             * This shape supports both fill and stroke colors.
             *
             * The Triangle consists of 3 lines, joining up to form a triangular shape. You can control the
             * position of each point of these lines. The triangle is always closed and cannot have an open
             * face. If you require that, consider using a Polygon instead.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param x1 The horizontal position of the first point in the triangle. Default 0.
             * @param y1 The vertical position of the first point in the triangle. Default 128.
             * @param x2 The horizontal position of the second point in the triangle. Default 64.
             * @param y2 The vertical position of the second point in the triangle. Default 0.
             * @param x3 The horizontal position of the third point in the triangle. Default 128.
             * @param y3 The vertical position of the third point in the triangle. Default 128.
             * @param fillColor The color the triangle will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the triangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            triangle(x?: number, y?: number, x1?: number, y1?: number, x2?: number, y2?: number, x3?: number, y3?: number, fillColor?: number, fillAlpha?: number): Triangle;

            /**
             * Creates a new Sprite Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Sprite Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            sprite(x: number, y: number, texture: string, frame?: string | integer): Sprite;

            /**
             * Creates a new Text Game Object and adds it to the Scene.
             *
             * A Text Game Object.
             *
             * Text objects work by creating their own internal hidden Canvas and then renders text to it using
             * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered
             * to your game during the render pass.
             *
             * Because it uses the Canvas API you can take advantage of all the features this offers, such as
             * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts
             * loaded externally, such as Google or interfaceKit Web fonts.
             *
             * You can only display fonts that are currently loaded and available to the browser: therefore fonts must
             * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,
             * or have the fonts ready available in the CSS on the page in which your Phaser game resides.
             *
             * See {@link http://www.jordanm.co.uk/tinyinterface this compatibility table} for the available default fonts
             * across mobile browsers.
             *
             * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being
             * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the
             * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of
             * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text
             * instead, as it benefits from batching and avoids expensive Canvas API calls.
             *
             * Note: This method will only be available if the Text Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param text The text this Text object will display.
             * @param style The Text style configuration object.
             */
            text(x: number, y: number, text: string | string[], style?: object): Text;

            /**
             * Creates a new TileSprite Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Game Object. If zero it will use the size of the texture frame.
             * @param height The height of the Game Object. If zero it will use the size of the texture frame.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            tileSprite(x: number, y: number, width: integer, height: integer, texture: string, frame?: string | integer): TileSprite;

            /**
             * Creates a new Zone Game Object and adds it to the Scene.
             *
             * Note: This method will only be available if the Zone Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Game Object.
             * @param height The height of the Game Object.
             */
            zone(x: number, y: number, width: number, height: number): Zone;

            /**
             * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.
             * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing
             * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map
             * data. For an empty map, you should specify tileWidth, tileHeight, width & height.
             * @param key The key in the Phaser cache that corresponds to the loaded tilemap data.
             * @param tileWidth The width of a tile in pixels. Pass in `null` to leave as the
             * default. Default 32.
             * @param tileHeight The height of a tile in pixels. Pass in `null` to leave as the
             * default. Default 32.
             * @param width The width of the map in tiles. Pass in `null` to leave as the
             * default. Default 10.
             * @param height The height of the map in tiles. Pass in `null` to leave as the
             * default. Default 10.
             * @param data Instead of loading from the cache, you can also load directly from
             * a 2D array of tile indexes. Pass in `null` for no data.
             * @param insertNull Controls how empty tiles, tiles with an index of -1, in the
             * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
             * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
             * the tile data doesn't need to change then setting this value to `true` will help with memory
             * consumption. However if your map is small or you need to update the tiles dynamically, then leave
             * the default value set. Default false.
             */
            tilemap(key?: string, tileWidth?: integer, tileHeight?: integer, width?: integer, height?: integer, data?: integer[][], insertNull?: boolean): Tilemaps.Tilemap;

            /**
             * Creates a new Tween object.
             *
             * Note: This method will only be available Tweens have been built into Phaser.
             * @param config The Tween configuration.
             */
            tween(config: object): Tweens.Tween;
        }

        /**
         * A Graphics object is a way to draw primitive shapes to your game. Primitives include forms of geometry, such as
         * Rectangles, Circles, and Polygons. They also include lines, arcs and curves. When you initially create a Graphics
         * object it will be empty.
         *
         * To draw to it you must first specify a line style or fill style (or both), draw shapes using paths, and finally
         * fill or stroke them. For example:
         *
         * ```javascript
         * graphics.lineStyle(5, 0xFF00FF, 1.0);
         * graphics.beginPath();
         * graphics.moveTo(100, 100);
         * graphics.lineTo(200, 200);
         * graphics.closePath();
         * graphics.strokePath();
         * ```
         *
         * There are also many helpful methods that draw and fill/stroke common shapes for you.
         *
         * ```javascript
         * graphics.lineStyle(5, 0xFF00FF, 1.0);
         * graphics.fillStyle(0xFFFFFF, 1.0);
         * graphics.fillRect(50, 50, 400, 200);
         * graphics.strokeRect(50, 50, 400, 200);
         * ```
         *
         * When a Graphics object is rendered it will render differently based on if the game is running under Canvas or WebGL.
         * Under Canvas it will use the HTML Canvas context drawing operations to draw the path.
         * Under WebGL the graphics data is decomposed into polygons. Both of these are expensive processes, especially with
         * complex shapes.
         *
         * If your Graphics object doesn't change much (or at all) once you've drawn your shape to it, then you will help
         * performance by calling {@link Phaser.GameObjects.Graphics#generateTexture}. This will 'bake' the Graphics object into
         * a Texture, and return it. You can then use this Texture for Sprites or other display objects. If your Graphics object
         * updates frequently then you should avoid doing this, as it will constantly generate new textures, which will consume
         * memory.
         *
         * As you can tell, Graphics objects are a bit of a trade-off. While they are extremely useful, you need to be careful
         * in their complexity and quantity of them in your game.
         */
        class Graphics extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Mask,
                Components.Pipeline,
                Components.Transform,
                Components.Visible,
                Components.ScrollFactor {
            /**
             *
             * @param scene The Scene to which this Graphics object belongs.
             * @param options Options that set the position and default style of this Graphics object.
             */
            constructor(scene: Scene, options?: GraphicsOptions);

            /**
             * The horizontal display origin of the Graphics.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of the Graphics.
             */
            displayOriginY: number;

            /**
             * The array of commands used to render the Graphics.
             */
            commandBuffer: any[];

            /**
             * The default fill color for shapes rendered by this Graphics object.
             */
            defaultFillColor: number;

            /**
             * The default fill alpha for shapes rendered by this Graphics object.
             */
            defaultFillAlpha: number;

            /**
             * The default stroke width for shapes rendered by this Graphics object.
             */
            defaultStrokeWidth: number;

            /**
             * The default stroke color for shapes rendered by this Graphics object.
             */
            defaultStrokeColor: number;

            /**
             * The default stroke alpha for shapes rendered by this Graphics object.
             */
            defaultStrokeAlpha: number;

            /**
             * Set the default style settings for this Graphics object.
             * @param options The styles to set as defaults.
             */
            setDefaultStyles(options: GraphicsStyles): Graphics;

            /**
             * Set the current line style.
             * @param lineWidth The stroke width.
             * @param color The stroke color.
             * @param alpha The stroke alpha. Default 1.
             */
            lineStyle(lineWidth: number, color: number, alpha?: number): Graphics;

            /**
             * Set the current fill style.
             * @param color The fill color.
             * @param alpha The fill alpha. Default 1.
             */
            fillStyle(color: number, alpha?: number): Graphics;

            /**
             * Sets a gradient fill style. This is a WebGL only feature.
             *
             * The gradient color values represent the 4 corners of an untransformed rectangle.
             * The gradient is used to color all filled shapes and paths drawn after calling this method.
             * If you wish to turn a gradient off, call `fillStyle` and provide a new single fill color.
             *
             * When filling a triangle only the first 3 color values provided are used for the 3 points of a triangle.
             *
             * This feature is best used only on rectangles and triangles. All other shapes will give strange results.
             *
             * Note that for objects such as arcs or ellipses, or anything which is made out of triangles, each triangle used
             * will be filled with a gradient on its own. There is no ability to gradient fill a shape or path as a single
             * entity at this time.
             * @param topLeft The tint being applied to the top-left of the Game Object.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             * @param alpha The fill alpha. Default 1.
             */
            fillGradientStyle(topLeft: integer, topRight: integer, bottomLeft: integer, bottomRight: integer, alpha?: number): Graphics;

            /**
             * Sets a gradient line style. This is a WebGL only feature.
             *
             * The gradient color values represent the 4 corners of an untransformed rectangle.
             * The gradient is used to color all stroked shapes and paths drawn after calling this method.
             * If you wish to turn a gradient off, call `lineStyle` and provide a new single line color.
             *
             * This feature is best used only on single lines. All other shapes will give strange results.
             *
             * Note that for objects such as arcs or ellipses, or anything which is made out of triangles, each triangle used
             * will be filled with a gradient on its own. There is no ability to gradient stroke a shape or path as a single
             * entity at this time.
             * @param lineWidth The stroke width.
             * @param topLeft The tint being applied to the top-left of the Game Object.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             * @param alpha The fill alpha. Default 1.
             */
            lineGradientStyle(lineWidth: number, topLeft: integer, topRight: integer, bottomLeft: integer, bottomRight: integer, alpha?: number): Graphics;

            /**
             * Sets the texture frame this Graphics Object will use when drawing all shapes defined after calling this.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             *
             * Once set, all shapes will use this texture. Call this method with no arguments to clear it.
             *
             * The textures are not tiled. They are stretched to the dimensions of the shapes being rendered. For this reason,
             * it works best with seamless / tileable textures.
             *
             * The mode argument controls how the textures are combined with the fill colors. The default value (0) will
             * multiply the texture by the fill color. A value of 1 will use just the fill color, but the alpha data from the texture,
             * and a value of 2 will use just the texture and no fill color at all.
             * @param key The key of the texture to be used, as stored in the Texture Manager. Leave blank to clear a previously set texture.
             * @param frame The name or index of the frame within the Texture.
             * @param mode The texture tint mode. 0 is multiply, 1 is alpha only and 2 is texture only. Default 0.
             */
            setTexture(key?: string, frame?: string | integer, mode?: number): this;

            /**
             * Start a new shape path.
             */
            beginPath(): Graphics;

            /**
             * Close the current path.
             */
            closePath(): Graphics;

            /**
             * Fill the current path.
             */
            fillPath(): Graphics;

            /**
             * Fill the current path.
             *
             * This is an alias for `Graphics.fillPath` and does the same thing.
             * It was added to match the CanvasRenderingContext 2D API.
             */
            fill(): Graphics;

            /**
             * Stroke the current path.
             */
            strokePath(): Graphics;

            /**
             * Stroke the current path.
             *
             * This is an alias for `Graphics.strokePath` and does the same thing.
             * It was added to match the CanvasRenderingContext 2D API.
             */
            stroke(): Graphics;

            /**
             * Fill the given circle.
             * @param circle The circle to fill.
             */
            fillCircleShape(circle: Geom.Circle): Graphics;

            /**
             * Stroke the given circle.
             * @param circle The circle to stroke.
             */
            strokeCircleShape(circle: Geom.Circle): Graphics;

            /**
             * Fill a circle with the given position and radius.
             * @param x The x coordinate of the center of the circle.
             * @param y The y coordinate of the center of the circle.
             * @param radius The radius of the circle.
             */
            fillCircle(x: number, y: number, radius: number): Graphics;

            /**
             * Stroke a circle with the given position and radius.
             * @param x The x coordinate of the center of the circle.
             * @param y The y coordinate of the center of the circle.
             * @param radius The radius of the circle.
             */
            strokeCircle(x: number, y: number, radius: number): Graphics;

            /**
             * Fill the given rectangle.
             * @param rect The rectangle to fill.
             */
            fillRectShape(rect: Geom.Rectangle): Graphics;

            /**
             * Stroke the given rectangle.
             * @param rect The rectangle to stroke.
             */
            strokeRectShape(rect: Geom.Rectangle): Graphics;

            /**
             * Fill a rectangle with the given position and size.
             * @param x The x coordinate of the top-left of the rectangle.
             * @param y The y coordinate of the top-left of the rectangle.
             * @param width The width of the rectangle.
             * @param height The height of the rectangle.
             */
            fillRect(x: number, y: number, width: number, height: number): Graphics;

            /**
             * Stroke a rectangle with the given position and size.
             * @param x The x coordinate of the top-left of the rectangle.
             * @param y The y coordinate of the top-left of the rectangle.
             * @param width The width of the rectangle.
             * @param height The height of the rectangle.
             */
            strokeRect(x: number, y: number, width: number, height: number): Graphics;

            /**
             * Fill a rounded rectangle with the given position, size and radius.
             * @param x The x coordinate of the top-left of the rectangle.
             * @param y The y coordinate of the top-left of the rectangle.
             * @param width The width of the rectangle.
             * @param height The height of the rectangle.
             * @param radius The corner radius; It can also be an object to specify different radii for corners. Default 20.
             */
            fillRoundedRect(x: number, y: number, width: number, height: number, radius?: RoundedRectRadius | number): Graphics;

            /**
             * Stroke a rounded rectangle with the given position, size and radius.
             * @param x The x coordinate of the top-left of the rectangle.
             * @param y The y coordinate of the top-left of the rectangle.
             * @param width The width of the rectangle.
             * @param height The height of the rectangle.
             * @param radius The corner radius; It can also be an object to specify different radii for corners. Default 20.
             */
            strokeRoundedRect(x: number, y: number, width: number, height: number, radius?: RoundedRectRadius | number): Graphics;

            /**
             * Fill the given point.
             *
             * Draws a square at the given position, 1 pixel in size by default.
             * @param point The point to fill.
             * @param size The size of the square to draw. Default 1.
             */
            fillPointShape(point: Geom.Point | Math.Vector2 | object, size?: number): Graphics;

            /**
             * Fill a point at the given position.
             *
             * Draws a square at the given position, 1 pixel in size by default.
             * @param x The x coordinate of the point.
             * @param y The y coordinate of the point.
             * @param size The size of the square to draw. Default 1.
             */
            fillPoint(x: number, y: number, size?: number): Graphics;

            /**
             * Fill the given triangle.
             * @param triangle The triangle to fill.
             */
            fillTriangleShape(triangle: Geom.Triangle): Graphics;

            /**
             * Stroke the given triangle.
             * @param triangle The triangle to stroke.
             */
            strokeTriangleShape(triangle: Geom.Triangle): Graphics;

            /**
             * Fill a triangle with the given points.
             * @param x0 The x coordinate of the first point.
             * @param y0 The y coordinate of the first point.
             * @param x1 The x coordinate of the second point.
             * @param y1 The y coordinate of the second point.
             * @param x2 The x coordinate of the third point.
             * @param y2 The y coordinate of the third point.
             */
            fillTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): Graphics;

            /**
             * Stroke a triangle with the given points.
             * @param x0 The x coordinate of the first point.
             * @param y0 The y coordinate of the first point.
             * @param x1 The x coordinate of the second point.
             * @param y1 The y coordinate of the second point.
             * @param x2 The x coordinate of the third point.
             * @param y2 The y coordinate of the third point.
             */
            strokeTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): Graphics;

            /**
             * Draw the given line.
             * @param line The line to stroke.
             */
            strokeLineShape(line: Geom.Line): Graphics;

            /**
             * Draw a line between the given points.
             * @param x1 The x coordinate of the start point of the line.
             * @param y1 The y coordinate of the start point of the line.
             * @param x2 The x coordinate of the end point of the line.
             * @param y2 The y coordinate of the end point of the line.
             */
            lineBetween(x1: number, y1: number, x2: number, y2: number): Graphics;

            /**
             * Draw a line from the current drawing position to the given position.
             *
             * Moves the current drawing position to the given position.
             * @param x The x coordinate to draw the line to.
             * @param y The y coordinate to draw the line to.
             */
            lineTo(x: number, y: number): Graphics;

            /**
             * Move the current drawing position to the given position.
             * @param x The x coordinate to move to.
             * @param y The y coordinate to move to.
             */
            moveTo(x: number, y: number): Graphics;

            /**
             * Draw a line from the current drawing position to the given position with a specific width and color.
             * @param x The x coordinate to draw the line to.
             * @param y The y coordinate to draw the line to.
             * @param width The width of the stroke.
             * @param rgb The color of the stroke.
             */
            lineFxTo(x: number, y: number, width: number, rgb: number): Graphics;

            /**
             * Move the current drawing position to the given position and change the pen width and color.
             * @param x The x coordinate to move to.
             * @param y The y coordinate to move to.
             * @param width The new stroke width.
             * @param rgb The new stroke color.
             */
            moveFxTo(x: number, y: number, width: number, rgb: number): Graphics;

            /**
             * Stroke the shape represented by the given array of points.
             *
             * Pass `true` to `autoClose` to close the shape automatically.
             * @param points The points to stroke.
             * @param autoClose When `true`, the shape is closed by joining the last point to the first point. Default false.
             * @param endIndex The index of `points` to stop drawing at. Defaults to `points.length`.
             */
            strokePoints(points: any[] | Geom.Point[], autoClose?: boolean, endIndex?: integer): Graphics;

            /**
             * Fill the shape represented by the given array of points.
             *
             * Pass `true` to `autoClose` to close the shape automatically.
             * @param points The points to fill.
             * @param autoClose Whether to automatically close the polygon. Default false.
             * @param endIndex The index of `points` to stop at. Defaults to `points.length`.
             */
            fillPoints(points: any[] | Geom.Point[], autoClose?: boolean, endIndex?: integer): Graphics;

            /**
             * Stroke the given ellipse.
             * @param ellipse The ellipse to stroke.
             * @param smoothness The number of points to draw the ellipse with. Default 32.
             */
            strokeEllipseShape(ellipse: Geom.Ellipse, smoothness?: integer): Graphics;

            /**
             * Stroke an ellipse with the given position and size.
             * @param x The x coordinate of the center of the ellipse.
             * @param y The y coordinate of the center of the ellipse.
             * @param width The width of the ellipse.
             * @param height The height of the ellipse.
             * @param smoothness The number of points to draw the ellipse with. Default 32.
             */
            strokeEllipse(x: number, y: number, width: number, height: number, smoothness?: integer): Graphics;

            /**
             * Fill the given ellipse.
             * @param ellipse The ellipse to fill.
             * @param smoothness The number of points to draw the ellipse with. Default 32.
             */
            fillEllipseShape(ellipse: Geom.Ellipse, smoothness?: integer): Graphics;

            /**
             * Fill an ellipse with the given position and size.
             * @param x The x coordinate of the center of the ellipse.
             * @param y The y coordinate of the center of the ellipse.
             * @param width The width of the ellipse.
             * @param height The height of the ellipse.
             * @param smoothness The number of points to draw the ellipse with. Default 32.
             */
            fillEllipse(x: number, y: number, width: number, height: number, smoothness?: integer): Graphics;

            /**
             * Draw an arc.
             *
             * This method can be used to create circles, or parts of circles.
             *
             * Make sure you call `beginPath` before starting the arc unless you wish for the arc to automatically
             * close when filled or stroked.
             *
             * Use the optional `overshoot` argument increase the number of iterations that take place when
             * the arc is rendered in WebGL. This is useful if you're drawing an arc with an especially thick line,
             * as it will allow the arc to fully join-up. Try small values at first, i.e. 0.01.
             *
             * Call {@link Phaser.GameObjects.Graphics#fillPath} or {@link Phaser.GameObjects.Graphics#strokePath} after calling
             * this method to draw the arc.
             * @param x The x coordinate of the center of the circle.
             * @param y The y coordinate of the center of the circle.
             * @param radius The radius of the circle.
             * @param startAngle The starting angle, in radians.
             * @param endAngle The ending angle, in radians.
             * @param anticlockwise Whether the drawing should be anticlockwise or clockwise. Default false.
             * @param overshoot This value allows you to increase the segment iterations in WebGL rendering.
             * Useful if the arc has a thick stroke and needs to overshoot to join-up cleanly. Use small numbers such as 0.01 to start with and increase as needed. Default 0.
             */
            arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean, overshoot?: number): Graphics;

            /**
             * Creates a pie-chart slice shape centered at `x`, `y` with the given radius.
             * You must define the start and end angle of the slice.
             *
             * Setting the `anticlockwise` argument to `true` creates a shape similar to Pacman.
             * Setting it to `false` creates a shape like a slice of pie.
             *
             * This method will begin a new path and close the path at the end of it.
             * To display the actual slice you need to call either `strokePath` or `fillPath` after it.
             * @param x The horizontal center of the slice.
             * @param y The vertical center of the slice.
             * @param radius The radius of the slice.
             * @param startAngle The start angle of the slice, given in radians.
             * @param endAngle The end angle of the slice, given in radians.
             * @param anticlockwise Whether the drawing should be anticlockwise or clockwise. Default false.
             * @param overshoot This value allows you to overshoot the endAngle by this amount. Useful if the arc has a thick stroke and needs to overshoot to join-up cleanly. Default 0.
             */
            slice(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean, overshoot?: number): Graphics;

            /**
             * Saves the state of the Graphics by pushing the current state onto a stack.
             *
             * The most recently saved state can then be restored with {@link Phaser.GameObjects.Graphics#restore}.
             */
            save(): Graphics;

            /**
             * Restores the most recently saved state of the Graphics by popping from the state stack.
             *
             * Use {@link Phaser.GameObjects.Graphics#save} to save the current state, and call this afterwards to restore that state.
             *
             * If there is no saved state, this command does nothing.
             */
            restore(): Graphics;

            /**
             * Translate the graphics.
             * @param x The horizontal translation to apply.
             * @param y The vertical translation to apply.
             */
            translate(x: number, y: number): Graphics;

            /**
             * Scale the graphics.
             * @param x The horizontal scale to apply.
             * @param y The vertical scale to apply.
             */
            scale(x: number, y: number): Graphics;

            /**
             * Rotate the graphics.
             * @param radians The rotation angle, in radians.
             */
            rotate(radians: number): Graphics;

            /**
             * Clear the command buffer and reset the fill style and line style to their defaults.
             */
            clear(): Graphics;

            /**
             * Generate a texture from this Graphics object.
             *
             * If `key` is a string it'll generate a new texture using it and add it into the
             * Texture Manager (assuming no key conflict happens).
             *
             * If `key` is a Canvas it will draw the texture to that canvas context. Note that it will NOT
             * automatically upload it to the GPU in WebGL mode.
             * @param key The key to store the texture with in the Texture Manager, or a Canvas to draw to.
             * @param width The width of the graphics to generate.
             * @param height The height of the graphics to generate.
             */
            generateTexture(key: string | HTMLCanvasElement, width?: integer, height?: integer): Graphics;

            /**
             * Internal destroy handler, called as part of the destroy process.
             */
            protected preDestroy(): void;

            /**
             * A Camera used specifically by the Graphics system for rendering to textures.
             */
            static TargetCamera: Cameras.Scene2D.Camera;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;
        }

        /**
         * A Group is a way for you to create, manipulate, or recycle similar Game Objects.
         *
         * Group membership is non-exclusive. A Game Object can belong to several groups, one group, or none.
         *
         * Groups themselves aren't displayable, and can't be positioned, rotated, scaled, or hidden.
         */
        class Group<G = GameObject> {
            /**
             *
             * @param scene The scene this group belongs to.
             * @param children Game Objects to add to this group; or the `config` argument.
             * @param config Settings for this group. If `key` is set, Phaser.GameObjects.Group#createMultiple is also called with these settings.
             */
            constructor(scene: Scene, children?: GameObject[] | GroupConfig | GroupCreateConfig, config?: GroupConfig | GroupCreateConfig);

            /**
             * This scene this group belongs to.
             */
            scene: Scene;

            /**
             * Members of this group.
             */
            children: Structs.Set<G>;

            /**
             * A flag identifying this object as a group.
             */
            isParent: boolean;

            /**
             * The class to create new group members from.
             */
            classinterface: GroupClassinterfaceConstructor;

            /**
             * Whether this group runs its {@link Phaser.GameObjects.Group#preUpdate} method
             * (which may update any members).
             */
            active: boolean;

            /**
             * The maximum size of this group, if used as a pool. -1 is no limit.
             */
            maxSize: integer;

            /**
             * A default texture key to use when creating new group members.
             *
             * This is used in {@link Phaser.GameObjects.Group#create}
             * but not in {@link Phaser.GameObjects.Group#createMultiple}.
             */
            defaultKey: string;

            /**
             * A default texture frame to use when creating new group members.
             */
            defaultFrame: string | integer;

            /**
             * Whether to call the update method of any members.
             */
            runChildUpdate: boolean;

            /**
             * A function to be called when adding or creating group members.
             */
            createCallback: GroupCallback;

            /**
             * A function to be called when removing group members.
             */
            removeCallback: GroupCallback;

            /**
             * A function to be called when creating several group members at once.
             */
            createMultipleCallback: GroupMultipleCreateCallback;

            /**
             * Creates a new Game Object and adds it to this group, unless the group {@link Phaser.GameObjects.Group#isFull is full}.
             *
             * Calls {@link Phaser.GameObjects.Group#createCallback}.
             * @param x The horizontal position of the new Game Object in the world. Default 0.
             * @param y The vertical position of the new Game Object in the world. Default 0.
             * @param key The texture key of the new Game Object. Default defaultKey.
             * @param frame The texture frame of the new Game Object. Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of the new Game Object. Default true.
             * @param active The {@link Phaser.GameObjects.GameObject#active} state of the new Game Object. Default true.
             */
            create(x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean, active?: boolean): any;

            /**
             * Creates several Game Objects and adds them to this group.
             *
             * If the group becomes {@link Phaser.GameObjects.Group#isFull}, no further Game Objects are created.
             *
             * Calls {@link Phaser.GameObjects.Group#createMultipleCallback} and {@link Phaser.GameObjects.Group#createCallback}.
             * @param config Creation settings. This can be a single configuration object or an array of such objects, which will be applied in turn.
             */
            createMultiple(config: GroupCreateConfig | GroupCreateConfig[]): any[];

            /**
             * A helper for {@link Phaser.GameObjects.Group#createMultiple}.
             * @param options Creation settings.
             */
            createFromConfig(options: GroupCreateConfig): any[];

            /**
             * Updates any group members, if {@link Phaser.GameObjects.Group#runChildUpdate} is enabled.
             * @param time The current timestamp.
             * @param delta The delta time elapsed since the last frame.
             */
            preUpdate(time: number, delta: number): void;

            /**
             * Adds a Game Object to this group.
             *
             * Calls {@link Phaser.GameObjects.Group#createCallback}.
             * @param child The Game Object to add.
             * @param addToScene Also add the Game Object to the scene. Default false.
             */
            add(child: GameObject, addToScene?: boolean): Group;

            /**
             * Adds several Game Objects to this group.
             *
             * Calls {@link Phaser.GameObjects.Group#createCallback}.
             * @param children The Game Objects to add.
             * @param addToScene Also add the Game Objects to the scene. Default false.
             */
            addMultiple(children: GameObject[], addToScene?: boolean): Group;

            /**
             * Removes a member of this Group and optionally removes it from the Scene and / or destroys it.
             *
             * Calls {@link Phaser.GameObjects.Group#removeCallback}.
             * @param child The Game Object to remove.
             * @param removeFromScene Optionally remove the Group member from the Scene it belongs to. Default false.
             * @param destroyChild Optionally call destroy on the removed Group member. Default false.
             */
            remove(child: GameObject, removeFromScene?: boolean, destroyChild?: boolean): Group;

            /**
             * Removes all members of this Group and optionally removes them from the Scene and / or destroys them.
             *
             * Does not call {@link Phaser.GameObjects.Group#removeCallback}.
             * @param removeFromScene Optionally remove each Group member from the Scene. Default false.
             * @param destroyChild Optionally call destroy on the removed Group members. Default false.
             */
            clear(removeFromScene?: boolean, destroyChild?: boolean): Group;

            /**
             * Tests if a Game Object is a member of this group.
             * @param child A Game Object.
             */
            contains(child: GameObject): boolean;

            /**
             * All members of the group.
             */
            getChildren(): GameObject[];

            /**
             * The number of members of the group.
             */
            getLength(): integer;

            /**
             * Scans the Group, from top to bottom, for the first member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
             * assigns `x` and `y`, and returns the member.
             *
             * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getFirst(state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): any;

            /**
             * Scans the Group, from top to bottom, for the nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
             * assigns `x` and `y`, and returns the member.
             *
             * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param nth The nth matching Group member to search for.
             * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getFirstNth(nth: integer, state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): any;

            /**
             * Scans the Group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
             * assigns `x` and `y`, and returns the member.
             *
             * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getLast(state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): any;

            /**
             * Scans the Group for the last nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
             * assigns `x` and `y`, and returns the member.
             *
             * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param nth The nth matching Group member to search for.
             * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getLastNth(nth: integer, state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): any;

            /**
             * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,
             * assigns `x` and `y`, and returns the member.
             *
             * If no inactive member is found and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
             * The new Game Object will have its active state set to `true`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            get(x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): any;

            /**
             * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `true`,
             * assigns `x` and `y`, and returns the member.
             *
             * If no active member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getFirstAlive(createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): any;

            /**
             * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,
             * assigns `x` and `y`, and returns the member.
             *
             * If no inactive member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.
             * The new Game Object will have an active state set to `true`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getFirstDead(createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): any;

            /**
             * {@link Phaser.GameObjects.Components.Animation#play Plays} an animation for all members of this group.
             * @param key The string-based key of the animation to play.
             * @param startFrame Optionally start the animation playing from this frame index. Default 0.
             */
            playAnimation(key: string, startFrame?: string): Group;

            /**
             * Whether this group's size at its {@link Phaser.GameObjects.Group#maxSize maximum}.
             */
            isFull(): boolean;

            /**
             * Counts the number of active (or inactive) group members.
             * @param value Count active (true) or inactive (false) group members. Default true.
             */
            countActive(value?: boolean): integer;

            /**
             * Counts the number of in-use (active) group members.
             */
            getTotalUsed(): integer;

            /**
             * The difference of {@link Phaser.GameObjects.Group#maxSize} and the number of active group members.
             *
             * This represents the number of group members that could be created or reactivated before reaching the size limit.
             */
            getTotalFree(): integer;

            /**
             * Sets the depth of each group member.
             * @param value The amount to set the property to.
             * @param step This is added to the `value` amount, multiplied by the iteration counter.
             */
            setDepth(value: number, step: number): Group;

            /**
             * Deactivates a member of this group.
             * @param gameObject A member of this group.
             */
            kill(gameObject: GameObject): void;

            /**
             * Deactivates and hides a member of this group.
             * @param gameObject A member of this group.
             */
            killAndHide(gameObject: GameObject): void;

            /**
             * Toggles (flips) the visible state of each member of this group.
             */
            toggleVisible(): Group;

            /**
             * Empties this group and removes it from the Scene.
             *
             * Does not call {@link Phaser.GameObjects.Group#removeCallback}.
             * @param destroyChildren Also {@link Phaser.GameObjects.GameObject#destroy} each group member. Default false.
             */
            destroy(destroyChildren?: boolean): void;
        }

        /**
         * An Image Game Object.
         *
         * An Image is a light-weight Game Object useful for the display of static images in your game,
         * such as logos, backgrounds, scenery or other non-animated elements. Images can have input
         * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an
         * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.
         */
        class Image extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.ScaleMode,
                Components.ScrollFactor,
                Components.Size,
                Components.TextureCrop,
                Components.Tint,
                Components.Transform,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Scene, x: number, y: number, texture: string, frame?: string | integer);

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): this;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): this;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): this;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): this;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): this;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Textures.Frame): this;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * A boolean flag indicating if this Game Object is being cropped or not.
             * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
             * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
             */
            isCropped: boolean;

            /**
             * Applies a crop to a texture based Game Object, such as a Sprite or Image.
             *
             * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
             *
             * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
             * changes what is shown when rendered.
             *
             * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
             *
             * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
             * half of it, you could call `setCrop(0, 0, 400, 600)`.
             *
             * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
             * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
             *
             * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
             *
             * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
             *
             * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
             * the renderer to skip several internal calculations.
             * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
             * @param y The y coordinate to start the crop from.
             * @param width The width of the crop rectangle in pixels.
             * @param height The height of the crop rectangle in pixels.
             */
            setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): this;

            /**
             * Sets the frame this Game Object will use to render with.
             *
             * The Frame has to belong to the current Texture being used.
             *
             * It can be either a string or an index.
             *
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

            /**
             * Fill or additive?
             */
            tintFill: boolean;

            /**
             * Clears all tint values associated with this Game Object.
             *
             * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
             * which results in no visible change to the texture.
             */
            clearTint(): this;

            /**
             * Sets an additive tint on this Game Object.
             *
             * The tint works by taking the pixel color values from the Game Objects texture, and then
             * multiplying it by the color value of the tint. You can provide either one color value,
             * in which case the whole Game Object will be tinted in that color. Or you can provide a color
             * per corner. The colors are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * Sets a fill-based tint on this Game Object.
             *
             * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
             * with those in the tint. You can use this for effects such as making a player flash 'white'
             * if hit by something. You can provide either one color value, in which case the whole
             * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
             * are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * Does this Game Object have a tint applied to it or not?
             */
            readonly isTinted: boolean;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * A 2D point light.
         *
         * These are typically created by a {@link Phaser.GameObjects.LightsManager}, available from within a scene via `this.lights`.
         *
         * Any Game Objects using the Light2D pipeline will then be affected by these Lights.
         *
         * They can also simply be used to represent a point light for your own purposes.
         */
        class Light {
            /**
             *
             * @param x The horizontal position of the light.
             * @param y The vertical position of the light.
             * @param radius The radius of the light.
             * @param r The red color of the light. A value between 0 and 1.
             * @param g The green color of the light. A value between 0 and 1.
             * @param b The blue color of the light. A value between 0 and 1.
             * @param intensity The intensity of the light.
             */
            constructor(x: number, y: number, radius: number, r: number, g: number, b: number, intensity: number);

            /**
             * The horizontal position of the light.
             */
            x: number;

            /**
             * The vertical position of the light.
             */
            y: number;

            /**
             * The radius of the light.
             */
            radius: number;

            /**
             * The red color of the light. A value between 0 and 1.
             */
            r: number;

            /**
             * The green color of the light. A value between 0 and 1.
             */
            g: number;

            /**
             * The blue color of the light. A value between 0 and 1.
             */
            b: number;

            /**
             * The intensity of the light.
             */
            intensity: number;

            /**
             * The horizontal scroll factor of the light.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of the light.
             */
            scrollFactorY: number;

            /**
             * Set the properties of the light.
             *
             * Sets both horizontal and vertical scroll factor to 1. Use {@link Phaser.GameObjects.Light#setScrollFactor} to set
             * the scroll factor.
             * @param x The horizontal position of the light.
             * @param y The vertical position of the light.
             * @param radius The radius of the light.
             * @param r The red color. A value between 0 and 1.
             * @param g The green color. A value between 0 and 1.
             * @param b The blue color. A value between 0 and 1.
             * @param intensity The intensity of the light.
             */
            set(x: number, y: number, radius: number, r: number, g: number, b: number, intensity: number): Light;

            /**
             * Set the scroll factor of the light.
             * @param x The horizontal scroll factor of the light.
             * @param y The vertical scroll factor of the light.
             */
            setScrollFactor(x: number, y: number): Light;

            /**
             * Set the color of the light from a single integer RGB value.
             * @param rgb The integer RGB color of the light.
             */
            setColor(rgb: number): Light;

            /**
             * Set the intensity of the light.
             * @param intensity The intensity of the light.
             */
            setIntensity(intensity: number): Light;

            /**
             * Set the position of the light.
             * @param x The horizontal position of the light.
             * @param y The vertical position of the light.
             */
            setPosition(x: number, y: number): Light;

            /**
             * Set the radius of the light.
             * @param radius The radius of the light.
             */
            setRadius(radius: number): Light;
        }

        /**
         * Manages Lights for a Scene.
         *
         * Affects the rendering of Game Objects using the `Light2D` pipeline.
         */
        class LightsManager {
            /**
             * The pool of Lights.
             *
             * Used to recycle removed Lights for a more efficient use of memory.
             */
            lightPool: Light[];

            /**
             * The Lights in the Scene.
             */
            lights: Light[];

            /**
             * Lights that have been culled from a Camera's viewport.
             *
             * Lights in this list will not be rendered.
             */
            culledLights: Light[];

            /**
             * The ambient color.
             */
            ambientColor: object;

            /**
             * Whether the Lights Manager is enabled.
             */
            active: boolean;

            /**
             * The maximum number of lights that a single Camera and the lights shader can process.
             * Change this via the `maxLights` property in your game config, as it cannot be changed at runtime.
             */
            readonly maxLights: integer;

            /**
             * Enable the Lights Manager.
             */
            enable(): LightsManager;

            /**
             * Disable the Lights Manager.
             */
            disable(): LightsManager;

            /**
             * Cull any Lights that aren't visible to the given Camera.
             *
             * Culling Lights improves performance by ensuring that only Lights within a Camera's viewport are rendered.
             * @param camera The Camera to cull Lights for.
             */
            cull(camera: Cameras.Scene2D.Camera): Light[];

            /**
             * Iterate over each Light with a callback.
             * @param callback The callback that is called with each Light.
             */
            forEachLight(callback: LightForEach): LightsManager;

            /**
             * Set the ambient light color.
             * @param rgb The integer RGB color of the ambient light.
             */
            setAmbientColor(rgb: number): LightsManager;

            /**
             * Returns the maximum number of Lights allowed to appear at once.
             */
            getMaxVisibleLights(): integer;

            /**
             * Get the number of Lights managed by this Lights Manager.
             */
            getLightCount(): integer;

            /**
             * Add a Light.
             * @param x The horizontal position of the Light. Default 0.
             * @param y The vertical position of the Light. Default 0.
             * @param radius The radius of the Light. Default 100.
             * @param rgb The integer RGB color of the light. Default 0xffffff.
             * @param intensity The intensity of the Light. Default 1.
             */
            addLight(x?: number, y?: number, radius?: number, rgb?: number, intensity?: number): Light;

            /**
             * Remove a Light.
             * @param light The Light to remove.
             */
            removeLight(light: Light): LightsManager;

            /**
             * Shut down the Lights Manager.
             *
             * Recycles all active Lights into the Light pool, resets ambient light color and clears the lists of Lights and
             * culled Lights.
             */
            shutdown(): void;

            /**
             * Destroy the Lights Manager.
             *
             * Cleans up all references by calling {@link Phaser.GameObjects.LightsManager#shutdown}.
             */
            destroy(): void;
        }

        /**
         * A Scene plugin that provides a {@link Phaser.GameObjects.LightsManager} for the Light2D pipeline.
         *
         * Available from within a Scene via `this.lights`.
         *
         * Add Lights using the {@link Phaser.GameObjects.LightsManager#addLight} method:
         *
         * ```javascript
         * // Enable the Lights Manager because it is disabled by default
         * this.lights.enable();
         *
         * // Create a Light at [400, 300] with a radius of 200
         * this.lights.addLight(400, 300, 200);
         * ```
         *
         * For Game Objects to be affected by the Lights when rendered, you will need to set them to use the `Light2D` pipeline like so:
         *
         * ```javascript
         * sprite.setPipeline('Light2D');
         * ```
         */
        class LightsPlugin extends LightsManager {
            /**
             *
             * @param scene The Scene that this Lights Plugin belongs to.
             */
            constructor(scene: Scene);

            /**
             * A reference to the Scene that this Lights Plugin belongs to.
             */
            scene: Scene;

            /**
             * A reference to the Scene's systems.
             */
            systems: Scenes.Systems;

            /**
             * Boot the Lights Plugin.
             */
            boot(): void;

            /**
             * Destroy the Lights Plugin.
             *
             * Cleans up all references.
             */
            destroy(): void;
        }

        /**
         * A Mesh Game Object.
         */
        class Mesh extends GameObject
            implements
                Components.BlendMode,
                Components.Depth,
                Components.GetBounds,
                Components.Mask,
                Components.Pipeline,
                Components.ScaleMode,
                Components.Size,
                Components.Texture,
                Components.Transform,
                Components.Visible,
                Components.ScrollFactor {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param vertices An array containing the vertices data for this Mesh.
             * @param uv An array containing the uv data for this Mesh.
             * @param colors An array containing the color data for this Mesh.
             * @param alphas An array containing the alpha data for this Mesh.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Scene, x: number, y: number, vertices: number[], uv: number[], colors: number[], alphas: number[], texture: string, frame?: string | integer);

            /**
             * An array containing the vertices data for this Mesh.
             */
            vertices: Float32Array;

            /**
             * An array containing the uv data for this Mesh.
             */
            uv: Float32Array;

            /**
             * An array containing the color data for this Mesh.
             */
            colors: Uint32Array;

            /**
             * An array containing the alpha data for this Mesh.
             */
            alphas: Float32Array;

            /**
             * Fill or additive mode used when blending the color values?
             */
            tintFill: boolean;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Textures.Frame): this;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): this;

            /**
             * Sets the frame this Game Object will use to render with.
             *
             * The Frame has to belong to the current Texture being used.
             *
             * It can be either a string or an index.
             *
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;
        }

        namespace Particles {
            /**
             * A Particle Emitter property.
             *
             * Facilitates changing Particle properties as they are emitted and throughout their lifetime.
             */
            class EmitterOp {
                /**
                 *
                 * @param config Settings for the Particle Emitter that owns this property.
                 * @param key The name of the property.
                 * @param defaultValue The default value of the property.
                 * @param emitOnly Whether the property can only be modified when a Particle is emitted. Default false.
                 */
                constructor(config: ParticleEmitterConfig, key: string, defaultValue: number, emitOnly?: boolean);

                /**
                 * The name of this property.
                 */
                propertyKey: string;

                /**
                 * The value of this property.
                 */
                propertyValue: number;

                /**
                 * The default value of this property.
                 */
                defaultValue: number;

                /**
                 * The number of steps for stepped easing between {@link Phaser.GameObjects.Particles.EmitterOp#start} and
                 * {@link Phaser.GameObjects.Particles.EmitterOp#end} values, per emit.
                 */
                steps: number;

                /**
                 * The step counter for stepped easing, per emit.
                 */
                counter: number;

                /**
                 * The start value for this property to ease between.
                 */
                start: number;

                /**
                 * The end value for this property to ease between.
                 */
                end: number;

                /**
                 * The easing function to use for updating this property.
                 */
                ease: CallbackFn;

                /**
                 * Whether this property can only be modified when a Particle is emitted.
                 *
                 * Set to `true` to allow only {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} callbacks to be set and
                 * affect this property.
                 *
                 * Set to `false` to allow both {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and
                 * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks to be set and affect this property.
                 */
                emitOnly: boolean;

                /**
                 * The callback to run for Particles when they are emitted from the Particle Emitter.
                 */
                onEmit: EmitterOpOnEmitCallback;

                /**
                 * The callback to run for Particles when they are updated.
                 */
                onUpdate: EmitterOpOnUpdateCallback;

                /**
                 * Load the property from a Particle Emitter configuration object.
                 *
                 * Optionally accepts a new property key to use, replacing the current one.
                 * @param config Settings for the Particle Emitter that owns this property.
                 * @param newKey The new key to use for this property, if any.
                 */
                loadConfig(config?: ParticleEmitterConfig, newKey?: string): void;

                /**
                 * Build a JSON representation of this Particle Emitter property.
                 */
                toJSON(): object;

                /**
                 * Change the current value of the property and update its callback methods.
                 * @param value The value of the property.
                 */
                onChange(value: number): EmitterOp;

                /**
                 * Update the {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and
                 * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks based on the interface of the current
                 * {@link Phaser.GameObjects.Particles.EmitterOp#propertyValue}.
                 */
                setMethods(): EmitterOp;

                /**
                 * Check whether an object has the given property.
                 * @param object The object to check.
                 * @param key The key of the property to look for in the object.
                 */
                has(object: object, key: string): boolean;

                /**
                 * Check whether an object has both of the given properties.
                 * @param object The object to check.
                 * @param key1 The key of the first property to check the object for.
                 * @param key2 The key of the second property to check the object for.
                 */
                hasBoth(object: object, key1: string, key2: string): boolean;

                /**
                 * Check whether an object has at least one of the given properties.
                 * @param object The object to check.
                 * @param key1 The key of the first property to check the object for.
                 * @param key2 The key of the second property to check the object for.
                 */
                hasEither(object: object, key1: string, key2: string): boolean;

                /**
                 * The returned value sets what the property will be at the START of the particles life, on emit.
                 * @param particle The particle.
                 * @param key The name of the property.
                 * @param value The current value of the property.
                 */
                defaultEmit(particle: Particle, key: string, value?: number): number;

                /**
                 * The returned value updates the property for the duration of the particles life.
                 * @param particle The particle.
                 * @param key The name of the property.
                 * @param t The T value (between 0 and 1)
                 * @param value The current value of the property.
                 */
                defaultUpdate(particle: Particle, key: string, t: number, value: number): number;

                /**
                 * An `onEmit` callback that returns the current value of the property.
                 */
                staticValueEmit(): number;

                /**
                 * An `onUpdate` callback that returns the current value of the property.
                 */
                staticValueUpdate(): number;

                /**
                 * An `onEmit` callback that returns a random value from the current value array.
                 */
                randomStaticValueEmit(): number;

                /**
                 * An `onEmit` callback that returns a value between the {@link Phaser.GameObjects.Particles.EmitterOp#start} and
                 * {@link Phaser.GameObjects.Particles.EmitterOp#end} range.
                 * @param particle The particle.
                 * @param key The key of the property.
                 */
                randomRangedValueEmit(particle: Particle, key: string): number;

                /**
                 * An `onEmit` callback that returns a stepped value between the
                 * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}
                 * range.
                 */
                steppedEmit(): number;

                /**
                 * An `onEmit` callback that returns an eased value between the
                 * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}
                 * range.
                 * @param particle The particle.
                 * @param key The name of the property.
                 */
                easedValueEmit(particle: Particle, key: string): number;

                /**
                 * An `onUpdate` callback that returns an eased value between the
                 * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}
                 * range.
                 * @param particle The particle.
                 * @param key The name of the property.
                 * @param t The T value (between 0 and 1)
                 */
                easeValueUpdate(particle: Particle, key: string, t: number): number;
            }

            /**
             * The GravityWell action applies a force on the particle to draw it towards, or repel it from, a single point.
             *
             * The force applied is inversely proportional to the square of the distance from the particle to the point, in accordance with Newton's law of gravity.
             *
             * This simulates the effect of gravity over large distances (as between planets, for example).
             */
            class GravityWell {
                /**
                 *
                 * @param x The x coordinate of the Gravity Well, in world space. Default 0.
                 * @param y The y coordinate of the Gravity Well, in world space. Default 0.
                 * @param power The strength of the gravity force - larger numbers produce a stronger force. Default 0.
                 * @param epsilon The minimum distance for which the gravity force is calculated. Default 100.
                 * @param gravity The gravitational force of this Gravity Well. Default 50.
                 */
                constructor(x?: number | GravityWellConfig, y?: number, power?: number, epsilon?: number, gravity?: number);

                /**
                 * The x coordinate of the Gravity Well, in world space.
                 */
                x: number;

                /**
                 * The y coordinate of the Gravity Well, in world space.
                 */
                y: number;

                /**
                 * The active state of the Gravity Well. An inactive Gravity Well will not influence any particles.
                 */
                active: boolean;

                /**
                 * The strength of the gravity force - larger numbers produce a stronger force.
                 */
                power: number;

                /**
                 * The minimum distance for which the gravity force is calculated.
                 */
                epsilon: number;

                /**
                 * Takes a Particle and updates it based on the properties of this Gravity Well.
                 * @param particle The Particle to update.
                 * @param delta The delta time in ms.
                 * @param step The delta value divided by 1000.
                 */
                update(particle: Particle, delta: number, step: number): void;
            }

            /**
             * A Particle is a simple Game Object controlled by a Particle Emitter and Manager, and rendered by the Manager.
             * It uses its own lightweight physics system, and can interact only with its Emitter's bounds and zones.
             */
            class Particle {
                /**
                 *
                 * @param emitter The Emitter to which this Particle belongs.
                 */
                constructor(emitter: ParticleEmitter);

                /**
                 * The Emitter to which this Particle belongs.
                 *
                 * A Particle can only belong to a single Emitter and is created, updated and destroyed via it.
                 */
                emitter: ParticleEmitter;

                /**
                 * The texture frame used to render this Particle.
                 */
                frame: Textures.Frame;

                /**
                 * The x coordinate of this Particle.
                 */
                x: number;

                /**
                 * The y coordinate of this Particle.
                 */
                y: number;

                /**
                 * The x velocity of this Particle.
                 */
                velocityX: number;

                /**
                 * The y velocity of this Particle.
                 */
                velocityY: number;

                /**
                 * The x acceleration of this Particle.
                 */
                accelerationX: number;

                /**
                 * The y acceleration of this Particle.
                 */
                accelerationY: number;

                /**
                 * The maximum horizontal velocity this Particle can travel at.
                 */
                maxVelocityX: number;

                /**
                 * The maximum vertical velocity this Particle can travel at.
                 */
                maxVelocityY: number;

                /**
                 * The bounciness, or restitution, of this Particle.
                 */
                bounce: number;

                /**
                 * The horizontal scale of this Particle.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Particle.
                 */
                scaleY: number;

                /**
                 * The alpha value of this Particle.
                 */
                alpha: number;

                /**
                 * The angle of this Particle in degrees.
                 */
                angle: number;

                /**
                 * The angle of this Particle in radians.
                 */
                rotation: number;

                /**
                 * The tint applied to this Particle.
                 */
                tint: integer;

                /**
                 * The lifespan of this Particle in ms.
                 */
                life: number;

                /**
                 * The current life of this Particle in ms.
                 */
                lifeCurrent: number;

                /**
                 * The delay applied to this Particle upon emission, in ms.
                 */
                delayCurrent: number;

                /**
                 * The normalized lifespan T value, where 0 is the start and 1 is the end.
                 */
                lifeT: number;

                /**
                 * The data used by the ease equation.
                 */
                data: object;

                /**
                 * Checks to see if this Particle is alive and updating.
                 */
                isAlive(): boolean;

                /**
                 * Resets the position of this particle back to zero.
                 */
                resetPosition(): void;

                /**
                 * Starts this Particle from the given coordinates.
                 * @param x The x coordinate to launch this Particle from.
                 * @param y The y coordinate to launch this Particle from.
                 */
                fire(x: number, y: number): void;

                /**
                 * An internal method that calculates the velocity of the Particle.
                 * @param emitter The Emitter that is updating this Particle.
                 * @param delta The delta time in ms.
                 * @param step The delta value divided by 1000.
                 * @param processors Particle processors (gravity wells).
                 */
                computeVelocity(emitter: ParticleEmitter, delta: number, step: number, processors: any[]): void;

                /**
                 * Checks if this Particle is still within the bounds defined by the given Emitter.
                 *
                 * If not, and depending on the Emitter collision flags, the Particle may either stop or rebound.
                 * @param emitter The Emitter to check the bounds against.
                 */
                checkBounds(emitter: ParticleEmitter): void;

                /**
                 * The main update method for this Particle.
                 *
                 * Updates its life values, computes the velocity and repositions the Particle.
                 * @param delta The delta time in ms.
                 * @param step The delta value divided by 1000.
                 * @param processors An optional array of update processors.
                 */
                update(delta: number, step: number, processors: any[]): boolean;
            }

            /**
             * A particle emitter represents a single particle stream.
             * It controls a pool of {@link Phaser.GameObjects.Particles.Particle Particles} and is controlled
             * by a {@link Phaser.GameObjects.Particles.ParticleEmitterManager Particle Emitter Manager}.
             */
            class ParticleEmitter
                implements Components.BlendMode, Components.Mask, Components.ScrollFactor, Components.Visible {
                /**
                 *
                 * @param manager The Emitter Manager this Emitter belongs to.
                 * @param config Settings for this emitter.
                 */
                constructor(manager: ParticleEmitterManager, config: ParticleEmitterConfig);

                /**
                 * The Emitter Manager this Emitter belongs to.
                 */
                manager: ParticleEmitterManager;

                /**
                 * The texture assigned to particles.
                 */
                texture: Textures.Texture;

                /**
                 * The texture frames assigned to particles.
                 */
                frames: Textures.Frame[];

                /**
                 * The default texture frame assigned to particles.
                 */
                defaultFrame: Textures.Frame;

                /**
                 * Names of simple configuration properties.
                 */
                configFastMap: object;

                /**
                 * Names of complex configuration properties.
                 */
                configOpMap: object;

                /**
                 * The name of this Particle Emitter.
                 *
                 * Empty by default and never populated by Phaser, this is left for developers to use.
                 */
                name: string;

                /**
                 * The Particle Class which will be emitted by this Emitter.
                 */
                particleClass: Particle;

                /**
                 * The x-coordinate of the particle origin (where particles will be emitted).
                 */
                x: EmitterOp;

                /**
                 * The y-coordinate of the particle origin (where particles will be emitted).
                 */
                y: EmitterOp;

                /**
                 * A radial emitter will emit particles in all directions between angle min and max,
                 * using {@link Phaser.GameObjects.Particles.ParticleEmitter#speed} as the value. If set to false then this acts as a point Emitter.
                 * A point emitter will emit particles only in the direction derived from the speedX and speedY values.
                 */
                radial: boolean;

                /**
                 * Horizontal acceleration applied to emitted particles, in pixels per second squared.
                 */
                gravityX: number;

                /**
                 * Vertical acceleration applied to emitted particles, in pixels per second squared.
                 */
                gravityY: number;

                /**
                 * Whether accelerationX and accelerationY are non-zero. Set automatically during configuration.
                 */
                acceleration: boolean;

                /**
                 * Horizontal acceleration applied to emitted particles, in pixels per second squared.
                 */
                accelerationX: EmitterOp;

                /**
                 * Vertical acceleration applied to emitted particles, in pixels per second squared.
                 */
                accelerationY: EmitterOp;

                /**
                 * The maximum horizontal velocity of emitted particles, in pixels per second squared.
                 */
                maxVelocityX: EmitterOp;

                /**
                 * The maximum vertical velocity of emitted particles, in pixels per second squared.
                 */
                maxVelocityY: EmitterOp;

                /**
                 * The initial horizontal speed of emitted particles, in pixels per second.
                 */
                speedX: EmitterOp;

                /**
                 * The initial vertical speed of emitted particles, in pixels per second.
                 */
                speedY: EmitterOp;

                /**
                 * Whether moveToX and moveToY are nonzero. Set automatically during configuration.
                 */
                moveTo: boolean;

                /**
                 * The x-coordinate emitted particles move toward, when {@link Phaser.GameObjects.Particles.ParticleEmitter#moveTo} is true.
                 */
                moveToX: EmitterOp;

                /**
                 * The y-coordinate emitted particles move toward, when {@link Phaser.GameObjects.Particles.ParticleEmitter#moveTo} is true.
                 */
                moveToY: EmitterOp;

                /**
                 * Whether particles will rebound when they meet the emitter bounds.
                 */
                bounce: EmitterOp;

                /**
                 * The horizontal scale of emitted particles.
                 */
                scaleX: EmitterOp;

                /**
                 * The vertical scale of emitted particles.
                 */
                scaleY: EmitterOp;

                /**
                 * Color tint applied to emitted particles. Any alpha component (0xAA000000) is ignored.
                 */
                tint: EmitterOp;

                /**
                 * The alpha (transparency) of emitted particles.
                 */
                alpha: EmitterOp;

                /**
                 * The lifespan of emitted particles, in ms.
                 */
                lifespan: EmitterOp;

                /**
                 * The angle of the initial velocity of emitted particles, in degrees.
                 */
                angle: EmitterOp;

                /**
                 * The rotation of emitted particles, in degrees.
                 */
                rotate: EmitterOp;

                /**
                 * A function to call when a particle is emitted.
                 */
                emitCallback: ParticleEmitterCallback;

                /**
                 * The calling context for {@link Phaser.GameObjects.Particles.ParticleEmitter#emitCallback}.
                 */
                emitCallbackScope: any;

                /**
                 * A function to call when a particle dies.
                 */
                deathCallback: ParticleDeathCallback;

                /**
                 * The calling context for {@link Phaser.GameObjects.Particles.ParticleEmitter#deathCallback}.
                 */
                deathCallbackScope: any;

                /**
                 * Set to hard limit the amount of particle objects this emitter is allowed to create.
                 * 0 means unlimited.
                 */
                maxParticles: integer;

                /**
                 * How many particles are emitted each time particles are emitted (one explosion or one flow cycle).
                 */
                quantity: EmitterOp;

                /**
                 * How many ms to wait after emission before the particles start updating.
                 */
                delay: EmitterOp;

                /**
                 * For a flow emitter, the time interval (>= 0) between particle flow cycles in ms.
                 * A value of 0 means there is one particle flow cycle for each logic update (the maximum flow frequency). This is the default setting.
                 * For an exploding emitter, this value will be -1.
                 * Calling {@link Phaser.GameObjects.Particles.ParticleEmitter#flow} also puts the emitter in flow mode (frequency >= 0).
                 * Calling {@link Phaser.GameObjects.Particles.ParticleEmitter#explode} also puts the emitter in explode mode (frequency = -1).
                 */
                frequency: number;

                /**
                 * Controls if the emitter is currently emitting a particle flow (when frequency >= 0).
                 * Already alive particles will continue to update until they expire.
                 * Controlled by {@link Phaser.GameObjects.Particles.ParticleEmitter#start} and {@link Phaser.GameObjects.Particles.ParticleEmitter#stop}.
                 */
                on: boolean;

                /**
                 * Newly emitted particles are added to the top of the particle list, i.e. rendered above those already alive.
                 * Set to false to send them to the back.
                 */
                particleBringToTop: boolean;

                /**
                 * The time rate applied to active particles, affecting lifespan, movement, and tweens. Values larger than 1 are faster than normal.
                 */
                timeScale: number;

                /**
                 * An object describing a shape to emit particles from.
                 */
                emitZone: Zones.EdgeZone | Zones.RandomZone;

                /**
                 * An object describing a shape that deactivates particles when they interact with it.
                 */
                deathZone: Zones.DeathZone;

                /**
                 * A rectangular boundary constraining particle movement.
                 */
                bounds: Geom.Rectangle;

                /**
                 * Whether particles interact with the left edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
                 */
                collideLeft: boolean;

                /**
                 * Whether particles interact with the right edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
                 */
                collideRight: boolean;

                /**
                 * Whether particles interact with the top edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
                 */
                collideTop: boolean;

                /**
                 * Whether particles interact with the bottom edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.
                 */
                collideBottom: boolean;

                /**
                 * Whether this emitter updates itself and its particles.
                 *
                 * Controlled by {@link Phaser.GameObjects.Particles.ParticleEmitter#pause}
                 * and {@link Phaser.GameObjects.Particles.ParticleEmitter#resume}.
                 */
                active: boolean;

                /**
                 * Set this to false to hide any active particles.
                 */
                visible: boolean;

                /**
                 * The blend mode of this emitter's particles.
                 */
                blendMode: integer;

                /**
                 * A Game Object whose position is used as the particle origin.
                 */
                follow: GameObject;

                /**
                 * The offset of the particle origin from the {@link Phaser.GameObjects.Particles.ParticleEmitter#follow} target.
                 */
                followOffset: Math.Vector2;

                /**
                 * Whether the emitter's {@link Phaser.GameObjects.Particles.ParticleEmitter#visible} state will track
                 * the {@link Phaser.GameObjects.Particles.ParticleEmitter#follow} target's visibility state.
                 */
                trackVisible: boolean;

                /**
                 * The current texture frame, as an index of {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.
                 */
                currentFrame: integer;

                /**
                 * Whether texture {@link Phaser.GameObjects.Particles.ParticleEmitter#frames} are selected at random.
                 */
                randomFrame: boolean;

                /**
                 * The number of consecutive particles that receive a single texture frame (per frame cycle).
                 */
                frameQuantity: integer;

                /**
                 * Merges configuration settings into the emitter's current settings.
                 * @param config Settings for this emitter.
                 */
                fromJSON(config: ParticleEmitterConfig): ParticleEmitter;

                /**
                 * Creates a description of this emitter suitable for JSON serialization.
                 * @param output An object to copy output into.
                 */
                toJSON(output?: object): object;

                /**
                 * Continuously moves the particle origin to follow a Game Object's position.
                 * @param target The Game Object to follow.
                 * @param offsetX Horizontal offset of the particle origin from the Game Object. Default 0.
                 * @param offsetY Vertical offset of the particle origin from the Game Object. Default 0.
                 * @param trackVisible Whether the emitter's visible state will track the target's visible state. Default false.
                 */
                startFollow(target: GameObject, offsetX?: number, offsetY?: number, trackVisible?: boolean): ParticleEmitter;

                /**
                 * Stops following a Game Object.
                 */
                stopFollow(): ParticleEmitter;

                /**
                 * Chooses a texture frame from {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.
                 */
                getFrame(): Textures.Frame;

                /**
                 * Sets a pattern for assigning texture frames to emitted particles.
                 * @param frames One or more texture frames, or a configuration object.
                 * @param pickRandom Whether frames should be assigned at random from `frames`. Default true.
                 * @param quantity The number of consecutive particles that will receive each frame. Default 1.
                 */
                setFrame(frames: any[] | string | integer | ParticleEmitterFrameConfig, pickRandom?: boolean, quantity?: integer): ParticleEmitter;

                /**
                 * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle movement on or off.
                 * @param value Radial mode (true) or point mode (true). Default true.
                 */
                setRadial(value?: boolean): ParticleEmitter;

                /**
                 * Sets the position of the emitter's particle origin.
                 * New particles will be emitted here.
                 * @param x The x-coordinate of the particle origin.
                 * @param y The y-coordinate of the particle origin.
                 */
                setPosition(x: number | number[] | EmitterOpOnEmitCallback | object, y: number | number[] | EmitterOpOnEmitCallback | object): ParticleEmitter;

                /**
                 * Sets or modifies a rectangular boundary constraining the particles.
                 *
                 * To remove the boundary, set {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds} to null.
                 * @param x The x-coordinate of the left edge of the boundary, or an object representing a rectangle.
                 * @param y The y-coordinate of the top edge of the boundary.
                 * @param width The width of the boundary.
                 * @param height The height of the boundary.
                 */
                setBounds(x: number | ParticleEmitterBounds | ParticleEmitterBoundsAlt, y: number, width: number, height: number): ParticleEmitter;

                /**
                 * Sets the initial horizontal speed of emitted particles.
                 * Changes the emitter to point mode.
                 * @param value The speed, in pixels per second.
                 */
                setSpeedX(value: number | number[] | EmitterOpOnEmitCallback | object): ParticleEmitter;

                /**
                 * Sets the initial vertical speed of emitted particles.
                 * Changes the emitter to point mode.
                 * @param value The speed, in pixels per second.
                 */
                setSpeedY(value: number | number[] | EmitterOpOnEmitCallback | object): ParticleEmitter;

                /**
                 * Sets the initial radial speed of emitted particles.
                 * Changes the emitter to radial mode.
                 * @param value The speed, in pixels per second.
                 */
                setSpeed(value: number | number[] | EmitterOpOnEmitCallback | object): ParticleEmitter;

                /**
                 * Sets the horizontal scale of emitted particles.
                 * @param value The scale, relative to 1.
                 */
                setScaleX(value: number | number[] | EmitterOpOnUpdateCallback | object): ParticleEmitter;

                /**
                 * Sets the vertical scale of emitted particles.
                 * @param value The scale, relative to 1.
                 */
                setScaleY(value: number | number[] | EmitterOpOnUpdateCallback | object): ParticleEmitter;

                /**
                 * Sets the scale of emitted particles.
                 * @param value The scale, relative to 1.
                 */
                setScale(value: number | number[] | EmitterOpOnUpdateCallback | object): ParticleEmitter;

                /**
                 * Sets the horizontal gravity applied to emitted particles.
                 * @param value Acceleration due to gravity, in pixels per second squared.
                 */
                setGravityX(value: number): ParticleEmitter;

                /**
                 * Sets the vertical gravity applied to emitted particles.
                 * @param value Acceleration due to gravity, in pixels per second squared.
                 */
                setGravityY(value: number): ParticleEmitter;

                /**
                 * Sets the gravity applied to emitted particles.
                 * @param x Horizontal acceleration due to gravity, in pixels per second squared.
                 * @param y Vertical acceleration due to gravity, in pixels per second squared.
                 */
                setGravity(x: number, y: number): ParticleEmitter;

                /**
                 * Sets the opacity of emitted particles.
                 * @param value A value between 0 (transparent) and 1 (opaque).
                 */
                setAlpha(value: number | number[] | EmitterOpOnUpdateCallback | object): ParticleEmitter;

                /**
                 * Sets the angle of a {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle stream.
                 * @param value The angle of the initial velocity of emitted particles.
                 */
                setEmitterAngle(value: number | number[] | EmitterOpOnEmitCallback | object): ParticleEmitter;

                /**
                 * Sets the angle of a {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle stream.
                 * @param value The angle of the initial velocity of emitted particles.
                 */
                setAngle(value: number | number[] | EmitterOpOnEmitCallback | object): ParticleEmitter;

                /**
                 * Sets the lifespan of newly emitted particles.
                 * @param value The particle lifespan, in ms.
                 */
                setLifespan(value: number | number[] | EmitterOpOnEmitCallback | object): ParticleEmitter;

                /**
                 * Sets the number of particles released at each flow cycle or explosion.
                 * @param quantity The number of particles to release at each flow cycle or explosion.
                 */
                setQuantity(quantity: number | number[] | EmitterOpOnEmitCallback | object): ParticleEmitter;

                /**
                 * Sets the emitter's {@link Phaser.GameObjects.Particles.ParticleEmitter#frequency}
                 * and {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.
                 * @param frequency The time interval (>= 0) of each flow cycle, in ms; or -1 to put the emitter in explosion mode.
                 * @param quantity The number of particles to release at each flow cycle or explosion.
                 */
                setFrequency(frequency: number, quantity?: number | number[] | EmitterOpOnEmitCallback | object): ParticleEmitter;

                /**
                 * Sets or removes the {@link Phaser.GameObjects.Particles.ParticleEmitter#emitZone}.
                 *
                 * An {@link ParticleEmitterEdgeZoneConfig EdgeZone} places particles on its edges.
                 * Its {@link EdgeZoneSource source} can be a Curve, Path, Circle, Ellipse, Line, Polygon, Rectangle, or Triangle,
                 * or any object with a suitable {@link EdgeZoneSourceCallback getPoints} method.
                 *
                 * A {@link ParticleEmitterRandomZoneConfig RandomZone} places randomly within its interior.
                 * Its {@link RandomZoneSource source} can be a Circle, Ellipse, Line, Polygon, Rectangle, or Triangle,
                 * or any object with a suitable {@link RandomZoneSourceCallback getRandomPoint} method.
                 * @param zoneConfig An object describing the zone, or `undefined` to remove any current emit zone.
                 */
                setEmitZone(zoneConfig?: ParticleEmitterEdgeZoneConfig | ParticleEmitterRandomZoneConfig): ParticleEmitter;

                /**
                 * Sets or removes the {@link Phaser.GameObjects.Particles.ParticleEmitter#deathZone}.
                 * @param zoneConfig An object describing the zone, or `undefined` to remove any current death zone.
                 */
                setDeathZone(zoneConfig?: ParticleEmitterDeathZoneConfig): ParticleEmitter;

                /**
                 * Creates inactive particles and adds them to this emitter's pool.
                 * @param particleCount The number of particles to create.
                 */
                reserve(particleCount: integer): ParticleEmitter;

                /**
                 * Gets the number of active (in-use) particles in this emitter.
                 */
                getAliveParticleCount(): integer;

                /**
                 * Gets the number of inactive (available) particles in this emitter.
                 */
                getDeadParticleCount(): integer;

                /**
                 * Gets the total number of particles in this emitter.
                 */
                getParticleCount(): integer;

                /**
                 * Whether this emitter is at its limit (if set).
                 */
                atLimit(): boolean;

                /**
                 * Sets a function to call for each newly emitted particle.
                 * @param callback The function.
                 * @param context The calling context.
                 */
                onParticleEmit(callback: ParticleEmitterCallback, context?: any): ParticleEmitter;

                /**
                 * Sets a function to call for each particle death.
                 * @param callback The function.
                 * @param context The function's calling context.
                 */
                onParticleDeath(callback: ParticleDeathCallback, context?: any): ParticleEmitter;

                /**
                 * Deactivates every particle in this emitter.
                 */
                killAll(): ParticleEmitter;

                /**
                 * Calls a function for each active particle in this emitter.
                 * @param callback The function.
                 * @param context The function's calling context.
                 */
                forEachAlive(callback: ParticleEmitterCallback, context: any): ParticleEmitter;

                /**
                 * Calls a function for each inactive particle in this emitter.
                 * @param callback The function.
                 * @param context The function's calling context.
                 */
                forEachDead(callback: ParticleEmitterCallback, context: any): ParticleEmitter;

                /**
                 * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#on} the emitter and resets the flow counter.
                 *
                 * If this emitter is in flow mode (frequency >= 0; the default), the particle flow will start (or restart).
                 *
                 * If this emitter is in explode mode (frequency = -1), nothing will happen.
                 * Use {@link Phaser.GameObjects.Particles.ParticleEmitter#explode} or {@link Phaser.GameObjects.Particles.ParticleEmitter#flow} instead.
                 */
                start(): ParticleEmitter;

                /**
                 * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#on off} the emitter.
                 */
                stop(): ParticleEmitter;

                /**
                 * {@link Phaser.GameObjects.Particles.ParticleEmitter#active Deactivates} the emitter.
                 */
                pause(): ParticleEmitter;

                /**
                 * {@link Phaser.GameObjects.Particles.ParticleEmitter#active Activates} the emitter.
                 */
                resume(): ParticleEmitter;

                /**
                 * Sorts active particles with {@link Phaser.GameObjects.Particles.ParticleEmitter#depthSortCallback}.
                 */
                depthSort(): ParticleEmitter;

                /**
                 * Puts the emitter in flow mode (frequency >= 0) and starts (or restarts) a particle flow.
                 *
                 * To resume a flow at the current frequency and quantity, use {@link Phaser.GameObjects.Particles.ParticleEmitter#start} instead.
                 * @param frequency The time interval (>= 0) of each flow cycle, in ms.
                 * @param count The number of particles to emit at each flow cycle. Default 1.
                 */
                flow(frequency: number, count?: number | number[] | EmitterOpOnEmitCallback | object): ParticleEmitter;

                /**
                 * Puts the emitter in explode mode (frequency = -1), stopping any current particle flow, and emits several particles all at once.
                 * @param count The amount of Particles to emit.
                 * @param x The x coordinate to emit the Particles from.
                 * @param y The y coordinate to emit the Particles from.
                 */
                explode(count: integer, x: number, y: number): Particle;

                /**
                 * Emits particles at a given position (or the emitter's current position).
                 * @param x The x coordinate to emit the Particles from. Default this.x.
                 * @param y The y coordinate to emit the Particles from. Default this.x.
                 * @param count The number of Particles to emit. Default this.quantity.
                 */
                emitParticleAt(x?: number, y?: number, count?: integer): Particle;

                /**
                 * Emits particles at a given position (or the emitter's current position).
                 * @param count The number of Particles to emit. Default this.quantity.
                 * @param x The x coordinate to emit the Particles from. Default this.x.
                 * @param y The y coordinate to emit the Particles from. Default this.x.
                 */
                emitParticle(count?: integer, x?: number, y?: number): Particle;

                /**
                 * Updates this emitter and its particles.
                 * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                preUpdate(time: integer, delta: number): void;

                /**
                 * Calculates the difference of two particles, for sorting them by depth.
                 * @param a The first particle.
                 * @param b The second particle.
                 */
                depthSortCallback(a: object, b: object): integer;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | BlendModes): this;

                /**
                 * The Mask this Game Object is using during render.
                 */
                mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

                /**
                 * Sets the mask that this Game Object will use to render with.
                 *
                 * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
                 * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
                 *
                 * If a mask is already set on this Game Object it will be immediately replaced.
                 *
                 * Masks are positioned in global space and are not relative to the Game Object to which they
                 * are applied. The reason for this is that multiple Game Objects can all share the same mask.
                 *
                 * Masks have no impact on physics or input detection. They are purely a rendering component
                 * that allows you to limit what is visible during the render pass.
                 * @param mask The mask this Game Object will use when rendering.
                 */
                setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

                /**
                 * Clears the mask that this Game Object was using.
                 * @param destroyMask Destroy the mask before clearing it? Default false.
                 */
                clearMask(destroyMask?: boolean): this;

                /**
                 * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a renderable Game Object.
                 * A renderable Game Object is one that uses a texture to render with, such as an
                 * Image, Sprite, Render Texture or BitmapText.
                 *
                 * If you do not provide a renderable object, and this Game Object has a texture,
                 * it will use itself as the object. This means you can call this method to create
                 * a Bitmap Mask from any renderable Game Object.
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

                /**
                 * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a Graphics Game Object.
                 *
                 * If you do not provide a graphics object, and this Game Object is an instance
                 * of a Graphics object, then it will use itself to create the mask.
                 *
                 * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
                 * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
                 */
                createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

                /**
                 * The horizontal scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): this;

                /**
                 * Sets the visibility of this Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): this;
            }

            /**
             * A Particle Emitter Manager creates and controls {@link Phaser.GameObjects.Particles.ParticleEmitter Particle Emitters} and
             * {@link Phaser.GameObjects.Particles.GravityWell Gravity Wells}.
             */
            class ParticleEmitterManager extends GameObject
                implements Components.Depth, Components.Pipeline, Components.Transform, Components.Visible {
                /**
                 *
                 * @param scene The Scene to which this Emitter Manager belongs.
                 * @param texture The key of the Texture this Emitter Manager will use to render particles, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Emitter Manager will use to render particles.
                 * @param emitters Configuration settings for one or more emitters to create.
                 */
                constructor(scene: Scene, texture: string, frame?: string | integer, emitters?: ParticleEmitterConfig | ParticleEmitterConfig[]);

                /**
                 * The time scale applied to all emitters and particles, affecting flow rate, lifespan, and movement.
                 * Values larger than 1 are faster than normal.
                 * This is multiplied with any timeScale set on each individual emitter.
                 */
                timeScale: number;

                /**
                 * The texture used to render this Emitter Manager's particles.
                 */
                texture: Textures.Texture;

                /**
                 * The texture frame used to render this Emitter Manager's particles.
                 */
                frame: Textures.Frame;

                /**
                 * Names of this Emitter Manager's texture frames.
                 */
                frameNames: string[];

                /**
                 * A list of Emitters being managed by this Emitter Manager.
                 */
                emitters: Structs.List<ParticleEmitter>;

                /**
                 * A list of Gravity Wells being managed by this Emitter Manager.
                 */
                wells: Structs.List<GravityWell>;

                /**
                 * Sets the texture and frame this Emitter Manager will use to render with.
                 *
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): ParticleEmitterManager;

                /**
                 * Sets the frame this Emitter Manager will use to render with.
                 *
                 * The Frame has to belong to the current Texture being used.
                 *
                 * It can be either a string or an index.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setFrame(frame?: string | integer): ParticleEmitterManager;

                /**
                 * Assigns texture frames to an emitter.
                 * @param frames The texture frames.
                 * @param emitter The particle emitter to modify.
                 */
                setEmitterFrames(frames: Textures.Frame | Textures.Frame[], emitter: ParticleEmitter): ParticleEmitterManager;

                /**
                 * Adds an existing Particle Emitter to this Emitter Manager.
                 * @param emitter The Particle Emitter to add to this Emitter Manager.
                 */
                addEmitter(emitter: ParticleEmitter): ParticleEmitter;

                /**
                 * Creates a new Particle Emitter object, adds it to this Emitter Manager and returns a reference to it.
                 * @param config Configuration settings for the Particle Emitter to create.
                 */
                createEmitter(config: ParticleEmitterConfig): ParticleEmitter;

                /**
                 * Adds an existing Gravity Well object to this Emitter Manager.
                 * @param well The Gravity Well to add to this Emitter Manager.
                 */
                addGravityWell(well: GravityWell): GravityWell;

                /**
                 * Creates a new Gravity Well, adds it to this Emitter Manager and returns a reference to it.
                 * @param config Configuration settings for the Gravity Well to create.
                 */
                createGravityWell(config: GravityWellConfig): GravityWell;

                /**
                 * Emits particles from each active emitter.
                 * @param count The number of particles to release from each emitter. The default is the emitter's own {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.
                 * @param x The x-coordinate to to emit particles from. The default is the x-coordinate of the emitter's current location.
                 * @param y The y-coordinate to to emit particles from. The default is the y-coordinate of the emitter's current location.
                 */
                emitParticle(count?: integer, x?: number, y?: number): ParticleEmitterManager;

                /**
                 * Emits particles from each active emitter.
                 * @param x The x-coordinate to to emit particles from. The default is the x-coordinate of the emitter's current location.
                 * @param y The y-coordinate to to emit particles from. The default is the y-coordinate of the emitter's current location.
                 * @param count The number of particles to release from each emitter. The default is the emitter's own {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.
                 */
                emitParticleAt(x?: number, y?: number, count?: integer): ParticleEmitterManager;

                /**
                 * Pauses this Emitter Manager.
                 *
                 * This has the effect of pausing all emitters, and all particles of those emitters, currently under its control.
                 *
                 * The particles will still render, but they will not have any of their logic updated.
                 */
                pause(): ParticleEmitterManager;

                /**
                 * Resumes this Emitter Manager, should it have been previously paused.
                 */
                resume(): ParticleEmitterManager;

                /**
                 * Gets all active particle processors (gravity wells).
                 */
                getProcessors(): GravityWell[];

                /**
                 * Updates all active emitters.
                 * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                preUpdate(time: integer, delta: number): void;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): this;

                /**
                 * The initial WebGL pipeline of this Game Object.
                 */
                defaultPipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * The current WebGL pipeline of this Game Object.
                 */
                pipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
                 */
                initPipeline(pipelineName?: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): this;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 *
                 * Where 0 is to the right, 90 is down, 180 is left.
                 *
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 *
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): this;

                /**
                 * Sets the position of this Game Object to be a random position within the confines of
                 * the given area.
                 *
                 * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
                 *
                 * The position does not factor in the size of this Game Object, meaning that only the origin is
                 * guaranteed to be within the area.
                 * @param x The x position of the top-left of the random area. Default 0.
                 * @param y The y position of the top-left of the random area. Default 0.
                 * @param width The width of the random area.
                 * @param height The height of the random area.
                 */
                setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): this;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): this;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): this;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): this;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): this;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): this;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): this;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 * @param parentMatrix A temporary matrix to hold parent values during the calculations.
                 */
                getWorldTransformMatrix(
                    tempMatrix?: Components.TransformMatrix,
                    parentMatrix?: Components.TransformMatrix
                ): Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): this;
            }

            namespace Zones {
                /**
                 * A Death Zone.
                 *
                 * A Death Zone is a special interface of zone that will kill a Particle as soon as it either enters, or leaves, the zone.
                 *
                 * The zone consists of a `source` which could be a Geometric shape, such as a Rectangle or Ellipse, or your own
                 * object as long as it includes a `contains` method for which the Particles can be tested against.
                 */
                class DeathZone {
                    /**
                     *
                     * @param source An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.
                     * @param killOnEnter Should the Particle be killed when it enters the zone? `true` or leaves it? `false`
                     */
                    constructor(source: DeathZoneSource, killOnEnter: boolean);

                    /**
                     * An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.
                     * This could be a Geometry shape, such as `Phaser.Geom.Circle`, or your own custom object.
                     */
                    source: DeathZoneSource;

                    /**
                     * Set to `true` if the Particle should be killed if it enters this zone.
                     * Set to `false` to kill the Particle if it leaves this zone.
                     */
                    killOnEnter: boolean;

                    /**
                     * Checks if the given Particle will be killed or not by this zone.
                     * @param particle The Particle to be checked against this zone.
                     */
                    willKill(particle: Particle): boolean;
                }

                /**
                 * A zone that places particles on a shape's edges.
                 */
                class EdgeZone {
                    /**
                     *
                     * @param source An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.
                     * @param quantity The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.
                     * @param stepRate The distance between each particle. When set, `quantity` is implied and should be set to 0.
                     * @param yoyo Whether particles are placed from start to end and then end to start. Default false.
                     * @param seamless Whether one endpoint will be removed if it's identical to the other. Default true.
                     */
                    constructor(source: EdgeZoneSource, quantity: integer, stepRate: number, yoyo?: boolean, seamless?: boolean);

                    /**
                     * An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.
                     */
                    source: EdgeZoneSource | RandomZoneSource;

                    /**
                     * The points placed on the source edge.
                     */
                    points: Geom.Point[];

                    /**
                     * The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.
                     */
                    quantity: integer;

                    /**
                     * The distance between each particle. When set, `quantity` is implied and should be set to 0.
                     */
                    stepRate: number;

                    /**
                     * Whether particles are placed from start to end and then end to start.
                     */
                    yoyo: boolean;

                    /**
                     * The counter used for iterating the EdgeZone's points.
                     */
                    counter: number;

                    /**
                     * Whether one endpoint will be removed if it's identical to the other.
                     */
                    seamless: boolean;

                    /**
                     * Update the {@link Phaser.GameObjects.Particles.Zones.EdgeZone#points} from the EdgeZone's
                     * {@link Phaser.GameObjects.Particles.Zones.EdgeZone#source}.
                     *
                     * Also updates internal properties.
                     */
                    updateSource(): EdgeZone;

                    /**
                     * Change the EdgeZone's source.
                     * @param source An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.
                     */
                    changeSource(source: EdgeZoneSource): EdgeZone;

                    /**
                     * Get the next point in the Zone and set its coordinates on the given Particle.
                     * @param particle The Particle.
                     */
                    getPoint(particle: Particle): void;
                }

                /**
                 * A zone that places particles randomly within a shape's area.
                 */
                class RandomZone {
                    /**
                     *
                     * @param source An object instance with a `getRandomPoint(point)` method.
                     */
                    constructor(source: RandomZoneSource);

                    /**
                     * An object instance with a `getRandomPoint(point)` method.
                     */
                    source: RandomZoneSource;

                    /**
                     * Get the next point in the Zone and set its coordinates on the given Particle.
                     * @param particle The Particle.
                     */
                    getPoint(particle: Particle): void;
                }
            }
        }

        /**
         * A PathFollower Game Object.
         *
         * A PathFollower is a Sprite Game Object with some extra helpers to allow it to follow a Path automatically.
         *
         * Anything you can do with a standard Sprite can be done with this PathFollower, such as animate it, tint it,
         * scale it and so on.
         *
         * PathFollowers are bound to a single Path at any one time and can traverse the length of the Path, from start
         * to finish, forwards or backwards, or from any given point on the Path to its end. They can optionally rotate
         * to face the direction of the path, be offset from the path coordinates or rotate independently of the Path.
         */
        class PathFollower extends Sprite {
            /**
             *
             * @param scene The Scene to which this PathFollower belongs.
             * @param path The Path this PathFollower is following. It can only follow one Path at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Scene, path: Curves.Path, x: number, y: number, texture: string, frame?: string | integer);

            /**
             * The Path this PathFollower is following. It can only follow one Path at a time.
             */
            path: Curves.Path;

            /**
             * Should the PathFollower automatically rotate to point in the direction of the Path?
             */
            rotateToPath: boolean;

            /**
             * If the PathFollower is rotating to match the Path (@see Phaser.GameObjects.PathFollower#rotateToPath)
             * this value is added to the rotation value. This allows you to rotate objects to a path but control
             * the angle of the rotation as well.
             */
            pathRotationOffset: number;

            /**
             * An additional vector to add to the PathFollowers position, allowing you to offset it from the
             * Path coordinates.
             */
            pathOffset: Math.Vector2;

            /**
             * A Vector2 that stores the current point of the path the follower is on.
             */
            pathVector: Math.Vector2;

            /**
             * The Tween used for following the Path.
             */
            pathTween: Tweens.Tween;

            /**
             * Settings for the PathFollower.
             */
            pathConfig: PathConfig;

            /**
             * Set the Path that this PathFollower should follow.
             *
             * Optionally accepts {@link PathConfig} settings.
             * @param path The Path this PathFollower is following. It can only follow one Path at a time.
             * @param config Settings for the PathFollower.
             */
            setPath(path: Curves.Path, config?: PathConfig): PathFollower;

            /**
             * Set whether the PathFollower should automatically rotate to point in the direction of the Path.
             * @param value Whether the PathFollower should automatically rotate to point in the direction of the Path.
             * @param offset Rotation offset in degrees. Default 0.
             */
            setRotateToPath(value: boolean, offset?: number): PathFollower;

            /**
             * Is this PathFollower actively following a Path or not?
             *
             * To be considered as `isFollowing` it must be currently moving on a Path, and not paused.
             */
            isFollowing(): boolean;

            /**
             * Starts this PathFollower following its given Path.
             * @param config The duration of the follow, or a PathFollower config object. Default {}.
             * @param startAt Optional start position of the follow, between 0 and 1. Default 0.
             */
            startFollow(config?: number | PathConfig, startAt?: number): PathFollower;

            /**
             * Pauses this PathFollower. It will still continue to render, but it will remain motionless at the
             * point on the Path at which you paused it.
             */
            pauseFollow(): PathFollower;

            /**
             * Resumes a previously paused PathFollower.
             *
             * If the PathFollower was not paused this has no effect.
             */
            resumeFollow(): PathFollower;

            /**
             * Stops this PathFollower from following the path any longer.
             *
             * This will invoke any 'stop' conditions that may exist on the Path, or for the follower.
             */
            stopFollow(): PathFollower;

            /**
             * Internal update handler that advances this PathFollower along the path.
             *
             * Called automatically by the Scene step, should not typically be called directly.
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             * @param delta The delta time, in ms, elapsed since the last frame.
             */
            protected preUpdate(time: integer, delta: number): void;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): this;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): this;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): this;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): this;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): this;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Textures.Frame): this;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * A boolean flag indicating if this Game Object is being cropped or not.
             * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
             * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
             */
            isCropped: boolean;

            /**
             * Applies a crop to a texture based Game Object, such as a Sprite or Image.
             *
             * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
             *
             * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
             * changes what is shown when rendered.
             *
             * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
             *
             * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
             * half of it, you could call `setCrop(0, 0, 400, 600)`.
             *
             * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
             * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
             *
             * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
             *
             * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
             *
             * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
             * the renderer to skip several internal calculations.
             * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
             * @param y The y coordinate to start the crop from.
             * @param width The width of the crop rectangle in pixels.
             * @param height The height of the crop rectangle in pixels.
             */
            setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): this;

            /**
             * Sets the frame this Game Object will use to render with.
             *
             * The Frame has to belong to the current Texture being used.
             *
             * It can be either a string or an index.
             *
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

            /**
             * Fill or additive?
             */
            tintFill: boolean;

            /**
             * Clears all tint values associated with this Game Object.
             *
             * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
             * which results in no visible change to the texture.
             */
            clearTint(): this;

            /**
             * Sets an additive tint on this Game Object.
             *
             * The tint works by taking the pixel color values from the Game Objects texture, and then
             * multiplying it by the color value of the tint. You can provide either one color value,
             * in which case the whole Game Object will be tinted in that color. Or you can provide a color
             * per corner. The colors are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * Sets a fill-based tint on this Game Object.
             *
             * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
             * with those in the tint. You can use this for effects such as making a player flash 'white'
             * if hit by something. You can provide either one color value, in which case the whole
             * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
             * are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * Does this Game Object have a tint applied to it or not?
             */
            readonly isTinted: boolean;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * A Quad Game Object.
         *
         * A Quad is a Mesh Game Object pre-configured with two triangles arranged into a rectangle, with a single
         * texture spread across them.
         *
         * You can manipulate the corner points of the quad via the getters and setters such as `topLeftX`, and also
         * change their alpha and color values. The quad itself can be moved by adjusting the `x` and `y` properties.
         */
        class Quad extends Mesh {
            /**
             *
             * @param scene The Scene to which this Quad belongs.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Scene, x: number, y: number, texture: string, frame?: string | integer);

            /**
             * Sets the frame this Game Object will use to render with.
             *
             * The Frame has to belong to the current Texture being used.
             *
             * It can be either a string or an index.
             *
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             */
            setFrame(frame: string | integer): this;

            /**
             * The top-left x vertex of this Quad.
             */
            topLeftX: number;

            /**
             * The top-left y vertex of this Quad.
             */
            topLeftY: number;

            /**
             * The top-right x vertex of this Quad.
             */
            topRightX: number;

            /**
             * The top-right y vertex of this Quad.
             */
            topRightY: number;

            /**
             * The bottom-left x vertex of this Quad.
             */
            bottomLeftX: number;

            /**
             * The bottom-left y vertex of this Quad.
             */
            bottomLeftY: number;

            /**
             * The bottom-right x vertex of this Quad.
             */
            bottomRightX: number;

            /**
             * The bottom-right y vertex of this Quad.
             */
            bottomRightY: number;

            /**
             * The top-left alpha value of this Quad.
             */
            topLeftAlpha: number;

            /**
             * The top-right alpha value of this Quad.
             */
            topRightAlpha: number;

            /**
             * The bottom-left alpha value of this Quad.
             */
            bottomLeftAlpha: number;

            /**
             * The bottom-right alpha value of this Quad.
             */
            bottomRightAlpha: number;

            /**
             * The top-left color value of this Quad.
             */
            topLeftColor: number;

            /**
             * The top-right color value of this Quad.
             */
            topRightColor: number;

            /**
             * The bottom-left color value of this Quad.
             */
            bottomLeftColor: number;

            /**
             * The bottom-right color value of this Quad.
             */
            bottomRightColor: number;

            /**
             * Sets the top-left vertex position of this Quad.
             * @param x The horizontal coordinate of the vertex.
             * @param y The vertical coordinate of the vertex.
             */
            setTopLeft(x: number, y: number): Quad;

            /**
             * Sets the top-right vertex position of this Quad.
             * @param x The horizontal coordinate of the vertex.
             * @param y The vertical coordinate of the vertex.
             */
            setTopRight(x: number, y: number): Quad;

            /**
             * Sets the bottom-left vertex position of this Quad.
             * @param x The horizontal coordinate of the vertex.
             * @param y The vertical coordinate of the vertex.
             */
            setBottomLeft(x: number, y: number): Quad;

            /**
             * Sets the bottom-right vertex position of this Quad.
             * @param x The horizontal coordinate of the vertex.
             * @param y The vertical coordinate of the vertex.
             */
            setBottomRight(x: number, y: number): Quad;

            /**
             * Resets the positions of the four corner vertices of this Quad.
             */
            resetPosition(): Quad;

            /**
             * Resets the alpha values used by this Quad back to 1.
             */
            resetAlpha(): Quad;

            /**
             * Resets the color values used by this Quad back to 0xffffff.
             */
            resetColors(): Quad;

            /**
             * Resets the position, alpha and color values used by this Quad.
             */
            reset(): Quad;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Textures.Frame): this;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;
        }

        /**
         * A Render Texture.
         *
         * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and
         * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic
         * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.
         *
         * Note that under WebGL a FrameBuffer, which is what the Render Texture uses internally, cannot be anti-aliased. This means
         * that when drawing objects such as Shapes to a Render Texture they will appear to be drawn with no aliasing, however this
         * is a technical limitation of WebGL. To get around it, create your shape as a texture in an art package, then draw that
         * to the Render Texture.
         */
        class RenderTexture extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.ComputedSize,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.ScaleMode,
                Components.ScrollFactor,
                Components.Tint,
                Components.Transform,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param width The width of the Render Texture. Default 32.
             * @param height The height of the Render Texture. Default 32.
             */
            constructor(scene: Scene, x?: number, y?: number, width?: integer, height?: integer);

            /**
             * A reference to either the Canvas or WebGL Renderer that the Game instance is using.
             */
            renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer;

            /**
             * A reference to the Texture Manager.
             */
            textureManager: Textures.TextureManager;

            /**
             * The tint of the Render Texture when rendered.
             */
            globalTint: number;

            /**
             * The alpha of the Render Texture when rendered.
             */
            globalAlpha: number;

            /**
             * The HTML Canvas Element that the Render Texture is drawing to when using the Canvas Renderer.
             */
            canvas: HTMLCanvasElement;

            /**
             * A reference to the Rendering Context belonging to the Canvas Element this Render Texture is drawing to.
             */
            context: CanvasRenderingContext2D;

            /**
             * A reference to the GL Frame Buffer this Render Texture is drawing to.
             * This is only set if Phaser is running with the WebGL Renderer.
             */
            framebuffer: WebGLFramebuffer;

            /**
             * The Texture corresponding to this Render Texture.
             */
            texture: Textures.Texture;

            /**
             * The Frame corresponding to this Render Texture.
             */
            frame: Textures.Frame;

            /**
             * An internal Camera that can be used to move around the Render Texture.
             * Control it just like you would any Scene Camera. The difference is that it only impacts the placement of what
             * is drawn to the Render Texture. You can scroll, zoom and rotate this Camera.
             */
            camera: Cameras.Scene2D.BaseCamera;

            /**
             * Is this Render Texture dirty or not? If not it won't spend time clearing or filling itself.
             */
            dirty: boolean;

            /**
             * A reference to the WebGL Rendering Context.
             */
            gl: WebGLRenderingContext;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Resizes the Render Texture to the new dimensions given.
             *
             * In WebGL it will destroy and then re-create the frame buffer being used by the Render Texture.
             * In Canvas it will resize the underlying canvas element.
             * Both approaches will erase everything currently drawn to the Render Texture.
             *
             * If the dimensions given are the same as those already being used, calling this method will do nothing.
             * @param width The new width of the Render Texture.
             * @param height The new height of the Render Texture. If not specified, will be set the same as the `width`.
             */
            resize(width: number, height?: number): this;

            /**
             * Set the tint to use when rendering this Render Texture.
             * @param tint The tint value.
             */
            setGlobalTint(tint: integer): this;

            /**
             * Set the alpha to use when rendering this Render Texture.
             * @param alpha The alpha value.
             */
            setGlobalAlpha(alpha: number): this;

            /**
             * Stores a copy of this Render Texture in the Texture Manager using the given key.
             *
             * After doing this, any texture based Game Object, such as a Sprite, can use the contents of this
             * Render Texture by using the texture key:
             *
             * ```javascript
             * var rt = this.add.renderTexture(0, 0, 128, 128);
             *
             * // Draw something to the Render Texture
             *
             * rt.saveTexture('doodle');
             *
             * this.add.image(400, 300, 'doodle');
             * ```
             *
             * Updating the contents of this Render Texture will automatically update _any_ Game Object
             * that is using it as a texture. Calling `saveTexture` again will not save another copy
             * of the same texture, it will just rename the key of the existing copy.
             *
             * By default it will create a single base texture. You can add frames to the texture
             * by using the `Texture.add` method. After doing this, you can then allow Game Objects
             * to use a specific frame from a Render Texture.
             * @param key The unique key to store the texture as within the global Texture Manager.
             */
            saveTexture(key: string): Textures.Texture;

            /**
             * Fills the Render Texture with the given color.
             * @param rgb The color to fill the Render Texture with.
             * @param alpha The alpha value used by the fill. Default 1.
             */
            fill(rgb: number, alpha?: number): this;

            /**
             * Clears the Render Texture.
             */
            clear(): this;

            /**
             * Draws the given object, or an array of objects, to this Render Texture using a blend mode of ERASE.
             * This has the effect of erasing any filled pixels in the objects from this Render Texture.
             *
             * It can accept any of the following:
             *
             * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.
             * * Dynamic and Static Tilemap Layers.
             * * A Group. The contents of which will be iterated and drawn in turn.
             * * A Container. The contents of which will be iterated fully, and drawn in turn.
             * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.
             * * Another Render Texture.
             * * A Texture Frame instance.
             * * A string. This is used to look-up a texture from the Texture Manager.
             *
             * Note: You cannot erase a Render Texture from itself.
             *
             * If passing in a Group or Container it will only draw children that return `true`
             * when their `willRender()` method is called. I.e. a Container with 10 children,
             * 5 of which have `visible=false` will only draw the 5 visible ones.
             *
             * If passing in an array of Game Objects it will draw them all, regardless if
             * they pass a `willRender` check or not.
             *
             * You can pass in a string in which case it will look for a texture in the Texture
             * Manager matching that string, and draw the base frame.
             *
             * You can pass in the `x` and `y` coordinates to draw the objects at. The use of
             * the coordinates differ based on what objects are being drawn. If the object is
             * a Group, Container or Display List, the coordinates are _added_ to the positions
             * of the children. For all other types of object, the coordinates are exact.
             *
             * Calling this method causes the WebGL batch to flush, so it can write the texture
             * data to the framebuffer being used internally. The batch is flushed at the end,
             * after the entries have been iterated. So if you've a bunch of objects to draw,
             * try and pass them in an array in one single call, rather than making lots of
             * separate calls.
             * @param entries Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.
             * @param x The x position to draw the Frame at, or the offset applied to the object.
             * @param y The y position to draw the Frame at, or the offset applied to the object.
             */
            erase(entries: any, x?: number, y?: number): this;

            /**
             * Draws the given object, or an array of objects, to this Render Texture.
             *
             * It can accept any of the following:
             *
             * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.
             * * Dynamic and Static Tilemap Layers.
             * * A Group. The contents of which will be iterated and drawn in turn.
             * * A Container. The contents of which will be iterated fully, and drawn in turn.
             * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.
             * * Another Render Texture.
             * * A Texture Frame instance.
             * * A string. This is used to look-up a texture from the Texture Manager.
             *
             * Note: You cannot draw a Render Texture to itself.
             *
             * If passing in a Group or Container it will only draw children that return `true`
             * when their `willRender()` method is called. I.e. a Container with 10 children,
             * 5 of which have `visible=false` will only draw the 5 visible ones.
             *
             * If passing in an array of Game Objects it will draw them all, regardless if
             * they pass a `willRender` check or not.
             *
             * You can pass in a string in which case it will look for a texture in the Texture
             * Manager matching that string, and draw the base frame. If you need to specify
             * exactly which frame to draw then use the method `drawFrame` instead.
             *
             * You can pass in the `x` and `y` coordinates to draw the objects at. The use of
             * the coordinates differ based on what objects are being drawn. If the object is
             * a Group, Container or Display List, the coordinates are _added_ to the positions
             * of the children. For all other types of object, the coordinates are exact.
             *
             * The `alpha` and `tint` values are only used by Texture Frames.
             * Game Objects use their own alpha and tint values when being drawn.
             *
             * Calling this method causes the WebGL batch to flush, so it can write the texture
             * data to the framebuffer being used internally. The batch is flushed at the end,
             * after the entries have been iterated. So if you've a bunch of objects to draw,
             * try and pass them in an array in one single call, rather than making lots of
             * separate calls.
             * @param entries Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.
             * @param x The x position to draw the Frame at, or the offset applied to the object.
             * @param y The y position to draw the Frame at, or the offset applied to the object.
             * @param alpha The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.
             * @param tint WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.
             */
            draw(entries: any, x?: number, y?: number, alpha?: number, tint?: number): this;

            /**
             * Draws the Texture Frame to the Render Texture at the given position.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             *
             * ```javascript
             * var rt = this.add.renderTexture(0, 0, 800, 600);
             * rt.drawFrame(key, frame);
             * ```
             *
             * You can optionally provide a position, alpha and tint value to apply to the frame
             * before it is drawn.
             *
             * Calling this method will cause a batch flush, so if you've got a stack of things to draw
             * in a tight loop, try using the `draw` method instead.
             *
             * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             * @param x The x position to draw the frame at. Default 0.
             * @param y The y position to draw the frame at. Default 0.
             * @param alpha The alpha to use. If not specified it uses the `globalAlpha` property.
             * @param tint WebGL only. The tint color to use. If not specified it uses the `globalTint` property.
             */
            drawFrame(key: string, frame?: string | integer, x?: number, y?: number, alpha?: number, tint?: number): this;

            /**
             * Internal destroy handler, called as part of the destroy process.
             */
            protected preDestroy(): void;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): this;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): this;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): this;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): this;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): this;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * Fill or additive?
             */
            tintFill: boolean;

            /**
             * Clears all tint values associated with this Game Object.
             *
             * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
             * which results in no visible change to the texture.
             */
            clearTint(): this;

            /**
             * Sets an additive tint on this Game Object.
             *
             * The tint works by taking the pixel color values from the Game Objects texture, and then
             * multiplying it by the color value of the tint. You can provide either one color value,
             * in which case the whole Game Object will be tinted in that color. Or you can provide a color
             * per corner. The colors are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * Sets a fill-based tint on this Game Object.
             *
             * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
             * with those in the tint. You can use this for effects such as making a player flash 'white'
             * if hit by something. You can provide either one color value, in which case the whole
             * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
             * are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * Does this Game Object have a tint applied to it or not?
             */
            readonly isTinted: boolean;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports both fill and stroke colors.
         *
         * When it renders it displays an arc shape. You can control the start and end angles of the arc,
         * as well as if the angles are winding clockwise or anti-clockwise. With the default settings
         * it renders as a complete circle. By changing the angles you can create other arc shapes,
         * such as half-circles.
         *
         * Arcs also have an `iterations` property and corresponding `setIterations` method. This allows
         * you to control how smooth the shape renders in WebGL, by controlling the number of iterations
         * that take place during construction.
         */
        class Arc extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param radius The radius of the arc. Default 128.
             * @param startAngle The start angle of the arc, in degrees. Default 0.
             * @param endAngle The end angle of the arc, in degrees. Default 360.
             * @param anticlockwise The winding order of the start and end angles. Default false.
             * @param fillColor The color the arc will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            constructor(scene: Scene, x?: number, y?: number, radius?: number, startAngle?: integer, endAngle?: integer, anticlockwise?: boolean, fillColor?: number, fillAlpha?: number);

            /**
             * The number of iterations used when drawing the arc.
             * Increase this value for smoother arcs, at the cost of more polygons being rendered.
             * Modify this value by small amounts, such as 0.01.
             */
            iterations: number;

            /**
             * The radius of the arc.
             */
            radius: number;

            /**
             * The start angle of the arc, in degrees.
             */
            startAngle: integer;

            /**
             * The end angle of the arc, in degrees.
             */
            endAngle: integer;

            /**
             * The winding order of the start and end angles.
             */
            anticlockwise: boolean;

            /**
             * Sets the radius of the arc.
             * This call can be chained.
             * @param value The value to set the radius to.
             */
            setRadius(value: number): this;

            /**
             * Sets the number of iterations used when drawing the arc.
             * Increase this value for smoother arcs, at the cost of more polygons being rendered.
             * Modify this value by small amounts, such as 0.01.
             * This call can be chained.
             * @param value The value to set the iterations to.
             */
            setIterations(value: number): this;

            /**
             * Sets the starting angle of the arc, in degrees.
             * This call can be chained.
             * @param value The value to set the starting angle to.
             */
            setStartAngle(value: integer): this;

            /**
             * Sets the ending angle of the arc, in degrees.
             * This call can be chained.
             * @param value The value to set the ending angle to.
             */
            setEndAngle(value: integer): this;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Curve Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports both fill and stroke colors.
         *
         * To render a Curve Shape you must first create a `Phaser.Curves.Curve` object, then pass it to
         * the Curve Shape in the constructor.
         *
         * The Curve shape also has a `smoothness` property and corresponding `setSmoothness` method.
         * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations
         * that take place during construction. Increase and decrease the default value for smoother, or more
         * jagged, shapes.
         */
        class Curve extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param curve The Curve object to use to create the Shape.
             * @param fillColor The color the curve will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the curve will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            constructor(scene: Scene, x?: number, y?: number, curve?: Curves.Curve, fillColor?: number, fillAlpha?: number);

            /**
             * The smoothness of the curve. The number of points used when rendering it.
             * Increase this value for smoother curves, at the cost of more polygons being rendered.
             */
            smoothness: integer;

            /**
             * Sets the smoothness of the curve. The number of points used when rendering it.
             * Increase this value for smoother curves, at the cost of more polygons being rendered.
             * This call can be chained.
             * @param value The value to set the smoothness to.
             */
            setSmoothness(value: integer): this;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports both fill and stroke colors.
         *
         * When it renders it displays an ellipse shape. You can control the width and height of the ellipse.
         * If the width and height match it will render as a circle. If the width is less than the height,
         * it will look more like an egg shape.
         *
         * The Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.
         * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations
         * that take place during construction. Increase and decrease the default value for smoother, or more
         * jagged, shapes.
         */
        class Ellipse extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param width The width of the ellipse. An ellipse with equal width and height renders as a circle. Default 128.
             * @param height The height of the ellipse. An ellipse with equal width and height renders as a circle. Default 128.
             * @param fillColor The color the ellipse will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the ellipse will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            constructor(scene: Scene, x?: number, y?: number, width?: number, height?: number, fillColor?: number, fillAlpha?: number);

            /**
             * The smoothness of the ellipse. The number of points used when rendering it.
             * Increase this value for a smoother ellipse, at the cost of more polygons being rendered.
             */
            smoothness: integer;

            /**
             * Sets the size of the ellipse by changing the underlying geometry data, rather than scaling the object.
             * This call can be chained.
             * @param width The width of the ellipse.
             * @param height The height of the ellipse.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the smoothness of the ellipse. The number of points used when rendering it.
             * Increase this value for a smoother ellipse, at the cost of more polygons being rendered.
             * This call can be chained.
             * @param value The value to set the smoothness to.
             */
            setSmoothness(value: integer): this;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Grid Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports only fill colors and cannot be stroked.
         *
         * A Grid Shape allows you to display a grid in your game, where you can control the size of the
         * grid as well as the width and height of the grid cells. You can set a fill color for each grid
         * cell as well as an alternate fill color. When the alternate fill color is set then the grid
         * cells will alternate the fill colors as they render, creating a chess-board effect. You can
         * also optionally have an outline fill color. If set, this draws lines between the grid cells
         * in the given color. If you specify an outline color with an alpha of zero, then it will draw
         * the cells spaced out, but without the lines between them.
         */
        class Grid extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param width The width of the grid. Default 128.
             * @param height The height of the grid. Default 128.
             * @param cellWidth The width of one cell in the grid. Default 32.
             * @param cellHeight The height of one cell in the grid. Default 32.
             * @param fillColor The color the grid cells will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             * @param outlineFillColor The color of the lines between the grid cells. See the `setOutline` method.
             * @param outlineFillAlpha The alpha of the lines between the grid cells.
             */
            constructor(
                scene: Scene,
                x?: number,
                y?: number,
                width?: number,
                height?: number,
                cellWidth?: number,
                cellHeight?: number,
                fillColor?: number,
                fillAlpha?: number,
                outlineFillColor?: number,
                outlineFillAlpha?: number
            );

            /**
             * The width of each grid cell.
             * Must be a positive value.
             */
            cellWidth: number;

            /**
             * The height of each grid cell.
             * Must be a positive value.
             */
            cellHeight: number;

            /**
             * Will the grid render its cells in the `fillColor`?
             */
            showCells: boolean;

            /**
             * The color of the lines between each grid cell.
             */
            outlineFillColor: number;

            /**
             * The alpha value for the color of the lines between each grid cell.
             */
            outlineFillAlpha: number;

            /**
             * Will the grid display the lines between each cell when it renders?
             */
            showOutline: boolean;

            /**
             * Will the grid render the alternating cells in the `altFillColor`?
             */
            showAltCells: boolean;

            /**
             * The color the alternating grid cells will be filled with, i.e. 0xff0000 for red.
             */
            altFillColor: number;

            /**
             * The alpha the alternating grid cells will be filled with.
             * You can also set the alpha of the overall Shape using its `alpha` property.
             */
            altFillAlpha: number;

            /**
             * Sets the fill color and alpha level the grid cells will use when rendering.
             *
             * If this method is called with no values then the grid cells will not be rendered,
             * however the grid lines and alternating cells may still be.
             *
             * Also see the `setOutlineStyle` and `setAltFillStyle` methods.
             *
             * This call can be chained.
             * @param fillColor The color the grid cells will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property. Default 1.
             */
            setFillStyle(fillColor?: number, fillAlpha?: number): this;

            /**
             * Sets the fill color and alpha level that the alternating grid cells will use.
             *
             * If this method is called with no values then alternating grid cells will not be rendered in a different color.
             *
             * Also see the `setOutlineStyle` and `setFillStyle` methods.
             *
             * This call can be chained.
             * @param fillColor The color the alternating grid cells will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the alternating grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property. Default 1.
             */
            setAltFillStyle(fillColor?: number, fillAlpha?: number): this;

            /**
             * Sets the fill color and alpha level that the lines between each grid cell will use.
             *
             * If this method is called with no values then the grid lines will not be rendered at all, however
             * the cells themselves may still be if they have colors set.
             *
             * Also see the `setFillStyle` and `setAltFillStyle` methods.
             *
             * This call can be chained.
             * @param fillColor The color the lines between the grid cells will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the lines between the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property. Default 1.
             */
            setOutlineStyle(fillColor?: number, fillAlpha?: number): this;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The IsoBox Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports only fill colors and cannot be stroked.
         *
         * An IsoBox is an 'isometric' rectangle. Each face of it has a different fill color. You can set
         * the color of the top, left and right faces of the rectangle respectively. You can also choose
         * which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.
         *
         * You cannot view an IsoBox from under-neath, however you can change the 'angle' by setting
         * the `projection` property.
         */
        class IsoBox extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param size The width of the iso box in pixels. The left and right faces will be exactly half this value. Default 48.
             * @param height The height of the iso box. The left and right faces will be this tall. The overall height of the isobox will be this value plus half the `size` value. Default 32.
             * @param fillTop The fill color of the top face of the iso box. Default 0xeeeeee.
             * @param fillLeft The fill color of the left face of the iso box. Default 0x999999.
             * @param fillRight The fill color of the right face of the iso box. Default 0xcccccc.
             */
            constructor(scene: Scene, x?: number, y?: number, size?: number, height?: number, fillTop?: number, fillLeft?: number, fillRight?: number);

            /**
             * The projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.
             */
            projection: integer;

            /**
             * The color used to fill in the top of the iso box.
             */
            fillTop: number;

            /**
             * The color used to fill in the left-facing side of the iso box.
             */
            fillLeft: number;

            /**
             * The color used to fill in the right-facing side of the iso box.
             */
            fillRight: number;

            /**
             * Controls if the top-face of the iso box be rendered.
             */
            showTop: boolean;

            /**
             * Controls if the left-face of the iso box be rendered.
             */
            showLeft: boolean;

            /**
             * Controls if the right-face of the iso box be rendered.
             */
            showRight: boolean;

            /**
             * Sets the projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.
             * This call can be chained.
             * @param value The value to set the projection to.
             */
            setProjection(value: integer): this;

            /**
             * Sets which faces of the iso box will be rendered.
             * This call can be chained.
             * @param showTop Show the top-face of the iso box. Default true.
             * @param showLeft Show the left-face of the iso box. Default true.
             * @param showRight Show the right-face of the iso box. Default true.
             */
            setFaces(showTop?: boolean, showLeft?: boolean, showRight?: boolean): this;

            /**
             * Sets the fill colors for each face of the iso box.
             * This call can be chained.
             * @param fillTop The color used to fill the top of the iso box.
             * @param fillLeft The color used to fill in the left-facing side of the iso box.
             * @param fillRight The color used to fill in the right-facing side of the iso box.
             */
            setFillStyle(fillTop?: number, fillLeft?: number, fillRight?: number): this;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The IsoTriangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports only fill colors and cannot be stroked.
         *
         * An IsoTriangle is an 'isometric' triangle. Think of it like a pyramid. Each face has a different
         * fill color. You can set the color of the top, left and right faces of the triangle respectively
         * You can also choose which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.
         *
         * You cannot view an IsoTriangle from under-neath, however you can change the 'angle' by setting
         * the `projection` property. The `reversed` property controls if the IsoTriangle is rendered upside
         * down or not.
         */
        class IsoTriangle extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param size The width of the iso triangle in pixels. The left and right faces will be exactly half this value. Default 48.
             * @param height The height of the iso triangle. The left and right faces will be this tall.
             * The overall height of the iso triangle will be this value plus half the `size` value. Default 32.
             * @param reversed Is the iso triangle upside down? Default false.
             * @param fillTop The fill color of the top face of the iso triangle. Default 0xeeeeee.
             * @param fillLeft The fill color of the left face of the iso triangle. Default 0x999999.
             * @param fillRight The fill color of the right face of the iso triangle. Default 0xcccccc.
             */
            constructor(scene: Scene, x?: number, y?: number, size?: number, height?: number, reversed?: boolean, fillTop?: number, fillLeft?: number, fillRight?: number);

            /**
             * The projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.
             */
            projection: integer;

            /**
             * The color used to fill in the top of the iso triangle. This is only used if the triangle is reversed.
             */
            fillTop: number;

            /**
             * The color used to fill in the left-facing side of the iso triangle.
             */
            fillLeft: number;

            /**
             * The color used to fill in the right-facing side of the iso triangle.
             */
            fillRight: number;

            /**
             * Controls if the top-face of the iso triangle be rendered.
             */
            showTop: boolean;

            /**
             * Controls if the left-face of the iso triangle be rendered.
             */
            showLeft: boolean;

            /**
             * Controls if the right-face of the iso triangle be rendered.
             */
            showRight: boolean;

            /**
             * Sets if the iso triangle will be rendered upside down or not.
             */
            isReversed: boolean;

            /**
             * Sets the projection level of the iso triangle. Change this to change the 'angle' at which you are looking at the pyramid.
             * This call can be chained.
             * @param value The value to set the projection to.
             */
            setProjection(value: integer): this;

            /**
             * Sets if the iso triangle will be rendered upside down or not.
             * This call can be chained.
             * @param reversed Sets if the iso triangle will be rendered upside down or not.
             */
            setReversed(reversed: boolean): this;

            /**
             * Sets which faces of the iso triangle will be rendered.
             * This call can be chained.
             * @param showTop Show the top-face of the iso triangle (only if `reversed` is true) Default true.
             * @param showLeft Show the left-face of the iso triangle. Default true.
             * @param showRight Show the right-face of the iso triangle. Default true.
             */
            setFaces(showTop?: boolean, showLeft?: boolean, showRight?: boolean): this;

            /**
             * Sets the fill colors for each face of the iso triangle.
             * This call can be chained.
             * @param fillTop The color used to fill the top of the iso triangle.
             * @param fillLeft The color used to fill in the left-facing side of the iso triangle.
             * @param fillRight The color used to fill in the right-facing side of the iso triangle.
             */
            setFillStyle(fillTop?: number, fillLeft?: number, fillRight?: number): this;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Line Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports only stroke colors and cannot be filled.
         *
         * A Line Shape allows you to draw a line between two points in your game. You can control the
         * stroke color and thickness of the line. In WebGL only you can also specify a different
         * thickness for the start and end of the line, allowing you to render lines that taper-off.
         *
         * If you need to draw multiple lines in a sequence you may wish to use the Polygon Shape instead.
         */
        class Line extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param x1 The horizontal position of the start of the line. Default 0.
             * @param y1 The vertical position of the start of the line. Default 0.
             * @param x2 The horizontal position of the end of the line. Default 128.
             * @param y2 The vertical position of the end of the line. Default 0.
             * @param strokeColor The color the line will be drawn in, i.e. 0xff0000 for red.
             * @param strokeAlpha The alpha the line will be drawn in. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            constructor(scene: Scene, x?: number, y?: number, x1?: number, y1?: number, x2?: number, y2?: number, strokeColor?: number, strokeAlpha?: number);

            /**
             * The width (or thickness) of the line.
             * See the setLineWidth method for extra details on changing this on WebGL.
             */
            lineWidth: number;

            /**
             * Sets the width of the line.
             *
             * When using the WebGL renderer you can have different start and end widths.
             * When using the Canvas renderer only the `startWidth` value is used. The `endWidth` is ignored.
             *
             * This call can be chained.
             * @param startWidth The start width of the line.
             * @param endWidth The end width of the line. Only used in WebGL.
             */
            setLineWidth(startWidth: number, endWidth?: number): this;

            /**
             * Sets the start and end coordinates of this Line.
             * @param x1 The horizontal position of the start of the line. Default 0.
             * @param y1 The vertical position of the start of the line. Default 0.
             * @param x2 The horizontal position of the end of the line. Default 0.
             * @param y2 The vertical position of the end of the line. Default 0.
             */
            setTo(x1?: number, y1?: number, x2?: number, y2?: number): this;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports both fill and stroke colors.
         *
         * The Polygon Shape is created by providing a list of points, which are then used to create an
         * internal Polygon geometry object. The points can be set from a variety of formats:
         *
         * - A string containing paired values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`
         * - An array of Point or Vector2 objects: `[new Phaser.Math.Vec2(x1, y1), ...]`
         * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
         * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
         * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
         *
         * By default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending
         * on the coordinates of the points provided, the final shape may be rendered offset from its origin.
         */
        class Polygon extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param points The points that make up the polygon.
             * @param fillColor The color the polygon will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the polygon will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            constructor(scene: Scene, x?: number, y?: number, points?: any, fillColor?: number, fillAlpha?: number);

            /**
             * Smooths the polygon over the number of iterations specified.
             * The base polygon data will be updated and replaced with the smoothed values.
             * This call can be chained.
             * @param iterations The number of times to apply the polygon smoothing. Default 1.
             */
            smooth(iterations?: integer): this;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports both fill and stroke colors.
         *
         * You can change the size of the rectangle by changing the `width` and `height` properties.
         */
        class Rectangle extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the rectangle. Default 128.
             * @param height The height of the rectangle. Default 128.
             * @param fillColor The color the rectangle will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the rectangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            constructor(scene: Scene, x: number, y: number, width?: number, height?: number, fillColor?: number, fillAlpha?: number);

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Shape Game Object is a base class for the various different shapes, such as the Arc, Star or Polygon.
         * You cannot add a Shape directly to your Scene, it is meant as a base for your own custom Shape classes.
         */
        class Shape extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.ComputedSize,
                Components.Depth,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.ScaleMode,
                Components.ScrollFactor,
                Components.Transform,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param interface The internal interface of the Shape.
             * @param data The data of the source shape geometry, if any.
             */
            constructor(scene: Scene, interface?: string, data?: any);

            /**
             * The source Shape data. Typically a geometry object.
             * You should not manipulate this directly.
             */
            readonly data: any;

            /**
             * Holds the polygon path data for filled rendering.
             */
            readonly pathData: number[];

            /**
             * Holds the earcut polygon path index data for filled rendering.
             */
            readonly pathIndexes: integer[];

            /**
             * The fill color used by this Shape.
             */
            fillColor: number;

            /**
             * The fill alpha value used by this Shape.
             */
            fillAlpha: number;

            /**
             * The stroke color used by this Shape.
             */
            strokeColor: number;

            /**
             * The stroke alpha value used by this Shape.
             */
            strokeAlpha: number;

            /**
             * The stroke line width used by this Shape.
             */
            lineWidth: number;

            /**
             * Controls if this Shape is filled or not.
             * Note that some Shapes do not support being filled (such as Line shapes)
             */
            isFilled: boolean;

            /**
             * Controls if this Shape is stroked or not.
             * Note that some Shapes do not support being stroked (such as Iso Box shapes)
             */
            isStroked: boolean;

            /**
             * Controls if this Shape path is closed during rendering when stroked.
             * Note that some Shapes are always closed when stroked (such as Ellipse shapes)
             */
            closePath: boolean;

            /**
             * Sets the fill color and alpha for this Shape.
             *
             * If you wish for the Shape to not be filled then call this method with no arguments, or just set `isFilled` to `false`.
             *
             * Note that some Shapes do not support fill colors, such as the Line shape.
             *
             * This call can be chained.
             * @param color The color used to fill this shape. If not provided the Shape will not be filled.
             * @param alpha The alpha value used when filling this shape, if a fill color is given. Default 1.
             */
            setFillStyle(color?: number, alpha?: number): this;

            /**
             * Sets the stroke color and alpha for this Shape.
             *
             * If you wish for the Shape to not be stroked then call this method with no arguments, or just set `isStroked` to `false`.
             *
             * Note that some Shapes do not support being stroked, such as the Iso Box shape.
             *
             * This call can be chained.
             * @param lineWidth The width of line to stroke with. If not provided or undefined the Shape will not be stroked.
             * @param color The color used to stroke this shape. If not provided the Shape will not be stroked.
             * @param alpha The alpha value used when stroking this shape, if a stroke color is given. Default 1.
             */
            setStrokeStyle(lineWidth?: number, color?: number, alpha?: number): this;

            /**
             * Sets if this Shape path is closed during rendering when stroked.
             * Note that some Shapes are always closed when stroked (such as Ellipse shapes)
             *
             * This call can be chained.
             * @param value Set to `true` if the Shape should be closed when stroked, otherwise `false`.
             */
            setClosePath(value: boolean): this;

            /**
             * Internal destroy handler, called as part of the destroy process.
             */
            protected preDestroy(): void;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Star Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports both fill and stroke colors.
         *
         * As the name implies, the Star shape will display a star in your game. You can control several
         * aspects of it including the number of points that constitute the star. The default is 5. If
         * you change it to 4 it will render as a diamond. If you increase them, you'll get a more spiky
         * star shape.
         *
         * You can also control the inner and outer radius, which is how 'long' each point of the star is.
         * Modify these values to create more interesting shapes.
         */
        class Star extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param points The number of points on the star. Default 5.
             * @param innerRadius The inner radius of the star. Default 32.
             * @param outerRadius The outer radius of the star. Default 64.
             * @param fillColor The color the star will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the star will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            constructor(scene: Scene, x?: number, y?: number, points?: number, innerRadius?: number, outerRadius?: number, fillColor?: number, fillAlpha?: number);

            /**
             * Sets the number of points that make up the Star shape.
             * This call can be chained.
             * @param value The amount of points the Star will have.
             */
            setPoints(value: integer): this;

            /**
             * Sets the inner radius of the Star shape.
             * This call can be chained.
             * @param value The amount to set the inner radius to.
             */
            setInnerRadius(value: number): this;

            /**
             * Sets the outer radius of the Star shape.
             * This call can be chained.
             * @param value The amount to set the outer radius to.
             */
            setOuterRadius(value: number): this;

            /**
             * The number of points that make up the Star shape.
             */
            points: integer;

            /**
             * The inner radius of the Star shape.
             */
            innerRadius: number;

            /**
             * The outer radius of the Star shape.
             */
            outerRadius: number;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can
         * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling
         * it for input or physics. It provides a quick and easy way for you to render this shape in your
         * game without using a texture, while still taking advantage of being fully batched in WebGL.
         *
         * This shape supports both fill and stroke colors.
         *
         * The Triangle consists of 3 lines, joining up to form a triangular shape. You can control the
         * position of each point of these lines. The triangle is always closed and cannot have an open
         * face. If you require that, consider using a Polygon instead.
         */
        class Triangle extends Shape {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param x1 The horizontal position of the first point in the triangle. Default 0.
             * @param y1 The vertical position of the first point in the triangle. Default 128.
             * @param x2 The horizontal position of the second point in the triangle. Default 64.
             * @param y2 The vertical position of the second point in the triangle. Default 0.
             * @param x3 The horizontal position of the third point in the triangle. Default 128.
             * @param y3 The vertical position of the third point in the triangle. Default 128.
             * @param fillColor The color the triangle will be filled with, i.e. 0xff0000 for red.
             * @param fillAlpha The alpha the triangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.
             */
            constructor(scene: Scene, x?: number, y?: number, x1?: number, y1?: number, x2?: number, y2?: number, x3?: number, y3?: number, fillColor?: number, fillAlpha?: number);

            /**
             * Sets the data for the lines that make up this Triangle shape.
             * @param x1 The horizontal position of the first point in the triangle. Default 0.
             * @param y1 The vertical position of the first point in the triangle. Default 0.
             * @param x2 The horizontal position of the second point in the triangle. Default 0.
             * @param y2 The vertical position of the second point in the triangle. Default 0.
             * @param x3 The horizontal position of the third point in the triangle. Default 0.
             * @param y3 The vertical position of the third point in the triangle. Default 0.
             */
            setTo(x1?: number, y1?: number, x2?: number, y2?: number, x3?: number, y3?: number): this;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * A Sprite Game Object.
         *
         * A Sprite Game Object is used for the display of both static and animated images in your game.
         * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled
         * and animated.
         *
         * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.
         * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation
         * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.
         */
        class Sprite extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.ScaleMode,
                Components.ScrollFactor,
                Components.Size,
                Components.TextureCrop,
                Components.Tint,
                Components.Transform,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Scene, x: number, y: number, texture: string, frame?: string | integer);

            /**
             * The Animation Controller of this Sprite.
             */
            anims: Components.Animation;

            /**
             * Update this Sprite's animations.
             * @param time The current timestamp.
             * @param delta The delta time, in ms, elapsed since the last frame.
             */
            protected preUpdate(time: number, delta: number): void;

            /**
             * Start playing the given animation.
             * @param key The string-based key of the animation to play.
             * @param ignoreIfPlaying If an animation is already playing then ignore this call. Default false.
             * @param startFrame Optionally start the animation playing from this frame index. Default 0.
             */
            play(key: string, ignoreIfPlaying?: boolean, startFrame?: integer): Sprite;

            /**
             * Build a JSON representation of this Sprite.
             */
            toJSON(): JSONGameObject;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): this;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): this;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): this;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): this;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): this;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Textures.Frame): this;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * A boolean flag indicating if this Game Object is being cropped or not.
             * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
             * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
             */
            isCropped: boolean;

            /**
             * Applies a crop to a texture based Game Object, such as a Sprite or Image.
             *
             * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
             *
             * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
             * changes what is shown when rendered.
             *
             * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
             *
             * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
             * half of it, you could call `setCrop(0, 0, 400, 600)`.
             *
             * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
             * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
             *
             * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
             *
             * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
             *
             * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
             * the renderer to skip several internal calculations.
             * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
             * @param y The y coordinate to start the crop from.
             * @param width The width of the crop rectangle in pixels.
             * @param height The height of the crop rectangle in pixels.
             */
            setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): this;

            /**
             * Sets the frame this Game Object will use to render with.
             *
             * The Frame has to belong to the current Texture being used.
             *
             * It can be either a string or an index.
             *
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

            /**
             * Fill or additive?
             */
            tintFill: boolean;

            /**
             * Clears all tint values associated with this Game Object.
             *
             * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
             * which results in no visible change to the texture.
             */
            clearTint(): this;

            /**
             * Sets an additive tint on this Game Object.
             *
             * The tint works by taking the pixel color values from the Game Objects texture, and then
             * multiplying it by the color value of the tint. You can provide either one color value,
             * in which case the whole Game Object will be tinted in that color. Or you can provide a color
             * per corner. The colors are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * Sets a fill-based tint on this Game Object.
             *
             * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
             * with those in the tint. You can use this for effects such as making a player flash 'white'
             * if hit by something. You can provide either one color value, in which case the whole
             * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
             * are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * Does this Game Object have a tint applied to it or not?
             */
            readonly isTinted: boolean;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * A Text Game Object.
         *
         * Text objects work by creating their own internal hidden Canvas and then renders text to it using
         * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered
         * to your game during the render pass.
         *
         * Because it uses the Canvas API you can take advantage of all the features this offers, such as
         * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts
         * loaded externally, such as Google or interfaceKit Web fonts.
         *
         * **Important:** If the font you wish to use has a space or digit in its name, such as
         * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes, either
         * when creating the Text object, or when setting the font via `setFont` or `setFontFamily`. I.e.:
         *
         * ```javascript
         * this.add.text(0, 0, 'Hello World', { fontFamily: '"Roboto Condensed"' });
         * ```
         *
         * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all
         * quoted properly, too:
         *
         * ```javascript
         * this.add.text(0, 0, 'Hello World', { fontFamily: 'Verdana, "Times New Roman", Tahoma, serif' });
         * ```
         *
         * You can only display fonts that are currently loaded and available to the browser: therefore fonts must
         * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,
         * or have the fonts ready available in the CSS on the page in which your Phaser game resides.
         *
         * See {@link http://www.jordanm.co.uk/tinyinterface this compatibility table} for the available default fonts
         * across mobile browsers.
         *
         * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being
         * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the
         * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of
         * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text
         * instead, as it benefits from batching and avoids expensive Canvas API calls.
         */
        class Text extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.ComputedSize,
                Components.Crop,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.ScaleMode,
                Components.ScrollFactor,
                Components.Tint,
                Components.Transform,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param text The text this Text object will display.
             * @param style The text style configuration object.
             */
            constructor(scene: Scene, x: number, y: number, text: string | string[], style: object);

            /**
             * Returns an object containing dimensions of the Text object.
             * @param text The Text object to calculate the size from.
             * @param size The Text metrics to use when calculating the size.
             * @param lines The lines of text to calculate the size from.
             */
            static GetTextSize(text: Text, size: BitmapTextMetrics, lines: any[]): object;

            /**
             * Calculates the ascent, descent and fontSize of a given font style.
             * @param textStyle The TextStyle object to measure.
             */
            static MeasureText(textStyle: TextStyle): object;

            /**
             * The renderer in use by this Text object.
             */
            renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer;

            /**
             * The canvas element that the text is rendered to.
             */
            canvas: HTMLCanvasElement;

            /**
             * The context of the canvas element that the text is rendered to.
             */
            context: CanvasRenderingContext2D;

            /**
             * The Text Style object.
             *
             * Manages the style of this Text object.
             */
            style: TextStyle;

            /**
             * Whether to automatically round line positions.
             */
            autoRound: boolean;

            /**
             * The Regular Expression that is used to split the text up into lines, in
             * multi-line text. By default this is `/(?:\r\n|\r|\n)/`.
             * You can change this RegExp to be anything else that you may need.
             */
            splitRegExp: object;

            /**
             * Specify a padding value which is added to the line width and height when calculating the Text size.
             * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions.
             */
            padding: object;

            /**
             * The width of this Text object.
             */
            width: number;

            /**
             * The height of this Text object.
             */
            height: number;

            /**
             * The line spacing value.
             * This value is added to the font height to calculate the overall line height.
             * Only has an effect if this Text object contains multiple lines of text.
             *
             * If you update this property directly, instead of using the `setLineSpacing` method, then
             * be sure to call `updateText` after, or you won't see the change reflected in the Text object.
             */
            lineSpacing: number;

            /**
             * Whether the text or its settings have changed and need updating.
             */
            dirty: boolean;

            /**
             * Initialize right to left text.
             */
            initRTL(): void;

            /**
             * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal
             * bounds.
             * @param text The text to perform word wrap detection against.
             */
            runWordWrap(text: string): string;

            /**
             * Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal
             * bounds. Consecutive spaces will be collapsed and replaced with a single space. Lines will be
             * trimmed of white space before processing. Throws an error if wordWrapWidth is less than a
             * single character.
             * @param text The text to perform word wrap detection against.
             * @param context The Canvas Rendering Context.
             * @param wordWrapWidth The word wrap width.
             */
            advancedWordWrap(text: string, context: CanvasRenderingContext2D, wordWrapWidth: number): string;

            /**
             * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal
             * bounds. Spaces are not collapsed and whitespace is not trimmed.
             * @param text The text to perform word wrap detection against.
             * @param context The Canvas Rendering Context.
             * @param wordWrapWidth The word wrap width.
             */
            basicWordWrap(text: string, context: CanvasRenderingContext2D, wordWrapWidth: number): string;

            /**
             * Runs the given text through this Text objects word wrapping and returns the results as an
             * array, where each element of the array corresponds to a wrapped line of text.
             * @param text The text for which the wrapping will be calculated. If unspecified, the Text objects current text will be used.
             */
            getWrappedText(text: string): string[];

            /**
             * Set the text to display.
             *
             * An array of strings will be joined with `\n` line breaks.
             * @param value The string, or array of strings, to be set as the content of this Text object.
             */
            setText(value: string | string[]): Text;

            /**
             * Set the text style.
             * @param style The style settings to set.
             */
            setStyle(style: object): Text;

            /**
             * Set the font.
             *
             * If a string is given, the font family is set.
             *
             * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`
             * properties of that object are set.
             *
             * **Important:** If the font you wish to use has a space or digit in its name, such as
             * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes:
             *
             * ```javascript
             * Text.setFont('"Roboto Condensed"');
             * ```
             *
             * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all
             * quoted properly, too:
             *
             * ```javascript
             * Text.setFont('Verdana, "Times New Roman", Tahoma, serif');
             * ```
             * @param font The font family or font settings to set.
             */
            setFont(font: string): Text;

            /**
             * Set the font family.
             *
             * **Important:** If the font you wish to use has a space or digit in its name, such as
             * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes:
             *
             * ```javascript
             * Text.setFont('"Roboto Condensed"');
             * ```
             *
             * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all
             * quoted properly, too:
             *
             * ```javascript
             * Text.setFont('Verdana, "Times New Roman", Tahoma, serif');
             * ```
             * @param family The font family.
             */
            setFontFamily(family: string): Text;

            /**
             * Set the font size.
             * @param size The font size.
             */
            setFontSize(size: number): Text;

            /**
             * Set the font style.
             * @param style The font style.
             */
            setFontStyle(style: string): Text;

            /**
             * Set a fixed width and height for the text.
             *
             * Pass in `0` for either of these parameters to disable fixed width or height respectively.
             * @param width The fixed width to set. `0` disables fixed width.
             * @param height The fixed height to set. `0` disables fixed height.
             */
            setFixedSize(width: number, height: number): Text;

            /**
             * Set the background color.
             * @param color The background color.
             */
            setBackgroundColor(color: string): Text;

            /**
             * Set the fill style to be used by the Text object.
             *
             * This can be any valid CanvasRenderingContext2D fillStyle value, such as
             * a color (in hex, rgb, rgba, hsl or named values), a gradient or a pattern.
             *
             * See the [MDN fillStyle docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle) for more details.
             * @param color The text fill style. Can be any valid CanvasRenderingContext `fillStyle` value.
             */
            setFill(color: string | CanvasGradient | CanvasPattern): Text;

            /**
             * Set the text fill color.
             * @param color The text fill color.
             */
            setColor(color: string): Text;

            /**
             * Set the stroke settings.
             * @param color The stroke color.
             * @param thickness The stroke thickness.
             */
            setStroke(color: string, thickness: number): Text;

            /**
             * Set the shadow settings.
             * @param x The horizontal shadow offset. Default 0.
             * @param y The vertical shadow offset. Default 0.
             * @param color The shadow color. Default '#000'.
             * @param blur The shadow blur radius. Default 0.
             * @param shadowStroke Whether to stroke the shadow. Default false.
             * @param shadowFill Whether to fill the shadow. Default true.
             */
            setShadow(x?: number, y?: number, color?: string, blur?: number, shadowStroke?: boolean, shadowFill?: boolean): Text;

            /**
             * Set the shadow offset.
             * @param x The horizontal shadow offset.
             * @param y The vertical shadow offset.
             */
            setShadowOffset(x: number, y: number): Text;

            /**
             * Set the shadow color.
             * @param color The shadow color.
             */
            setShadowColor(color: string): Text;

            /**
             * Set the shadow blur radius.
             * @param blur The shadow blur radius.
             */
            setShadowBlur(blur: number): Text;

            /**
             * Enable or disable shadow stroke.
             * @param enabled Whether shadow stroke is enabled or not.
             */
            setShadowStroke(enabled: boolean): Text;

            /**
             * Enable or disable shadow fill.
             * @param enabled Whether shadow fill is enabled or not.
             */
            setShadowFill(enabled: boolean): Text;

            /**
             * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.
             * @param width The maximum width of a line in pixels. Set to null to remove wrapping.
             * @param useAdvancedWrap Whether or not to use the advanced wrapping
             * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,
             * spaces and whitespace are left as is. Default false.
             */
            setWordWrapWidth(width: number, useAdvancedWrap?: boolean): Text;

            /**
             * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.
             * @param callback A custom function that will be responsible for wrapping the
             * text. It will receive two arguments: text (the string to wrap), textObject (this Text
             * instance). It should return the wrapped lines either as an array of lines or as a string with
             * newline characters in place to indicate where breaks should happen.
             * @param scope The scope that will be applied when the callback is invoked. Default null.
             */
            setWordWrapCallback(callback: TextStyleWordWrapCallback, scope?: object): Text;

            /**
             * Set the text alignment.
             *
             * Expects values like `'left'`, `'right'`, `'center'` or `'justified'`.
             * @param align The text alignment.
             */
            setAlign(align: string): Text;

            /**
             * Set the resolution used by this Text object.
             *
             * By default it will be set to match the resolution set in the Game Config,
             * but you can override it via this method, or by specifying it in the Text style configuration object.
             *
             * It allows for much clearer text on High DPI devices, at the cost of memory because it uses larger
             * internal Canvas textures for the Text.
             *
             * Therefore, please use with caution, as the more high res Text you have, the more memory it uses.
             * @param value The resolution for this Text object to use.
             */
            setResolution(value: number): Text;

            /**
             * Sets the line spacing value.
             *
             * This value is _added_ to the height of the font when calculating the overall line height.
             * This only has an effect if this Text object consists of multiple lines of text.
             * @param value The amount to add to the font height to achieve the overall line height.
             */
            setLineSpacing(value: number): Text;

            /**
             * Set the text padding.
             *
             * 'left' can be an object.
             *
             * If only 'left' and 'top' are given they are treated as 'x' and 'y'.
             * @param left The left padding value, or a padding config object.
             * @param top The top padding value.
             * @param right The right padding value.
             * @param bottom The bottom padding value.
             */
            setPadding(left: number | object, top: number, right: number, bottom: number): Text;

            /**
             * Set the maximum number of lines to draw.
             * @param max The maximum number of lines to draw. Default 0.
             */
            setMaxLines(max?: integer): Text;

            /**
             * Update the displayed text.
             */
            updateText(): Text;

            /**
             * Get the current text metrics.
             */
            getTextMetrics(): object;

            /**
             * The text string being rendered by this Text Game Object.
             */
            text: string;

            /**
             * Build a JSON representation of the Text object.
             */
            toJSON(): JSONGameObject;

            /**
             * Internal destroy handler, called as part of the destroy process.
             */
            protected preDestroy(): void;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * A boolean flag indicating if this Game Object is being cropped or not.
             * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
             * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
             */
            isCropped: boolean;

            /**
             * Applies a crop to a texture based Game Object, such as a Sprite or Image.
             *
             * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
             *
             * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
             * changes what is shown when rendered.
             *
             * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
             *
             * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
             * half of it, you could call `setCrop(0, 0, 400, 600)`.
             *
             * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
             * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
             *
             * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
             *
             * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
             *
             * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
             * the renderer to skip several internal calculations.
             * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
             * @param y The y coordinate to start the crop from.
             * @param width The width of the crop rectangle in pixels.
             * @param height The height of the crop rectangle in pixels.
             */
            setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): this;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): this;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): this;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): this;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): this;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * Fill or additive?
             */
            tintFill: boolean;

            /**
             * Clears all tint values associated with this Game Object.
             *
             * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
             * which results in no visible change to the texture.
             */
            clearTint(): this;

            /**
             * Sets an additive tint on this Game Object.
             *
             * The tint works by taking the pixel color values from the Game Objects texture, and then
             * multiplying it by the color value of the tint. You can provide either one color value,
             * in which case the whole Game Object will be tinted in that color. Or you can provide a color
             * per corner. The colors are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * Sets a fill-based tint on this Game Object.
             *
             * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
             * with those in the tint. You can use this for effects such as making a player flash 'white'
             * if hit by something. You can provide either one color value, in which case the whole
             * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
             * are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * Does this Game Object have a tint applied to it or not?
             */
            readonly isTinted: boolean;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * A TextStyle class manages all of the style settings for a Text object.
         *
         * Text Game Objects create a TextStyle instance automatically, which is
         * accessed via the `Text.style` property. You do not normally need to
         * instantiate one yourself.
         */
        class TextStyle {
            /**
             *
             * @param text The Text object that this TextStyle is styling.
             * @param style The style settings to set.
             */
            constructor(text: Text, style: object);

            /**
             * The Text object that this TextStyle is styling.
             */
            parent: Text;

            /**
             * The font family.
             */
            fontFamily: string;

            /**
             * The font size.
             */
            fontSize: string;

            /**
             * The font style.
             */
            fontStyle: string;

            /**
             * The background color.
             */
            backgroundColor: string;

            /**
             * The text fill color.
             */
            color: string;

            /**
             * The text stroke color.
             */
            stroke: string;

            /**
             * The text stroke thickness.
             */
            strokeThickness: number;

            /**
             * The horizontal shadow offset.
             */
            shadowOffsetX: number;

            /**
             * The vertical shadow offset.
             */
            shadowOffsetY: number;

            /**
             * The shadow color.
             */
            shadowColor: string;

            /**
             * The shadow blur radius.
             */
            shadowBlur: number;

            /**
             * Whether shadow stroke is enabled or not.
             */
            shadowStroke: boolean;

            /**
             * Whether shadow fill is enabled or not.
             */
            shadowFill: boolean;

            /**
             * The text alignment.
             */
            align: string;

            /**
             * The maximum number of lines to draw.
             */
            maxLines: integer;

            /**
             * The fixed width of the text.
             *
             * `0` means no fixed with.
             */
            fixedWidth: number;

            /**
             * The fixed height of the text.
             *
             * `0` means no fixed height.
             */
            fixedHeight: number;

            /**
             * The resolution the text is rendered to its internal canvas at.
             * The default is 0, which means it will use the resolution set in the Game Config.
             */
            resolution: number;

            /**
             * Whether the text should render right to left.
             */
            rtl: boolean;

            /**
             * The test string to use when measuring the font.
             */
            testString: string;

            /**
             * The amount of horizontal padding adding to the width of the text when calculating the font metrics.
             */
            baselineX: number;

            /**
             * The amount of vertical padding adding to the width of the text when calculating the font metrics.
             */
            baselineY: number;

            /**
             * Set the text style.
             * @param style The style settings to set.
             * @param updateText Whether to update the text immediately. Default true.
             * @param setDefaults Use the default values is not set, or the local values. Default false.
             */
            setStyle(style: object, updateText?: boolean, setDefaults?: boolean): Text;

            /**
             * Synchronize the font settings to the given Canvas Rendering Context.
             * @param canvas The Canvas Element.
             * @param context The Canvas Rendering Context.
             */
            syncFont(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D): void;

            /**
             * Synchronize the text style settings to the given Canvas Rendering Context.
             * @param canvas The Canvas Element.
             * @param context The Canvas Rendering Context.
             */
            syncStyle(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D): void;

            /**
             * Synchronize the shadow settings to the given Canvas Rendering Context.
             * @param context The Canvas Rendering Context.
             * @param enabled Whether shadows are enabled or not.
             */
            syncShadow(context: CanvasRenderingContext2D, enabled: boolean): void;

            /**
             * Update the style settings for the parent Text object.
             * @param recalculateMetrics Whether to recalculate font and text metrics.
             */
            update(recalculateMetrics: boolean): Text;

            /**
             * Set the font.
             *
             * If a string is given, the font family is set.
             *
             * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`
             * properties of that object are set.
             * @param font The font family or font settings to set.
             * @param updateText Whether to update the text immediately. Default true.
             */
            setFont(font: string | object, updateText?: boolean): Text;

            /**
             * Set the font family.
             * @param family The font family.
             */
            setFontFamily(family: string): Text;

            /**
             * Set the font style.
             * @param style The font style.
             */
            setFontStyle(style: string): Text;

            /**
             * Set the font size.
             * @param size The font size.
             */
            setFontSize(size: number | string): Text;

            /**
             * Set the test string to use when measuring the font.
             * @param string The test string to use when measuring the font.
             */
            setTestString(string: string): Text;

            /**
             * Set a fixed width and height for the text.
             *
             * Pass in `0` for either of these parameters to disable fixed width or height respectively.
             * @param width The fixed width to set.
             * @param height The fixed height to set.
             */
            setFixedSize(width: number, height: number): Text;

            /**
             * Set the background color.
             * @param color The background color.
             */
            setBackgroundColor(color: string): Text;

            /**
             * Set the text fill color.
             * @param color The text fill color.
             */
            setFill(color: string): Text;

            /**
             * Set the text fill color.
             * @param color The text fill color.
             */
            setColor(color: string): Text;

            /**
             * Set the resolution used by the Text object.
             *
             * By default it will be set to match the resolution set in the Game Config,
             * but you can override it via this method. It allows for much clearer text on High DPI devices,
             * at the cost of memory because it uses larger internal Canvas textures for the Text.
             *
             * Please use with caution, as the more high res Text you have, the more memory it uses up.
             * @param value The resolution for this Text object to use.
             */
            setResolution(value: number): Text;

            /**
             * Set the stroke settings.
             * @param color The stroke color.
             * @param thickness The stroke thickness.
             */
            setStroke(color: string, thickness: number): Text;

            /**
             * Set the shadow settings.
             *
             * Calling this method always re-measures the parent Text object,
             * so only call it when you actually change the shadow settings.
             * @param x The horizontal shadow offset. Default 0.
             * @param y The vertical shadow offset. Default 0.
             * @param color The shadow color. Default '#000'.
             * @param blur The shadow blur radius. Default 0.
             * @param shadowStroke Whether to stroke the shadow. Default false.
             * @param shadowFill Whether to fill the shadow. Default true.
             */
            setShadow(x?: number, y?: number, color?: string, blur?: number, shadowStroke?: boolean, shadowFill?: boolean): Text;

            /**
             * Set the shadow offset.
             * @param x The horizontal shadow offset. Default 0.
             * @param y The vertical shadow offset. Default 0.
             */
            setShadowOffset(x?: number, y?: number): Text;

            /**
             * Set the shadow color.
             * @param color The shadow color. Default '#000'.
             */
            setShadowColor(color?: string): Text;

            /**
             * Set the shadow blur radius.
             * @param blur The shadow blur radius. Default 0.
             */
            setShadowBlur(blur?: number): Text;

            /**
             * Enable or disable shadow stroke.
             * @param enabled Whether shadow stroke is enabled or not.
             */
            setShadowStroke(enabled: boolean): Text;

            /**
             * Enable or disable shadow fill.
             * @param enabled Whether shadow fill is enabled or not.
             */
            setShadowFill(enabled: boolean): Text;

            /**
             * Set the width (in pixels) to use for wrapping lines.
             *
             * Pass in null to remove wrapping by width.
             * @param width The maximum width of a line in pixels. Set to null to remove wrapping.
             * @param useAdvancedWrap Whether or not to use the advanced wrapping
             * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,
             * spaces and whitespace are left as is. Default false.
             */
            setWordWrapWidth(width: number, useAdvancedWrap?: boolean): Text;

            /**
             * Set a custom callback for wrapping lines.
             *
             * Pass in null to remove wrapping by callback.
             * @param callback A custom function that will be responsible for wrapping the
             * text. It will receive two arguments: text (the string to wrap), textObject (this Text
             * instance). It should return the wrapped lines either as an array of lines or as a string with
             * newline characters in place to indicate where breaks should happen.
             * @param scope The scope that will be applied when the callback is invoked. Default null.
             */
            setWordWrapCallback(callback: TextStyleWordWrapCallback, scope?: object): Text;

            /**
             * Set the text alignment.
             *
             * Expects values like `'left'`, `'right'`, `'center'` or `'justified'`.
             * @param align The text alignment.
             */
            setAlign(align: string): Text;

            /**
             * Set the maximum number of lines to draw.
             * @param max The maximum number of lines to draw. Default 0.
             */
            setMaxLines(max?: integer): Text;

            /**
             * Get the current text metrics.
             */
            getTextMetrics(): BitmapTextMetrics;

            /**
             * Build a JSON representation of this Text Style.
             */
            toJSON(): object;

            /**
             * Destroy this Text Style.
             */
            destroy(): void;
        }

        /**
         * A TileSprite is a Sprite that has a repeating texture.
         *
         * The texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and
         * are designed so that you can create game backdrops using seamless textures as a source.
         *
         * You shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background
         * that scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`
         * property to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will
         * consume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to
         * adjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.
         *
         * An important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide
         * seamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means
         * they need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a
         * TileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then
         * scaled back down again during rendering to the original dimensions. While this works, in that it allows you to use
         * any size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,
         * due to the interpolation that took place when it was resized into a POT texture. This is especially visible in
         * pixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you
         * provide POT textures for Tile Sprites.
         */
        class TileSprite extends GameObject
            implements
                Components.Alpha,
                Components.BlendMode,
                Components.ComputedSize,
                Components.Crop,
                Components.Depth,
                Components.Flip,
                Components.GetBounds,
                Components.Mask,
                Components.Origin,
                Components.Pipeline,
                Components.ScaleMode,
                Components.ScrollFactor,
                Components.Tint,
                Components.Transform,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Game Object. If zero it will use the size of the texture frame.
             * @param height The height of the Game Object. If zero it will use the size of the texture frame.
             * @param textureKey The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frameKey An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Scene, x: number, y: number, width: integer, height: integer, textureKey: string, frameKey?: string | integer);

            /**
             * Whether the Tile Sprite has changed in some way, requiring an re-render of its tile texture.
             *
             * Such changes include the texture frame and scroll position of the Tile Sprite.
             */
            dirty: boolean;

            /**
             * The renderer in use by this Tile Sprite.
             */
            renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer;

            /**
             * The Canvas element that the TileSprite renders its fill pattern in to.
             * Only used in Canvas mode.
             */
            canvas: HTMLCanvasElement;

            /**
             * The Context of the Canvas element that the TileSprite renders its fill pattern in to.
             * Only used in Canvas mode.
             */
            context: CanvasRenderingContext2D;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Textures.Texture | Textures.CanvasTexture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Textures.Frame;

            /**
             * The next power of two value from the width of the Fill Pattern frame.
             */
            potWidth: integer;

            /**
             * The next power of two value from the height of the Fill Pattern frame.
             */
            potHeight: integer;

            /**
             * The Canvas that the TileSprites texture is rendered to.
             * This is used to create a WebGL texture from.
             */
            fillCanvas: HTMLCanvasElement;

            /**
             * The Canvas Context used to render the TileSprites texture.
             */
            fillContext: CanvasRenderingContext2D;

            /**
             * The texture that the Tile Sprite is rendered to, which is then rendered to a Scene.
             * In WebGL this is a WebGLTexture. In Canvas it's a Canvas Fill Pattern.
             */
            fillPattern: WebGLTexture | CanvasPattern;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             *
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): this;

            /**
             * Sets the frame this Game Object will use to render with.
             *
             * The Frame has to belong to the current Texture being used.
             *
             * It can be either a string or an index.
             * @param frame The name or index of the frame within the Texture.
             */
            setFrame(frame: string | integer): this;

            /**
             * Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.
             * @param x The x position of this sprite's tiling texture.
             * @param y The y position of this sprite's tiling texture.
             */
            setTilePosition(x?: number, y?: number): this;

            /**
             * Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.
             * @param x The horizontal scale of the tiling texture.
             * @param y The vertical scale of the tiling texture.
             */
            setTileScale(x?: number, y?: number): this;

            /**
             * Internal destroy handler, called as part of the destroy process.
             */
            protected preDestroy(): void;

            /**
             * The horizontal scroll position of the Tile Sprite.
             */
            tilePositionX: number;

            /**
             * The vertical scroll position of the Tile Sprite.
             */
            tilePositionY: number;

            /**
             * The horizontal scale of the Tile Sprite texture.
             */
            tileScaleX: number;

            /**
             * The vertical scale of the Tile Sprite texture.
             */
            tileScaleY: number;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * A boolean flag indicating if this Game Object is being cropped or not.
             * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
             * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
             */
            isCropped: boolean;

            /**
             * Applies a crop to a texture based Game Object, such as a Sprite or Image.
             *
             * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
             *
             * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
             * changes what is shown when rendered.
             *
             * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
             *
             * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
             * half of it, you could call `setCrop(0, 0, 400, 600)`.
             *
             * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
             * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
             *
             * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
             *
             * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
             *
             * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
             * the renderer to skip several internal calculations.
             * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
             * @param y The y coordinate to start the crop from.
             * @param width The width of the crop rectangle in pixels.
             * @param height The height of the crop rectangle in pixels.
             */
            setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): this;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): this;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): this;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): this;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): this;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The Mask this Game Object is using during render.
             */
            mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

            /**
             * Sets the mask that this Game Object will use to render with.
             *
             * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
             * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
             *
             * If a mask is already set on this Game Object it will be immediately replaced.
             *
             * Masks are positioned in global space and are not relative to the Game Object to which they
             * are applied. The reason for this is that multiple Game Objects can all share the same mask.
             *
             * Masks have no impact on physics or input detection. They are purely a rendering component
             * that allows you to limit what is visible during the render pass.
             * @param mask The mask this Game Object will use when rendering.
             */
            setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

            /**
             * Clears the mask that this Game Object was using.
             * @param destroyMask Destroy the mask before clearing it? Default false.
             */
            clearMask(destroyMask?: boolean): this;

            /**
             * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a renderable Game Object.
             * A renderable Game Object is one that uses a texture to render with, such as an
             * Image, Sprite, Render Texture or BitmapText.
             *
             * If you do not provide a renderable object, and this Game Object has a texture,
             * it will use itself as the object. This means you can call this method to create
             * a Bitmap Mask from any renderable Game Object.
             * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
             */
            createBitmapMask(renderable?: GameObject): Display.Masks.BitmapMask;

            /**
             * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
             * including this one.
             *
             * To create the mask you need to pass in a reference to a Graphics Game Object.
             *
             * If you do not provide a graphics object, and this Game Object is an instance
             * of a Graphics object, then it will use itself to create the mask.
             *
             * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
             * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
             */
            createGeometryMask(graphics?: Graphics): Display.Masks.GeometryMask;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * Fill or additive?
             */
            tintFill: boolean;

            /**
             * Clears all tint values associated with this Game Object.
             *
             * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
             * which results in no visible change to the texture.
             */
            clearTint(): this;

            /**
             * Sets an additive tint on this Game Object.
             *
             * The tint works by taking the pixel color values from the Game Objects texture, and then
             * multiplying it by the color value of the tint. You can provide either one color value,
             * in which case the whole Game Object will be tinted in that color. Or you can provide a color
             * per corner. The colors are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * Sets a fill-based tint on this Game Object.
             *
             * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
             * with those in the tint. You can use this for effects such as making a player flash 'white'
             * if hit by something. You can provide either one color value, in which case the whole
             * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
             * are blended together across the extent of the Game Object.
             *
             * To modify the tint color once set, either call this method again with new values or use the
             * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
             * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
             *
             * To remove a tint call `clearTint`.
             *
             * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * Does this Game Object have a tint applied to it or not?
             */
            readonly isTinted: boolean;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * The Update List plugin.
         *
         * Update Lists belong to a Scene and maintain the list Game Objects to be updated every frame.
         *
         * Some or all of these Game Objects may also be part of the Scene's [Display List]{@link Phaser.GameObjects.DisplayList}, for Rendering.
         */
        class UpdateList {
            /**
             *
             * @param scene The Scene that the Update List belongs to.
             */
            constructor(scene: Scene);

            /**
             * The Scene that the Update List belongs to.
             */
            scene: Scene;

            /**
             * The Scene's Systems.
             */
            systems: Scenes.Systems;

            /**
             * Add a Game Object to the Update List.
             * @param child The Game Object to add.
             */
            add(child: GameObject): GameObject;

            /**
             * The pre-update step.
             *
             * Handles Game Objects that are pending insertion to and removal from the list.
             */
            preUpdate(): void;

            /**
             * The update step.
             *
             * Pre-updates every active Game Object in the list.
             * @param time The current timestamp.
             * @param delta The delta time elapsed since the last frame.
             */
            update(time: number, delta: number): void;

            /**
             * Remove a Game Object from the list.
             * @param child The Game Object to remove from the list.
             */
            remove(child: GameObject): GameObject;

            /**
             * Remove all Game Objects from the list.
             */
            removeAll(): UpdateList;

            /**
             * The Scene that owns this plugin is shutting down.
             * We need to kill and reset all internal properties as well as stop listening to Scene events.
             */
            shutdown(): void;

            /**
             * The Scene that owns this plugin is being destroyed.
             * We need to shutdown and then kill off all external references.
             */
            destroy(): void;

            /**
             * The length of the list.
             */
            readonly length: integer;
        }

        /**
         * A Zone Game Object.
         *
         * A Zone is a non-rendering rectangular Game Object that has a position and size.
         * It has no texture and never displays, but does live on the display list and
         * can be moved, scaled and rotated like any other Game Object.
         *
         * Its primary use is for creating Drop Zones and Input Hit Areas and it has a couple of helper methods
         * specifically for this. It is also useful for object overlap checks, or as a base for your own
         * non-displaying Game Objects.
         * The default origin is 0.5, the center of the Zone, the same as with Game Objects.
         */
        class Zone extends GameObject
            implements
                Components.Depth,
                Components.GetBounds,
                Components.Origin,
                Components.ScaleMode,
                Components.Transform,
                Components.ScrollFactor,
                Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Game Object. Default 1.
             * @param height The height of the Game Object. Default 1.
             */
            constructor(scene: Scene, x: number, y: number, width?: number, height?: number);

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The Blend Mode of the Game Object.
             * Although a Zone never renders, it still has a blend mode to allow it to fit seamlessly into
             * display lists without causing a batch flush.
             */
            blendMode: integer;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             * @param resizeInput If this Zone has a Rectangle for a hit area this argument will resize the hit area as well. Default true.
             */
            setSize(width: number, height: number, resizeInput?: boolean): Zone;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Zone;

            /**
             * Sets this Zone to be a Circular Drop Zone.
             * The circle is centered on this Zones `x` and `y` coordinates.
             * @param radius The radius of the Circle that will form the Drop Zone.
             */
            setCircleDropZone(radius: number): Zone;

            /**
             * Sets this Zone to be a Rectangle Drop Zone.
             * The rectangle is centered on this Zones `x` and `y` coordinates.
             * @param width The width of the rectangle drop zone.
             * @param height The height of the rectangle drop zone.
             */
            setRectangleDropZone(width: number, height: number): Zone;

            /**
             * Allows you to define your own Geometry shape to be used as a Drop Zone.
             * @param shape A Geometry shape instance, such as Phaser.Geom.Ellipse, or your own custom shape.
             * @param callback A function that will return `true` if the given x/y coords it is sent are within the shape.
             */
            setDropZone(shape: object, callback: HitAreaCallback): Zone;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Components.TransformMatrix): Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: Components.TransformMatrix,
                parentMatrix?: Components.TransformMatrix
            ): Components.TransformMatrix;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }
    }

    namespace Geom {
        /**
         * A Circle object.
         *
         * This is a geometry object, containing numerical values and related methods to inspect and modify them.
         * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.
         * To render a Circle you should look at the capabilities of the Graphics class.
         */
        class Circle {
            /**
             *
             * @param x The x position of the center of the circle. Default 0.
             * @param y The y position of the center of the circle. Default 0.
             * @param radius The radius of the circle. Default 0.
             */
            constructor(x?: number, y?: number, radius?: number);

            /**
             * Calculates the area of the circle.
             * @param circle The Circle to get the area of.
             */
            static Area(circle: Circle): number;

            /**
             * The x position of the center of the circle.
             */
            x: number;

            /**
             * The y position of the center of the circle.
             */
            y: number;

            /**
             * Check to see if the Circle contains the given x / y coordinates.
             * @param x The x coordinate to check within the circle.
             * @param y The y coordinate to check within the circle.
             */
            contains(x: number, y: number): boolean;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Circle
             * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
             * at 180 degrees around the circle.
             * @param position A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.
             * @param out An object to store the return values in. If not given a Point object will be created.
             */
            getPoint<O extends Point>(position: number, out?: O): O;

            /**
             * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,
             * based on the given quantity or stepRate values.
             * @param quantity The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
             * @param stepRate Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.
             * @param output An array to insert the points in to. If not provided a new array will be created.
             */
            getPoints<O extends Point[]>(quantity: integer, stepRate?: number, output?: O): O;

            /**
             * Returns a uniformly distributed random point from anywhere within the Circle.
             * @param point A Point or point-like object to set the random `x` and `y` values in.
             */
            getRandomPoint<O extends Point>(point?: O): O;

            /**
             * Sets the x, y and radius of this circle.
             * @param x The x position of the center of the circle. Default 0.
             * @param y The y position of the center of the circle. Default 0.
             * @param radius The radius of the circle. Default 0.
             */
            setTo(x?: number, y?: number, radius?: number): Circle;

            /**
             * Sets this Circle to be empty with a radius of zero.
             * Does not change its position.
             */
            setEmpty(): Circle;

            /**
             * Sets the position of this Circle.
             * @param x The x position of the center of the circle. Default 0.
             * @param y The y position of the center of the circle. Default 0.
             */
            setPosition(x?: number, y?: number): Circle;

            /**
             * Checks to see if the Circle is empty: has a radius of zero.
             */
            isEmpty(): boolean;

            /**
             * The radius of the Circle.
             */
            radius: number;

            /**
             * The diameter of the Circle.
             */
            diameter: number;

            /**
             * The left position of the Circle.
             */
            left: number;

            /**
             * The right position of the Circle.
             */
            right: number;

            /**
             * The top position of the Circle.
             */
            top: number;

            /**
             * The bottom position of the Circle.
             */
            bottom: number;

            /**
             * Returns the circumference of the given Circle.
             * @param circle The Circle to get the circumference of.
             */
            static Circumference(circle: Circle): number;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
             * @param circle The Circle to get the circumference point on.
             * @param angle The angle from the center of the Circle to the circumference to return the point from. Given in radians.
             * @param out A Point, or point-like object, to store the results in. If not given a Point will be created.
             */
            static CircumferencePoint<O extends Point>(circle: Circle, angle: number, out?: O): O;

            /**
             * Creates a new Circle instance based on the values contained in the given source.
             * @param source The Circle to be cloned. Can be an instance of a Circle or a circle-like object, with x, y and radius properties.
             */
            static Clone(source: Circle | object): Circle;

            /**
             * Check to see if the Circle contains the given x / y coordinates.
             * @param circle The Circle to check.
             * @param x The x coordinate to check within the circle.
             * @param y The y coordinate to check within the circle.
             */
            static Contains(circle: Circle, x: number, y: number): boolean;

            /**
             * Check to see if the Circle contains the given Point object.
             * @param circle The Circle to check.
             * @param point The Point object to check if it's within the Circle or not.
             */
            static ContainsPoint(circle: Circle, point: Point | object): boolean;

            /**
             * Check to see if the Circle contains all four points of the given Rectangle object.
             * @param circle The Circle to check.
             * @param rect The Rectangle object to check if it's within the Circle or not.
             */
            static ContainsRect(circle: Circle, rect: Rectangle | object): boolean;

            /**
             * Copies the `x`, `y` and `radius` properties from the `source` Circle
             * into the given `dest` Circle, then returns the `dest` Circle.
             * @param source The source Circle to copy the values from.
             * @param dest The destination Circle to copy the values to.
             */
            static CopyFrom<O extends Circle>(source: Circle, dest: O): O;

            /**
             * Compares the `x`, `y` and `radius` properties of the two given Circles.
             * Returns `true` if they all match, otherwise returns `false`.
             * @param circle The first Circle to compare.
             * @param toCompare The second Circle to compare.
             */
            static Equals(circle: Circle, toCompare: Circle): boolean;

            /**
             * Returns the bounds of the Circle object.
             * @param circle The Circle to get the bounds from.
             * @param out A Rectangle, or rectangle-like object, to store the circle bounds in. If not given a new Rectangle will be created.
             */
            static GetBounds<O extends Rectangle>(circle: Circle, out?: O): O;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Circle
             * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
             * at 180 degrees around the circle.
             * @param circle The Circle to get the circumference point on.
             * @param position A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.
             * @param out An object to store the return values in. If not given a Point object will be created.
             */
            static GetPoint<O extends Point>(circle: Circle, position: number, out?: O): O;

            /**
             * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,
             * based on the given quantity or stepRate values.
             * @param circle The Circle to get the points from.
             * @param quantity The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
             * @param stepRate Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.
             * @param output An array to insert the points in to. If not provided a new array will be created.
             */
            static GetPoints(circle: Circle, quantity: integer, stepRate?: number, output?: any[]): Point[];

            /**
             * Offsets the Circle by the values given.
             * @param circle The Circle to be offset (translated.)
             * @param x The amount to horizontally offset the Circle by.
             * @param y The amount to vertically offset the Circle by.
             */
            static Offset<O extends Circle>(circle: O, x: number, y: number): O;

            /**
             * Offsets the Circle by the values given in the `x` and `y` properties of the Point object.
             * @param circle The Circle to be offset (translated.)
             * @param point The Point object containing the values to offset the Circle by.
             */
            static OffsetPoint<O extends Circle>(circle: O, point: Point | object): O;

            /**
             * Returns a uniformly distributed random point from anywhere within the given Circle.
             * @param circle The Circle to get a random point from.
             * @param out A Point or point-like object to set the random `x` and `y` values in.
             */
            static Random<O extends Point>(circle: Circle, out?: O): O;
        }

        /**
         * An Ellipse object.
         *
         * This is a geometry object, containing numerical values and related methods to inspect and modify them.
         * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.
         * To render an Ellipse you should look at the capabilities of the Graphics class.
         */
        class Ellipse {
            /**
             *
             * @param x The x position of the center of the ellipse. Default 0.
             * @param y The y position of the center of the ellipse. Default 0.
             * @param width The width of the ellipse. Default 0.
             * @param height The height of the ellipse. Default 0.
             */
            constructor(x?: number, y?: number, width?: number, height?: number);

            /**
             * Calculates the area of the Ellipse.
             * @param ellipse The Ellipse to get the area of.
             */
            static Area(ellipse: Ellipse): number;

            /**
             * Returns the circumference of the given Ellipse.
             * @param ellipse The Ellipse to get the circumference of.
             */
            static Circumference(ellipse: Ellipse): number;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse based on the given angle.
             * @param ellipse The Ellipse to get the circumference point on.
             * @param angle The angle from the center of the Ellipse to the circumference to return the point from. Given in radians.
             * @param out A Point, or point-like object, to store the results in. If not given a Point will be created.
             */
            static CircumferencePoint<O extends Point>(ellipse: Ellipse, angle: number, out?: O): O;

            /**
             * Creates a new Ellipse instance based on the values contained in the given source.
             * @param source The Ellipse to be cloned. Can be an instance of an Ellipse or a ellipse-like object, with x, y, width and height properties.
             */
            static Clone(source: Ellipse): Ellipse;

            /**
             * Check to see if the Ellipse contains the given x / y coordinates.
             * @param ellipse The Ellipse to check.
             * @param x The x coordinate to check within the ellipse.
             * @param y The y coordinate to check within the ellipse.
             */
            static Contains(ellipse: Ellipse, x: number, y: number): boolean;

            /**
             * Check to see if the Ellipse contains the given Point object.
             * @param ellipse The Ellipse to check.
             * @param point The Point object to check if it's within the Circle or not.
             */
            static ContainsPoint(ellipse: Ellipse, point: Point | object): boolean;

            /**
             * Check to see if the Ellipse contains all four points of the given Rectangle object.
             * @param ellipse The Ellipse to check.
             * @param rect The Rectangle object to check if it's within the Ellipse or not.
             */
            static ContainsRect(ellipse: Ellipse, rect: Rectangle | object): boolean;

            /**
             * Copies the `x`, `y`, `width` and `height` properties from the `source` Ellipse
             * into the given `dest` Ellipse, then returns the `dest` Ellipse.
             * @param source The source Ellipse to copy the values from.
             * @param dest The destination Ellipse to copy the values to.
             */
            static CopyFrom<O extends Ellipse>(source: Ellipse, dest: O): O;

            /**
             * The x position of the center of the ellipse.
             */
            x: number;

            /**
             * The y position of the center of the ellipse.
             */
            y: number;

            /**
             * The width of the ellipse.
             */
            width: number;

            /**
             * The height of the ellipse.
             */
            height: number;

            /**
             * Check to see if the Ellipse contains the given x / y coordinates.
             * @param x The x coordinate to check within the ellipse.
             * @param y The y coordinate to check within the ellipse.
             */
            contains(x: number, y: number): boolean;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse
             * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
             * at 180 degrees around the circle.
             * @param position A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the ellipse.
             * @param out An object to store the return values in. If not given a Point object will be created.
             */
            getPoint<O extends Point>(position: number, out?: O): O;

            /**
             * Returns an array of Point objects containing the coordinates of the points around the circumference of the Ellipse,
             * based on the given quantity or stepRate values.
             * @param quantity The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
             * @param stepRate Sets the quantity by getting the circumference of the ellipse and dividing it by the stepRate.
             * @param output An array to insert the points in to. If not provided a new array will be created.
             */
            getPoints(quantity: integer, stepRate?: number, output?: any[]): Point[];

            /**
             * Returns a uniformly distributed random point from anywhere within the given Ellipse.
             * @param point A Point or point-like object to set the random `x` and `y` values in.
             */
            getRandomPoint<O extends Point>(point?: O): O;

            /**
             * Sets the x, y, width and height of this ellipse.
             * @param x The x position of the center of the ellipse.
             * @param y The y position of the center of the ellipse.
             * @param width The width of the ellipse.
             * @param height The height of the ellipse.
             */
            setTo(x: number, y: number, width: number, height: number): Ellipse;

            /**
             * Sets this Ellipse to be empty with a width and height of zero.
             * Does not change its position.
             */
            setEmpty(): Ellipse;

            /**
             * Sets the position of this Ellipse.
             * @param x The x position of the center of the ellipse.
             * @param y The y position of the center of the ellipse.
             */
            setPosition(x: number, y: number): Ellipse;

            /**
             * Sets the size of this Ellipse.
             * Does not change its position.
             * @param width The width of the ellipse.
             * @param height The height of the ellipse. Default width.
             */
            setSize(width: number, height?: number): Ellipse;

            /**
             * Checks to see if the Ellipse is empty: has a width or height equal to zero.
             */
            isEmpty(): boolean;

            /**
             * Returns the minor radius of the ellipse. Also known as the Semi Minor Axis.
             */
            getMinorRadius(): number;

            /**
             * Returns the major radius of the ellipse. Also known as the Semi Major Axis.
             */
            getMajorRadius(): number;

            /**
             * The left position of the Ellipse.
             */
            left: number;

            /**
             * The right position of the Ellipse.
             */
            right: number;

            /**
             * The top position of the Ellipse.
             */
            top: number;

            /**
             * The bottom position of the Ellipse.
             */
            bottom: number;

            /**
             * Compares the `x`, `y`, `width` and `height` properties of the two given Ellipses.
             * Returns `true` if they all match, otherwise returns `false`.
             * @param ellipse The first Ellipse to compare.
             * @param toCompare The second Ellipse to compare.
             */
            static Equals(ellipse: Ellipse, toCompare: Ellipse): boolean;

            /**
             * Returns the bounds of the Ellipse object.
             * @param ellipse The Ellipse to get the bounds from.
             * @param out A Rectangle, or rectangle-like object, to store the ellipse bounds in. If not given a new Rectangle will be created.
             */
            static GetBounds<O extends Rectangle>(ellipse: Ellipse, out?: O): O;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse
             * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
             * at 180 degrees around the circle.
             * @param ellipse The Ellipse to get the circumference point on.
             * @param position A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the ellipse.
             * @param out An object to store the return values in. If not given a Point object will be created.
             */
            static GetPoint<O extends Point>(ellipse: Ellipse, position: number, out?: O): O;

            /**
             * Returns an array of Point objects containing the coordinates of the points around the circumference of the Ellipse,
             * based on the given quantity or stepRate values.
             * @param ellipse The Ellipse to get the points from.
             * @param quantity The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
             * @param stepRate Sets the quantity by getting the circumference of the ellipse and dividing it by the stepRate.
             * @param out An array to insert the points in to. If not provided a new array will be created.
             */
            static GetPoints<O extends Point[]>(ellipse: Ellipse, quantity: integer, stepRate?: number, out?: O): O;

            /**
             * Offsets the Ellipse by the values given.
             * @param ellipse The Ellipse to be offset (translated.)
             * @param x The amount to horizontally offset the Ellipse by.
             * @param y The amount to vertically offset the Ellipse by.
             */
            static Offset<O extends Ellipse>(ellipse: O, x: number, y: number): O;

            /**
             * Offsets the Ellipse by the values given in the `x` and `y` properties of the Point object.
             * @param ellipse The Ellipse to be offset (translated.)
             * @param point The Point object containing the values to offset the Ellipse by.
             */
            static OffsetPoint<O extends Ellipse>(ellipse: O, point: Point | object): O;

            /**
             * Returns a uniformly distributed random point from anywhere within the given Ellipse.
             * @param ellipse The Ellipse to get a random point from.
             * @param out A Point or point-like object to set the random `x` and `y` values in.
             */
            static Random<O extends Point>(ellipse: Ellipse, out?: O): O;
        }

        namespace Intersects {
            /**
             * Checks if two Circles intersect.
             * @param circleA The first Circle to check for intersection.
             * @param circleB The second Circle to check for intersection.
             */
            function CircleToCircle(circleA: Circle, circleB: Circle): boolean;

            /**
             * Checks for intersection between a circle and a rectangle.
             * @param circle The circle to be checked.
             * @param rect The rectangle to be checked.
             */
            function CircleToRectangle(circle: Circle, rect: Rectangle): boolean;

            /**
             * Checks if two Rectangle shapes intersect and returns the area of this intersection as Rectangle object.
             *
             * If optional `output` parameter is omitted, new Rectangle object is created and returned. If there is intersection, it will contain intersection area.
             * If there is no intersection, it wil be empty Rectangle (all values set to zero).
             *
             * If Rectangle object is passed as `output` and there is intersection, then intersection area data will be loaded into it and it will be returned.
             * If there is no intersetion, it will be returned without any change.
             * @param rectA The first Rectangle object.
             * @param rectB The second Rectangle object.
             * @param output Optional Rectangle object. If given, the intersection data will be loaded into it (in case of no intersection, it will be left unchanged).
             * Otherwise, new Rectangle object will be created and returned with either intersection data or empty (all values set to zero), if there is no intersection.
             */
            function GetRectangleIntersection<O extends Rectangle>(rectA: Rectangle, rectB: Rectangle, output?: O): O;

            /**
             * Checks for intersection between the line segment and circle.
             *
             * Based on code by [Matt DesLauriers](https://github.com/mattdesl/line-circle-collision/blob/master/LICENSE.md).
             * @param line The line segment to check.
             * @param circle The circle to check against the line.
             * @param nearest An optional Point-like object. If given the closest point on the Line where the circle intersects will be stored in this object.
             */
            function LineToCircle(line: Line, circle: Circle, nearest?: Point | {x: number; y: number}): boolean;

            /**
             * Checks if two Lines intersect. If the Lines are identical, they will be treated as parallel and thus non-intersecting.
             * @param line1 The first Line to check.
             * @param line2 The second Line to check.
             * @param out A Point in which to optionally store the point of intersection.
             */
            function LineToLine(line1: Line, line2: Line, out?: Point): boolean;

            /**
             * Checks for intersection between the Line and a Rectangle shape, or a rectangle-like
             * object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.
             *
             * An intersection is considered valid if:
             *
             * The line starts within, or ends within, the Rectangle.
             * The line segment intersects one of the 4 rectangle edges.
             *
             * The for the purposes of this function rectangles are considered 'solid'.
             * @param line The Line to check for intersection.
             * @param rect The Rectangle to check for intersection.
             */
            function LineToRectangle(line: Line, rect: Rectangle | object): boolean;

            /**
             * Checks if the a Point falls between the two end-points of a Line, based on the given line thickness.
             *
             * Assumes that the line end points are circular, not square.
             * @param point The point, or point-like object to check.
             * @param line The line segment to test for intersection on.
             * @param lineThickness The line thickness. Assumes that the line end points are circular. Default 1.
             */
            function PointToLine(point: Point | {x: number; y: number}, line: Line, lineThickness?: number): boolean;

            /**
             * Checks if a Point is located on the given line segment.
             * @param point The Point to check for intersection.
             * @param line The line segment to check for intersection.
             */
            function PointToLineSegment(point: Point, line: Line): boolean;

            /**
             * Checks if two Rectangles intersect.
             *
             * A Rectangle intersects another Rectangle if any part of its bounds is within the other Rectangle's bounds.
             * As such, the two Rectangles are considered "solid". A Rectangle with no width or no height will never intersect another Rectangle.
             * @param rectA The first Rectangle to check for intersection.
             * @param rectB The second Rectangle to check for intersection.
             */
            function RectangleToRectangle(rectA: Rectangle, rectB: Rectangle): boolean;

            /**
             * Checks for intersection between Rectangle shape and Triangle shape.
             * @param rect Rectangle object to test.
             * @param triangle Triangle object to test.
             */
            function RectangleToTriangle(rect: Rectangle, triangle: Triangle): boolean;

            /**
             * Check if rectangle intersects with values.
             * @param rect The rectangle object
             * @param left The x coordinate of the left of the Rectangle.
             * @param right The x coordinate of the right of the Rectangle.
             * @param top The y coordinate of the top of the Rectangle.
             * @param bottom The y coordinate of the bottom of the Rectangle.
             * @param tolerance Tolerance allowed in the calculation, expressed in pixels. Default 0.
             */
            function RectangleToValues(rect: Rectangle, left: number, right: number, top: number, bottom: number, tolerance?: number): boolean;

            /**
             * Checks if a Triangle and a Circle intersect.
             *
             * A Circle intersects a Triangle if its center is located within it or if any of the Triangle's sides intersect the Circle.
             * As such, the Triangle and the Circle are considered "solid" for the intersection.
             * @param triangle The Triangle to check for intersection.
             * @param circle The Circle to check for intersection.
             */
            function TriangleToCircle(triangle: Triangle, circle: Circle): boolean;

            /**
             * Checks if a Triangle and a Line intersect.
             *
             * The Line intersects the Triangle if it starts inside of it, ends inside of it, or crosses any of the Triangle's sides. Thus, the Triangle is considered "solid".
             * @param triangle The Triangle to check with.
             * @param line The Line to check with.
             */
            function TriangleToLine(triangle: Triangle, line: Line): boolean;

            /**
             * Checks if two Triangles intersect.
             *
             * A Triangle intersects another Triangle if any pair of their lines intersects or if any point of one Triangle is within the other Triangle. Thus, the Triangles are considered "solid".
             * @param triangleA The first Triangle to check for intersection.
             * @param triangleB The second Triangle to check for intersection.
             */
            function TriangleToTriangle(triangleA: Triangle, triangleB: Triangle): boolean;
        }

        /**
         * Defines a Line segment, a part of a line between two endpoints.
         */
        class Line {
            /**
             *
             * @param x1 The x coordinate of the lines starting point. Default 0.
             * @param y1 The y coordinate of the lines starting point. Default 0.
             * @param x2 The x coordinate of the lines ending point. Default 0.
             * @param y2 The y coordinate of the lines ending point. Default 0.
             */
            constructor(x1?: number, y1?: number, x2?: number, y2?: number);

            /**
             * Calculate the angle of the line in radians.
             * @param line The line to calculate the angle of.
             */
            static Angle(line: Line): number;

            /**
             * Using Bresenham's line algorithm this will return an array of all coordinates on this line.
             *
             * The `start` and `end` points are rounded before this runs as the algorithm works on integers.
             * @param line The line.
             * @param stepRate The optional step rate for the points on the line. Default 1.
             * @param results An optional array to push the resulting coordinates into.
             */
            static BresenhamPoints(line: Line, stepRate?: integer, results?: any[]): object[];

            /**
             * Center a line on the given coordinates.
             * @param line The line to center.
             * @param x The horizontal coordinate to center the line on.
             * @param y The vertical coordinate to center the line on.
             */
            static CenterOn(line: Line, x: number, y: number): Line;

            /**
             * Clone the given line.
             * @param source The source line to clone.
             */
            static Clone(source: Line): Line;

            /**
             * Copy the values of one line to a destination line.
             * @param source The source line to copy the values from.
             * @param dest The destination line to copy the values to.
             */
            static CopyFrom<O extends Line>(source: Line, dest: O): O;

            /**
             * Compare two lines for strict equality.
             * @param line The first line to compare.
             * @param toCompare The second line to compare.
             */
            static Equals(line: Line, toCompare: Line): boolean;

            /**
             * Extends the start and end points of a Line by the given amounts.
             *
             * The amounts can be positive or negative. Positive points will increase the length of the line,
             * while negative ones will decrease it.
             *
             * If no `right` value is provided it will extend the length of the line equally in both directions.
             *
             * Pass a value of zero to leave the start or end point unchanged.
             * @param line The line instance to extend.
             * @param left The amount to extend the start of the line by.
             * @param right The amount to extend the end of the line by. If not given it will be set to the `left` value.
             */
            static Extend(line: Line, left: number, right?: number): Line;

            /**
             * Get the midpoint of the given line.
             * @param line The line to get the midpoint of.
             * @param out An optional point object to store the midpoint in.
             */
            static GetMidPoint<O extends Point>(line: Line, out?: O): O;

            /**
             * Get the nearest point on a line perpendicular to the given point.
             * @param line The line to get the nearest point on.
             * @param point The point to get the nearest point to.
             * @param out An optional point, or point-like object, to store the coordinates of the nearest point on the line.
             */
            static GetNearestPoint<O extends Point>(line: Line, point: Point | object, out?: O): O;

            /**
             * Calculate the normal of the given line.
             *
             * The normal of a line is a vector that points perpendicular from it.
             * @param line The line to calculate the normal of.
             * @param out An optional point object to store the normal in.
             */
            static GetNormal<O extends Point>(line: Line, out?: O): O;

            /**
             * Get a point on a line that's a given percentage along its length.
             * @param line The line.
             * @param position A value between 0 and 1, where 0 is the start, 0.5 is the middle and 1 is the end of the line.
             * @param out An optional point, or point-like object, to store the coordinates of the point on the line.
             */
            static GetPoint<O extends Point>(line: Line, position: number, out?: O): O;

            /**
             * Get a number of points along a line's length.
             *
             * Provide a `quantity` to get an exact number of points along the line.
             *
             * Provide a `stepRate` to ensure a specific distance between each point on the line. Set `quantity` to `0` when
             * providing a `stepRate`.
             * @param line The line.
             * @param quantity The number of points to place on the line. Set to `0` to use `stepRate` instead.
             * @param stepRate The distance between each point on the line. When set, `quantity` is implied and should be set to `0`.
             * @param out An optional array of Points, or point-like objects, to store the coordinates of the points on the line.
             */
            static GetPoints<O extends Point[]>(line: Line, quantity: integer, stepRate?: number, out?: O): O;

            /**
             * Get the shortest distance from a Line to the given Point.
             * @param line The line to get the distance from.
             * @param point The point to get the shortest distance to.
             */
            static GetShortestDistance<O extends Point>(line: Line, point: O | object): O;

            /**
             * Calculate the height of the given line.
             * @param line The line to calculate the height of.
             */
            static Height(line: Line): number;

            /**
             * Calculate the length of the given line.
             * @param line The line to calculate the length of.
             */
            static Length(line: Line): number;

            /**
             * The x coordinate of the lines starting point.
             */
            x1: number;

            /**
             * The y coordinate of the lines starting point.
             */
            y1: number;

            /**
             * The x coordinate of the lines ending point.
             */
            x2: number;

            /**
             * The y coordinate of the lines ending point.
             */
            y2: number;

            /**
             * Get a point on a line that's a given percentage along its length.
             * @param position A value between 0 and 1, where 0 is the start, 0.5 is the middle and 1 is the end of the line.
             * @param output An optional point, or point-like object, to store the coordinates of the point on the line.
             */
            getPoint<O extends Point>(position: number, output?: O): O;

            /**
             * Get a number of points along a line's length.
             *
             * Provide a `quantity` to get an exact number of points along the line.
             *
             * Provide a `stepRate` to ensure a specific distance between each point on the line. Set `quantity` to `0` when
             * providing a `stepRate`.
             * @param quantity The number of points to place on the line. Set to `0` to use `stepRate` instead.
             * @param stepRate The distance between each point on the line. When set, `quantity` is implied and should be set to `0`.
             * @param output An optional array of Points, or point-like objects, to store the coordinates of the points on the line.
             */
            getPoints<O extends Point>(quantity: integer, stepRate?: integer, output?: O): O;

            /**
             * Get a random Point on the Line.
             * @param point An instance of a Point to be modified.
             */
            getRandomPoint<O extends Point>(point?: O): O;

            /**
             * Set new coordinates for the line endpoints.
             * @param x1 The x coordinate of the lines starting point. Default 0.
             * @param y1 The y coordinate of the lines starting point. Default 0.
             * @param x2 The x coordinate of the lines ending point. Default 0.
             * @param y2 The y coordinate of the lines ending point. Default 0.
             */
            setTo(x1?: number, y1?: number, x2?: number, y2?: number): Line;

            /**
             * Returns a Vector2 object that corresponds to the start of this Line.
             * @param vec2 A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.
             */
            getPointA<O extends Math.Vector2>(vec2?: O): O;

            /**
             * Returns a Vector2 object that corresponds to the end of this Line.
             * @param vec2 A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.
             */
            getPointB<O extends Math.Vector2>(vec2?: O): O;

            /**
             * The left position of the Line.
             */
            left: number;

            /**
             * The right position of the Line.
             */
            right: number;

            /**
             * The top position of the Line.
             */
            top: number;

            /**
             * The bottom position of the Line.
             */
            bottom: number;

            /**
             * Get the angle of the normal of the given line in radians.
             * @param line The line to calculate the angle of the normal of.
             */
            static NormalAngle(line: Line): number;

            /**
             * [description]
             * @param line The Line object to get the normal value from.
             */
            static NormalX(line: Line): number;

            /**
             * The Y value of the normal of the given line.
             * The normal of a line is a vector that points perpendicular from it.
             * @param line The line to calculate the normal of.
             */
            static NormalY(line: Line): number;

            /**
             * Offset a line by the given amount.
             * @param line The line to offset.
             * @param x The horizontal offset to add to the line.
             * @param y The vertical offset to add to the line.
             */
            static Offset<O extends Line>(line: O, x: number, y: number): O;

            /**
             * Calculate the perpendicular slope of the given line.
             * @param line The line to calculate the perpendicular slope of.
             */
            static PerpSlope(line: Line): number;

            /**
             * Returns a random point on a given Line.
             * @param line The Line to calculate the random Point on.
             * @param out An instance of a Point to be modified.
             */
            static Random<O extends Point>(line: Line, out?: O): O;

            /**
             * Calculate the reflected angle between two lines.
             *
             * This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.
             * @param lineA The first line.
             * @param lineB The second line.
             */
            static ReflectAngle(lineA: Line, lineB: Line): number;

            /**
             * Rotate a line around its midpoint by the given angle in radians.
             * @param line The line to rotate.
             * @param angle The angle of rotation in radians.
             */
            static Rotate<O extends Line>(line: O, angle: number): O;

            /**
             * Rotate a line around a point by the given angle in radians.
             * @param line The line to rotate.
             * @param point The point to rotate the line around.
             * @param angle The angle of rotation in radians.
             */
            static RotateAroundPoint<O extends Line>(line: O, point: Point | object, angle: number): O;

            /**
             * Rotate a line around the given coordinates by the given angle in radians.
             * @param line The line to rotate.
             * @param x The horizontal coordinate to rotate the line around.
             * @param y The vertical coordinate to rotate the line around.
             * @param angle The angle of rotation in radians.
             */
            static RotateAroundXY<O extends Line>(line: O, x: number, y: number, angle: number): O;

            /**
             * Set a line to a given position, angle and length.
             * @param line The line to set.
             * @param x The horizontal start position of the line.
             * @param y The vertical start position of the line.
             * @param angle The angle of the line in radians.
             * @param length The length of the line.
             */
            static SetToAngle<O extends Line>(line: O, x: number, y: number, angle: number, length: number): O;

            /**
             * Calculate the slope of the given line.
             * @param line The line to calculate the slope of.
             */
            static Slope(line: Line): number;

            /**
             * Calculate the width of the given line.
             * @param line The line to calculate the width of.
             */
            static Width(line: Line): number;
        }

        /**
         * Defines a Point in 2D space, with an x and y component.
         */
        class Point {
            /**
             *
             * @param x The x coordinate of this Point. Default 0.
             * @param y The y coordinate of this Point. Default x.
             */
            constructor(x?: number, y?: number);

            /**
             * Apply `Math.ceil()` to each coordinate of the given Point.
             * @param point The Point to ceil.
             */
            static Ceil<O extends Point>(point: O): O;

            /**
             * Clone the given Point.
             * @param source The source Point to clone.
             */
            static Clone(source: Point): Point;

            /**
             * Copy the values of one Point to a destination Point.
             * @param source The source Point to copy the values from.
             * @param dest The destination Point to copy the values to.
             */
            static CopyFrom<O extends Point>(source: Point, dest: O): O;

            /**
             * A comparison of two `Point` objects to see if they are equal.
             * @param point The original `Point` to compare against.
             * @param toCompare The second `Point` to compare.
             */
            static Equals(point: Point, toCompare: Point): boolean;

            /**
             * Apply `Math.ceil()` to each coordinate of the given Point.
             * @param point The Point to floor.
             */
            static Floor<O extends Point>(point: O): O;

            /**
             * Get the centroid or geometric center of a plane figure (the arithmetic mean position of all the points in the figure).
             * Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.
             * @param points [description]
             * @param out [description]
             */
            static GetCentroid<O extends Point>(points: Point[], out?: O): O;

            /**
             * Calculate the magnitude of the point, which equivalent to the length of the line from the origin to this point.
             * @param point The point to calculate the magnitude for
             */
            static GetMagnitude(point: Point): number;

            /**
             * Calculates the square of magnitude of given point.(Can be used for fast magnitude calculation of point)
             * @param point Returns square of the magnitude/length of given point.
             */
            static GetMagnitudeSq(point: Point): number;

            /**
             * Calculates the Axis Aligned Bounding Box (or aabb) from an array of points.
             * @param points [description]
             * @param out [description]
             */
            static GetRectangleFromPoints<O extends Rectangle>(points: Point[], out?: O): O;

            /**
             * [description]
             * @param pointA The starting `Point` for the interpolation.
             * @param pointB The target `Point` for the interpolation.
             * @param t The amount to interpolate between the two points. Generally, a value between 0 (returns the starting `Point`) and 1 (returns the target `Point`).
             * If omitted, 0 is used. Default 0.
             * @param out An optional `Point` object whose `x` and `y` values will be set to the result of the interpolation (can also be any object with `x` and `y` properties).
             * If omitted, a new `Point` created and returned.
             */
            static Interpolate<O extends Point>(pointA: Point, pointB: Point, t?: number, out?: O): O;

            /**
             * Swaps the X and the Y coordinate of a point.
             * @param point The Point to modify.
             */
            static Invert<O extends Point>(point: O): O;

            /**
             * Inverts a Point's coordinates.
             * @param point The Point to invert.
             * @param out The Point to return the inverted coordinates in.
             */
            static Negative<O extends Point>(point: Point, out?: O): O;

            /**
             * The x coordinate of this Point.
             */
            x: number;

            /**
             * The y coordinate of this Point.
             */
            y: number;

            /**
             * Set the x and y coordinates of the point to the given values.
             * @param x The x coordinate of this Point. Default 0.
             * @param y The y coordinate of this Point. Default x.
             */
            setTo(x?: number, y?: number): Point;

            /**
             * [description]
             * @param pointA [description]
             * @param pointB [description]
             * @param out [description]
             */
            static Project<O extends Point>(pointA: Point, pointB: Point, out?: O): O;

            /**
             * [description]
             * @param pointA [description]
             * @param pointB [description]
             * @param out [description]
             */
            static ProjectUnit<O extends Point>(pointA: Point, pointB: Point, out?: O): O;

            /**
             * Changes the magnitude (length) of a two-dimensional vector without changing its direction.
             * @param point The Point to treat as the end point of the vector.
             * @param magnitude The new magnitude of the vector.
             */
            static SetMagnitude<O extends Point>(point: O, magnitude: number): O;
        }

        /**
         * A Polygon object
         *
         * The polygon is a closed shape consists of a series of connected straight lines defined by list of ordered points.
         * Several formats are supported to define the list of points, check the setTo method for details.
         * This is a geometry object allowing you to define and inspect the shape.
         * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.
         * To render a Polygon you should look at the capabilities of the Graphics class.
         */
        class Polygon {
            /**
             *
             * @param points List of points defining the perimeter of this Polygon. Several formats are supported:
             * - A string containing paired x y values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`
             * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
             * - An array of objects with public x y properties: `[obj1, obj2, ...]`
             * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
             * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
             */
            constructor(points?: Point[]);

            /**
             * Create a new polygon which is a copy of the specified polygon
             * @param polygon The polygon to create a clone of
             */
            static Clone(polygon: Polygon): Polygon;

            /**
             * Checks if a point is within the bounds of a Polygon.
             * @param polygon The Polygon to check against.
             * @param x The X coordinate of the point to check.
             * @param y The Y coordinate of the point to check.
             */
            static Contains(polygon: Polygon, x: number, y: number): boolean;

            /**
             * [description]
             * @param polygon [description]
             * @param point [description]
             */
            static ContainsPoint(polygon: Polygon, point: Point): boolean;

            /**
             * Calculates the bounding AABB rectangle of a polygon.
             * @param polygon The polygon that should be calculated.
             * @param out The rectangle or object that has x, y, width, and height properties to store the result. Optional.
             */
            static GetAABB<O extends Rectangle>(polygon: Polygon, out?: O): O;

            /**
             * Stores all of the points of a Polygon into a flat array of numbers following the sequence [ x,y, x,y, x,y ],
             * i.e. each point of the Polygon, in the order it's defined, corresponds to two elements of the resultant
             * array for the point's X and Y coordinate.
             * @param polygon The Polygon whose points to export.
             * @param output An array to which the points' coordinates should be appended.
             */
            static GetNumberArray<O extends number[]>(polygon: Polygon, output?: O): O;

            /**
             * Returns an array of Point objects containing the coordinates of the points around the perimeter of the Polygon,
             * based on the given quantity or stepRate values.
             * @param polygon The Polygon to get the points from.
             * @param quantity The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
             * @param stepRate Sets the quantity by getting the perimeter of the Polygon and dividing it by the stepRate.
             * @param output An array to insert the points in to. If not provided a new array will be created.
             */
            static GetPoints(polygon: Polygon, quantity: integer, stepRate?: number, output?: any[]): Point[];

            /**
             * Returns the perimeter of the given Polygon.
             * @param polygon The Polygon to get the perimeter of.
             */
            static Perimeter(polygon: Polygon): number;

            /**
             * The area of this Polygon.
             */
            area: number;

            /**
             * An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]
             */
            points: Point[];

            /**
             * Check to see if the Polygon contains the given x / y coordinates.
             * @param x The x coordinate to check within the polygon.
             * @param y The y coordinate to check within the polygon.
             */
            contains(x: number, y: number): boolean;

            /**
             * Sets this Polygon to the given points.
             *
             * The points can be set from a variety of formats:
             *
             * - A string containing paired values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`
             * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
             * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
             * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
             * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
             *
             * `setTo` may also be called without any arguments to remove all points.
             * @param points Points defining the perimeter of this polygon. Please check function description above for the different supported formats.
             */
            setTo(points: any[]): Polygon;

            /**
             * Calculates the area of the Polygon. This is available in the property Polygon.area
             */
            calculateArea(): number;

            /**
             * Returns an array of Point objects containing the coordinates of the points around the perimeter of the Polygon,
             * based on the given quantity or stepRate values.
             * @param quantity The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
             * @param stepRate Sets the quantity by getting the perimeter of the Polygon and dividing it by the stepRate.
             * @param output An array to insert the points in to. If not provided a new array will be created.
             */
            getPoints(quantity: integer, stepRate?: number, output?: any[]): Point[];

            /**
             * Reverses the order of the points of a Polygon.
             * @param polygon The Polygon to modify.
             */
            static Reverse<O extends Polygon>(polygon: O): O;

            /**
             * Takes a Polygon object and applies Chaikin's smoothing algorithm on its points.
             * @param polygon The polygon to be smoothed. The polygon will be modified in-place and returned.
             */
            static Smooth<O extends Polygon>(polygon: O): O;
        }

        /**
         * Encapsulates a 2D rectangle defined by its corner point in the top-left and its extends in x (width) and y (height)
         */
        class Rectangle {
            /**
             *
             * @param x The X coordinate of the top left corner of the Rectangle. Default 0.
             * @param y The Y coordinate of the top left corner of the Rectangle. Default 0.
             * @param width The width of the Rectangle. Default 0.
             * @param height The height of the Rectangle. Default 0.
             */
            constructor(x?: number, y?: number, width?: number, height?: number);

            /**
             * Calculates the area of the given Rectangle object.
             * @param rect The rectangle to calculate the area of.
             */
            static Area(rect: Rectangle): number;

            /**
             * Rounds a Rectangle's position up to the smallest integer greater than or equal to each current coordinate.
             * @param rect The Rectangle to adjust.
             */
            static Ceil<O extends Rectangle>(rect: O): O;

            /**
             * Rounds a Rectangle's position and size up to the smallest integer greater than or equal to each respective value.
             * @param rect The Rectangle to modify.
             */
            static CeilAll<O extends Rectangle>(rect: O): O;

            /**
             * Moves the top-left corner of a Rectangle so that its center is at the given coordinates.
             * @param rect The Rectangle to be centered.
             * @param x The X coordinate of the Rectangle's center.
             * @param y The Y coordinate of the Rectangle's center.
             */
            static CenterOn<O extends Rectangle>(rect: O, x: number, y: number): O;

            /**
             * Creates a new Rectangle which is identical to the given one.
             * @param source The Rectangle to clone.
             */
            static Clone(source: Rectangle): Rectangle;

            /**
             * Checks if a given point is inside a Rectangle's bounds.
             * @param rect The Rectangle to check.
             * @param x The X coordinate of the point to check.
             * @param y The Y coordinate of the point to check.
             */
            static Contains(rect: Rectangle, x: number, y: number): boolean;

            /**
             * Determines whether the specified point is contained within the rectangular region defined by this Rectangle object.
             * @param rect The Rectangle object.
             * @param point The point object to be checked. Can be a Phaser Point object or any object with x and y values.
             */
            static ContainsPoint(rect: Rectangle, point: Point): boolean;

            /**
             * Tests if one rectangle fully contains another.
             * @param rectA The first rectangle.
             * @param rectB The second rectangle.
             */
            static ContainsRect(rectA: Rectangle, rectB: Rectangle): boolean;

            /**
             * Copy the values of one Rectangle to a destination Rectangle.
             * @param source The source Rectangle to copy the values from.
             * @param dest The destination Rectangle to copy the values to.
             */
            static CopyFrom<O extends Rectangle>(source: Rectangle, dest: O): O;

            /**
             * Create an array of points for each corner of a Rectangle
             * If an array is specified, each point object will be added to the end of the array, otherwise a new array will be created.
             * @param rect The Rectangle object to be decomposed.
             * @param out If provided, each point will be added to this array.
             */
            static Decompose(rect: Rectangle, out?: any[]): any[];

            /**
             * Compares the `x`, `y`, `width` and `height` properties of two rectangles.
             * @param rect Rectangle A
             * @param toCompare Rectangle B
             */
            static Equals(rect: Rectangle, toCompare: Rectangle): boolean;

            /**
             * Adjusts the target rectangle, changing its width, height and position,
             * so that it fits inside the area of the source rectangle, while maintaining its original
             * aspect ratio.
             *
             * Unlike the `FitOutside` function, there may be some space inside the source area not covered.
             * @param target The target rectangle to adjust.
             * @param source The source rectangle to envlope the target in.
             */
            static FitInside<O extends Rectangle>(target: O, source: Rectangle): O;

            /**
             * Adjusts the target rectangle, changing its width, height and position,
             * so that it fully covers the area of the source rectangle, while maintaining its original
             * aspect ratio.
             *
             * Unlike the `FitInside` function, the target rectangle may extend further out than the source.
             * @param target The target rectangle to adjust.
             * @param source The source rectangle to envlope the target in.
             */
            static FitOutside<O extends Rectangle>(target: O, source: Rectangle): O;

            /**
             * Rounds down (floors) the top left X and Y co-ordinates of the given Rectangle to the largest integer less than or equal to them
             * @param rect The rectangle to floor the top left X and Y co-ordinates of
             */
            static Floor<O extends Rectangle>(rect: O): O;

            /**
             * Rounds a Rectangle's position and size down to the largest integer less than or equal to each current coordinate or dimension.
             * @param rect The Rectangle to adjust.
             */
            static FloorAll<O extends Rectangle>(rect: O): O;

            /**
             * Constructs new Rectangle or repositions and resizes an existing Rectangle so that all of the given points are on or within its bounds.
             * @param points An array of points (either arrays with two elements corresponding to the X and Y coordinate or an object with
             * public `x` and `y` properties) which should be surrounded by the Rectangle.
             * @param out Optional Rectangle to adjust.
             */
            static FromPoints<O extends Rectangle>(points: any[], out?: O): O;

            /**
             * Calculates the width/height ratio of a rectangle.
             * @param rect The rectangle.
             */
            static GetAspectRatio(rect: Rectangle): number;

            /**
             * Returns the center of a Rectangle as a Point.
             * @param rect The Rectangle to get the center of.
             * @param out Optional point-like object to update with the center coordinates.
             */
            static GetCenter<O extends Point>(rect: Rectangle, out?: O): O;

            /**
             * Position is a value between 0 and 1 where 0 = the top-left of the rectangle and 0.5 = the bottom right.
             * @param rectangle [description]
             * @param position [description]
             * @param out [description]
             */
            static GetPoint<O extends Point>(rectangle: Rectangle, position: number, out?: O): O;

            /**
             * Return an array of points from the perimeter of the rectangle, each spaced out based on the quantity or step required.
             * @param rectangle The Rectangle object to get the points from.
             * @param step Step between points. Used to calculate the number of points to return when quantity is falsy. Ignored if quantity is positive.
             * @param quantity The number of evenly spaced points from the rectangles perimeter to return. If falsy, step param will be used to calculate the number of points.
             * @param out An optional array to store the points in.
             */
            static GetPoints<O extends Point[]>(rectangle: Rectangle, step: number, quantity: integer, out?: O): O;

            /**
             * [description]
             * @param rect [description]
             * @param out [description]
             */
            static GetSize<O extends Point>(rect: Rectangle, out?: O): O;

            /**
             * Increases the size of a Rectangle by a specified amount.
             *
             * The center of the Rectangle stays the same. The amounts are added to each side, so the actual increase in width or height is two times bigger than the respective argument.
             * @param rect The Rectangle to inflate.
             * @param x How many pixels the left and the right side should be moved by horizontally.
             * @param y How many pixels the top and the bottom side should be moved by vertically.
             */
            static Inflate<O extends Rectangle>(rect: O, x: number, y: number): O;

            /**
             * Takes two Rectangles and first checks to see if they intersect.
             * If they intersect it will return the area of intersection in the `out` Rectangle.
             * If they do not intersect, the `out` Rectangle will have a width and height of zero.
             * @param rectA The first Rectangle to get the intersection from.
             * @param rectB The second Rectangle to get the intersection from.
             * @param out A Rectangle to store the intersection results in.
             */
            static Intersection<O extends Rectangle>(rectA: O, rectB: O, out?: O): O;

            /**
             * [description]
             * @param rect [description]
             * @param step [description]
             * @param quantity [description]
             * @param out [description]
             */
            static MarchingAnts<O extends Point[]>(rect: Rectangle, step: number, quantity: integer, out?: O): O;

            /**
             * Merges a Rectangle with a list of points by repositioning and/or resizing it such that all points are located on or within its bounds.
             * @param target The Rectangle which should be merged.
             * @param points An array of Points (or any object with public `x` and `y` properties) which should be merged with the Rectangle.
             */
            static MergePoints<O extends Rectangle>(target: O, points: Point[]): O;

            /**
             * Merges the source rectangle into the target rectangle and returns the target.
             * Neither rectangle should have a negative width or height.
             * @param target Target rectangle. Will be modified to include source rectangle.
             * @param source Rectangle that will be merged into target rectangle.
             */
            static MergeRect<O extends Rectangle>(target: O, source: Rectangle): O;

            /**
             * Merges a Rectangle with a point by repositioning and/or resizing it so that the point is on or within its bounds.
             * @param target The Rectangle which should be merged and modified.
             * @param x The X coordinate of the point which should be merged.
             * @param y The Y coordinate of the point which should be merged.
             */
            static MergeXY<O extends Rectangle>(target: O, x: number, y: number): O;

            /**
             * Nudges (translates) the top left corner of a Rectangle by a given offset.
             * @param rect The Rectangle to adjust.
             * @param x The distance to move the Rectangle horizontally.
             * @param y The distance to move the Rectangle vertically.
             */
            static Offset<O extends Rectangle>(rect: O, x: number, y: number): O;

            /**
             * Nudges (translates) the top-left corner of a Rectangle by the coordinates of a point (translation vector).
             * @param rect The Rectangle to adjust.
             * @param point The point whose coordinates should be used as an offset.
             */
            static OffsetPoint<O extends Rectangle>(rect: O, point: Point | Math.Vector2): O;

            /**
             * Checks if two Rectangles overlap. If a Rectangle is within another Rectangle, the two will be considered overlapping. Thus, the Rectangles are treated as "solid".
             * @param rectA The first Rectangle to check.
             * @param rectB The second Rectangle to check.
             */
            static Overlaps(rectA: Rectangle, rectB: Rectangle): boolean;

            /**
             * Calculates the perimeter of a Rectangle.
             * @param rect The Rectangle to use.
             */
            static Perimeter(rect: Rectangle): number;

            /**
             * [description]
             * @param rectangle [description]
             * @param angle [description]
             * @param out [description]
             */
            static PerimeterPoint<O extends Point>(rectangle: Rectangle, angle: integer, out?: O): O;

            /**
             * Returns a random point within a Rectangle.
             * @param rect The Rectangle to return a point from.
             * @param out The object to update with the point's coordinates.
             */
            static Random<O extends Point>(rect: Rectangle, out: O): O;

            /**
             * Calculates a random point that lies within the `outer` Rectangle, but outside of the `inner` Rectangle.
             * The inner Rectangle must be fully contained within the outer rectangle.
             * @param outer The outer Rectangle to get the random point within.
             * @param inner The inner Rectangle to exclude from the returned point.
             * @param out A Point, or Point-like object to store the result in. If not specified, a new Point will be created.
             */
            static RandomOutside<O extends Point>(outer: Rectangle, inner: Rectangle, out?: O): O;

            /**
             * The X coordinate of the top left corner of the Rectangle.
             */
            x: number;

            /**
             * The Y coordinate of the top left corner of the Rectangle.
             */
            y: number;

            /**
             * The width of the Rectangle, i.e. the distance between its left side (defined by `x`) and its right side.
             */
            width: number;

            /**
             * The height of the Rectangle, i.e. the distance between its top side (defined by `y`) and its bottom side.
             */
            height: number;

            /**
             * Checks if the given point is inside the Rectangle's bounds.
             * @param x The X coordinate of the point to check.
             * @param y The Y coordinate of the point to check.
             */
            contains(x: number, y: number): boolean;

            /**
             * Calculates the coordinates of a point at a certain `position` on the Rectangle's perimeter.
             *
             * The `position` is a fraction between 0 and 1 which defines how far into the perimeter the point is.
             *
             * A value of 0 or 1 returns the point at the top left corner of the rectangle, while a value of 0.5 returns the point at the bottom right corner of the rectangle.
             * Values between 0 and 0.5 are on the top or the right side and values between 0.5 and 1 are on the bottom or the left side.
             * @param position The normalized distance into the Rectangle's perimeter to return.
             * @param output An object to update with the `x` and `y` coordinates of the point.
             */
            getPoint<O extends Point>(position: number, output?: O): O;

            /**
             * Returns an array of points from the perimeter of the Rectangle, each spaced out based on the quantity or step required.
             * @param quantity The number of points to return.
             * Set to `false` or 0 to return an arbitrary number of points (`perimeter / stepRate`) evenly spaced around the Rectangle based on the `stepRate`.
             * @param stepRate If `quantity` is 0, determines the normalized distance between each returned point.
             * @param output An array to which to append the points.
             */
            getPoints<O extends Point[]>(quantity: integer, stepRate?: number, output?: O): O;

            /**
             * Returns a random point within the Rectangle's bounds.
             * @param point The object in which to store the `x` and `y` coordinates of the point.
             */
            getRandomPoint<O extends Point>(point?: O): O;

            /**
             * Sets the position, width, and height of the Rectangle.
             * @param x The X coordinate of the top left corner of the Rectangle.
             * @param y The Y coordinate of the top left corner of the Rectangle.
             * @param width The width of the Rectangle.
             * @param height The height of the Rectangle.
             */
            setTo(x: number, y: number, width: number, height: number): Rectangle;

            /**
             * Resets the position, width, and height of the Rectangle to 0.
             */
            setEmpty(): Rectangle;

            /**
             * Sets the position of the Rectangle.
             * @param x The X coordinate of the top left corner of the Rectangle.
             * @param y The Y coordinate of the top left corner of the Rectangle. Default x.
             */
            setPosition(x: number, y?: number): Rectangle;

            /**
             * Sets the width and height of the Rectangle.
             * @param width The width to set the Rectangle to.
             * @param height The height to set the Rectangle to. Default width.
             */
            setSize(width: number, height?: number): Rectangle;

            /**
             * Determines if the Rectangle is empty. A Rectangle is empty if its width or height is less than or equal to 0.
             */
            isEmpty(): boolean;

            /**
             * Returns a Line object that corresponds to the top of this Rectangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineA<O extends Line>(line?: O): O;

            /**
             * Returns a Line object that corresponds to the right of this Rectangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineB<O extends Line>(line?: O): O;

            /**
             * Returns a Line object that corresponds to the bottom of this Rectangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineC<O extends Line>(line?: O): O;

            /**
             * Returns a Line object that corresponds to the left of this Rectangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineD<O extends Line>(line?: O): O;

            /**
             * The x coordinate of the left of the Rectangle.
             * Changing the left property of a Rectangle object has no effect on the y and height properties.
             * However it does affect the width property, whereas changing the x value does not affect the width property.
             */
            left: number;

            /**
             * The sum of the x and width properties.
             * Changing the right property of a Rectangle object has no effect on the x, y and height properties, however it does affect the width property.
             */
            right: number;

            /**
             * The y coordinate of the top of the Rectangle. Changing the top property of a Rectangle object has no effect on the x and width properties.
             * However it does affect the height property, whereas changing the y value does not affect the height property.
             */
            top: number;

            /**
             * The sum of the y and height properties.
             * Changing the bottom property of a Rectangle object has no effect on the x, y and width properties, but does change the height property.
             */
            bottom: number;

            /**
             * The x coordinate of the center of the Rectangle.
             */
            centerX: number;

            /**
             * The y coordinate of the center of the Rectangle.
             */
            centerY: number;

            /**
             * Determines if the two objects (either Rectangles or Rectangle-like) have the same width and height values under strict equality.
             * @param rect The first Rectangle object.
             * @param toCompare The second Rectangle object.
             */
            static SameDimensions(rect: Rectangle, toCompare: Rectangle): boolean;

            /**
             * Scales the width and height of this Rectangle by the given amounts.
             * @param rect The `Rectangle` object that will be scaled by the specified amount(s).
             * @param x The factor by which to scale the rectangle horizontally.
             * @param y The amount by which to scale the rectangle vertically. If this is not specified, the rectangle will be scaled by the factor `x` in both directions.
             */
            static Scale<O extends Rectangle>(rect: O, x: number, y: number): O;

            /**
             * Creates a new Rectangle or repositions and/or resizes an existing Rectangle so that it encompasses the two given Rectangles, i.e. calculates their union.
             * @param rectA The first Rectangle to use.
             * @param rectB The second Rectangle to use.
             * @param out The Rectangle to store the union in.
             */
            static Union<O extends Rectangle>(rectA: Rectangle, rectB: Rectangle, out?: O): O;
        }

        /**
         * A triangle is a plane created by connecting three points.
         * The first two arguments specify the first point, the middle two arguments
         * specify the second point, and the last two arguments specify the third point.
         */
        class Triangle {
            /**
             *
             * @param x1 `x` coordinate of the first point. Default 0.
             * @param y1 `y` coordinate of the first point. Default 0.
             * @param x2 `x` coordinate of the second point. Default 0.
             * @param y2 `y` coordinate of the second point. Default 0.
             * @param x3 `x` coordinate of the third point. Default 0.
             * @param y3 `y` coordinate of the third point. Default 0.
             */
            constructor(x1?: number, y1?: number, x2?: number, y2?: number, x3?: number, y3?: number);

            /**
             * Returns the area of a Triangle.
             * @param triangle The Triangle to use.
             */
            static Area(triangle: Triangle): number;

            /**
             * Builds an equilateral triangle. In the equilateral triangle, all the sides are the same length (congruent) and all the angles are the same size (congruent).
             * The x/y specifies the top-middle of the triangle (x1/y1) and length is the length of each side.
             * @param x x coordinate of the top point of the triangle.
             * @param y y coordinate of the top point of the triangle.
             * @param length Length of each side of the triangle.
             */
            static BuildEquilateral(x: number, y: number, length: number): Triangle;

            /**
             * [description]
             * @param data A flat array of vertice coordinates like [x0,y0, x1,y1, x2,y2, ...]
             * @param holes An array of hole indices if any (e.g. [5, 8] for a 12-vertice input would mean one hole with vertices 5–7 and another with 8–11). Default null.
             * @param scaleX [description] Default 1.
             * @param scaleY [description] Default 1.
             * @param out [description]
             */
            static BuildFromPolygon<O extends Triangle[]>(data: any[], holes?: any[], scaleX?: number, scaleY?: number, out?: O): O;

            /**
             * Builds a right triangle, i.e. one which has a 90-degree angle and two acute angles.
             * @param x The X coordinate of the right angle, which will also be the first X coordinate of the constructed Triangle.
             * @param y The Y coordinate of the right angle, which will also be the first Y coordinate of the constructed Triangle.
             * @param width The length of the side which is to the left or to the right of the right angle.
             * @param height The length of the side which is above or below the right angle.
             */
            static BuildRight(x: number, y: number, width: number, height: number): Triangle;

            /**
             * Positions the Triangle so that it is centered on the given coordinates.
             * @param triangle The triangle to be positioned.
             * @param x The horizontal coordinate to center on.
             * @param y The vertical coordinate to center on.
             * @param centerFunc The function used to center the triangle. Defaults to Centroid centering.
             */
            static CenterOn<O extends Triangle>(triangle: O, x: number, y: number, centerFunc?: CenterFunction): O;

            /**
             * Calculates the position of a Triangle's centroid, which is also its center of mass (center of gravity).
             *
             * The centroid is the point in a Triangle at which its three medians (the lines drawn from the vertices to the bisectors of the opposite sides) meet. It divides each one in a 2:1 ratio.
             * @param triangle The Triangle to use.
             * @param out An object to store the coordinates in.
             */
            static Centroid<O extends Point>(triangle: Triangle, out?: O): O;

            /**
             * Computes the circumcentre of a triangle. The circumcentre is the centre of
             * the circumcircle, the smallest circle which encloses the triangle. It is also
             * the common intersection point of the perpendicular bisectors of the sides of
             * the triangle, and is the only point which has equal distance to all three
             * vertices of the triangle.
             * @param triangle [description]
             * @param out [description]
             */
            static CircumCenter<O extends Math.Vector2>(triangle: Triangle, out?: O): O;

            /**
             * Finds the circumscribed circle (circumcircle) of a Triangle object. The circumcircle is the circle which touches all of the triangle's vertices.
             * @param triangle The Triangle to use as input.
             * @param out An optional Circle to store the result in.
             */
            static CircumCircle<O extends Circle>(triangle: Triangle, out?: O): O;

            /**
             * Clones a Triangle object.
             * @param source The Triangle to clone.
             */
            static Clone(source: Triangle): Triangle;

            /**
             * Checks if a point (as a pair of coordinates) is inside a Triangle's bounds.
             * @param triangle The Triangle to check.
             * @param x The X coordinate of the point to check.
             * @param y The Y coordinate of the point to check.
             */
            static Contains(triangle: Triangle, x: number, y: number): boolean;

            /**
             * Filters an array of point-like objects to only those contained within a triangle.
             * If `returnFirst` is true, will return an array containing only the first point in the provided array that is within the triangle (or an empty array if there are no such points).
             * @param triangle The triangle that the points are being checked in.
             * @param points An array of point-like objects (objects that have an `x` and `y` property)
             * @param returnFirst If `true`, return an array containing only the first point found that is within the triangle. Default false.
             * @param out If provided, the points that are within the triangle will be appended to this array instead of being added to a new array.
             * If `returnFirst` is true, only the first point found within the triangle will be appended. This array will also be returned by this function.
             */
            static ContainsArray(triangle: Triangle, points: Point[], returnFirst?: boolean, out?: any[]): Point[];

            /**
             * Tests if a triangle contains a point.
             * @param triangle The triangle.
             * @param point The point to test, or any point-like object with public `x` and `y` properties.
             */
            static ContainsPoint(triangle: Triangle, point: Point | Math.Vector2 | {x: number; y: number}): boolean;

            /**
             * Copy the values of one Triangle to a destination Triangle.
             * @param source The source Triangle to copy the values from.
             * @param dest The destination Triangle to copy the values to.
             */
            static CopyFrom<O extends Triangle>(source: Triangle, dest: O): O;

            /**
             * Decomposes a Triangle into an array of its points.
             * @param triangle The Triangle to decompose.
             * @param out An array to store the points into.
             */
            static Decompose(triangle: Triangle, out?: any[]): any[];

            /**
             * Returns true if two triangles have the same coordinates.
             * @param triangle The first triangle to check.
             * @param toCompare The second triangle to check.
             */
            static Equals(triangle: Triangle, toCompare: Triangle): boolean;

            /**
             * Returns a Point from around the perimeter of a Triangle.
             * @param triangle The Triangle to get the point on its perimeter from.
             * @param position The position along the perimeter of the triangle. A value between 0 and 1.
             * @param out An option Point, or Point-like object to store the value in. If not given a new Point will be created.
             */
            static GetPoint<O extends Point>(triangle: Triangle, position: number, out?: O): O;

            /**
             * Returns an array of evenly spaced points on the perimeter of a Triangle.
             * @param triangle The Triangle to get the points from.
             * @param quantity The number of evenly spaced points to return. Set to 0 to return an arbitrary number of points based on the `stepRate`.
             * @param stepRate If `quantity` is 0, the distance between each returned point.
             * @param out An array to which the points should be appended.
             */
            static GetPoints<O extends Point>(triangle: Triangle, quantity: integer, stepRate: number, out?: O): O;

            /**
             * Calculates the position of the incenter of a Triangle object.
             * This is the point where its three angle bisectors meet and it's also the center of the incircle, which is the circle inscribed in the triangle.
             * @param triangle The Triangle to find the incenter of.
             * @param out An optional Point in which to store the coordinates.
             */
            static InCenter<O extends Point>(triangle: Triangle, out?: O): O;

            /**
             * Moves each point (vertex) of a Triangle by a given offset, thus moving the entire Triangle by that offset.
             * @param triangle The Triangle to move.
             * @param x The horizontal offset (distance) by which to move each point. Can be positive or negative.
             * @param y The vertical offset (distance) by which to move each point. Can be positive or negative.
             */
            static Offset<O extends Triangle>(triangle: O, x: number, y: number): O;

            /**
             * Gets the length of the perimeter of the given triangle.
             * @param triangle [description]
             */
            static Perimeter(triangle: Triangle): number;

            /**
             * [description]
             * @param triangle [description]
             * @param out [description]
             */
            static Random<O extends Point>(triangle: Triangle, out?: O): O;

            /**
             * Rotates a Triangle about its incenter, which is the point at which its three angle bisectors meet.
             * @param triangle The Triangle to rotate.
             * @param angle The angle by which to rotate the Triangle, in radians.
             */
            static Rotate<O extends Triangle>(triangle: O, angle: number): O;

            /**
             * Rotates a Triangle at a certain angle about a given Point or object with public `x` and `y` properties.
             * @param triangle The Triangle to rotate.
             * @param point The Point to rotate the Triangle about.
             * @param angle The angle by which to rotate the Triangle, in radians.
             */
            static RotateAroundPoint<O extends Triangle>(triangle: O, point: Point, angle: number): O;

            /**
             * Rotates an entire Triangle at a given angle about a specific point.
             * @param triangle The Triangle to rotate.
             * @param x The X coordinate of the point to rotate the Triangle about.
             * @param y The Y coordinate of the point to rotate the Triangle about.
             * @param angle The angle by which to rotate the Triangle, in radians.
             */
            static RotateAroundXY<O extends Triangle>(triangle: O, x: number, y: number, angle: number): O;

            /**
             * `x` coordinate of the first point.
             */
            x1: number;

            /**
             * `y` coordinate of the first point.
             */
            y1: number;

            /**
             * `x` coordinate of the second point.
             */
            x2: number;

            /**
             * `y` coordinate of the second point.
             */
            y2: number;

            /**
             * `x` coordinate of the third point.
             */
            x3: number;

            /**
             * `y` coordinate of the third point.
             */
            y3: number;

            /**
             * Checks whether a given points lies within the triangle.
             * @param x The x coordinate of the point to check.
             * @param y The y coordinate of the point to check.
             */
            contains(x: number, y: number): boolean;

            /**
             * Returns a specific point  on the triangle.
             * @param position Position as float within `0` and `1`. `0` equals the first point.
             * @param output Optional Point, or point-like object, that the calculated point will be written to.
             */
            getPoint<O extends Point>(position: number, output?: O): O;

            /**
             * Calculates a list of evenly distributed points on the triangle.
             * It is either possible to pass an amount of points to be generated (`quantity`) or the distance between two points (`stepRate`).
             * @param quantity Number of points to be generated. Can be falsey when `stepRate` should be used. All points have the same distance along the triangle.
             * @param stepRate Distance between two points. Will only be used when `quantity` is falsey.
             * @param output Optional Array for writing the calculated points into. Otherwise a new array will be created.
             */
            getPoints<O extends Point[]>(quantity: integer, stepRate?: number, output?: O): O;

            /**
             * Returns a random point along the triangle.
             * @param point Optional `Point` that should be modified. Otherwise a new one will be created.
             */
            getRandomPoint<O extends Point>(point?: O): O;

            /**
             * Sets all three points of the triangle. Leaving out any coordinate sets it to be `0`.
             * @param x1 `x` coordinate of the first point. Default 0.
             * @param y1 `y` coordinate of the first point. Default 0.
             * @param x2 `x` coordinate of the second point. Default 0.
             * @param y2 `y` coordinate of the second point. Default 0.
             * @param x3 `x` coordinate of the third point. Default 0.
             * @param y3 `y` coordinate of the third point. Default 0.
             */
            setTo(x1?: number, y1?: number, x2?: number, y2?: number, x3?: number, y3?: number): Triangle;

            /**
             * Returns a Line object that corresponds to Line A of this Triangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineA<O extends Line>(line?: O): O;

            /**
             * Returns a Line object that corresponds to Line B of this Triangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineB<O extends Line>(line?: O): O;

            /**
             * Returns a Line object that corresponds to Line C of this Triangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineC<O extends Line>(line?: O): O;

            /**
             * Left most X coordinate of the triangle. Setting it moves the triangle on the X axis accordingly.
             */
            left: number;

            /**
             * Right most X coordinate of the triangle. Setting it moves the triangle on the X axis accordingly.
             */
            right: number;

            /**
             * Top most Y coordinate of the triangle. Setting it moves the triangle on the Y axis accordingly.
             */
            top: number;

            /**
             * Bottom most Y coordinate of the triangle. Setting it moves the triangle on the Y axis accordingly.
             */
            bottom: number;
        }
    }

    namespace Input {
        /**
         * The mouse pointer is being held down.
         */
        const MOUSE_DOWN: integer;

        /**
         * The mouse pointer is being moved.
         */
        const MOUSE_MOVE: integer;

        /**
         * The mouse pointer is released.
         */
        const MOUSE_UP: integer;

        /**
         * A touch pointer has been started.
         */
        const TOUCH_START: integer;

        /**
         * A touch pointer has been started.
         */
        const TOUCH_MOVE: integer;

        /**
         * A touch pointer has been started.
         */
        const TOUCH_END: integer;

        /**
         * A touch pointer has been been cancelled by the browser.
         */
        const TOUCH_CANCEL: integer;

        /**
         * The pointer lock has changed.
         */
        const POINTER_LOCK_CHANGE: integer;

        interface InteractiveObject {
            /**
             * The Game Object to which this Interactive Object is bound.
             */
            gameObject: GameObjects.GameObject;
            /**
             * Is this Interactive Object currently enabled for input events?
             */
            enabled: boolean;
            /**
             * Is this Interactive Object draggable? Enable with `InputPlugin.setDraggable`.
             */
            draggable: boolean;
            /**
             * Is this Interactive Object a drag-targets drop zone? Set when the object is created.
             */
            dropZone: boolean;
            /**
             * Should this Interactive Object change the cursor (via css) when over? (desktop only)
             */
            cursor: boolean | string;
            /**
             * An optional drop target for a draggable Interactive Object.
             */
            target: GameObjects.GameObject;
            /**
             * The most recent Camera to be tested against this Interactive Object.
             */
            camera: Cameras.Scene2D.Camera;
            /**
             * The hit area for this Interactive Object. Typically a geometry shape, like a Rectangle or Circle.
             */
            hitArea: any;
            /**
             * The 'contains' check callback that the hit area shape will use for all hit tests.
             */
            hitAreaCallback: HitAreaCallback;
            /**
             * The x coordinate that the Pointer interacted with this object on, relative to the Game Object's top-left position.
             */
            localX: number;
            /**
             * The y coordinate that the Pointer interacted with this object on, relative to the Game Object's top-left position.
             */
            localY: number;
            /**
             * The current drag state of this Interactive Object. 0 = Not being dragged, 1 = being checked for drag, or 2 = being actively dragged.
             */
            dragState: 0 | 1 | 2;
            /**
             * The x coordinate that the Pointer started dragging this Interactive Object from.
             */
            dragStartX: number;
            /**
             * The y coordinate that the Pointer started dragging this Interactive Object from.
             */
            dragStartY: number;
            /**
             * The x coordinate that this Interactive Object is currently being dragged to.
             */
            dragX: number;
            /**
             * The y coordinate that this Interactive Object is currently being dragged to.
             */
            dragY: number;
        }

        /**
         * Creates a new Interactive Object.
         *
         * This is called automatically by the Input Manager when you enable a Game Object for input.
         *
         * The resulting Interactive Object is mapped to the Game Object's `input` property.
         * @param gameObject The Game Object to which this Interactive Object is bound.
         * @param hitArea The hit area for this Interactive Object. Typically a geometry shape, like a Rectangle or Circle.
         * @param hitAreaCallback The 'contains' check callback that the hit area shape will use for all hit tests.
         */
        function CreateInteractiveObject(gameObject: GameObjects.GameObject, hitArea: any, hitAreaCallback: HitAreaCallback): InteractiveObject;

        /**
         * Creates a new Pixel Perfect Handler function.
         *
         * Access via `InputPlugin.makePixelPerfect` rather than calling it directly.
         * @param textureManager A reference to the Texture Manager.
         * @param alphaTolerance The alpha level that the pixel should be above to be included as a successful interaction.
         */
        function CreatePixelPerfectHandler(textureManager: Textures.TextureManager, alphaTolerance: integer): CallbackFn;

        /**
         * A Phaser Input Event Data object.
         *
         * This object is passed to the registered event listeners and allows you to stop any further propagation.
         */
        interface EventData {
            /**
             * The cancelled state of this Event.
             */
            cancelled?: boolean;
            /**
             * Call this method to stop this event from passing any further down the event chain.
             */
            stopPropagation: CallbackFn;
        }

        namespace Events {
            /**
             * The Input Plugin Boot Event.
             *
             * This internal event is dispatched by the Input Plugin when it boots, signalling to all of its systems to create themselves.
             */
            const BOOT: any;

            /**
             * The Input Plugin Destroy Event.
             *
             * This internal event is dispatched by the Input Plugin when it is destroyed, signalling to all of its systems to destroy themselves.
             */
            const DESTROY: any;

            /**
             * The Pointer Drag End Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer stops dragging a Game Object.
             *
             * Listen to this event from within a Scene using: `this.input.on('dragend', listener)`.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_END]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_END} event instead.
             */
            const DRAG_END: any;

            /**
             * The Pointer Drag Enter Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object into a Drag Target.
             *
             * Listen to this event from within a Scene using: `this.input.on('dragenter', listener)`.
             *
             * A Pointer can only drag a single Game Object at once.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_ENTER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_ENTER} event instead.
             */
            const DRAG_ENTER: any;

            /**
             * The Pointer Drag Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer moves while dragging a Game Object.
             *
             * Listen to this event from within a Scene using: `this.input.on('drag', listener)`.
             *
             * A Pointer can only drag a single Game Object at once.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG} event instead.
             */
            const DRAG: any;

            /**
             * The Pointer Drag Leave Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object out of a Drag Target.
             *
             * Listen to this event from within a Scene using: `this.input.on('dragleave', listener)`.
             *
             * A Pointer can only drag a single Game Object at once.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_LEAVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_LEAVE} event instead.
             */
            const DRAG_LEAVE: any;

            /**
             * The Pointer Drag Over Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object over a Drag Target.
             *
             * When the Game Object first enters the drag target it will emit a `dragenter` event. If it then moves while within
             * the drag target, it will emit this event instead.
             *
             * Listen to this event from within a Scene using: `this.input.on('dragover', listener)`.
             *
             * A Pointer can only drag a single Game Object at once.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_OVER} event instead.
             */
            const DRAG_OVER: any;

            /**
             * The Pointer Drag Start Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer starts to drag any Game Object.
             *
             * Listen to this event from within a Scene using: `this.input.on('dragstart', listener)`.
             *
             * A Pointer can only drag a single Game Object at once.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_START]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_START} event instead.
             */
            const DRAG_START: any;

            /**
             * The Pointer Drop Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer drops a Game Object on a Drag Target.
             *
             * Listen to this event from within a Scene using: `this.input.on('drop', listener)`.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DROP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DROP} event instead.
             */
            const DROP: any;

            /**
             * The Game Object Down Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down on _any_ interactive Game Object.
             *
             * Listen to this event from within a Scene using: `this.input.on('gameobjectdown', listener)`.
             *
             * To receive this event, the Game Objects must have been set as interactive.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN} event instead.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}
             * 2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}
             * 3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const GAMEOBJECT_DOWN: any;

            /**
             * The Game Object Drag End Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer stops dragging it.
             *
             * Listen to this event from a Game Object using: `gameObject.on('dragend', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive and enabled for drag.
             * See [GameObject.setInteractive](Phaser.GameObjects.GameObject#setInteractive) for more details.
             */
            const GAMEOBJECT_DRAG_END: any;

            /**
             * The Game Object Drag Enter Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer drags it into a drag target.
             *
             * Listen to this event from a Game Object using: `gameObject.on('dragenter', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive and enabled for drag.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             */
            const GAMEOBJECT_DRAG_ENTER: any;

            /**
             * The Game Object Drag Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer moves while dragging it.
             *
             * Listen to this event from a Game Object using: `gameObject.on('drag', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive and enabled for drag.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             */
            const GAMEOBJECT_DRAG: any;

            /**
             * The Game Object Drag Leave Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer drags it out of a drag target.
             *
             * Listen to this event from a Game Object using: `gameObject.on('dragleave', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive and enabled for drag.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             */
            const GAMEOBJECT_DRAG_LEAVE: any;

            /**
             * The Game Object Drag Over Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer drags it over a drag target.
             *
             * When the Game Object first enters the drag target it will emit a `dragenter` event. If it then moves while within
             * the drag target, it will emit this event instead.
             *
             * Listen to this event from a Game Object using: `gameObject.on('dragover', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive and enabled for drag.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             */
            const GAMEOBJECT_DRAG_OVER: any;

            /**
             * The Game Object Drag Start Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer starts to drag it.
             *
             * Listen to this event from a Game Object using: `gameObject.on('dragstart', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive and enabled for drag.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * There are lots of useful drag related properties that are set within the Game Object when dragging occurs.
             * For example, `gameObject.input.dragStartX`, `dragStartY` and so on.
             */
            const GAMEOBJECT_DRAG_START: any;

            /**
             * The Game Object Drop Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer drops it on a Drag Target.
             *
             * Listen to this event from a Game Object using: `gameObject.on('drop', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive and enabled for drag.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             */
            const GAMEOBJECT_DROP: any;

            /**
             * The Game Object Move Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is moved across _any_ interactive Game Object.
             *
             * Listen to this event from within a Scene using: `this.input.on('gameobjectmove', listener)`.
             *
             * To receive this event, the Game Objects must have been set as interactive.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE} event instead.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}
             * 2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}
             * 3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const GAMEOBJECT_MOVE: any;

            /**
             * The Game Object Out Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer moves out of _any_ interactive Game Object.
             *
             * Listen to this event from within a Scene using: `this.input.on('gameobjectout', listener)`.
             *
             * To receive this event, the Game Objects must have been set as interactive.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT} event instead.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}
             * 2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}
             * 3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const GAMEOBJECT_OUT: any;

            /**
             * The Game Object Over Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer moves over _any_ interactive Game Object.
             *
             * Listen to this event from within a Scene using: `this.input.on('gameobjectover', listener)`.
             *
             * To receive this event, the Game Objects must have been set as interactive.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER} event instead.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}
             * 2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}
             * 3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const GAMEOBJECT_OVER: any;

            /**
             * The Game Object Pointer Down Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer is pressed down on it.
             *
             * Listen to this event from a Game Object using: `gameObject.on('pointerdown', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}
             * 2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}
             * 3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const GAMEOBJECT_POINTER_DOWN: any;

            /**
             * The Game Object Pointer Move Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer is moved while over it.
             *
             * Listen to this event from a Game Object using: `gameObject.on('pointermove', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}
             * 2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}
             * 3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const GAMEOBJECT_POINTER_MOVE: any;

            /**
             * The Game Object Pointer Out Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer moves out of it.
             *
             * Listen to this event from a Game Object using: `gameObject.on('pointerout', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}
             * 2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}
             * 3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const GAMEOBJECT_POINTER_OUT: any;

            /**
             * The Game Object Pointer Over Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer moves over it.
             *
             * Listen to this event from a Game Object using: `gameObject.on('pointerover', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}
             * 2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}
             * 3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const GAMEOBJECT_POINTER_OVER: any;

            /**
             * The Game Object Pointer Up Event.
             *
             * This event is dispatched by an interactive Game Object if a pointer is released while over it.
             *
             * Listen to this event from a Game Object using: `gameObject.on('pointerup', listener)`.
             * Note that the scope of the listener is automatically set to be the Game Object instance itself.
             *
             * To receive this event, the Game Object must have been set as interactive.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}
             * 2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}
             * 3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const GAMEOBJECT_POINTER_UP: any;

            /**
             * The Game Object Up Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is released while over _any_ interactive Game Object.
             *
             * Listen to this event from within a Scene using: `this.input.on('gameobjectup', listener)`.
             *
             * To receive this event, the Game Objects must have been set as interactive.
             * See [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.
             *
             * To listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP} event instead.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}
             * 2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}
             * 3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const GAMEOBJECT_UP: any;

            /**
             * The Input Plugin Game Out Event.
             *
             * This event is dispatched by the Input Plugin if the active pointer leaves the game canvas and is now
             * outside of it, elsewhere on the web page.
             *
             * Listen to this event from within a Scene using: `this.input.on('gameout', listener)`.
             */
            const GAME_OUT: any;

            /**
             * The Input Plugin Game Over Event.
             *
             * This event is dispatched by the Input Plugin if the active pointer enters the game canvas and is now
             * over of it, having previously been elsewhere on the web page.
             *
             * Listen to this event from within a Scene using: `this.input.on('gameover', listener)`.
             */
            const GAME_OVER: any;

            /**
             * The Input Manager Boot Event.
             *
             * This internal event is dispatched by the Input Manager when it boots.
             */
            const MANAGER_BOOT: any;

            /**
             * The Input Manager Process Event.
             *
             * This internal event is dispatched by the Input Manager when not using the legacy queue system,
             * and it wants the Input Plugins to update themselves.
             */
            const MANAGER_PROCESS: any;

            /**
             * The Input Manager Update Event.
             *
             * This internal event is dispatched by the Input Manager as part of its update step.
             */
            const MANAGER_UPDATE: any;

            /**
             * The Input Manager Pointer Lock Change Event.
             *
             * This event is dispatched by the Input Manager when it is processing a native Pointer Lock Change DOM Event.
             */
            const POINTERLOCK_CHANGE: any;

            /**
             * The Pointer Down Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down anywhere.
             *
             * Listen to this event from within a Scene using: `this.input.on('pointerdown', listener)`.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}
             * 2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}
             * 3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const POINTER_DOWN: any;

            /**
             * The Pointer Down Outside Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down anywhere outside of the game canvas.
             *
             * Listen to this event from within a Scene using: `this.input.on('pointerdownoutside', listener)`.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}
             * 2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}
             * 3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const POINTER_DOWN_OUTSIDE: any;

            /**
             * The Pointer Move Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is moved anywhere.
             *
             * Listen to this event from within a Scene using: `this.input.on('pointermove', listener)`.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}
             * 2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}
             * 3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const POINTER_MOVE: any;

            /**
             * The Pointer Out Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer moves out of any interactive Game Object.
             *
             * Listen to this event from within a Scene using: `this.input.on('pointerup', listener)`.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}
             * 2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}
             * 3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const POINTER_OUT: any;

            /**
             * The Pointer Over Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer moves over any interactive Game Object.
             *
             * Listen to this event from within a Scene using: `this.input.on('pointerover', listener)`.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}
             * 2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}
             * 3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const POINTER_OVER: any;

            /**
             * The Pointer Up Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is released anywhere.
             *
             * Listen to this event from within a Scene using: `this.input.on('pointerup', listener)`.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}
             * 2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}
             * 3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const POINTER_UP: any;

            /**
             * The Pointer Up Outside Input Event.
             *
             * This event is dispatched by the Input Plugin belonging to a Scene if a pointer is released anywhere outside of the game canvas.
             *
             * Listen to this event from within a Scene using: `this.input.on('pointerupoutside', listener)`.
             *
             * The event hierarchy is as follows:
             *
             * 1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}
             * 2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}
             * 3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}
             *
             * With the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop
             * the propagation of this event.
             */
            const POINTER_UP_OUTSIDE: any;

            /**
             * The Input Plugin Pre-Update Event.
             *
             * This internal event is dispatched by the Input Plugin at the start of its `preUpdate` method.
             * This hook is designed specifically for input plugins, but can also be listened to from user-land code.
             */
            const PRE_UPDATE: any;

            /**
             * The Input Plugin Shutdown Event.
             *
             * This internal event is dispatched by the Input Plugin when it shuts down, signalling to all of its systems to shut themselves down.
             */
            const SHUTDOWN: any;

            /**
             * The Input Plugin Start Event.
             *
             * This internal event is dispatched by the Input Plugin when it has finished setting-up,
             * signalling to all of its internal systems to start.
             */
            const START: any;

            /**
             * The Input Plugin Update Event.
             *
             * This internal event is dispatched by the Input Plugin at the start of its `update` method.
             * This hook is designed specifically for input plugins, but can also be listened to from user-land code.
             */
            const UPDATE: any;
        }

        namespace Gamepad {
            /**
             * Contains information about a specific Gamepad Axis.
             * Axis objects are created automatically by the Gamepad as they are needed.
             */
            class Axis {
                /**
                 *
                 * @param pad A reference to the Gamepad that this Axis belongs to.
                 * @param index The index of this Axis.
                 */
                constructor(pad: Gamepad, index: integer);

                /**
                 * A reference to the Gamepad that this Axis belongs to.
                 */
                pad: Gamepad;

                /**
                 * An event emitter to use to emit the axis events.
                 */
                events: Phaser.Events.EventEmitter;

                /**
                 * The index of this Axis.
                 */
                index: integer;

                /**
                 * The raw axis value, between -1 and 1 with 0 being dead center.
                 * Use the method `getValue` to get a normalized value with the threshold applied.
                 */
                value: number;

                /**
                 * Movement tolerance threshold below which axis values are ignored in `getValue`.
                 */
                threshold: number;

                /**
                 * Applies the `threshold` value to the axis and returns it.
                 */
                getValue(): number;

                /**
                 * Destroys this Axis instance and releases external references it holds.
                 */
                destroy(): void;
            }

            /**
             * Contains information about a specific button on a Gamepad.
             * Button objects are created automatically by the Gamepad as they are needed.
             */
            class Button {
                /**
                 *
                 * @param pad A reference to the Gamepad that this Button belongs to.
                 * @param index The index of this Button.
                 */
                constructor(pad: Gamepad, index: integer);

                /**
                 * A reference to the Gamepad that this Button belongs to.
                 */
                pad: Gamepad;

                /**
                 * An event emitter to use to emit the button events.
                 */
                events: Phaser.Events.EventEmitter;

                /**
                 * The index of this Button.
                 */
                index: integer;

                /**
                 * Between 0 and 1.
                 */
                value: number;

                /**
                 * Can be set for analogue buttons to enable a 'pressure' threshold,
                 * before a button is considered as being 'pressed'.
                 */
                threshold: number;

                /**
                 * Is the Button being pressed down or not?
                 */
                pressed: boolean;

                /**
                 * Destroys this Button instance and releases external references it holds.
                 */
                destroy(): void;
            }

            namespace Configs {
                /**
                 * Tatar SNES USB Controller Gamepad Configuration.
                 * USB Gamepad  (STANDARD GAMEPAD Vendor: 0079 Product: 0011)
                 */
                const SNES_USB: object;

                /**
                 * PlayStation DualShock 4 Gamepad Configuration.
                 * Sony PlayStation DualShock 4 (v2) wireless controller
                 */
                const DUALSHOCK_4: object;

                /**
                 * XBox 360 Gamepad Configuration.
                 */
                const XBOX_360: object;
            }

            namespace Events {
                /**
                 * The Gamepad Button Down Event.
                 *
                 * This event is dispatched by the Gamepad Plugin when a button has been pressed on any active Gamepad.
                 *
                 * Listen to this event from within a Scene using: `this.input.gamepad.on('down', listener)`.
                 *
                 * You can also listen for a DOWN event from a Gamepad instance. See the [GAMEPAD_BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_DOWN} event for details.
                 */
                const BUTTON_DOWN: any;

                /**
                 * The Gamepad Button Up Event.
                 *
                 * This event is dispatched by the Gamepad Plugin when a button has been released on any active Gamepad.
                 *
                 * Listen to this event from within a Scene using: `this.input.gamepad.on('up', listener)`.
                 *
                 * You can also listen for an UP event from a Gamepad instance. See the [GAMEPAD_BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_UP} event for details.
                 */
                const BUTTON_UP: any;

                /**
                 * The Gamepad Connected Event.
                 *
                 * This event is dispatched by the Gamepad Plugin when a Gamepad has been connected.
                 *
                 * Listen to this event from within a Scene using: `this.input.gamepad.once('connected', listener)`.
                 *
                 * Note that the browser may require you to press a button on a gamepad before it will allow you to access it,
                 * this is for security reasons. However, it may also trust the page already, in which case you won't get the
                 * 'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads
                 * already connected.
                 */
                const CONNECTED: any;

                /**
                 * The Gamepad Disconnected Event.
                 *
                 * This event is dispatched by the Gamepad Plugin when a Gamepad has been disconnected.
                 *
                 * Listen to this event from within a Scene using: `this.input.gamepad.once('disconnected', listener)`.
                 */
                const DISCONNECTED: any;

                /**
                 * The Gamepad Button Down Event.
                 *
                 * This event is dispatched by a Gamepad instance when a button has been pressed on it.
                 *
                 * Listen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:
                 * `this.input.gamepad.pad1.on('down', listener)`.
                 *
                 * Note that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.
                 *
                 * You can also listen for a DOWN event from the Gamepad Plugin. See the [BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_DOWN} event for details.
                 */
                const GAMEPAD_BUTTON_DOWN: any;

                /**
                 * The Gamepad Button Up Event.
                 *
                 * This event is dispatched by a Gamepad instance when a button has been released on it.
                 *
                 * Listen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:
                 * `this.input.gamepad.pad1.on('up', listener)`.
                 *
                 * Note that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.
                 *
                 * You can also listen for an UP event from the Gamepad Plugin. See the [BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_UP} event for details.
                 */
                const GAMEPAD_BUTTON_UP: any;
            }

            /**
             * A single Gamepad.
             *
             * These are created, updated and managed by the Gamepad Plugin.
             */
            class Gamepad extends Phaser.Events.EventEmitter {
                /**
                 *
                 * @param manager A reference to the Gamepad Plugin.
                 * @param pad The Gamepad object, as extracted from GamepadEvent.
                 */
                constructor(manager: GamepadPlugin, pad: Pad);

                /**
                 * A reference to the Gamepad Plugin.
                 */
                manager: GamepadPlugin;

                /**
                 * A reference to the native Gamepad object that is connected to the browser.
                 */
                pad: any;

                /**
                 * A string containing some information about the controller.
                 *
                 * This is not strictly specified, but in Firefox it will contain three pieces of information
                 * separated by dashes (-): two 4-digit hexadecimal strings containing the USB vendor and
                 * product id of the controller, and the name of the controller as provided by the driver.
                 * In Chrome it will contain the name of the controller as provided by the driver,
                 * followed by vendor and product 4-digit hexadecimal strings.
                 */
                id: string;

                /**
                 * An integer that is unique for each Gamepad currently connected to the system.
                 * This can be used to distinguish multiple controllers.
                 * Note that disconnecting a device and then connecting a new device may reuse the previous index.
                 */
                index: number;

                /**
                 * An array of Gamepad Button objects, corresponding to the different buttons available on the Gamepad.
                 */
                buttons: Button[];

                /**
                 * An array of Gamepad Axis objects, corresponding to the different axes available on the Gamepad, if any.
                 */
                axes: Axis[];

                /**
                 * The Gamepad's Haptic Actuator (Vibration / Rumble support).
                 * This is highly experimental and only set if both present on the device,
                 * and exposed by both the hardware and browser.
                 */
                vibration: GamepadHapticActuator;

                /**
                 * A Vector2 containing the most recent values from the Gamepad's left axis stick.
                 * This is updated automatically as part of the Gamepad.update cycle.
                 * The H Axis is mapped to the `Vector2.x` property, and the V Axis to the `Vector2.y` property.
                 * The values are based on the Axis thresholds.
                 * If the Gamepad does not have a left axis stick, the values will always be zero.
                 */
                leftStick: Math.Vector2;

                /**
                 * A Vector2 containing the most recent values from the Gamepad's right axis stick.
                 * This is updated automatically as part of the Gamepad.update cycle.
                 * The H Axis is mapped to the `Vector2.x` property, and the V Axis to the `Vector2.y` property.
                 * The values are based on the Axis thresholds.
                 * If the Gamepad does not have a right axis stick, the values will always be zero.
                 */
                rightStick: Math.Vector2;

                /**
                 * Gets the total number of axis this Gamepad claims to support.
                 */
                getAxisTotal(): integer;

                /**
                 * Gets the value of an axis based on the given index.
                 * The index must be valid within the range of axes supported by this Gamepad.
                 * The return value will be a float between 0 and 1.
                 * @param index The index of the axes to get the value for.
                 */
                getAxisValue(index: integer): number;

                /**
                 * Sets the threshold value of all axis on this Gamepad.
                 * The value is a float between 0 and 1 and is the amount below which the axis is considered as not having been moved.
                 * @param value A value between 0 and 1.
                 */
                setAxisThreshold(value: number): void;

                /**
                 * Gets the total number of buttons this Gamepad claims to have.
                 */
                getButtonTotal(): integer;

                /**
                 * Gets the value of a button based on the given index.
                 * The index must be valid within the range of buttons supported by this Gamepad.
                 *
                 * The return value will be either 0 or 1 for an analogue button, or a float between 0 and 1
                 * for a pressure-sensitive digital button, such as the shoulder buttons on a Dual Shock.
                 * @param index The index of the button to get the value for.
                 */
                getButtonValue(index: integer): number;

                /**
                 * Returns if the button is pressed down or not.
                 * The index must be valid within the range of buttons supported by this Gamepad.
                 * @param index The index of the button to get the value for.
                 */
                isButtonDown(index: integer): boolean;

                /**
                 * Destroys this Gamepad instance, its buttons and axes, and releases external references it holds.
                 */
                destroy(): void;

                /**
                 * Is this Gamepad currently connected or not?
                 */
                connected: boolean;

                /**
                 * A timestamp containing the most recent time this Gamepad was updated.
                 */
                timestamp: number;

                /**
                 * Is the Gamepad's Left button being pressed?
                 * If the Gamepad doesn't have this button it will always return false.
                 * This is the d-pad left button under standard Gamepad mapping.
                 */
                left: boolean;

                /**
                 * Is the Gamepad's Right button being pressed?
                 * If the Gamepad doesn't have this button it will always return false.
                 * This is the d-pad right button under standard Gamepad mapping.
                 */
                right: boolean;

                /**
                 * Is the Gamepad's Up button being pressed?
                 * If the Gamepad doesn't have this button it will always return false.
                 * This is the d-pad up button under standard Gamepad mapping.
                 */
                up: boolean;

                /**
                 * Is the Gamepad's Down button being pressed?
                 * If the Gamepad doesn't have this button it will always return false.
                 * This is the d-pad down button under standard Gamepad mapping.
                 */
                down: boolean;

                /**
                 * Is the Gamepad's bottom button in the right button cluster being pressed?
                 * If the Gamepad doesn't have this button it will always return false.
                 * On a Dual Shock controller it's the X button.
                 * On an XBox controller it's the A button.
                 */
                A: boolean;

                /**
                 * Is the Gamepad's top button in the right button cluster being pressed?
                 * If the Gamepad doesn't have this button it will always return false.
                 * On a Dual Shock controller it's the Triangle button.
                 * On an XBox controller it's the Y button.
                 */
                Y: boolean;

                /**
                 * Is the Gamepad's left button in the right button cluster being pressed?
                 * If the Gamepad doesn't have this button it will always return false.
                 * On a Dual Shock controller it's the Square button.
                 * On an XBox controller it's the X button.
                 */
                X: boolean;

                /**
                 * Is the Gamepad's right button in the right button cluster being pressed?
                 * If the Gamepad doesn't have this button it will always return false.
                 * On a Dual Shock controller it's the Circle button.
                 * On an XBox controller it's the B button.
                 */
                B: boolean;

                /**
                 * Returns the value of the Gamepad's top left shoulder button.
                 * If the Gamepad doesn't have this button it will always return zero.
                 * The value is a float between 0 and 1, corresponding to how depressed the button is.
                 * On a Dual Shock controller it's the L1 button.
                 * On an XBox controller it's the LB button.
                 */
                L1: number;

                /**
                 * Returns the value of the Gamepad's bottom left shoulder button.
                 * If the Gamepad doesn't have this button it will always return zero.
                 * The value is a float between 0 and 1, corresponding to how depressed the button is.
                 * On a Dual Shock controller it's the L2 button.
                 * On an XBox controller it's the LT button.
                 */
                L2: number;

                /**
                 * Returns the value of the Gamepad's top right shoulder button.
                 * If the Gamepad doesn't have this button it will always return zero.
                 * The value is a float between 0 and 1, corresponding to how depressed the button is.
                 * On a Dual Shock controller it's the R1 button.
                 * On an XBox controller it's the RB button.
                 */
                R1: number;

                /**
                 * Returns the value of the Gamepad's bottom right shoulder button.
                 * If the Gamepad doesn't have this button it will always return zero.
                 * The value is a float between 0 and 1, corresponding to how depressed the button is.
                 * On a Dual Shock controller it's the R2 button.
                 * On an XBox controller it's the RT button.
                 */
                R2: number;
            }

            /**
             * The Gamepad Plugin is an input plugin that belongs to the Scene-owned Input system.
             *
             * Its role is to listen for native DOM Gamepad Events and then process them.
             *
             * You do not need to create this class directly, the Input system will create an instance of it automatically.
             *
             * You can access it from within a Scene using `this.input.gamepad`.
             *
             * To listen for a gamepad being connected:
             *
             * ```javascript
             * this.input.gamepad.once('connected', function (pad) {
             *     //   'pad' is a reference to the gamepad that was just connected
             * });
             * ```
             *
             * Note that the browser may require you to press a button on a gamepad before it will allow you to access it,
             * this is for security reasons. However, it may also trust the page already, in which case you won't get the
             * 'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads
             * already connected.
             *
             * Once you have received the connected event, or polled the gamepads and found them enabled, you can access
             * them via the built-in properties `GamepadPlugin.pad1` to `pad4`, for up to 4 game pads. With a reference
             * to the gamepads you can poll its buttons and axis sticks. See the properties and methods available on
             * the `Gamepad` class for more details.
             *
             * For more information about Gamepad support in browsers see the following resources:
             *
             * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API
             * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API
             * https://www.smashingmagazine.com/2015/11/gamepad-api-in-web-games/
             * http://html5gamepad.com/
             */
            class GamepadPlugin extends Phaser.Events.EventEmitter {
                /**
                 *
                 * @param sceneInputPlugin A reference to the Scene Input Plugin that the KeyboardPlugin belongs to.
                 */
                constructor(sceneInputPlugin: InputPlugin);

                /**
                 * A reference to the Scene that this Input Plugin is responsible for.
                 */
                scene: Scene;

                /**
                 * A reference to the Scene Systems Settings.
                 */
                settings: Scenes.Settings.Object;

                /**
                 * A reference to the Scene Input Plugin that created this Keyboard Plugin.
                 */
                sceneInputPlugin: InputPlugin;

                /**
                 * A boolean that controls if the Gamepad Manager is enabled or not.
                 * Can be toggled on the fly.
                 */
                enabled: boolean;

                /**
                 * The Gamepad Event target, as defined in the Game Config.
                 * Typically the browser window, but can be any interactive DOM element.
                 */
                target: any;

                /**
                 * An array of the connected Gamepads.
                 */
                gamepads: Gamepad[];

                /**
                 * Checks to see if both this plugin and the Scene to which it belongs is active.
                 */
                isActive(): boolean;

                /**
                 * Disconnects all current Gamepads.
                 */
                disconnectAll(): void;

                /**
                 * Returns an array of all currently connected Gamepads.
                 */
                getAll(): Gamepad[];

                /**
                 * Looks-up a single Gamepad based on the given index value.
                 * @param index The index of the Gamepad to get.
                 */
                getPad(index: number): Gamepad;

                /**
                 * The total number of connected game pads.
                 */
                total: integer;

                /**
                 * A reference to the first connected Gamepad.
                 *
                 * This will be undefined if either no pads are connected, or the browser
                 * has not yet issued a gamepadconnect, which can happen even if a Gamepad
                 * is plugged in, but hasn't yet had any buttons pressed on it.
                 */
                pad1: Gamepad;

                /**
                 * A reference to the second connected Gamepad.
                 *
                 * This will be undefined if either no pads are connected, or the browser
                 * has not yet issued a gamepadconnect, which can happen even if a Gamepad
                 * is plugged in, but hasn't yet had any buttons pressed on it.
                 */
                pad2: Gamepad;

                /**
                 * A reference to the third connected Gamepad.
                 *
                 * This will be undefined if either no pads are connected, or the browser
                 * has not yet issued a gamepadconnect, which can happen even if a Gamepad
                 * is plugged in, but hasn't yet had any buttons pressed on it.
                 */
                pad3: Gamepad;

                /**
                 * A reference to the fourth connected Gamepad.
                 *
                 * This will be undefined if either no pads are connected, or the browser
                 * has not yet issued a gamepadconnect, which can happen even if a Gamepad
                 * is plugged in, but hasn't yet had any buttons pressed on it.
                 */
                pad4: Gamepad;
            }
        }

        /**
         * The Input Manager is responsible for handling the pointer related systems in a single Phaser Game instance.
         *
         * Based on the Game Config it will create handlers for mouse and touch support.
         *
         * Keyboard and Gamepad are plugins, handled directly by the InputPlugin class.
         *
         * It then manages the event queue, pointer creation and general hit test related operations.
         *
         * You rarely need to interact with the Input Manager directly, and as such, all of its properties and methods
         * should be considered private. Instead, you should use the Input Plugin, which is a Scene level system, responsible
         * for dealing with all input events for a Scene.
         */
        class InputManager {
            /**
             *
             * @param game The Game instance that owns the Input Manager.
             * @param config The Input Configuration object, as set in the Game Config.
             */
            constructor(game: Game, config: object);

            /**
             * The Game instance that owns the Input Manager.
             * A Game only maintains on instance of the Input Manager at any time.
             */
            readonly game: Game;

            /**
             * A reference to the global Game Scale Manager.
             * Used for all bounds checks and pointer scaling.
             */
            scaleManager: Scale.ScaleManager;

            /**
             * The Canvas that is used for all DOM event input listeners.
             */
            canvas: HTMLCanvasElement;

            /**
             * The Game Configuration object, as set during the game boot.
             */
            config: Core.Config;

            /**
             * If set, the Input Manager will run its update loop every frame.
             */
            enabled: boolean;

            /**
             * The Event Emitter instance that the Input Manager uses to emit events from.
             */
            events: Phaser.Events.EventEmitter;

            /**
             * A standard FIFO queue for the native DOM events waiting to be handled by the Input Manager.
             */
            queue: any[];

            /**
             * Are any mouse or touch pointers currently over the game canvas?
             * This is updated automatically by the canvas over and out handlers.
             */
            readonly isOver: boolean;

            /**
             * The default CSS cursor to be used when interacting with your game.
             *
             * See the `setDefaultCursor` method for more details.
             */
            defaultCursor: string;

            /**
             * A reference to the Keyboard Manager class, if enabled via the `input.keyboard` Game Config property.
             */
            keyboard: Keyboard.KeyboardManager;

            /**
             * A reference to the Mouse Manager class, if enabled via the `input.mouse` Game Config property.
             */
            mouse: Mouse.MouseManager;

            /**
             * A reference to the Touch Manager class, if enabled via the `input.touch` Game Config property.
             */
            touch: Touch.TouchManager;

            /**
             * An array of Pointers that have been added to the game.
             * The first entry is reserved for the Mouse Pointer, the rest are Touch Pointers.
             *
             * By default there is 1 touch pointer enabled. If you need more use the `addPointer` method to start them,
             * or set the `input.activePointers` property in the Game Config.
             */
            pointers: Pointer[];

            /**
             * The number of touch objects activated and being processed each update.
             *
             * You can change this by either calling `addPointer` at run-time, or by
             * setting the `input.activePointers` property in the Game Config.
             */
            readonly pointersTotal: integer;

            /**
             * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.
             * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`
             * which will always map to the most recently interacted pointer.
             */
            mousePointer: Pointer;

            /**
             * The most recently active Pointer object.
             *
             * If you've only 1 Pointer in your game then this will accurately be either the first finger touched, or the mouse.
             *
             * If your game doesn't need to support multi-touch then you can safely use this property in all of your game
             * code and it will adapt to be either the mouse or the touch, based on device.
             */
            activePointer: Pointer;

            /**
             * Reset every frame. Set to `true` if any of the Pointers are dirty this frame.
             */
            dirty: boolean;

            /**
             * If the top-most Scene in the Scene List receives an input it will stop input from
             * propagating any lower down the scene list, i.e. if you have a UI Scene at the top
             * and click something on it, that click will not then be passed down to any other
             * Scene below. Disable this to have input events passed through all Scenes, all the time.
             */
            globalTopOnly: boolean;

            /**
             * An internal flag that controls if the Input Manager will ignore or process native DOM events this frame.
             * Set via the InputPlugin.stopPropagation method.
             */
            ignoreEvents: boolean;

            /**
             * Use the internal event queue or not?
             *
             * Set this via the Game Config with the `inputQueue` property.
             *
             * Phaser 3.15.1 and earlier used a event queue by default.
             *
             * This was changed in version 3.16 to use an immediate-mode system.
             * The previous queue based version remains and is left under this flag for backwards
             * compatibility. This flag, along with the legacy system, will be removed in a future version.
             */
            useQueue: boolean;

            /**
             * The Boot handler is called by Phaser.Game when it first starts up.
             * The renderer is available by now.
             */
            protected boot(): void;

            /**
             * Tells the Input system to set a custom cursor.
             *
             * This cursor will be the default cursor used when interacting with the game canvas.
             *
             * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.
             *
             * Any valid CSS cursor value is allowed, including paths to image files, i.e.:
             *
             * ```javascript
             * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');
             * ```
             *
             * Please read about the differences between browsers when it comes to the file formats and sizes they support:
             *
             * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
             * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property
             *
             * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.
             * @param cursor The CSS to be used when setting the default cursor.
             */
            setDefaultCursor(cursor: string): void;

            /**
             * Adds new Pointer objects to the Input Manager.
             *
             * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.
             *
             * You can create more either by calling this method, or by setting the `input.activePointers` property
             * in the Game Config, up to a maximum of 10 pointers.
             *
             * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added
             * via this method.
             * @param quantity The number of new Pointers to create. A maximum of 10 is allowed in total. Default 1.
             */
            addPointer(quantity?: integer): Pointer[];

            /**
             * Internal method that gets a list of all the active Input Plugins in the game
             * and updates each of them in turn, in reverse order (top to bottom), to allow
             * for DOM top-level event handling simulation.
             * @param time The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().
             * @param delta The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.
             */
            updateInputPlugins(time: number, delta: number): void;

            /**
             * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`
             * in your game config, to force it to use the legacy event queue system. This method is deprecated and
             * will be removed in a future version.
             *
             * Adds a callback to be invoked whenever the native DOM `mouseup` or `touchend` events are received.
             * By setting the `isOnce` argument you can control if the callback is called once,
             * or every time the DOM event occurs.
             *
             * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,
             * within the scope of the DOM event handler. Therefore, they are considered as 'native'
             * from the perspective of the browser. This means they can be used for tasks such as
             * opening new browser windows, or anything which explicitly requires user input to activate.
             * However, as a result of this, they come with their own risks, and as such should not be used
             * for general game input, but instead be reserved for special circumstances.
             *
             * If all you're trying to do is execute a callback when a pointer is released, then
             * please use the internal Input event system instead.
             *
             * Please understand that these callbacks are invoked when the browser feels like doing so,
             * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep
             * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,
             * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating
             * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind
             * solve.
             * @param callback The callback to be invoked on this dom event.
             * @param isOnce `true` if the callback will only be invoked once, `false` to call every time this event happens. Default true.
             */
            addUpCallback(callback: CallbackFn, isOnce?: boolean): this;

            /**
             * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`
             * in your game config, to force it to use the legacy event queue system. This method is deprecated and
             * will be removed in a future version.
             *
             * Adds a callback to be invoked whenever the native DOM `mousedown` or `touchstart` events are received.
             * By setting the `isOnce` argument you can control if the callback is called once,
             * or every time the DOM event occurs.
             *
             * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,
             * within the scope of the DOM event handler. Therefore, they are considered as 'native'
             * from the perspective of the browser. This means they can be used for tasks such as
             * opening new browser windows, or anything which explicitly requires user input to activate.
             * However, as a result of this, they come with their own risks, and as such should not be used
             * for general game input, but instead be reserved for special circumstances.
             *
             * If all you're trying to do is execute a callback when a pointer is down, then
             * please use the internal Input event system instead.
             *
             * Please understand that these callbacks are invoked when the browser feels like doing so,
             * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep
             * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,
             * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating
             * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind
             * solve.
             * @param callback The callback to be invoked on this dom event.
             * @param isOnce `true` if the callback will only be invoked once, `false` to call every time this event happens. Default true.
             */
            addDownCallback(callback: CallbackFn, isOnce?: boolean): this;

            /**
             * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`
             * in your game config, to force it to use the legacy event queue system. This method is deprecated and
             * will be removed in a future version.
             *
             * Adds a callback to be invoked whenever the native DOM `mousemove` or `touchmove` events are received.
             * By setting the `isOnce` argument you can control if the callback is called once,
             * or every time the DOM event occurs.
             *
             * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,
             * within the scope of the DOM event handler. Therefore, they are considered as 'native'
             * from the perspective of the browser. This means they can be used for tasks such as
             * opening new browser windows, or anything which explicitly requires user input to activate.
             * However, as a result of this, they come with their own risks, and as such should not be used
             * for general game input, but instead be reserved for special circumstances.
             *
             * If all you're trying to do is execute a callback when a pointer is moved, then
             * please use the internal Input event system instead.
             *
             * Please understand that these callbacks are invoked when the browser feels like doing so,
             * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep
             * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,
             * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating
             * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind
             * solve.
             * @param callback The callback to be invoked on this dom event.
             * @param isOnce `true` if the callback will only be invoked once, `false` to call every time this event happens. Default false.
             */
            addMoveCallback(callback: CallbackFn, isOnce?: boolean): this;

            /**
             * Performs a hit test using the given Pointer and camera, against an array of interactive Game Objects.
             *
             * The Game Objects are culled against the camera, and then the coordinates are translated into the local camera space
             * and used to determine if they fall within the remaining Game Objects hit areas or not.
             *
             * If nothing is matched an empty array is returned.
             *
             * This method is called automatically by InputPlugin.hitTestPointer and doesn't usually need to be invoked directly.
             * @param pointer The Pointer to test against.
             * @param gameObjects An array of interactive Game Objects to check.
             * @param camera The Camera which is being tested against.
             * @param output An array to store the results in. If not given, a new empty array is created.
             */
            hitTest(pointer: Pointer, gameObjects: any[], camera: Cameras.Scene2D.Camera, output?: any[]): any[];

            /**
             * Checks if the given x and y coordinate are within the hit area of the Game Object.
             *
             * This method assumes that the coordinate values have already been translated into the space of the Game Object.
             *
             * If the coordinates are within the hit area they are set into the Game Objects Input `localX` and `localY` properties.
             * @param gameObject The interactive Game Object to check against.
             * @param x The translated x coordinate for the hit test.
             * @param y The translated y coordinate for the hit test.
             */
            pointWithinHitArea(gameObject: GameObjects.GameObject, x: number, y: number): boolean;

            /**
             * Checks if the given x and y coordinate are within the hit area of the Interactive Object.
             *
             * This method assumes that the coordinate values have already been translated into the space of the Interactive Object.
             *
             * If the coordinates are within the hit area they are set into the Interactive Objects Input `localX` and `localY` properties.
             * @param object The Interactive Object to check against.
             * @param x The translated x coordinate for the hit test.
             * @param y The translated y coordinate for the hit test.
             */
            pointWithinInteractiveObject(object: InteractiveObject, x: number, y: number): boolean;

            /**
             * Transforms the pageX and pageY values of a Pointer into the scaled coordinate space of the Input Manager.
             * @param pointer The Pointer to transform the values for.
             * @param pageX The Page X value.
             * @param pageY The Page Y value.
             * @param wasMove Are we transforming the Pointer from a move event, or an up / down event?
             */
            transformPointer(pointer: Pointer, pageX: number, pageY: number, wasMove: boolean): void;

            /**
             * Destroys the Input Manager and all of its systems.
             *
             * There is no way to recover from doing this.
             */
            destroy(): void;
        }

        /**
         * The Input Plugin belongs to a Scene and handles all input related events and operations for it.
         *
         * You can access it from within a Scene using `this.input`.
         *
         * It emits events directly. For example, you can do:
         *
         * ```javascript
         * this.input.on('pointerdown', callback, context);
         * ```
         *
         * To listen for a pointer down event anywhere on the game canvas.
         *
         * Game Objects can be enabled for input by calling their `setInteractive` method. After which they
         * will directly emit input events:
         *
         * ```javascript
         * var sprite = this.add.sprite(x, y, texture);
         * sprite.setInteractive();
         * sprite.on('pointerdown', callback, context);
         * ```
         *
         * Please see the Input examples and tutorials for more information.
         */
        class InputPlugin extends Phaser.Events.EventEmitter {
            /**
             *
             * @param scene A reference to the Scene that this Input Plugin is responsible for.
             */
            constructor(scene: Scene);

            /**
             * An instance of the Gamepad Plugin class, if enabled via the `input.gamepad` Scene or Game Config property.
             * Use this to create access Gamepads connected to the browser and respond to gamepad buttons.
             */
            gamepad: Gamepad.GamepadPlugin;

            /**
             * A reference to the Scene that this Input Plugin is responsible for.
             */
            scene: Scene;

            /**
             * A reference to the Scene Systems class.
             */
            systems: Scenes.Systems;

            /**
             * A reference to the Scene Systems Settings.
             */
            settings: Scenes.Settings.Object;

            /**
             * A reference to the Game Input Manager.
             */
            manager: InputManager;

            /**
             * If set, the Input Plugin will run its update loop every frame.
             */
            enabled: boolean;

            /**
             * A reference to the Scene Display List. This property is set during the `boot` method.
             */
            displayList: GameObjects.DisplayList;

            /**
             * A reference to the Scene Cameras Manager. This property is set during the `boot` method.
             */
            cameras: Cameras.Scene2D.CameraManager;

            /**
             * A reference to the Mouse Manager.
             *
             * This property is only set if Mouse support has been enabled in your Game Configuration file.
             *
             * If you just wish to get access to the mouse pointer, use the `mousePointer` property instead.
             */
            mouse: Mouse.MouseManager;

            /**
             * When set to `true` (the default) the Input Plugin will emulate DOM behavior by only emitting events from
             * the top-most Game Objects in the Display List.
             *
             * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.
             */
            topOnly: boolean;

            /**
             * How often should the Pointers be checked?
             *
             * The value is a time, given in ms, and is the time that must have elapsed between game steps before
             * the Pointers will be polled again. When a pointer is polled it runs a hit test to see which Game
             * Objects are currently below it, or being interacted with it.
             *
             * Pointers will *always* be checked if they have been moved by the user, or press or released.
             *
             * This property only controls how often they will be polled if they have not been updated.
             * You should set this if you want to have Game Objects constantly check against the pointers, even
             * if the pointer didn't move itself.
             *
             * Set to 0 to poll constantly. Set to -1 to only poll on user movement.
             */
            pollRate: integer;

            /**
             * The distance, in pixels, a pointer has to move while being held down, before it thinks it is being dragged.
             */
            dragDistanceThreshold: number;

            /**
             * The amount of time, in ms, a pointer has to be held down before it thinks it is dragging.
             */
            dragTimeThreshold: number;

            /**
             * Checks to see if both this plugin and the Scene to which it belongs is active.
             */
            isActive(): boolean;

            /**
             * Clears a Game Object so it no longer has an Interactive Object associated with it.
             * The Game Object is then queued for removal from the Input Plugin on the next update.
             * @param gameObject The Game Object that will have its Interactive Object removed.
             */
            clear(gameObject: GameObjects.GameObject): GameObjects.GameObject;

            /**
             * Disables Input on a single Game Object.
             *
             * An input disabled Game Object still retains its Interactive Object component and can be re-enabled
             * at any time, by passing it to `InputPlugin.enable`.
             * @param gameObject The Game Object to have its input system disabled.
             */
            disable(gameObject: GameObjects.GameObject): void;

            /**
             * Enable a Game Object for interaction.
             *
             * If the Game Object already has an Interactive Object component, it is enabled and returned.
             *
             * Otherwise, a new Interactive Object component is created and assigned to the Game Object's `input` property.
             *
             * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area
             * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced
             * input detection.
             *
             * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If
             * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific
             * shape for it to use.
             *
             * You can also provide an Input Configuration Object as the only argument to this method.
             * @param gameObject The Game Object to be enabled for input.
             * @param shape Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
             * @param callback The 'contains' function to invoke to check if the pointer is within the hit area.
             * @param dropZone Is this Game Object a drop zone or not? Default false.
             */
            enable(gameObject: GameObjects.GameObject, shape?: InputConfiguration | object, callback?: HitAreaCallback, dropZone?: boolean): InputPlugin;

            /**
             * Takes the given Pointer and performs a hit test against it, to see which interactive Game Objects
             * it is currently above.
             *
             * The hit test is performed against which-ever Camera the Pointer is over. If it is over multiple
             * cameras, it starts checking the camera at the top of the camera list, and if nothing is found, iterates down the list.
             * @param pointer The Pointer to check against the Game Objects.
             */
            hitTestPointer(pointer: Pointer): GameObjects.GameObject[];

            /**
             * Returns the drag state of the given Pointer for this Input Plugin.
             *
             * The state will be one of the following:
             *
             * 0 = Not dragging anything
             * 1 = Primary button down and objects below, so collect a draglist
             * 2 = Pointer being checked if meets drag criteria
             * 3 = Pointer meets criteria, notify the draglist
             * 4 = Pointer actively dragging the draglist and has moved
             * 5 = Pointer actively dragging but has been released, notify draglist
             * @param pointer The Pointer to get the drag state for.
             */
            getDragState(pointer: Pointer): integer;

            /**
             * Sets the drag state of the given Pointer for this Input Plugin.
             *
             * The state must be one of the following values:
             *
             * 0 = Not dragging anything
             * 1 = Primary button down and objects below, so collect a draglist
             * 2 = Pointer being checked if meets drag criteria
             * 3 = Pointer meets criteria, notify the draglist
             * 4 = Pointer actively dragging the draglist and has moved
             * 5 = Pointer actively dragging but has been released, notify draglist
             * @param pointer The Pointer to set the drag state for.
             * @param state The drag state value. An integer between 0 and 5.
             */
            setDragState(pointer: Pointer, state: integer): void;

            /**
             * Sets the draggable state of the given array of Game Objects.
             *
             * They can either be set to be draggable, or can have their draggable state removed by passing `false`.
             *
             * A Game Object will not fire drag events unless it has been specifically enabled for drag.
             * @param gameObjects An array of Game Objects to change the draggable state on.
             * @param value Set to `true` if the Game Objects should be made draggable, `false` if they should be unset. Default true.
             */
            setDraggable(gameObjects: GameObjects.GameObject | GameObjects.GameObject[], value?: boolean): InputPlugin;

            /**
             * Creates a function that can be passed to `setInteractive`, `enable` or `setHitArea` that will handle
             * pixel-perfect input detection on an Image or Sprite based Game Object, or any custom class that extends them.
             *
             * The following will create a sprite that is clickable on any pixel that has an alpha value >= 1.
             *
             * ```javascript
             * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect());
             * ```
             *
             * The following will create a sprite that is clickable on any pixel that has an alpha value >= 150.
             *
             * ```javascript
             * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect(150));
             * ```
             *
             * Once you have made an Interactive Object pixel perfect it impacts all input related events for it: down, up,
             * dragstart, drag, etc.
             *
             * As a pointer interacts with the Game Object it will constantly poll the texture, extracting a single pixel from
             * the given coordinates and checking its color values. This is an expensive process, so should only be enabled on
             * Game Objects that really need it.
             *
             * You cannot make non-texture based Game Objects pixel perfect. So this will not work on Graphics, BitmapText,
             * Render Textures, Text, Tilemaps, Containers or Particles.
             * @param alphaTolerance The alpha level that the pixel should be above to be included as a successful interaction. Default 1.
             */
            makePixelPerfect(alphaTolerance?: integer): CallbackFn;

            /**
             * Sets the hit area for the given array of Game Objects.
             *
             * A hit area is typically one of the geometric shapes Phaser provides, such as a `Phaser.Geom.Rectangle`
             * or `Phaser.Geom.Circle`. However, it can be any object as long as it works with the provided callback.
             *
             * If no hit area is provided a Rectangle is created based on the size of the Game Object, if possible
             * to calculate.
             *
             * The hit area callback is the function that takes an `x` and `y` coordinate and returns a boolean if
             * those values fall within the area of the shape or not. All of the Phaser geometry objects provide this,
             * such as `Phaser.Geom.Rectangle.Contains`.
             * @param gameObjects An array of Game Objects to set the hit area on.
             * @param shape Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
             * @param callback The 'contains' function to invoke to check if the pointer is within the hit area.
             */
            setHitArea(
                gameObjects: GameObjects.GameObject | GameObjects.GameObject[],
                shape?: InputConfiguration | object,
                callback?: HitAreaCallback
            ): InputPlugin;

            /**
             * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Circle` shape, using
             * the given coordinates and radius to control its position and size.
             * @param gameObjects An array of Game Objects to set as having a circle hit area.
             * @param x The center of the circle.
             * @param y The center of the circle.
             * @param radius The radius of the circle.
             * @param callback The hit area callback. If undefined it uses Circle.Contains.
             */
            setHitAreaCircle(gameObjects: GameObjects.GameObject | GameObjects.GameObject[], x: number, y: number, radius: number, callback?: HitAreaCallback): InputPlugin;

            /**
             * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Ellipse` shape, using
             * the given coordinates and dimensions to control its position and size.
             * @param gameObjects An array of Game Objects to set as having an ellipse hit area.
             * @param x The center of the ellipse.
             * @param y The center of the ellipse.
             * @param width The width of the ellipse.
             * @param height The height of the ellipse.
             * @param callback The hit area callback. If undefined it uses Ellipse.Contains.
             */
            setHitAreaEllipse(
                gameObjects: GameObjects.GameObject | GameObjects.GameObject[],
                x: number,
                y: number,
                width: number,
                height: number,
                callback?: HitAreaCallback
            ): InputPlugin;

            /**
             * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using
             * the Game Objects texture frame to define the position and size of the hit area.
             * @param gameObjects An array of Game Objects to set as having an ellipse hit area.
             * @param callback The hit area callback. If undefined it uses Rectangle.Contains.
             */
            setHitAreaFromTexture(gameObjects: GameObjects.GameObject | GameObjects.GameObject[], callback?: HitAreaCallback): InputPlugin;

            /**
             * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using
             * the given coordinates and dimensions to control its position and size.
             * @param gameObjects An array of Game Objects to set as having a rectangular hit area.
             * @param x The top-left of the rectangle.
             * @param y The top-left of the rectangle.
             * @param width The width of the rectangle.
             * @param height The height of the rectangle.
             * @param callback The hit area callback. If undefined it uses Rectangle.Contains.
             */
            setHitAreaRectangle(
                gameObjects: GameObjects.GameObject | GameObjects.GameObject[],
                x: number,
                y: number,
                width: number,
                height: number,
                callback?: HitAreaCallback
            ): InputPlugin;

            /**
             * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Triangle` shape, using
             * the given coordinates to control the position of its points.
             * @param gameObjects An array of Game Objects to set as having a  triangular hit area.
             * @param x1 The x coordinate of the first point of the triangle.
             * @param y1 The y coordinate of the first point of the triangle.
             * @param x2 The x coordinate of the second point of the triangle.
             * @param y2 The y coordinate of the second point of the triangle.
             * @param x3 The x coordinate of the third point of the triangle.
             * @param y3 The y coordinate of the third point of the triangle.
             * @param callback The hit area callback. If undefined it uses Triangle.Contains.
             */
            setHitAreaTriangle(
                gameObjects: GameObjects.GameObject | GameObjects.GameObject[],
                x1: number,
                y1: number,
                x2: number,
                y2: number,
                x3: number,
                y3: number,
                callback?: HitAreaCallback
            ): InputPlugin;

            /**
             * Sets the Pointers to always poll.
             *
             * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,
             * or being interacted with it, regardless if the Pointer has actually moved or not.
             *
             * You should enable this if you want objects in your game to fire over / out events, and the objects
             * are constantly moving, but the pointer may not have. Polling every frame has additional computation
             * costs, especially if there are a large number of interactive objects in your game.
             */
            setPollAlways(): InputPlugin;

            /**
             * Sets the Pointers to only poll when they are moved or updated.
             *
             * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,
             * or being interacted with it.
             */
            setPollOnMove(): InputPlugin;

            /**
             * Sets the poll rate value. This is the amount of time that should have elapsed before a pointer
             * will be polled again. See the `setPollAlways` and `setPollOnMove` methods.
             * @param value The amount of time, in ms, that should elapsed before re-polling the pointers.
             */
            setPollRate(value: number): InputPlugin;

            /**
             * When set to `true` the global Input Manager will emulate DOM behavior by only emitting events from
             * the top-most Game Objects in the Display List.
             *
             * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.
             * @param value `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.
             */
            setGlobalTopOnly(value: boolean): InputPlugin;

            /**
             * When set to `true` this Input Plugin will emulate DOM behavior by only emitting events from
             * the top-most Game Objects in the Display List.
             *
             * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.
             * @param value `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.
             */
            setTopOnly(value: boolean): InputPlugin;

            /**
             * Given an array of Game Objects, sort the array and return it, so that the objects are in depth index order
             * with the lowest at the bottom.
             * @param gameObjects An array of Game Objects to be sorted.
             */
            sortGameObjects(gameObjects: GameObjects.GameObject[]): GameObjects.GameObject[];

            /**
             * Causes the Input Manager to stop emitting any events for the remainder of this game step.
             */
            stopPropagation(): InputPlugin;

            /**
             * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`
             * in your game config, to force it to use the legacy event queue system. This method is deprecated and
             * will be removed in a future version.
             *
             * Adds a callback to be invoked whenever the native DOM `mouseup` or `touchend` events are received.
             * By setting the `isOnce` argument you can control if the callback is called once,
             * or every time the DOM event occurs.
             *
             * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,
             * within the scope of the DOM event handler. Therefore, they are considered as 'native'
             * from the perspective of the browser. This means they can be used for tasks such as
             * opening new browser windows, or anything which explicitly requires user input to activate.
             * However, as a result of this, they come with their own risks, and as such should not be used
             * for general game input, but instead be reserved for special circumstances.
             *
             * If all you're trying to do is execute a callback when a pointer is released, then
             * please use the internal Input event system instead.
             *
             * Please understand that these callbacks are invoked when the browser feels like doing so,
             * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep
             * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,
             * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating
             * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind
             * solve.
             * @param callback The callback to be invoked on this DOM event.
             * @param isOnce `true` if the callback will only be invoked once, `false` to call every time this event happens. Default true.
             */
            addUpCallback(callback: CallbackFn, isOnce?: boolean): this;

            /**
             * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`
             * in your game config, to force it to use the legacy event queue system. This method is deprecated and
             * will be removed in a future version.
             *
             * Adds a callback to be invoked whenever the native DOM `mousedown` or `touchstart` events are received.
             * By setting the `isOnce` argument you can control if the callback is called once,
             * or every time the DOM event occurs.
             *
             * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,
             * within the scope of the DOM event handler. Therefore, they are considered as 'native'
             * from the perspective of the browser. This means they can be used for tasks such as
             * opening new browser windows, or anything which explicitly requires user input to activate.
             * However, as a result of this, they come with their own risks, and as such should not be used
             * for general game input, but instead be reserved for special circumstances.
             *
             * If all you're trying to do is execute a callback when a pointer is down, then
             * please use the internal Input event system instead.
             *
             * Please understand that these callbacks are invoked when the browser feels like doing so,
             * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep
             * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,
             * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating
             * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind
             * solve.
             * @param callback The callback to be invoked on this dom event.
             * @param isOnce `true` if the callback will only be invoked once, `false` to call every time this event happens. Default true.
             */
            addDownCallback(callback: CallbackFn, isOnce?: boolean): this;

            /**
             * **Note:** As of Phaser 3.16 this method is no longer required _unless_ you have set `input.queue = true`
             * in your game config, to force it to use the legacy event queue system. This method is deprecated and
             * will be removed in a future version.
             *
             * Adds a callback to be invoked whenever the native DOM `mousemove` or `touchmove` events are received.
             * By setting the `isOnce` argument you can control if the callback is called once,
             * or every time the DOM event occurs.
             *
             * Callbacks passed to this method are invoked _immediately_ when the DOM event happens,
             * within the scope of the DOM event handler. Therefore, they are considered as 'native'
             * from the perspective of the browser. This means they can be used for tasks such as
             * opening new browser windows, or anything which explicitly requires user input to activate.
             * However, as a result of this, they come with their own risks, and as such should not be used
             * for general game input, but instead be reserved for special circumstances.
             *
             * If all you're trying to do is execute a callback when a pointer is moved, then
             * please use the internal Input event system instead.
             *
             * Please understand that these callbacks are invoked when the browser feels like doing so,
             * which may be entirely out of the normal flow of the Phaser Game Loop. Therefore, you should absolutely keep
             * Phaser related operations to a minimum in these callbacks. For example, don't destroy Game Objects,
             * change Scenes or manipulate internal systems, otherwise you run a very real risk of creating
             * heisenbugs (https://en.wikipedia.org/wiki/Heisenbug) that prove a challenge to reproduce, never mind
             * solve.
             * @param callback The callback to be invoked on this dom event.
             * @param isOnce `true` if the callback will only be invoked once, `false` to call every time this event happens. Default false.
             */
            addMoveCallback(callback: CallbackFn, isOnce?: boolean): this;

            /**
             * Adds new Pointer objects to the Input Manager.
             *
             * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.
             *
             * You can create more either by calling this method, or by setting the `input.activePointers` property
             * in the Game Config, up to a maximum of 10 pointers.
             *
             * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added
             * via this method.
             * @param quantity The number of new Pointers to create. A maximum of 10 is allowed in total. Default 1.
             */
            addPointer(quantity?: integer): Pointer[];

            /**
             * Tells the Input system to set a custom cursor.
             *
             * This cursor will be the default cursor used when interacting with the game canvas.
             *
             * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.
             *
             * Any valid CSS cursor value is allowed, including paths to image files, i.e.:
             *
             * ```javascript
             * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');
             * ```
             *
             * Please read about the differences between browsers when it comes to the file formats and sizes they support:
             *
             * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
             * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property
             *
             * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.
             * @param cursor The CSS to be used when setting the default cursor.
             */
            setDefaultCursor(cursor: string): InputPlugin;

            /**
             * The x coordinates of the ActivePointer based on the first camera in the camera list.
             * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.
             */
            readonly x: number;

            /**
             * The y coordinates of the ActivePointer based on the first camera in the camera list.
             * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.
             */
            readonly y: number;

            /**
             * Are any mouse or touch pointers currently over the game canvas?
             */
            readonly isOver: boolean;

            /**
             * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.
             * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`
             * which will always map to the most recently interacted pointer.
             */
            readonly mousePointer: Pointer;

            /**
             * The current active input Pointer.
             */
            readonly activePointer: Pointer;

            /**
             * A touch-based Pointer object.
             * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
             */
            readonly pointer1: Pointer;

            /**
             * A touch-based Pointer object.
             * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
             */
            readonly pointer2: Pointer;

            /**
             * A touch-based Pointer object.
             * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
             */
            readonly pointer3: Pointer;

            /**
             * A touch-based Pointer object.
             * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
             */
            readonly pointer4: Pointer;

            /**
             * A touch-based Pointer object.
             * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
             */
            readonly pointer5: Pointer;

            /**
             * A touch-based Pointer object.
             * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
             */
            readonly pointer6: Pointer;

            /**
             * A touch-based Pointer object.
             * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
             */
            readonly pointer7: Pointer;

            /**
             * A touch-based Pointer object.
             * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
             */
            readonly pointer8: Pointer;

            /**
             * A touch-based Pointer object.
             * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
             */
            readonly pointer9: Pointer;

            /**
             * A touch-based Pointer object.
             * This will be `undefined` by default unless you add a new Pointer using `addPointer`.
             */
            readonly pointer10: Pointer;

            /**
             * An instance of the Keyboard Plugin class, if enabled via the `input.keyboard` Scene or Game Config property.
             * Use this to create Key objects and listen for keyboard specific events.
             */
            keyboard: Keyboard.KeyboardPlugin;
        }

        interface InputConfiguration {
            /**
             * The object / shape to use as the Hit Area. If not given it will try to create a Rectangle based on the texture frame.
             */
            hitArea?: any;
            /**
             * The callback that determines if the pointer is within the Hit Area shape or not.
             */
            hitAreaCallback?: CallbackFn;
            /**
             * If `true` the Interactive Object will be set to be draggable and emit drag events.
             */
            draggable?: boolean;
            /**
             * If `true` the Interactive Object will be set to be a drop zone for draggable objects.
             */
            dropZone?: boolean;
            /**
             * If `true` the Interactive Object will set the `pointer` hand cursor when a pointer is over it. This is a short-cut for setting `cursor: 'pointer'`.
             */
            useHandCursor?: boolean;
            /**
             * The CSS string to be used when the cursor is over this Interactive Object.
             */
            cursor?: string;
            /**
             * If `true` the a pixel perfect function will be set for the hit area callback. Only works with texture based Game Objects.
             */
            pixelPerfect?: boolean;
            /**
             * If `pixelPerfect` is set, this is the alpha tolerance threshold value used in the callback.
             */
            alphaTolerance?: integer;
        }

        namespace InputPluginCache {
            /**
             * Static method called directly by the Core internal Plugins.
             * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)
             * Plugin is the object to instantiate to create the plugin
             * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)
             */
            const register: CallbackFn;

            /**
             * Returns the input plugin object from the cache based on the given key.
             */
            const getCore: CallbackFn;

            /**
             * Installs all of the registered Input Plugins into the given target.
             */
            const install: CallbackFn;

            /**
             * Removes an input plugin based on the given key.
             */
            const remove: CallbackFn;
        }

        namespace Keyboard {
            /**
             * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them
             * it will emit a `keycombomatch` event from the Keyboard Manager.
             *
             * The keys to be listened for can be defined as:
             *
             * A string (i.e. 'ATARI')
             * An array of either integers (key codes) or strings, or a mixture of both
             * An array of objects (such as Key objects) with a public 'keyCode' property
             *
             * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)
             * you could pass the following array of key codes:
             *
             * ```javascript
             * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });
             *
             * this.input.keyboard.on('keycombomatch', function (event) {
             *     console.log('Konami Code entered!');
             * });
             * ```
             *
             * Or, to listen for the user entering the word PHASER:
             *
             * ```javascript
             * this.input.keyboard.createCombo('PHASER');
             * ```
             */
            class KeyCombo {
                /**
                 *
                 * @param keyboardPlugin A reference to the Keyboard Plugin.
                 * @param keys The keys that comprise this combo.
                 * @param config A Key Combo configuration object.
                 */
                constructor(keyboardPlugin: KeyboardPlugin, keys: string | integer[] | object[], config?: KeyComboConfig);

                /**
                 * A reference to the Keyboard Manager
                 */
                manager: KeyboardPlugin;

                /**
                 * A flag that controls if this Key Combo is actively processing keys or not.
                 */
                enabled: boolean;

                /**
                 * An array of the keycodes that comprise this combo.
                 */
                keyCodes: any[];

                /**
                 * The current keyCode the combo is waiting for.
                 */
                current: integer;

                /**
                 * The current index of the key being waited for in the 'keys' string.
                 */
                index: integer;

                /**
                 * The length of this combo (in keycodes)
                 */
                size: number;

                /**
                 * The time the previous key in the combo was matched.
                 */
                timeLastMatched: number;

                /**
                 * Has this Key Combo been matched yet?
                 */
                matched: boolean;

                /**
                 * The time the entire combo was matched.
                 */
                timeMatched: number;

                /**
                 * If they press the wrong key do we reset the combo?
                 */
                resetOnWrongKey: boolean;

                /**
                 * The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.
                 */
                maxKeyDelay: integer;

                /**
                 * If previously matched and they press the first key of the combo again, will it reset?
                 */
                resetOnMatch: boolean;

                /**
                 * If the combo matches, will it delete itself?
                 */
                deleteOnMatch: boolean;

                /**
                 * How far complete is this combo? A value between 0 and 1.
                 */
                readonly progress: number;

                /**
                 * Destroys this Key Combo and all of its references.
                 */
                destroy(): void;
            }

            namespace Events {
                /**
                 * The Global Key Down Event.
                 *
                 * This event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.
                 *
                 * Listen to this event from within a Scene using: `this.input.keyboard.on('keydown', listener)`.
                 *
                 * You can also listen for a specific key being pressed. See [Keyboard.Events.KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_DOWN} for details.
                 *
                 * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.
                 *
                 * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
                 * Read [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.
                 *
                 * Also, please be aware that some browser extensions can disable or override Phaser keyboard handling.
                 * For example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.
                 * There are others. So, please check your extensions if you find you have specific keys that don't work.
                 */
                const ANY_KEY_DOWN: any;

                /**
                 * The Global Key Up Event.
                 *
                 * This event is dispatched by the Keyboard Plugin when any key on the keyboard is released.
                 *
                 * Listen to this event from within a Scene using: `this.input.keyboard.on('keyup', listener)`.
                 *
                 * You can also listen for a specific key being released. See [Keyboard.Events.KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_UP} for details.
                 *
                 * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.
                 */
                const ANY_KEY_UP: any;

                /**
                 * The Key Combo Match Event.
                 *
                 * This event is dispatched by the Keyboard Plugin when a [Key Combo]{@link Phaser.Input.Keyboard.KeyCombo} is matched.
                 *
                 * Listen for this event from the Key Plugin after a combo has been created:
                 *
                 * ```javascript
                 * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });
                 *
                 * this.input.keyboard.on('keycombomatch', function (event) {
                 *     console.log('Konami Code entered!');
                 * });
                 * ```
                 */
                const COMBO_MATCH: any;

                /**
                 * The Key Down Event.
                 *
                 * This event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is pressed.
                 *
                 * Listen for this event from the Key object instance directly:
                 *
                 * ```javascript
                 * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                 *
                 * spaceBar.on('down', listener)
                 * ```
                 *
                 * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.
                 */
                const DOWN: any;

                /**
                 * The Key Down Event.
                 *
                 * This event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.
                 *
                 * Unlike the `ANY_KEY_DOWN` event, this one has a special dynamic event name. For example, to listen for the `A` key being pressed
                 * use the following from within a Scene: `this.input.keyboard.on('keydown-A', listener)`. You can replace the `-A` part of the event
                 * name with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar:
                 * `this.input.keyboard.on('keydown-SPACE', listener)`.
                 *
                 * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.
                 *
                 * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.
                 *
                 * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
                 * Read [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.
                 *
                 * Also, please be aware that some browser extensions can disable or override Phaser keyboard handling.
                 * For example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.
                 * There are others. So, please check your extensions if you find you have specific keys that don't work.
                 */
                const KEY_DOWN: any;

                /**
                 * The Key Up Event.
                 *
                 * This event is dispatched by the Keyboard Plugin when any key on the keyboard is released.
                 *
                 * Unlike the `ANY_KEY_UP` event, this one has a special dynamic event name. For example, to listen for the `A` key being released
                 * use the following from within a Scene: `this.input.keyboard.on('keyup-A', listener)`. You can replace the `-A` part of the event
                 * name with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar:
                 * `this.input.keyboard.on('keyup-SPACE', listener)`.
                 *
                 * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.
                 *
                 * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.
                 */
                const KEY_UP: any;

                /**
                 * The Key Up Event.
                 *
                 * This event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is released.
                 *
                 * Listen for this event from the Key object instance directly:
                 *
                 * ```javascript
                 * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                 *
                 * spaceBar.on('up', listener)
                 * ```
                 *
                 * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.
                 */
                const UP: any;
            }

            /**
             * The Keyboard Manager is a helper class that belongs to the global Input Manager.
             *
             * Its role is to listen for native DOM Keyboard Events and then store them for further processing by the Keyboard Plugin.
             *
             * You do not need to create this class directly, the Input Manager will create an instance of it automatically if keyboard
             * input has been enabled in the Game Config.
             */
            class KeyboardManager {
                /**
                 *
                 * @param inputManager A reference to the Input Manager.
                 */
                constructor(inputManager: InputManager);

                /**
                 * A reference to the Input Manager.
                 */
                manager: InputManager;

                /**
                 * A flag that controls if the non-modified keys, matching those stored in the `captures` array,
                 * have `preventDefault` called on them or not.
                 *
                 * A non-modified key is one that doesn't have a modifier key held down with it. The modifier keys are
                 * shift, control, alt and the meta key (Command on a Mac, the Windows Key on Windows).
                 * Therefore, if the user presses shift + r, it won't prevent this combination, because of the modifier.
                 * However, if the user presses just the r key on its own, it will have its event prevented.
                 *
                 * If you wish to stop capturing the keys, for example switching out to a DOM based element, then
                 * you can toggle this property at run-time.
                 */
                preventDefault: boolean;

                /**
                 * An array of Key Code values that will automatically have `preventDefault` called on them,
                 * as long as the `KeyboardManager.preventDefault` boolean is set to `true`.
                 *
                 * By default the array is empty.
                 *
                 * The key must be non-modified when pressed in order to be captured.
                 *
                 * A non-modified key is one that doesn't have a modifier key held down with it. The modifier keys are
                 * shift, control, alt and the meta key (Command on a Mac, the Windows Key on Windows).
                 * Therefore, if the user presses shift + r, it won't prevent this combination, because of the modifier.
                 * However, if the user presses just the r key on its own, it will have its event prevented.
                 *
                 * If you wish to stop capturing the keys, for example switching out to a DOM based element, then
                 * you can toggle the `KeyboardManager.preventDefault` boolean at run-time.
                 *
                 * If you need more specific control, you can create Key objects and set the flag on each of those instead.
                 *
                 * This array can be populated via the Game Config by setting the `input.keyboard.capture` array, or you
                 * can call the `addCapture` method. See also `removeCapture` and `clearCaptures`.
                 */
                captures: integer[];

                /**
                 * A boolean that controls if the Keyboard Manager is enabled or not.
                 * Can be toggled on the fly.
                 */
                enabled: boolean;

                /**
                 * The Keyboard Event target, as defined in the Game Config.
                 * Typically the window in which the game is rendering, but can be any interactive DOM element.
                 */
                target: any;

                /**
                 * The Key Down Event handler.
                 * This function is sent the native DOM KeyEvent.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onKeyDown: CallbackFn;

                /**
                 * The Key Up Event handler.
                 * This function is sent the native DOM KeyEvent.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onKeyUp: CallbackFn;

                /**
                 * Starts the Keyboard Event listeners running.
                 * This is called automatically and does not need to be manually invoked.
                 */
                startListeners(): void;

                /**
                 * Stops the Key Event listeners.
                 * This is called automatically and does not need to be manually invoked.
                 */
                stopListeners(): void;

                /**
                 * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.
                 * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.
                 *
                 * This `addCapture` method enables consuming keyboard event for specific keys so it doesn't bubble up to the the browser
                 * and cause the default browser behavior.
                 *
                 * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to say prevent
                 * the SPACE BAR from triggering a page scroll, then it will prevent it for any Scene in your game, not just the calling one.
                 *
                 * You can pass in a single key code value, or an array of key codes, or a string:
                 *
                 * ```javascript
                 * this.input.keyboard.addCapture(62);
                 * ```
                 *
                 * An array of key codes:
                 *
                 * ```javascript
                 * this.input.keyboard.addCapture([ 62, 63, 64 ]);
                 * ```
                 *
                 * Or a string:
                 *
                 * ```javascript
                 * this.input.keyboard.addCapture('W,S,A,D');
                 * ```
                 *
                 * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.
                 *
                 * You can also provide an array mixing both strings and key code integers.
                 *
                 * If there are active captures after calling this method, the `preventDefault` property is set to `true`.
                 * @param keycode The Key Codes to enable capture for, preventing them reaching the browser.
                 */
                addCapture(keycode: string | integer | integer[] | string | integer[]): void;

                /**
                 * Removes an existing key capture.
                 *
                 * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to remove
                 * the capture of a key, then it will remove it for any Scene in your game, not just the calling one.
                 *
                 * You can pass in a single key code value, or an array of key codes, or a string:
                 *
                 * ```javascript
                 * this.input.keyboard.removeCapture(62);
                 * ```
                 *
                 * An array of key codes:
                 *
                 * ```javascript
                 * this.input.keyboard.removeCapture([ 62, 63, 64 ]);
                 * ```
                 *
                 * Or a string:
                 *
                 * ```javascript
                 * this.input.keyboard.removeCapture('W,S,A,D');
                 * ```
                 *
                 * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.
                 *
                 * You can also provide an array mixing both strings and key code integers.
                 *
                 * If there are no captures left after calling this method, the `preventDefault` property is set to `false`.
                 * @param keycode The Key Codes to disable capture for, allowing them reaching the browser again.
                 */
                removeCapture(keycode: string | integer | integer[] | string | integer[]): void;

                /**
                 * Removes all keyboard captures and sets the `preventDefault` property to `false`.
                 */
                clearCaptures(): void;

                /**
                 * Destroys this Keyboard Manager instance.
                 */
                destroy(): void;
            }

            /**
             * The Keyboard Plugin is an input plugin that belongs to the Scene-owned Input system.
             *
             * Its role is to listen for native DOM Keyboard Events and then process them.
             *
             * You do not need to create this class directly, the Input system will create an instance of it automatically.
             *
             * You can access it from within a Scene using `this.input.keyboard`. For example, you can do:
             *
             * ```javascript
             * this.input.keyboard.on('keydown', callback, context);
             * ```
             *
             * Or, to listen for a specific key:
             *
             * ```javascript
             * this.input.keyboard.on('keydown-A', callback, context);
             * ```
             *
             * You can also create Key objects, which you can then poll in your game loop:
             *
             * ```javascript
             * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
             * ```
             *
             * If you have multiple parallel Scenes, each trying to get keyboard input, be sure to disable capture on them to stop them from
             * stealing input from another Scene in the list. You can do this with `this.input.keyboard.enabled = false` within the
             * Scene to stop all input, or `this.input.keyboard.preventDefault = false` to stop a Scene halting input on another Scene.
             *
             * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
             * See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.
             *
             * Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.
             * For example the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.
             * And there are others. So, please check your extensions before opening Phaser issues about keys that don't work.
             */
            class KeyboardPlugin extends Phaser.Events.EventEmitter {
                /**
                 *
                 * @param sceneInputPlugin A reference to the Scene Input Plugin that the KeyboardPlugin belongs to.
                 */
                constructor(sceneInputPlugin: InputPlugin);

                /**
                 * A reference to the core game, so we can listen for visibility events.
                 */
                game: Game;

                /**
                 * A reference to the Scene that this Input Plugin is responsible for.
                 */
                scene: Scene;

                /**
                 * A reference to the Scene Systems Settings.
                 */
                settings: Scenes.Settings.Object;

                /**
                 * A reference to the Scene Input Plugin that created this Keyboard Plugin.
                 */
                sceneInputPlugin: InputPlugin;

                /**
                 * A reference to the global Keyboard Manager.
                 */
                manager: InputPlugin;

                /**
                 * A boolean that controls if this Keyboard Plugin is enabled or not.
                 * Can be toggled on the fly.
                 */
                enabled: boolean;

                /**
                 * An array of Key objects to process.
                 */
                keys: Key[];

                /**
                 * An array of KeyCombo objects to process.
                 */
                combos: KeyCombo[];

                /**
                 * Checks to see if both this plugin and the Scene to which it belongs is active.
                 */
                isActive(): boolean;

                /**
                 * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.
                 * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.
                 *
                 * This `addCapture` method enables consuming keyboard events for specific keys, so they don't bubble up the browser
                 * and cause the default behaviors.
                 *
                 * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to say prevent
                 * the SPACE BAR from triggering a page scroll, then it will prevent it for any Scene in your game, not just the calling one.
                 *
                 * You can pass a single key code value:
                 *
                 * ```javascript
                 * this.input.keyboard.addCapture(62);
                 * ```
                 *
                 * An array of key codes:
                 *
                 * ```javascript
                 * this.input.keyboard.addCapture([ 62, 63, 64 ]);
                 * ```
                 *
                 * Or, a comma-delimited string:
                 *
                 * ```javascript
                 * this.input.keyboard.addCapture('W,S,A,D');
                 * ```
                 *
                 * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.
                 *
                 * You can also provide an array mixing both strings and key code integers.
                 * @param keycode The Key Codes to enable event capture for.
                 */
                addCapture(keycode: string | integer | integer[] | string | integer[]): KeyboardPlugin;

                /**
                 * Removes an existing key capture.
                 *
                 * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to remove
                 * the capture of a key, then it will remove it for any Scene in your game, not just the calling one.
                 *
                 * You can pass a single key code value:
                 *
                 * ```javascript
                 * this.input.keyboard.removeCapture(62);
                 * ```
                 *
                 * An array of key codes:
                 *
                 * ```javascript
                 * this.input.keyboard.removeCapture([ 62, 63, 64 ]);
                 * ```
                 *
                 * Or, a comma-delimited string:
                 *
                 * ```javascript
                 * this.input.keyboard.removeCapture('W,S,A,D');
                 * ```
                 *
                 * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.
                 *
                 * You can also provide an array mixing both strings and key code integers.
                 * @param keycode The Key Codes to disable event capture for.
                 */
                removeCapture(keycode: string | integer | integer[] | string | integer[]): KeyboardPlugin;

                /**
                 * Returns an array that contains all of the keyboard captures currently enabled.
                 */
                getCaptures(): integer[];

                /**
                 * Allows Phaser to prevent any key captures you may have defined from bubbling up the browser.
                 * You can use this to re-enable event capturing if you had paused it via `disableGlobalCapture`.
                 */
                enableGlobalCapture(): KeyboardPlugin;

                /**
                 * Disables Phaser from preventing any key captures you may have defined, without actually removing them.
                 * You can use this to temporarily disable event capturing if, for example, you swap to a DOM element.
                 */
                disableGlobalCapture(): KeyboardPlugin;

                /**
                 * Removes all keyboard captures.
                 *
                 * Note that this is a global change. It will clear all event captures across your game, not just for this specific Scene.
                 */
                clearCaptures(): KeyboardPlugin;

                /**
                 * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right, and also Space Bar and shift.
                 */
                createCursorKeys(): CursorKeys;

                /**
                 * A practical way to create an object containing user selected hotkeys.
                 *
                 * For example:
                 *
                 * ```javascript
                 * this.input.keyboard.addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.W, 'down': Phaser.Input.Keyboard.KeyCodes.S });
                 * ```
                 *
                 * would return an object containing the properties (`up` and `down`) mapped to W and S {@link Phaser.Input.Keyboard.Key} objects.
                 *
                 * You can also pass in a comma-separated string:
                 *
                 * ```javascript
                 * this.input.keyboard.addKeys('W,S,A,D');
                 * ```
                 *
                 * Which will return an object with the properties W, S, A and D mapped to the relevant Key objects.
                 *
                 * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.
                 * @param keys An object containing Key Codes, or a comma-separated string.
                 * @param enableCapture Automatically call `preventDefault` on the native DOM browser event for the key codes being added. Default true.
                 * @param emitOnRepeat Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default). Default false.
                 */
                addKeys(keys: object | string, enableCapture?: boolean, emitOnRepeat?: boolean): object;

                /**
                 * Adds a Key object to this Keyboard Plugin.
                 *
                 * The given argument can be either an existing Key object, a string, such as `A` or `SPACE`, or a key code value.
                 *
                 * If a Key object is given, and one already exists matching the same key code, the existing one is replaced with the new one.
                 * @param key Either a Key object, a string, such as `A` or `SPACE`, or a key code value.
                 * @param enableCapture Automatically call `preventDefault` on the native DOM browser event for the key codes being added. Default true.
                 * @param emitOnRepeat Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default). Default false.
                 */
                addKey(key: Key | string | integer, enableCapture?: boolean, emitOnRepeat?: boolean): Key;

                /**
                 * Removes a Key object from this Keyboard Plugin.
                 *
                 * The given argument can be either a Key object, a string, such as `A` or `SPACE`, or a key code value.
                 * @param key Either a Key object, a string, such as `A` or `SPACE`, or a key code value.
                 */
                removeKey(key: Key | string | integer): KeyboardPlugin;

                /**
                 * Creates a new KeyCombo.
                 *
                 * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them
                 * it will emit a `keycombomatch` event from this Keyboard Plugin.
                 *
                 * The keys to be listened for can be defined as:
                 *
                 * A string (i.e. 'ATARI')
                 * An array of either integers (key codes) or strings, or a mixture of both
                 * An array of objects (such as Key objects) with a public 'keyCode' property
                 *
                 * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)
                 * you could pass the following array of key codes:
                 *
                 * ```javascript
                 * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });
                 *
                 * this.input.keyboard.on('keycombomatch', function (event) {
                 *     console.log('Konami Code entered!');
                 * });
                 * ```
                 *
                 * Or, to listen for the user entering the word PHASER:
                 *
                 * ```javascript
                 * this.input.keyboard.createCombo('PHASER');
                 * ```
                 * @param keys The keys that comprise this combo.
                 * @param config A Key Combo configuration object.
                 */
                createCombo(keys: string | integer[] | object[], config?: KeyComboConfig): KeyCombo;

                /**
                 * Checks if the given Key object is currently being held down.
                 *
                 * The difference between this method and checking the `Key.isDown` property directly is that you can provide
                 * a duration to this method. For example, if you wanted a key press to fire a bullet, but you only wanted
                 * it to be able to fire every 100ms, then you can call this method with a `duration` of 100 and it
                 * will only return `true` every 100ms.
                 *
                 * If the Keyboard Plugin has been disabled, this method will always return `false`.
                 * @param key A Key object.
                 * @param duration The duration which must have elapsed before this Key is considered as being down. Default 0.
                 */
                checkDown(key: Key, duration?: number): boolean;

                /**
                 * Resets all Key objects created by _this_ Keyboard Plugin back to their default un-pressed states.
                 * This can only reset keys created via the `addKey`, `addKeys` or `createCursors` methods.
                 * If you have created a Key object directly you'll need to reset it yourself.
                 *
                 * This method is called automatically when the Keyboard Plugin shuts down, but can be
                 * invoked directly at any time you require.
                 */
                resetKeys(): KeyboardPlugin;
            }

            interface CursorKeys {
                /**
                 * A Key object mapping to the UP arrow key.
                 */
                up: Key;
                /**
                 * A Key object mapping to the DOWN arrow key.
                 */
                down: Key;
                /**
                 * A Key object mapping to the LEFT arrow key.
                 */
                left: Key;
                /**
                 * A Key object mapping to the RIGHT arrow key.
                 */
                right: Key;
                /**
                 * A Key object mapping to the SPACE BAR key.
                 */
                space: Key;
                /**
                 * A Key object mapping to the SHIFT key.
                 */
                shift: Key;
            }

            /**
             * Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
             * or was pressed down longer ago than then given duration.
             * @param key The Key object to test.
             * @param duration The duration, in ms, within which the key must have been pressed down. Default 50.
             */
            function DownDuration(key: Key, duration?: integer): boolean;

            /**
             * The justDown value allows you to test if this Key has just been pressed down or not.
             *
             * When you check this value it will return `true` if the Key is down, otherwise `false`.
             *
             * You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.
             * This allows you to use it in situations where you want to check if this key is down without using an event, such as in a core game loop.
             * @param key The Key to check to see if it's just down or not.
             */
            function JustDown(key: Key): boolean;

            /**
             * The justUp value allows you to test if this Key has just been released or not.
             *
             * When you check this value it will return `true` if the Key is up, otherwise `false`.
             *
             * You can only call JustUp once per key release. It will only return `true` once, until the Key is pressed down and released again.
             * This allows you to use it in situations where you want to check if this key is up without using an event, such as in a core game loop.
             * @param key The Key to check to see if it's just up or not.
             */
            function JustUp(key: Key): boolean;

            /**
             * A generic Key object which can be passed to the Process functions (and so on)
             * keycode must be an integer
             */
            class Key extends Phaser.Events.EventEmitter {
                /**
                 *
                 * @param keyCode The keycode of this key.
                 */
                constructor(keyCode: integer);

                /**
                 * The keycode of this key.
                 */
                keyCode: integer;

                /**
                 * The original DOM event.
                 */
                originalEvent: KeyboardEvent;

                /**
                 * Can this Key be processed?
                 */
                enabled: boolean;

                /**
                 * The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
                 */
                isDown: boolean;

                /**
                 * The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
                 */
                isUp: boolean;

                /**
                 * The down state of the ALT key, if pressed at the same time as this key.
                 */
                altKey: boolean;

                /**
                 * The down state of the CTRL key, if pressed at the same time as this key.
                 */
                ctrlKey: boolean;

                /**
                 * The down state of the SHIFT key, if pressed at the same time as this key.
                 */
                shiftKey: boolean;

                /**
                 * The down state of the Meta key, if pressed at the same time as this key.
                 * On a Mac the Meta Key is the Command key. On Windows keyboards, it's the Windows key.
                 */
                metaKey: boolean;

                /**
                 * The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.
                 */
                location: number;

                /**
                 * The timestamp when the key was last pressed down.
                 */
                timeDown: number;

                /**
                 * The number of milliseconds this key was held down for in the previous down - up sequence.
                 */
                duration: number;

                /**
                 * The timestamp when the key was last released.
                 */
                timeUp: number;

                /**
                 * When a key is held down should it continuously fire the `down` event each time it repeats?
                 *
                 * By default it will emit the `down` event just once, but if you wish to receive the event
                 * for each repeat as well, enable this property.
                 */
                emitOnRepeat: boolean;

                /**
                 * If a key is held down this holds down the number of times the key has 'repeated'.
                 */
                repeats: number;

                /**
                 * Controls if this Key will continuously emit a `down` event while being held down (true),
                 * or emit the event just once, on first press, and then skip future events (false).
                 * @param value Emit `down` events on repeated key down actions, or just once?
                 */
                setEmitOnRepeat(value: boolean): Key;

                /**
                 * Processes the Key Down action for this Key.
                 * Called automatically by the Keyboard Plugin.
                 * @param event The native DOM Keyboard event.
                 */
                onDown(event: KeyboardEvent): void;

                /**
                 * Processes the Key Up action for this Key.
                 * Called automatically by the Keyboard Plugin.
                 * @param event The native DOM Keyboard event.
                 */
                onUp(event: KeyboardEvent): void;

                /**
                 * Resets this Key object back to its default un-pressed state.
                 */
                reset(): Key;

                /**
                 * Removes any bound event handlers and removes local references.
                 */
                destroy(): void;
            }

            /**
             * Keyboard Codes.
             */
            enum KeyCodes {
                BACKSPACE,
                TAB,
                ENTER,
                SHIFT,
                CTRL,
                ALT,
                PAUSE,
                CAPS_LOCK,
                ESC,
                SPACE,
                PAGE_UP,
                PAGE_DOWN,
                END,
                HOME,
                LEFT,
                UP,
                RIGHT,
                DOWN,
                PRINT_SCREEN,
                INSERT,
                DELETE,
                ZERO,
                ONE,
                TWO,
                THREE,
                FOUR,
                FIVE,
                SIX,
                SEVEN,
                EIGHT,
                NINE,
                NUMPAD_ZERO,
                NUMPAD_ONE,
                NUMPAD_TWO,
                NUMPAD_THREE,
                NUMPAD_FOUR,
                NUMPAD_FIVE,
                NUMPAD_SIX,
                NUMPAD_SEVEN,
                NUMPAD_EIGHT,
                NUMPAD_NINE,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
                R,
                S,
                T,
                U,
                V,
                W,
                X,
                Y,
                Z,
                F1,
                F2,
                F3,
                F4,
                F5,
                F6,
                F7,
                F8,
                F9,
                F10,
                F11,
                F12,
                SEMICOLON,
                PLUS,
                COMMA,
                MINUS,
                PERIOD,
                FORWARD_SLASH,
                BACK_SLASH,
                QUOTES,
                BACKTICK,
                OPEN_BRACKET,
                CLOSED_BRACKET,
                SEMICOLON_FIREFOX,
                COLON,
                COMMA_FIREFOX_WINDOWS,
                COMMA_FIREFOX,
                BRACKET_RIGHT_FIREFOX,
                BRACKET_LEFT_FIREFOX
            }

            /**
             * Returns `true` if the Key was released within the `duration` value given, or `false` if it either isn't up,
             * or was released longer ago than then given duration.
             * @param key The Key object to test.
             * @param duration The duration, in ms, within which the key must have been released. Default 50.
             */
            function UpDuration(key: Key, duration?: integer): boolean;
        }

        namespace Mouse {
            /**
             * The Mouse Manager is a helper class that belongs to the Input Manager.
             *
             * Its role is to listen for native DOM Mouse Events and then pass them onto the Input Manager for further processing.
             *
             * You do not need to create this class directly, the Input Manager will create an instance of it automatically.
             */
            class MouseManager {
                /**
                 *
                 * @param inputManager A reference to the Input Manager.
                 */
                constructor(inputManager: InputManager);

                /**
                 * A reference to the Input Manager.
                 */
                manager: InputManager;

                /**
                 * If true the DOM mouse events will have event.preventDefault applied to them, if false they will propagate fully.
                 */
                capture: boolean;

                /**
                 * A boolean that controls if the Mouse Manager is enabled or not.
                 * Can be toggled on the fly.
                 */
                enabled: boolean;

                /**
                 * The Touch Event target, as defined in the Game Config.
                 * Typically the canvas to which the game is rendering, but can be any interactive DOM element.
                 */
                target: any;

                /**
                 * If the mouse has been pointer locked successfully this will be set to true.
                 */
                locked: boolean;

                /**
                 * The Mouse Move Event handler.
                 * This function is sent the native DOM MouseEvent.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onMouseMove: CallbackFn;

                /**
                 * The Mouse Down Event handler.
                 * This function is sent the native DOM MouseEvent.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onMouseDown: CallbackFn;

                /**
                 * The Mouse Up Event handler.
                 * This function is sent the native DOM MouseEvent.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onMouseUp: CallbackFn;

                /**
                 * The Mouse Over Event handler.
                 * This function is sent the native DOM MouseEvent.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onMouseOver: CallbackFn;

                /**
                 * The Mouse Out Event handler.
                 * This function is sent the native DOM MouseEvent.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onMouseOut: CallbackFn;

                /**
                 * Internal pointerLockChange handler.
                 * This function is sent the native DOM MouseEvent.
                 * Initially empty and bound in the `startListeners` method.
                 */
                pointerLockChange: CallbackFn;

                /**
                 * Attempts to disable the context menu from appearing if you right-click on the browser.
                 *
                 * Works by listening for the `contextmenu` event and prevent defaulting it.
                 *
                 * Use this if you need to enable right-button mouse support in your game, and the browser
                 * menu keeps getting in the way.
                 */
                disableContextMenu(): MouseManager;

                /**
                 * If the browser supports it, you can request that the pointer be locked to the browser window.
                 *
                 * This is classically known as 'FPS controls', where the pointer can't leave the browser until
                 * the user presses an exit key.
                 *
                 * If the browser successfully enters a locked state, a `POINTER_LOCK_CHANGE_EVENT` will be dispatched,
                 * from the games Input Manager, with an `isPointerLocked` property.
                 *
                 * It is important to note that pointer lock can only be enabled after an 'engagement gesture',
                 * see: https://w3c.github.io/pointerlock/#dfn-engagement-gesture.
                 */
                requestPointerLock(): void;

                /**
                 * If the browser supports pointer lock, this will request that the pointer lock is released. If
                 * the browser successfully enters a locked state, a 'POINTER_LOCK_CHANGE_EVENT' will be
                 * dispatched - from the game's input manager - with an `isPointerLocked` property.
                 */
                releasePointerLock(): void;

                /**
                 * Starts the Mouse Event listeners running.
                 * This is called automatically and does not need to be manually invoked.
                 */
                startListeners(): void;

                /**
                 * Stops the Mouse Event listeners.
                 * This is called automatically and does not need to be manually invoked.
                 */
                stopListeners(): void;

                /**
                 * Destroys this Mouse Manager instance.
                 */
                destroy(): void;
            }
        }

        /**
         * A Pointer object encapsulates both mouse and touch input within Phaser.
         *
         * By default, Phaser will create 2 pointers for your game to use. If you require more, i.e. for a multi-touch
         * game, then use the `InputPlugin.addPointer` method to do so, rather than instantiating this class directly,
         * otherwise it won't be managed by the input system.
         *
         * You can reference the current active pointer via `InputPlugin.activePointer`. You can also use the properties
         * `InputPlugin.pointer1` through to `pointer10`, for each pointer you have enabled in your game.
         *
         * The properties of this object are set by the Input Plugin during processing. This object is then sent in all
         * input related events that the Input Plugin emits, so you can reference properties from it directly in your
         * callbacks.
         */
        class Pointer {
            /**
             *
             * @param manager A reference to the Input Manager.
             * @param id The internal ID of this Pointer.
             */
            constructor(manager: InputManager, id: integer);

            /**
             * A reference to the Input Manager.
             */
            manager: InputManager;

            /**
             * The internal ID of this Pointer.
             */
            readonly id: integer;

            /**
             * The most recent native DOM Event this Pointer has processed.
             */
            event: TouchEvent | MouseEvent;

            /**
             * The DOM element the Pointer was pressed down on, taken from the DOM event.
             */
            readonly downElement: any;

            /**
             * The DOM element the Pointer was released on, taken from the DOM event.
             */
            readonly upElement: any;

            /**
             * The camera the Pointer interacted with during its last update.
             *
             * A Pointer can only ever interact with one camera at once, which will be the top-most camera
             * in the list should multiple cameras be positioned on-top of each other.
             */
            camera: Cameras.Scene2D.Camera;

            /**
             * 0: No button or un-initialized
             * 1: Left button
             * 2: Right button
             * 4: Wheel button or middle button
             * 8: 4th button (typically the "Browser Back" button)
             * 16: 5th button (typically the "Browser Forward" button)
             *
             * For a mouse configured for left-handed use, the button actions are reversed.
             * In this case, the values are read from right to left.
             */
            buttons: integer;

            /**
             * The position of the Pointer in screen space.
             */
            readonly position: Math.Vector2;

            /**
             * The previous position of the Pointer in screen space.
             *
             * The old x and y values are stored in here during the InputManager.transformPointer call.
             *
             * Use the properties `velocity`, `angle` and `distance` to create your own gesture recognition.
             */
            readonly prevPosition: Math.Vector2;

            /**
             * The current velocity of the Pointer, based on its current and previous positions.
             *
             * This value is smoothed out each frame, according to the `motionFactor` property.
             *
             * This property is updated whenever the Pointer moves, regardless of any button states. In other words,
             * it changes based on movement alone - a button doesn't have to be pressed first.
             */
            readonly velocity: Math.Vector2;

            /**
             * The current angle the Pointer is moving, in radians, based on its previous and current position.
             *
             * The angle is based on the old position facing to the current position.
             *
             * This property is updated whenever the Pointer moves, regardless of any button states. In other words,
             * it changes based on movement alone - a button doesn't have to be pressed first.
             */
            readonly angle: number;

            /**
             * The distance the Pointer has moved, based on its previous and current position.
             *
             * This value is smoothed out each frame, according to the `motionFactor` property.
             *
             * This property is updated whenever the Pointer moves, regardless of any button states. In other words,
             * it changes based on movement alone - a button doesn't have to be pressed first.
             *
             * If you need the total distance travelled since the primary buttons was pressed down,
             * then use the `Pointer.getDistance` method.
             */
            readonly distance: number;

            /**
             * The smoothing factor to apply to the Pointer position.
             *
             * Due to their nature, pointer positions are inherently noisy. While this is fine for lots of games, if you need cleaner positions
             * then you can set this value to apply an automatic smoothing to the positions as they are recorded.
             *
             * The default value of zero means 'no smoothing'.
             * Set to a small value, such as 0.2, to apply an average level of smoothing between positions. You can do this by changing this
             * value directly, or by setting the `input.smoothFactor` property in the Game Config.
             *
             * Positions are only smoothed when the pointer moves. If the primary button on this Pointer enters an Up or Down state, then the position
             * is always precise, and not smoothed.
             */
            smoothFactor: number;

            /**
             * The factor applied to the motion smoothing each frame.
             *
             * This value is passed to the Smooth Step Interpolation that is used to calculate the velocity,
             * angle and distance of the Pointer. It's applied every frame, until the midPoint reaches the current
             * position of the Pointer. 0.2 provides a good average but can be increased if you need a
             * quicker update and are working in a high performance environment. Never set this value to
             * zero.
             */
            motionFactor: number;

            /**
             * The x position of this Pointer, translated into the coordinate space of the most recent Camera it interacted with.
             */
            worldX: number;

            /**
             * The y position of this Pointer, translated into the coordinate space of the most recent Camera it interacted with.
             */
            worldY: number;

            /**
             * Time when this Pointer was most recently moved (regardless of the state of its buttons, if any)
             */
            moveTime: number;

            /**
             * X coordinate of the Pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects.
             */
            downX: number;

            /**
             * Y coordinate of the Pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects.
             */
            downY: number;

            /**
             * Time when Button 1 (left button), or Touch, was pressed, used for dragging objects.
             */
            downTime: number;

            /**
             * X coordinate of the Pointer when Button 1 (left button), or Touch, was released, used for dragging objects.
             */
            upX: number;

            /**
             * Y coordinate of the Pointer when Button 1 (left button), or Touch, was released, used for dragging objects.
             */
            upY: number;

            /**
             * Time when Button 1 (left button), or Touch, was released, used for dragging objects.
             */
            upTime: number;

            /**
             * Is the primary button down? (usually button 0, the left mouse button)
             */
            primaryDown: boolean;

            /**
             * Is _any_ button on this pointer considered as being down?
             */
            isDown: boolean;

            /**
             * A dirty flag for this Pointer, used internally by the Input Plugin.
             */
            dirty: boolean;

            /**
             * Is this Pointer considered as being "just down" or not?
             */
            justDown: boolean;

            /**
             * Is this Pointer considered as being "just up" or not?
             */
            justUp: boolean;

            /**
             * Is this Pointer considered as being "just moved" or not?
             */
            justMoved: boolean;

            /**
             * Did the previous input event come from a Touch input (true) or Mouse? (false)
             */
            wasTouch: boolean;

            /**
             * Did this Pointer get canceled by a touchcancel event?
             *
             * Note: "canceled" is the American-English spelling of "cancelled". Please don't submit PRs correcting it!
             */
            wasCanceled: boolean;

            /**
             * If the mouse is locked, the horizontal relative movement of the Pointer in pixels since last frame.
             */
            movementX: number;

            /**
             * If the mouse is locked, the vertical relative movement of the Pointer in pixels since last frame.
             */
            movementY: number;

            /**
             * The identifier property of the Pointer as set by the DOM event when this Pointer is started.
             */
            identifier: number;

            /**
             * The pointerId property of the Pointer as set by the DOM event when this Pointer is started.
             * The browser can and will recycle this value.
             */
            pointerId: number;

            /**
             * An active Pointer is one that is currently pressed down on the display.
             * A Mouse is always considered as active.
             */
            active: boolean;

            /**
             * Time when this Pointer was most recently updated by the Game step.
             */
            time: number;

            /**
             * Takes a Camera and returns a Vector2 containing the translated position of this Pointer
             * within that Camera. This can be used to convert this Pointers position into camera space.
             * @param camera The Camera to use for the translation.
             * @param output A Vector2-like object in which to store the translated position.
             */
            positionToCamera(camera: Cameras.Scene2D.Camera, output?: Math.Vector2 | object): Math.Vector2 | object;

            /**
             * Checks to see if any buttons are being held down on this Pointer.
             */
            noButtonDown(): boolean;

            /**
             * Checks to see if the left button is being held down on this Pointer.
             */
            leftButtonDown(): boolean;

            /**
             * Checks to see if the right button is being held down on this Pointer.
             */
            rightButtonDown(): boolean;

            /**
             * Checks to see if the middle button is being held down on this Pointer.
             */
            middleButtonDown(): boolean;

            /**
             * Checks to see if the back button is being held down on this Pointer.
             */
            backButtonDown(): boolean;

            /**
             * Checks to see if the forward button is being held down on this Pointer.
             */
            forwardButtonDown(): boolean;

            /**
             * If the Pointer has a button pressed down at the time this method is called, it will return the
             * distance between the Pointer's `downX` and `downY` values and the current position.
             *
             * If no button is held down, it will return the last recorded distance, based on where
             * the Pointer was when the button was released.
             *
             * If you wish to get the distance being travelled currently, based on the velocity of the Pointer,
             * then see the `Pointer.distance` property.
             */
            getDistance(): number;

            /**
             * If the Pointer has a button pressed down at the time this method is called, it will return the
             * horizontal distance between the Pointer's `downX` and `downY` values and the current position.
             *
             * If no button is held down, it will return the last recorded horizontal distance, based on where
             * the Pointer was when the button was released.
             */
            getDistanceX(): number;

            /**
             * If the Pointer has a button pressed down at the time this method is called, it will return the
             * vertical distance between the Pointer's `downX` and `downY` values and the current position.
             *
             * If no button is held down, it will return the last recorded vertical distance, based on where
             * the Pointer was when the button was released.
             */
            getDistanceY(): number;

            /**
             * If the Pointer has a button pressed down at the time this method is called, it will return the
             * duration since the Pointer's was pressed down.
             *
             * If no button is held down, it will return the last recorded duration, based on the time
             * the Pointer button was released.
             */
            getDuration(): number;

            /**
             * If the Pointer has a button pressed down at the time this method is called, it will return the
             * angle between the Pointer's `downX` and `downY` values and the current position.
             *
             * If no button is held down, it will return the last recorded angle, based on where
             * the Pointer was when the button was released.
             *
             * The angle is based on the old position facing to the current position.
             *
             * If you wish to get the current angle, based on the velocity of the Pointer, then
             * see the `Pointer.angle` property.
             */
            getAngle(): number;

            /**
             * Takes the previous and current Pointer positions and then generates an array of interpolated values between
             * the two. The array will be populated up to the size of the `steps` argument.
             *
             * ```javaScript
             * var points = pointer.getInterpolatedPosition(4);
             *
             * // points[0] { x: 0, y: 0 }
             * // points[1] { x: 2, y: 1 }
             * // points[2] { x: 3, y: 2 }
             * // points[3] { x: 6, y: 3 }
             * ```
             *
             * Use this if you need to get smoothed values between the previous and current pointer positions. DOM pointer
             * events can often fire faster than the main browser loop, and this will help you avoid janky movement
             * especially if you have an object following a Pointer.
             *
             * Note that if you provide an output array it will only be populated up to the number of steps provided.
             * It will not clear any previous data that may have existed beyond the range of the steps count.
             *
             * Internally it uses the Smooth Step interpolation calculation.
             * @param steps The number of interpolation steps to use. Default 10.
             * @param out An array to store the results in. If not provided a new one will be created.
             */
            getInterpolatedPosition(steps?: integer, out?: any[]): any[];

            /**
             * Destroys this Pointer instance and resets its external references.
             */
            destroy(): void;

            /**
             * The x position of this Pointer.
             * The value is in screen space.
             * See `worldX` to get a camera converted position.
             */
            x: number;

            /**
             * The y position of this Pointer.
             * The value is in screen space.
             * See `worldY` to get a camera converted position.
             */
            y: number;
        }

        namespace Touch {
            /**
             * The Touch Manager is a helper class that belongs to the Input Manager.
             *
             * Its role is to listen for native DOM Touch Events and then pass them onto the Input Manager for further processing.
             *
             * You do not need to create this class directly, the Input Manager will create an instance of it automatically.
             */
            class TouchManager {
                /**
                 *
                 * @param inputManager A reference to the Input Manager.
                 */
                constructor(inputManager: InputManager);

                /**
                 * A reference to the Input Manager.
                 */
                manager: InputManager;

                /**
                 * If true the DOM events will have event.preventDefault applied to them, if false they will propagate fully.
                 */
                capture: boolean;

                /**
                 * A boolean that controls if the Touch Manager is enabled or not.
                 * Can be toggled on the fly.
                 */
                enabled: boolean;

                /**
                 * The Touch Event target, as defined in the Game Config.
                 * Typically the canvas to which the game is rendering, but can be any interactive DOM element.
                 */
                target: any;

                /**
                 * The Touch Start event handler function.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onTouchStart: CallbackFn;

                /**
                 * The Touch Move event handler function.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onTouchMove: CallbackFn;

                /**
                 * The Touch End event handler function.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onTouchEnd: CallbackFn;

                /**
                 * The Touch Cancel event handler function.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onTouchCancel: CallbackFn;

                /**
                 * The Touch Over event handler function.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onTouchOver: CallbackFn;

                /**
                 * The Touch Out event handler function.
                 * Initially empty and bound in the `startListeners` method.
                 */
                onTouchOut: CallbackFn;

                /**
                 * Starts the Touch Event listeners running as long as an input target is set.
                 *
                 * This method is called automatically if Touch Input is enabled in the game config,
                 * which it is by default. However, you can call it manually should you need to
                 * delay input capturing until later in the game.
                 */
                startListeners(): void;

                /**
                 * Stops the Touch Event listeners.
                 * This is called automatically and does not need to be manually invoked.
                 */
                stopListeners(): void;

                /**
                 * Destroys this Touch Manager instance.
                 */
                destroy(): void;
            }
        }
    }

    namespace Loader {
        /**
         * The Loader is idle.
         */
        const LOADER_IDLE: integer;

        /**
         * The Loader is actively loading.
         */
        const LOADER_LOADING: integer;

        /**
         * The Loader is processing files is has loaded.
         */
        const LOADER_PROCESSING: integer;

        /**
         * The Loader has completed loading and processing.
         */
        const LOADER_COMPLETE: integer;

        /**
         * The Loader is shutting down.
         */
        const LOADER_SHUTDOWN: integer;

        /**
         * The Loader has been destroyed.
         */
        const LOADER_DESTROYED: integer;

        /**
         * File is in the load queue but not yet started
         */
        const FILE_PENDING: integer;

        /**
         * File has been started to load by the loader (onLoad called)
         */
        const FILE_LOADING: integer;

        /**
         * File has loaded successfully, awaiting processing
         */
        const FILE_LOADED: integer;

        /**
         * File failed to load
         */
        const FILE_FAILED: integer;

        /**
         * File is being processed (onProcess callback)
         */
        const FILE_PROCESSING: integer;

        /**
         * The File has errored somehow during processing.
         */
        const FILE_ERRORED: integer;

        /**
         * File has finished processing.
         */
        const FILE_COMPLETE: integer;

        /**
         * File has been destroyed
         */
        const FILE_DESTROYED: integer;

        /**
         * File was populated from local data and doesn't need an HTTP request
         */
        const FILE_POPULATED: integer;

        namespace Events {
            /**
             * The Loader Plugin Add File Event.
             *
             * This event is dispatched when a new file is successfully added to the Loader and placed into the load queue.
             *
             * Listen to it from a Scene using: `this.load.on('addfile', listener)`.
             *
             * If you add lots of files to a Loader from a `preload` method, it will dispatch this event for each one of them.
             */
            const ADD: any;

            /**
             * The Loader Plugin Complete Event.
             *
             * This event is dispatched when the Loader has fully processed everything in the load queue.
             * By this point every loaded file will now be in its associated cache and ready for use.
             *
             * Listen to it from a Scene using: `this.load.on('complete', listener)`.
             */
            const COMPLETE: any;

            /**
             * The File Load Complete Event.
             *
             * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.
             *
             * Listen to it from a Scene using: `this.load.on('filecomplete', listener)`.
             *
             * You can also listen for the completion of a specific file. See the [FILE_KEY_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_KEY_COMPLETE} event.
             */
            const FILE_COMPLETE: any;

            /**
             * The File Load Complete Event.
             *
             * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.
             *
             * It uses a special dynamic event name constructed from the key and interface of the file.
             *
             * For example, if you have loaded an `image` with a key of `monster`, you can listen for it
             * using the following:
             *
             * ```javascript
             * this.load.on('filecomplete-image-monster', function (key, interface, data) {
             *     // Your handler code
             * });
             * ```
             *
             * Or, if you have loaded a texture `atlas` with a key of `Level1`:
             *
             * ```javascript
             * this.load.on('filecomplete-atlas-Level1', function (key, interface, data) {
             *     // Your handler code
             * });
             * ```
             *
             * Or, if you have loaded a sprite sheet with a key of `Explosion` and a prefix of `GAMEOVER`:
             *
             * ```javascript
             * this.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, interface, data) {
             *     // Your handler code
             * });
             * ```
             *
             * You can also listen for the generic completion of files. See the [FILE_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_COMPLETE} event.
             */
            const FILE_KEY_COMPLETE: any;

            /**
             * The File Load Error Event.
             *
             * This event is dispatched by the Loader Plugin when a file fails to load.
             *
             * Listen to it from a Scene using: `this.load.on('loaderror', listener)`.
             */
            const FILE_LOAD_ERROR: any;

            /**
             * The File Load Event.
             *
             * This event is dispatched by the Loader Plugin when a file finishes loading,
             * but _before_ it is processed and added to the internal Phaser caches.
             *
             * Listen to it from a Scene using: `this.load.on('load', listener)`.
             */
            const FILE_LOAD: any;

            /**
             * The File Load Progress Event.
             *
             * This event is dispatched by the Loader Plugin during the load of a file, if the browser receives a DOM ProgressEvent and
             * the `lengthComputable` event property is true. Depending on the size of the file and browser in use, this may, or may not happen.
             *
             * Listen to it from a Scene using: `this.load.on('fileprogress', listener)`.
             */
            const FILE_PROGRESS: any;

            /**
             * The Loader Plugin Post Process Event.
             *
             * This event is dispatched by the Loader Plugin when the Loader has finished loading everything in the load queue.
             * It is dispatched before the internal lists are cleared and each File is destroyed.
             *
             * Use this hook to perform any last minute processing of files that can only happen once the
             * Loader has completed, but prior to it emitting the `complete` event.
             *
             * Listen to it from a Scene using: `this.load.on('postprocess', listener)`.
             */
            const POST_PROCESS: any;

            /**
             * The Loader Plugin Progress Event.
             *
             * This event is dispatched when the Loader updates its load progress, typically as a result of a file having completed loading.
             *
             * Listen to it from a Scene using: `this.load.on('progress', listener)`.
             */
            const PROGRESS: any;

            /**
             * The Loader Plugin Start Event.
             *
             * This event is dispatched when the Loader starts running. At this point load progress is zero.
             *
             * This event is dispatched even if there aren't any files in the load queue.
             *
             * Listen to it from a Scene using: `this.load.on('start', listener)`.
             */
            const START: any;
        }

        /**
         * The base File class used by all File types that the Loader can support.
         * You shouldn't create an instance of a File directly, but should extend it with your own class, setting a custom interface and processing methods.
         */
        class File {
            /**
             *
             * @param loader The Loader that is going to load this File.
             * @param fileConfig The file configuration object, as created by the file interface.
             */
            constructor(loader: LoaderPlugin, fileConfig: FileConfig);

            /**
             * A reference to the Loader that is going to load this file.
             */
            loader: LoaderPlugin;

            /**
             * A reference to the Cache, or Texture Manager, that is going to store this file if it loads.
             */
            cache: Cache.BaseCache | Textures.TextureManager;

            /**
             * The file interface string (image, json, etc) for sorting within the Loader.
             */
            interface: string;

            /**
             * Unique cache key (unique within its file interface)
             */
            key: string;

            /**
             * The URL of the file, not including baseURL.
             * Automatically has Loader.path prepended to it.
             */
            url: string;

            /**
             * The final URL this file will load from, including baseURL and path.
             * Set automatically when the Loader calls 'load' on this file.
             */
            src: string;

            /**
             * The merged XHRSettings for this file.
             */
            xhrSettings: XHRSettingsObject;

            /**
             * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.
             */
            xhrLoader: XMLHttpRequest;

            /**
             * The current state of the file. One of the FILE_CONST values.
             */
            state: integer;

            /**
             * The total size of this file.
             * Set by onProgress and only if loading via XHR.
             */
            bytesTotal: number;

            /**
             * Updated as the file loads.
             * Only set if loading via XHR.
             */
            bytesLoaded: number;

            /**
             * A percentage value between 0 and 1 indicating how much of this file has loaded.
             * Only set if loading via XHR.
             */
            percentComplete: number;

            /**
             * For CORs based loading.
             * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)
             */
            crossOrigin: string | undefined;

            /**
             * The processed file data, stored here after the file has loaded.
             */
            data: any;

            /**
             * A config object that can be used by file types to store transitional data.
             */
            config: any;

            /**
             * If this is a multipart file, i.e. an atlas and its json together, then this is a reference
             * to the parent MultiFile. Set and used internally by the Loader or specific file types.
             */
            multiFile: MultiFile;

            /**
             * Does this file have an associated linked file? Such as an image and a normal map.
             * Atlases and Bitmap Fonts use the multiFile, because those files need loading together but aren't
             * actually bound by data, where-as a linkFile is.
             */
            linkFile: File;

            /**
             * Links this File with another, so they depend upon each other for loading and processing.
             * @param fileB The file to link to this one.
             */
            setLink(fileB: File): void;

            /**
             * Resets the XHRLoader instance this file is using.
             */
            resetXHR(): void;

            /**
             * Called by the Loader, starts the actual file downloading.
             * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.
             * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.
             */
            load(): void;

            /**
             * Called when the file finishes loading, is sent a DOM ProgressEvent.
             * @param xhr The XMLHttpRequest that caused this onload event.
             * @param event The DOM ProgressEvent that resulted from this load.
             */
            onLoad(xhr: XMLHttpRequest, event: ProgressEvent): void;

            /**
             * Called if the file errors while loading, is sent a DOM ProgressEvent.
             * @param xhr The XMLHttpRequest that caused this onload event.
             * @param event The DOM ProgressEvent that resulted from this error.
             */
            onError(xhr: XMLHttpRequest, event: ProgressEvent): void;

            /**
             * Called during the file load progress. Is sent a DOM ProgressEvent.
             * @param event The DOM ProgressEvent.
             */
            onProgress(event: ProgressEvent): void;

            /**
             * Usually overridden by the FileTypes and is called by Loader.nextFile.
             * This method controls what extra work this File does with its loaded data, for example a JSON file will parse itself during this stage.
             */
            onProcess(): void;

            /**
             * Called when the File has completed processing.
             * Checks on the state of its multifile, if set.
             */
            onProcessComplete(): void;

            /**
             * Called when the File has completed processing but it generated an error.
             * Checks on the state of its multifile, if set.
             */
            onProcessError(): void;

            /**
             * Checks if a key matching the one used by this file exists in the target Cache or not.
             * This is called automatically by the LoaderPlugin to decide if the file can be safely
             * loaded or will conflict.
             */
            hasCacheConflict(): boolean;

            /**
             * Adds this file to its target cache upon successful loading and processing.
             * This method is often overridden by specific file types.
             */
            addToCache(): void;

            /**
             * Called once the file has been added to its cache and is now ready for deletion from the Loader.
             * It will emit a `filecomplete` event from the LoaderPlugin.
             */
            pendingDestroy(): void;

            /**
             * Destroy this File and any references it holds.
             */
            destroy(): void;

            /**
             * Static method for creating object URL using URL API and setting it as image 'src' attribute.
             * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.
             * @param image Image object which 'src' attribute should be set to object URL.
             * @param blob A Blob object to create an object URL for.
             * @param defaultinterface Default mime interface used if blob interface is not available.
             */
            static createObjectURL(image: HTMLImageElement, blob: Blob, defaultinterface: string): void;

            /**
             * Static method for releasing an existing object URL which was previously created
             * by calling {@link File#createObjectURL} method.
             * @param image Image object which 'src' attribute should be revoked.
             */
            static revokeObjectURL(image: HTMLImageElement): void;
        }

        namespace FileTypes {
            /**
             * A single Animation JSON File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#animation method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#animation.
             */
            class AnimationJSONFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 * @param dataKey When the JSON file loads only this property will be stored in the Cache.
                 */
                constructor(loader: LoaderPlugin, key: string | JSONFileConfig, url?: string, xhrSettings?: XHRSettingsObject, dataKey?: string);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;

                /**
                 * Called at the end of the load process, after the Loader has finished all files in its queue.
                 */
                onLoadComplete(): void;
            }

            interface AtlasJSONFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Texture Manager.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the texture image file from.
                 */
                textureURL?: string;
                /**
                 * The default file extension to use for the image texture if no url is provided.
                 */
                textureExtension?: string;
                /**
                 * Extra XHR Settings specifically for the texture image file.
                 */
                textureXhrSettings?: XHRSettingsObject;
                /**
                 * The filename of an associated normal map. It uses the same path and url to load as the texture image.
                 */
                normalMap?: string;
                /**
                 * The absolute or relative URL to load the atlas json file from. Or a well formed JSON object to use instead.
                 */
                atlasURL?: string;
                /**
                 * The default file extension to use for the atlas json if no url is provided.
                 */
                atlasExtension?: string;
                /**
                 * Extra XHR Settings specifically for the atlas json file.
                 */
                atlasXhrSettings?: XHRSettingsObject;
            }

            /**
             * A single JSON based Texture Atlas File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#atlas method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlas.
             *
             * https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-for-phaser3?source=photonstorm
             */
            class AtlasJSONFile extends MultiFile {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param textureURL The absolute or relative URL to load the texture image file from.
                 * If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
                 * @param atlasURL The absolute or relative URL to load the texture atlas json data file from.
                 * If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
                 * @param textureXhrSettings An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.
                 * @param atlasXhrSettings An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | AtlasJSONFileConfig,
                    textureURL?: string | string[],
                    atlasURL?: string,
                    textureXhrSettings?: XHRSettingsObject,
                    atlasXhrSettings?: XHRSettingsObject
                );

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface AtlasXMLFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Texture Manager.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the texture image file from.
                 */
                textureURL?: string;
                /**
                 * The default file extension to use for the image texture if no url is provided.
                 */
                textureExtension?: string;
                /**
                 * Extra XHR Settings specifically for the texture image file.
                 */
                textureXhrSettings?: XHRSettingsObject;
                /**
                 * The filename of an associated normal map. It uses the same path and url to load as the texture image.
                 */
                normalMap?: string;
                /**
                 * The absolute or relative URL to load the atlas xml file from.
                 */
                atlasURL?: string;
                /**
                 * The default file extension to use for the atlas xml if no url is provided.
                 */
                atlasExtension?: string;
                /**
                 * Extra XHR Settings specifically for the atlas xml file.
                 */
                atlasXhrSettings?: XHRSettingsObject;
            }

            /**
             * A single XML based Texture Atlas File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#atlasXML method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlasXML.
             */
            class AtlasXMLFile extends MultiFile {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param textureURL The absolute or relative URL to load the texture image file from.
                 * If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
                 * @param atlasURL The absolute or relative URL to load the texture atlas xml data file from.
                 * If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was "alien" then the URL will be "alien.xml".
                 * @param textureXhrSettings An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.
                 * @param atlasXhrSettings An XHR Settings configuration object for the atlas xml file. Used in replacement of the Loaders default XHR Settings.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | AtlasXMLFileConfig,
                    textureURL?: string | string[],
                    atlasURL?: string,
                    textureXhrSettings?: XHRSettingsObject,
                    atlasXhrSettings?: XHRSettingsObject
                );

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface AudioFileConfig {
                /**
                 * The key of the file. Must be unique within the Loader and Audio Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                urlConfig?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
                /**
                 * The AudioContext this file will use to process itself.
                 */
                audioContext?: AudioContext;
            }

            /**
             * A single Audio File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#audio method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audio.
             */
            class AudioFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param urlConfig The absolute or relative URL to load this file from in a config object.
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 * @param audioContext The AudioContext this file will use to process itself.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | AudioFileConfig,
                    urlConfig?: any,
                    xhrSettings?: XHRSettingsObject,
                    audioContext?: AudioContext
                );

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }

            interface AudioSpriteFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Audio Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.
                 */
                jsonURL: string;
                /**
                 * Extra XHR Settings specifically for the json file.
                 */
                jsonXhrSettings?: XHRSettingsObject;
                /**
                 * The absolute or relative URL to load the audio file from.
                 */
                audioURL?: object;
                /**
                 * The audio configuration options.
                 */
                audioConfig?: any;
                /**
                 * Extra XHR Settings specifically for the audio file.
                 */
                audioXhrSettings?: XHRSettingsObject;
            }

            /**
             * An Audio Sprite File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#audioSprite method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audioSprite.
             */
            class AudioSpriteFile extends MultiFile {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param jsonURL The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.
                 * @param audioURL The absolute or relative URL to load the audio file from. If empty it will be obtained by parsing the JSON file.
                 * @param audioConfig The audio configuration options.
                 * @param audioXhrSettings An XHR Settings configuration object for the audio file. Used in replacement of the Loaders default XHR Settings.
                 * @param jsonXhrSettings An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | AudioSpriteFileConfig,
                    jsonURL: string,
                    audioURL?: object,
                    audioConfig?: any,
                    audioXhrSettings?: XHRSettingsObject,
                    jsonXhrSettings?: XHRSettingsObject
                );

                /**
                 * Called by each File when it finishes loading.
                 * @param file The File that has completed processing.
                 */
                onFileComplete(file: File): void;

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface BinaryFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Binary Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
                /**
                 * Optional interface to cast the binary file to once loaded. For example, `Uint8Array`.
                 */
                datainterface?: any;
            }

            /**
             * A single Binary File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#binary method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#binary.
             */
            class BinaryFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.bin`, i.e. if `key` was "alien" then the URL will be "alien.bin".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 * @param datainterface Optional interface to cast the binary file to once loaded. For example, `Uint8Array`.
                 */
                constructor(loader: LoaderPlugin, key: string | BinaryFileConfig, url?: string, xhrSettings?: XHRSettingsObject, datainterface?: any);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }

            interface BitmapFontFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Texture Manager.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the texture image file from.
                 */
                textureURL?: string;
                /**
                 * The default file extension to use for the image texture if no url is provided.
                 */
                textureExtension?: string;
                /**
                 * Extra XHR Settings specifically for the texture image file.
                 */
                textureXhrSettings?: XHRSettingsObject;
                /**
                 * The filename of an associated normal map. It uses the same path and url to load as the texture image.
                 */
                normalMap?: string;
                /**
                 * The absolute or relative URL to load the font data xml file from.
                 */
                fontDataURL?: string;
                /**
                 * The default file extension to use for the font data xml if no url is provided.
                 */
                fontDataExtension?: string;
                /**
                 * Extra XHR Settings specifically for the font data xml file.
                 */
                fontDataXhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Bitmap Font based File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#bitmapFont method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#bitmapFont.
             */
            class BitmapFontFile extends MultiFile {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param textureURL The absolute or relative URL to load the font image file from.
                 * If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
                 * @param fontDataURL The absolute or relative URL to load the font xml data file from.
                 * If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was "alien" then the URL will be "alien.xml".
                 * @param textureXhrSettings An XHR Settings configuration object for the font image file. Used in replacement of the Loaders default XHR Settings.
                 * @param fontDataXhrSettings An XHR Settings configuration object for the font data xml file. Used in replacement of the Loaders default XHR Settings.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | BitmapFontFileConfig,
                    textureURL?: string | string[],
                    fontDataURL?: string,
                    textureXhrSettings?: XHRSettingsObject,
                    fontDataXhrSettings?: XHRSettingsObject
                );

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface GLSLFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Text Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single GLSL File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#glsl method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#glsl.
             */
            class GLSLFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was "alien" then the URL will be "alien.txt".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(loader: LoaderPlugin, key: string | TextFileConfig, url?: string, xhrSettings?: XHRSettingsObject);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }

            /**
             * A single Audio File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#audio method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audio.
             */
            class HTML5AudioFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param urlConfig The absolute or relative URL to load this file from.
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(loader: LoaderPlugin, key: string | AudioFileConfig, urlConfig?: string, xhrSettings?: XHRSettingsObject);

                /**
                 * Called when the file finishes loading.
                 */
                onLoad(): void;

                /**
                 * Called if the file errors while loading.
                 */
                onError(): void;

                /**
                 * Called during the file load progress. Is sent a DOM ProgressEvent.
                 */
                onProgress(): void;

                /**
                 * Called by the Loader, starts the actual file downloading.
                 * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.
                 * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.
                 */
                load(): void;
            }

            interface HTMLFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Text Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single HTML File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#html method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#html.
             */
            class HTMLFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was "alien" then the URL will be "alien.html".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(loader: LoaderPlugin, key: string | HTMLFileConfig, url?: string, xhrSettings?: XHRSettingsObject);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }

            interface HTMLTextureFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Texture Manager.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
                /**
                 * The width of the texture the HTML will be rendered to.
                 */
                width?: integer;
                /**
                 * The height of the texture the HTML will be rendered to.
                 */
                height?: integer;
            }

            /**
             * A single HTML File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#htmlTexture method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#htmlTexture.
             */
            class HTMLTextureFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
                 * @param width The width of the texture the HTML will be rendered to.
                 * @param height The height of the texture the HTML will be rendered to.
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | HTMLTextureFileConfig,
                    url?: string,
                    width?: integer,
                    height?: integer,
                    xhrSettings?: XHRSettingsObject
                );

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface ImageFrameConfig {
                /**
                 * The width of the frame in pixels.
                 */
                frameWidth: integer;
                /**
                 * The height of the frame in pixels. Uses the `frameWidth` value if not provided.
                 */
                frameHeight?: integer;
                /**
                 * The first frame to start parsing from.
                 */
                startFrame?: integer;
                /**
                 * The frame to stop parsing at. If not provided it will calculate the value based on the image and frame dimensions.
                 */
                endFrame?: integer;
                /**
                 * The margin in the image. This is the space around the edge of the frames.
                 */
                margin?: integer;
                /**
                 * The spacing between each frame in the image.
                 */
                spacing?: integer;
            }

            interface ImageFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Texture Manager.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * The filename of an associated normal map. It uses the same path and url to load as the image.
                 */
                normalMap?: string;
                /**
                 * The frame configuration object. Only provided for, and used by, Sprite Sheets.
                 */
                frameConfig?: ImageFrameConfig;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Image File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#image method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#image.
             */
            class ImageFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 * @param frameConfig The frame configuration object. Only provided for, and used by, Sprite Sheets.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | ImageFileConfig,
                    url?: string | string[],
                    xhrSettings?: XHRSettingsObject,
                    frameConfig?: ImageFrameConfig
                );

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface JSONFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the JSON Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from. Or can be a ready formed JSON object, in which case it will be directly added to the Cache.
                 */
                url?: string | object;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * If specified instead of the whole JSON file being parsed and added to the Cache, only the section corresponding to this property key will be added.
                 * If the property you want to extract is nested, use periods to divide it.
                 */
                dataKey?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single JSON File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#json method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#json.
             */
            class JSONFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 * @param dataKey When the JSON file loads only this property will be stored in the Cache.
                 */
                constructor(loader: LoaderPlugin, key: string | JSONFileConfig, url?: string, xhrSettings?: XHRSettingsObject, dataKey?: string);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }

            interface MultiAtlasFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Texture Manager.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the multi atlas json file from. Or, a well formed JSON object.
                 */
                atlasURL?: string;
                /**
                 * The default file extension to use for the atlas json if no url is provided.
                 */
                atlasExtension?: string;
                /**
                 * Extra XHR Settings specifically for the atlas json file.
                 */
                atlasXhrSettings?: XHRSettingsObject;
                /**
                 * Optional path to use when loading the textures defined in the atlas data.
                 */
                path?: string;
                /**
                 * Optional Base URL to use when loading the textures defined in the atlas data.
                 */
                baseURL?: string;
                /**
                 * Extra XHR Settings specifically for the texture files.
                 */
                textureXhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Multi Texture Atlas File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#multiatlas method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#multiatlas.
             */
            class MultiAtlasFile extends MultiFile {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key of the file. Must be unique within both the Loader and the Texture Manager.
                 * @param atlasURL The absolute or relative URL to load the multi atlas json file from.
                 * @param path Optional path to use when loading the textures defined in the atlas data.
                 * @param baseURL Optional Base URL to use when loading the textures defined in the atlas data.
                 * @param atlasXhrSettings Extra XHR Settings specifically for the atlas json file.
                 * @param textureXhrSettings Extra XHR Settings specifically for the texture files.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string,
                    atlasURL?: string,
                    path?: string,
                    baseURL?: string,
                    atlasXhrSettings?: XHRSettingsObject,
                    textureXhrSettings?: XHRSettingsObject
                );

                /**
                 * Called by each File when it finishes loading.
                 * @param file The File that has completed processing.
                 */
                onFileComplete(file: File): void;

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface PackFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the JSON Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from. Or can be a ready formed JSON object, in which case it will be directly processed.
                 */
                url?: string | object;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * If specified instead of the whole JSON file being parsed, only the section corresponding to this property key will be added.
                 * If the property you want to extract is nested, use periods to divide it.
                 */
                dataKey?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single JSON Pack File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#pack method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#pack.
             */
            class PackFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 * @param dataKey When the JSON file loads only this property will be stored in the Cache.
                 */
                constructor(loader: LoaderPlugin, key: string | JSONFileConfig, url?: string, xhrSettings?: XHRSettingsObject, dataKey?: string);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }

            interface PluginFileConfig {
                /**
                 * The key of the file. Must be unique within the Loader.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Automatically start the plugin after loading?
                 */
                start?: boolean;
                /**
                 * If this plugin is to be injected into the Scene, this is the property key used.
                 */
                mapping?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Plugin Script File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#plugin method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#plugin.
             */
            class PluginFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js".
                 * @param start Automatically start the plugin after loading? Default false.
                 * @param mapping If this plugin is to be injected into the Scene, this is the property key used.
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | PluginFileConfig,
                    url?: string,
                    start?: boolean,
                    mapping?: string,
                    xhrSettings?: XHRSettingsObject
                );

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }

            interface SceneFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Text Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * An external Scene JavaScript File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#sceneFile method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#sceneFile.
             */
            class SceneFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(loader: LoaderPlugin, key: string | SceneFileConfig, url?: string, xhrSettings?: XHRSettingsObject);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface ScenePluginFileConfig {
                /**
                 * The key of the file. Must be unique within the Loader.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from. Or, a Scene Plugin.
                 */
                url?: string | CallbackFn;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * If this plugin is to be added to Scene.Systems, this is the property key for it.
                 */
                systemKey?: string;
                /**
                 * If this plugin is to be added to the Scene, this is the property key for it.
                 */
                sceneKey?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Scene Plugin Script File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#scenePlugin method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#scenePlugin.
             */
            class ScenePluginFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js".
                 * @param systemKey If this plugin is to be added to Scene.Systems, this is the property key for it.
                 * @param sceneKey If this plugin is to be added to the Scene, this is the property key for it.
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | ScenePluginFileConfig,
                    url?: string,
                    systemKey?: string,
                    sceneKey?: string,
                    xhrSettings?: XHRSettingsObject
                );

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }

            interface ScriptFileConfig {
                /**
                 * The key of the file. Must be unique within the Loader.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Script File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#script method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#script.
             */
            class ScriptFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(loader: LoaderPlugin, key: string | ScriptFileConfig, url?: string, xhrSettings?: XHRSettingsObject);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }

            interface SpriteSheetFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Texture Manager.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * The filename of an associated normal map. It uses the same path and url to load as the image.
                 */
                normalMap?: string;
                /**
                 * The frame configuration object.
                 */
                frameConfig?: ImageFrameConfig;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Sprite Sheet Image File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#spritesheet method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#spritesheet.
             */
            class SpriteSheetFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
                 * @param frameConfig The frame configuration object.
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | SpriteSheetFileConfig,
                    url?: string | string[],
                    frameConfig?: ImageFrameConfig,
                    xhrSettings?: XHRSettingsObject
                );

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface SVGSizeConfig {
                /**
                 * An optional width. The SVG will be resized to this size before being rendered to a texture.
                 */
                width?: integer;
                /**
                 * An optional height. The SVG will be resized to this size before being rendered to a texture.
                 */
                height?: integer;
                /**
                 * An optional scale. If given it overrides the width / height properties. The SVG is scaled by the scale factor before being rendered to a texture.
                 */
                scale?: number;
            }

            interface SVGFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Texture Manager.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
                /**
                 * The svg size configuration object.
                 */
                svgConfig?: SVGSizeConfig;
            }

            /**
             * A single SVG File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#svg method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#svg.
             */
            class SVGFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.svg`, i.e. if `key` was "alien" then the URL will be "alien.svg".
                 * @param svgConfig The svg size configuration object.
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | SVGFileConfig,
                    url?: string,
                    svgConfig?: SVGSizeConfig,
                    xhrSettings?: XHRSettingsObject
                );

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface TextFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Text Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Text File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#text method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#text.
             */
            class TextFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was "alien" then the URL will be "alien.txt".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(loader: LoaderPlugin, key: string | TextFileConfig, url?: string, xhrSettings?: XHRSettingsObject);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }

            interface TilemapCSVFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Tilemap Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Tilemap CSV File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapCSV method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapCSV.
             */
            class TilemapCSVFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.csv`, i.e. if `key` was "alien" then the URL will be "alien.csv".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(loader: LoaderPlugin, key: string | TilemapCSVFileConfig, url?: string, xhrSettings?: XHRSettingsObject);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface TilemapImpactFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Tilemap Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Impact.js Tilemap JSON File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapImpact method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapImpact.
             */
            class TilemapImpactFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(loader: LoaderPlugin, key: string | TilemapImpactFileConfig, url?: string, xhrSettings?: XHRSettingsObject);

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface TilemapJSONFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Tilemap Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single Tiled Tilemap JSON File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapTiledJSON method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapTiledJSON.
             */
            class TilemapJSONFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(loader: LoaderPlugin, key: string | TilemapJSONFileConfig, url?: string, xhrSettings?: XHRSettingsObject);

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface UnityAtlasFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Texture Manager.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the texture image file from.
                 */
                textureURL?: string;
                /**
                 * The default file extension to use for the image texture if no url is provided.
                 */
                textureExtension?: string;
                /**
                 * Extra XHR Settings specifically for the texture image file.
                 */
                textureXhrSettings?: XHRSettingsObject;
                /**
                 * The filename of an associated normal map. It uses the same path and url to load as the texture image.
                 */
                normalMap?: string;
                /**
                 * The absolute or relative URL to load the atlas data file from.
                 */
                atlasURL?: string;
                /**
                 * The default file extension to use for the atlas data if no url is provided.
                 */
                atlasExtension?: string;
                /**
                 * Extra XHR Settings specifically for the atlas data file.
                 */
                atlasXhrSettings?: XHRSettingsObject;
            }

            /**
             * A single text file based Unity Texture Atlas File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#unityAtlas method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#unityAtlas.
             */
            class UnityAtlasFile extends MultiFile {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param textureURL The absolute or relative URL to load the texture image file from.
                 * If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
                 * @param atlasURL The absolute or relative URL to load the texture atlas data file from.
                 * If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was "alien" then the URL will be "alien.txt".
                 * @param textureXhrSettings An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.
                 * @param atlasXhrSettings An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.
                 */
                constructor(
                    loader: LoaderPlugin,
                    key: string | UnityAtlasFileConfig,
                    textureURL?: string | string[],
                    atlasURL?: string,
                    textureXhrSettings?: XHRSettingsObject,
                    atlasXhrSettings?: XHRSettingsObject
                );

                /**
                 * Adds this file to its target cache upon successful loading and processing.
                 */
                addToCache(): void;
            }

            interface XMLFileConfig {
                /**
                 * The key of the file. Must be unique within both the Loader and the Text Cache.
                 */
                key: string;
                /**
                 * The absolute or relative URL to load the file from.
                 */
                url?: string;
                /**
                 * The default file extension to use if no url is provided.
                 */
                extension?: string;
                /**
                 * Extra XHR Settings specifically for this file.
                 */
                xhrSettings?: XHRSettingsObject;
            }

            /**
             * A single XML File suitable for loading by the Loader.
             *
             * These are created when you use the Phaser.Loader.LoaderPlugin#xml method and are not typically created directly.
             *
             * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#xml.
             */
            class XMLFile extends File {
                /**
                 *
                 * @param loader A reference to the Loader that is responsible for this file.
                 * @param key The key to use for this file, or a file configuration object.
                 * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was "alien" then the URL will be "alien.xml".
                 * @param xhrSettings Extra XHR Settings specifically for this file.
                 */
                constructor(loader: LoaderPlugin, key: string | XMLFileConfig, url?: string, xhrSettings?: XHRSettingsObject);

                /**
                 * Called automatically by Loader.nextFile.
                 * This method controls what extra work this File does with its loaded data.
                 */
                onProcess(): void;
            }
        }

        namespace FileTypesManager {
            /**
             * Static method called when a LoaderPlugin is created.
             *
             * Loops through the local types object and injects all of them as
             * properties into the LoaderPlugin instance.
             * @param loader The LoaderPlugin to install the types into.
             */
            function install(loader: LoaderPlugin): void;

            /**
             * Static method called directly by the File types.
             *
             * The key is a reference to the function used to load the files via the Loader, i.e. `image`.
             * @param key The key that will be used as the method name in the LoaderPlugin.
             * @param factoryFunction The function that will be called when LoaderPlugin.key is invoked.
             */
            function register(key: string, factoryFunction: CallbackFn): void;

            /**
             * Removed all associated file types.
             */
            function destroy(): void;
        }

        /**
         * Given a File and a baseURL value this returns the URL the File will use to download from.
         * @param file The File object.
         * @param baseURL A default base URL.
         */
        function GetURL(file: File, baseURL: string): string;

        /**
         * The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.
         * You typically interact with it via `this.load` in your Scene. Scenes can have a `preload` method, which is always
         * called before the Scenes `create` method, allowing you to preload assets that the Scene may need.
         *
         * If you call any `this.load` methods from outside of `Scene.preload` then you need to start the Loader going
         * yourself by calling `Loader.start()`. It's only automatically started during the Scene preload.
         *
         * The Loader uses a combination of tag loading (eg. Audio elements) and XHR and provides progress and completion events.
         * Files are loaded in parallel by default. The amount of concurrent connections can be controlled in your Game Configuration.
         *
         * Once the Loader has started loading you are still able to add files to it. These can be injected as a result of a loader
         * event, the interface of file being loaded (such as a pack file) or other external events. As long as the Loader hasn't finished
         * simply adding a new file to it, while running, will ensure it's added into the current queue.
         *
         * Every Scene has its own instance of the Loader and they are bound to the Scene in which they are created. However,
         * assets loaded by the Loader are placed into global game-level caches. For example, loading an XML file will place that
         * file inside `Game.cache.xml`, which is accessible from every Scene in your game, no matter who was responsible
         * for loading it. The same is true of Textures. A texture loaded in one Scene is instantly available to all other Scenes
         * in your game.
         *
         * The Loader works by using custom File types. These are stored in the FileTypesManager, which injects them into the Loader
         * when it's instantiated. You can create your own custom file types by extending either the File or MultiFile classes.
         * See those files for more details.
         */
        class LoaderPlugin extends Phaser.Events.EventEmitter {
            /**
             *
             * @param scene The Scene which owns this Loader instance.
             */
            constructor(scene: Scene);

            /**
             * Adds an Animation JSON Data file, or array of Animation JSON files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.animation('baddieAnims', 'files/BaddieAnims.json');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
             * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
             *
             * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the JSON Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.animation({
             *     key: 'baddieAnims',
             *     url: 'files/BaddieAnims.json'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.JSONFileConfig` for more details.
             *
             * Once the file has finished loading it will automatically be passed to the global Animation Managers `fromJSON` method.
             * This will parse all of the JSON data and create animation data from it. This process happens at the very end
             * of the Loader, once every other file in the load queue has finished. The reason for this is to allow you to load
             * both animation data and the images it relies upon in the same load call.
             *
             * Once the animation data has been parsed you will be able to play animations using that data.
             * Please see the Animation Manager `fromJSON` method for more details about the format and playback.
             *
             * You can also access the raw animation data from its Cache using its key:
             *
             * ```javascript
             * this.load.animation('baddieAnims', 'files/BaddieAnims.json');
             * // and later in your game ...
             * var data = this.cache.json.get('baddieAnims');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and
             * this is what you would use to retrieve the text from the JSON Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "data"
             * and no URL is given then the Loader will set the URL to be "data.json". It will always add `.json` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,
             * rather than the whole file. For example, if your JSON data had a structure like this:
             *
             * ```json
             * {
             *     "level1": {
             *         "baddies": {
             *             "aliens": {},
             *             "boss": {}
             *         }
             *     },
             *     "level2": {},
             *     "level3": {}
             * }
             * ```
             *
             * And if you only wanted to create animations from the `boss` data, then you could pass `level1.baddies.boss`as the `dataKey`.
             *
             * Note: The ability to load this interface of file will only be available if the JSON File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
             * @param dataKey When the Animation JSON file loads only this property will be stored in the Cache and used to create animation data.
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            animation(
                key: string | FileTypes.JSONFileConfig | FileTypes.JSONFileConfig[],
                url?: string,
                dataKey?: string,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a JSON based Texture Atlas, or array of atlases, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.atlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
             * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
             *
             * Phaser expects the atlas data to be provided in a JSON file, using either the JSON Hash or JSON Array format.
             * These files are created by software such as Texture Packer, Shoebox and Adobe Flash / Animate.
             * If you are using Texture Packer and have enabled multi-atlas support, then please use the Phaser Multi Atlas loader
             * instead of this one.
             *
             * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
             *
             * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Texture Manager first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.atlas({
             *     key: 'mainmenu',
             *     textureURL: 'images/MainMenu.png',
             *     atlasURL: 'images/MainMenu.json'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.AtlasJSONFileConfig` for more details.
             *
             * Instead of passing a URL for the atlas JSON data you can also pass in a well formed JSON object instead.
             *
             * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:
             *
             * ```javascript
             * this.load.atlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');
             * // and later in your game ...
             * this.add.image(x, y, 'mainmenu', 'background');
             * ```
             *
             * To get a list of all available frames within an atlas please consult your Texture Atlas software.
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
             * this is what you would use to retrieve the image from the Texture Manager.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
             * then you can specify it by providing an array as the `url` where the second element is the normal map:
             *
             * ```javascript
             * this.load.atlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.json');
             * ```
             *
             * Or, if you are using a config object use the `normalMap` property:
             *
             * ```javascript
             * this.load.atlas({
             *     key: 'mainmenu',
             *     textureURL: 'images/MainMenu.png',
             *     normalMap: 'images/MainMenu-n.png',
             *     atlasURL: 'images/MainMenu.json'
             * });
             * ```
             *
             * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
             * Normal maps are a WebGL only feature.
             *
             * Note: The ability to load this interface of file will only be available if the Atlas JSON File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param textureURL The absolute or relative URL to load the texture image file from.
             * If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
             * @param atlasURL The absolute or relative URL to load the texture atlas json data file from.
             * If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
             * @param textureXhrSettings An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.
             * @param atlasXhrSettings An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.
             */
            atlas(
                key: string | FileTypes.AtlasJSONFileConfig | FileTypes.AtlasJSONFileConfig[],
                textureURL?: string | string[],
                atlasURL?: string,
                textureXhrSettings?: XHRSettingsObject,
                atlasXhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds an XML based Texture Atlas, or array of atlases, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.atlasXML('mainmenu', 'images/MainMenu.png', 'images/MainMenu.xml');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
             * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
             *
             * Phaser expects the atlas data to be provided in an XML file format.
             * These files are created by software such as Shoebox and Adobe Flash / Animate.
             *
             * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
             *
             * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Texture Manager first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.atlasXML({
             *     key: 'mainmenu',
             *     textureURL: 'images/MainMenu.png',
             *     atlasURL: 'images/MainMenu.xml'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.AtlasXMLFileConfig` for more details.
             *
             * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:
             *
             * ```javascript
             * this.load.atlasXML('mainmenu', 'images/MainMenu.png', 'images/MainMenu.xml');
             * // and later in your game ...
             * this.add.image(x, y, 'mainmenu', 'background');
             * ```
             *
             * To get a list of all available frames within an atlas please consult your Texture Atlas software.
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
             * this is what you would use to retrieve the image from the Texture Manager.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
             * then you can specify it by providing an array as the `url` where the second element is the normal map:
             *
             * ```javascript
             * this.load.atlasXML('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.xml');
             * ```
             *
             * Or, if you are using a config object use the `normalMap` property:
             *
             * ```javascript
             * this.load.atlasXML({
             *     key: 'mainmenu',
             *     textureURL: 'images/MainMenu.png',
             *     normalMap: 'images/MainMenu-n.png',
             *     atlasURL: 'images/MainMenu.xml'
             * });
             * ```
             *
             * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
             * Normal maps are a WebGL only feature.
             *
             * Note: The ability to load this interface of file will only be available if the Atlas XML File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param textureURL The absolute or relative URL to load the texture image file from.
             * If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
             * @param atlasURL The absolute or relative URL to load the texture atlas xml data file from.
             * If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was "alien" then the URL will be "alien.xml".
             * @param textureXhrSettings An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.
             * @param atlasXhrSettings An XHR Settings configuration object for the atlas xml file. Used in replacement of the Loaders default XHR Settings.
             */
            atlasXML(
                key: string | FileTypes.AtlasXMLFileConfig | FileTypes.AtlasXMLFileConfig[],
                textureURL?: string | string[],
                atlasURL?: string,
                textureXhrSettings?: XHRSettingsObject,
                atlasXhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds an Audio or HTML5Audio file, or array of audio files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.audio('title', [ 'music/Title.ogg', 'music/Title.mp3', 'music/Title.m4a' ]);
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global Audio Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Audio Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Audio Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.audio({
             *     key: 'title',
             *     url: [ 'music/Title.ogg', 'music/Title.mp3', 'music/Title.m4a' ]
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.AudioFileConfig` for more details.
             *
             * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.
             *
             * Due to different browsers supporting different audio file types you should usually provide your audio files in a variety of formats.
             * ogg, mp3 and m4a are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on
             * browser support.
             *
             * If audio has been disabled in your game, either via the game config, or lack of support from the device, then no audio will be loaded.
             *
             * Note: The ability to load this interface of file will only be available if the Audio File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param urls The absolute or relative URL to load the audio files from.
             * @param config An object containing an `instances` property for HTML5Audio. Defaults to 1.
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            audio(
                key: string | FileTypes.AudioFileConfig | FileTypes.AudioFileConfig[],
                urls?: string | string[],
                config?: any,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a JSON based Audio Sprite, or array of audio sprites, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.audioSprite('kyobi', 'kyobi.json', [
             *         'kyobi.ogg',
             *         'kyobi.mp3',
             *         'kyobi.m4a'
             *     ]);
             * }
             * ```
             *
             * Audio Sprites are a combination of audio files and a JSON configuration.
             * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite
             *
             * If the JSON file includes a 'resource' object then you can let Phaser parse it and load the audio
             * files automatically based on its content. To do this exclude the audio URLs from the load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.audioSprite('kyobi', 'kyobi.json');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
             * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
             *
             * The key must be a unique String. It is used to add the file to the global Audio Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Audio Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Audio Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.audioSprite({
             *     key: 'kyobi',
             *     jsonURL: 'audio/Kyobi.json',
             *     audioURL: [
             *         'audio/Kyobi.ogg',
             *         'audio/Kyobi.mp3',
             *         'audio/Kyobi.m4a'
             *     ]
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.AudioSpriteFileConfig` for more details.
             *
             * Instead of passing a URL for the audio JSON data you can also pass in a well formed JSON object instead.
             *
             * Once the audio has finished loading you can use it create an Audio Sprite by referencing its key:
             *
             * ```javascript
             * this.load.audioSprite('kyobi', 'kyobi.json');
             * // and later in your game ...
             * var music = this.sound.addAudioSprite('kyobi');
             * music.play('title');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
             * this is what you would use to retrieve the image from the Texture Manager.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * Due to different browsers supporting different audio file types you should usually provide your audio files in a variety of formats.
             * ogg, mp3 and m4a are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on
             * browser support.
             *
             * If audio has been disabled in your game, either via the game config, or lack of support from the device, then no audio will be loaded.
             *
             * Note: The ability to load this interface of file will only be available if the Audio Sprite File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or an array of objects.
             * @param jsonURL The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.
             * @param audioURL The absolute or relative URL to load the audio file from. If empty it will be obtained by parsing the JSON file.
             * @param audioConfig The audio configuration options.
             * @param audioXhrSettings An XHR Settings configuration object for the audio file. Used in replacement of the Loaders default XHR Settings.
             * @param jsonXhrSettings An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.
             */
            audioSprite(
                key: string | FileTypes.AudioSpriteFileConfig | FileTypes.AudioSpriteFileConfig[],
                jsonURL: string,
                audioURL?: string | string[],
                audioConfig?: any,
                audioXhrSettings?: XHRSettingsObject,
                jsonXhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a Binary file, or array of Binary files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.binary('doom', 'files/Doom.wad');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global Binary Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Binary Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Binary Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.binary({
             *     key: 'doom',
             *     url: 'files/Doom.wad',
             *     datainterface: Uint8Array
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.BinaryFileConfig` for more details.
             *
             * Once the file has finished loading you can access it from its Cache using its key:
             *
             * ```javascript
             * this.load.binary('doom', 'files/Doom.wad');
             * // and later in your game ...
             * var data = this.cache.binary.get('doom');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `LEVEL1.` and the key was `Data` the final key will be `LEVEL1.Data` and
             * this is what you would use to retrieve the text from the Binary Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "doom"
             * and no URL is given then the Loader will set the URL to be "doom.bin". It will always add `.bin` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the Binary File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.bin`, i.e. if `key` was "alien" then the URL will be "alien.bin".
             * @param datainterface Optional interface to cast the binary file to once loaded. For example, `Uint8Array`.
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            binary(
                key: string | FileTypes.BinaryFileConfig | FileTypes.BinaryFileConfig[],
                url?: string,
                datainterface?: any,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds an XML based Bitmap Font, or array of fonts, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             * ```javascript
             * function preload ()
             * {
             *     this.load.bitmapFont('goldenFont', 'images/GoldFont.png', 'images/GoldFont.xml');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
             * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
             *
             * Phaser expects the font data to be provided in an XML file format.
             * These files are created by software such as the [Angelcode Bitmap Font Generator](http://www.angelcode.com/products/bmfont/),
             * [Littera](http://kvazars.com/littera/) or [Glyph Designer](https://71squared.com/glyphdesigner)
             *
             * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
             *
             * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Texture Manager first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.bitmapFont({
             *     key: 'goldenFont',
             *     textureURL: 'images/GoldFont.png',
             *     fontDataURL: 'images/GoldFont.xml'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.BitmapFontFileConfig` for more details.
             *
             * Once the atlas has finished loading you can use key of it when creating a Bitmap Text Game Object:
             *
             * ```javascript
             * this.load.bitmapFont('goldenFont', 'images/GoldFont.png', 'images/GoldFont.xml');
             * // and later in your game ...
             * this.add.bitmapText(x, y, 'goldenFont', 'Hello World');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
             * this is what you would use when creating a Bitmap Text object.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
             * then you can specify it by providing an array as the `url` where the second element is the normal map:
             *
             * ```javascript
             * this.load.bitmapFont('goldenFont', [ 'images/GoldFont.png', 'images/GoldFont-n.png' ], 'images/GoldFont.xml');
             * ```
             *
             * Or, if you are using a config object use the `normalMap` property:
             *
             * ```javascript
             * this.load.bitmapFont({
             *     key: 'goldenFont',
             *     textureURL: 'images/GoldFont.png',
             *     normalMap: 'images/GoldFont-n.png',
             *     fontDataURL: 'images/GoldFont.xml'
             * });
             * ```
             *
             * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
             * Normal maps are a WebGL only feature.
             *
             * Note: The ability to load this interface of file will only be available if the Bitmap Font File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param textureURL The absolute or relative URL to load the font image file from.
             * If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
             * @param fontDataURL The absolute or relative URL to load the font xml data file from.
             * If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was "alien" then the URL will be "alien.xml".
             * @param textureXhrSettings An XHR Settings configuration object for the font image file. Used in replacement of the Loaders default XHR Settings.
             * @param fontDataXhrSettings An XHR Settings configuration object for the font data xml file. Used in replacement of the Loaders default XHR Settings.
             */
            bitmapFont(
                key: string | FileTypes.BitmapFontFileConfig | FileTypes.BitmapFontFileConfig[],
                textureURL?: string | string[],
                fontDataURL?: string,
                textureXhrSettings?: XHRSettingsObject,
                fontDataXhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a GLSL file, or array of GLSL files, to the current load queue.
             * In Phaser 3 GLSL files are just plain Text files at the current moment in time.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.glsl('plasma', 'shaders/Plasma.glsl');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global Shader Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Shader Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Shader Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.glsl({
             *     key: 'plasma',
             *     url: 'shaders/Plasma.glsl'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.GLSLFileConfig` for more details.
             *
             * Once the file has finished loading you can access it from its Cache using its key:
             *
             * ```javascript
             * this.load.glsl('plasma', 'shaders/Plasma.glsl');
             * // and later in your game ...
             * var data = this.cache.shader.get('plasma');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `FX.` and the key was `Plasma` the final key will be `FX.Plasma` and
             * this is what you would use to retrieve the text from the Shader Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "plasma"
             * and no URL is given then the Loader will set the URL to be "plasma.glsl". It will always add `.glsl` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the GLSL File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.glsl`, i.e. if `key` was "alien" then the URL will be "alien.glsl".
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            glsl(key: string | FileTypes.GLSLFileConfig | FileTypes.GLSLFileConfig[], url?: string, xhrSettings?: XHRSettingsObject): LoaderPlugin;

            /**
             * Adds an HTML file, or array of HTML files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.html('story', 'files/LoginForm.html');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global HTML Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the HTML Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the HTML Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.html({
             *     key: 'login',
             *     url: 'files/LoginForm.html'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.HTMLFileConfig` for more details.
             *
             * Once the file has finished loading you can access it from its Cache using its key:
             *
             * ```javascript
             * this.load.html('login', 'files/LoginForm.html');
             * // and later in your game ...
             * var data = this.cache.html.get('login');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and
             * this is what you would use to retrieve the html from the HTML Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "story"
             * and no URL is given then the Loader will set the URL to be "story.html". It will always add `.html` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the HTML File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was "alien" then the URL will be "alien.html".
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            html(key: string | FileTypes.HTMLFileConfig | FileTypes.HTMLFileConfig[], url?: string, xhrSettings?: XHRSettingsObject): LoaderPlugin;

            /**
             * Adds an HTML File, or array of HTML Files, to the current load queue. When the files are loaded they
             * will be rendered to textures and stored in the Texture Manager.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.htmlTexture('instructions', 'content/intro.html', 256, 512);
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Texture Manager first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.htmlTexture({
             *     key: 'instructions',
             *     url: 'content/intro.html',
             *     width: 256,
             *     height: 512
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.HTMLTextureFileConfig` for more details.
             *
             * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:
             *
             * ```javascript
             * this.load.htmlTexture('instructions', 'content/intro.html', 256, 512);
             * // and later in your game ...
             * this.add.image(x, y, 'instructions');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
             * this is what you would use to retrieve the image from the Texture Manager.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.html". It will always add `.html` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * The width and height are the size of the texture to which the HTML will be rendered. It's not possible to determine these
             * automatically, so you will need to provide them, either as arguments or in the file config object.
             * When the HTML file has loaded a new SVG element is created with a size and viewbox set to the width and height given.
             * The SVG file has a body tag added to it, with the HTML file contents included. It then calls `window.Blob` on the SVG,
             * and if successful is added to the Texture Manager, otherwise it fails processing. The overall quality of the rendered
             * HTML depends on your browser, and some of them may not even support the svg / blob process used. Be aware that there are
             * limitations on what HTML can be inside an SVG. You can find out more details in this
             * [Mozilla MDN entry](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Drawing_DOM_objects_into_a_canvas).
             *
             * Note: The ability to load this interface of file will only be available if the HTMLTextureFile File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was "alien" then the URL will be "alien.html".
             * @param width The width of the texture the HTML will be rendered to. Default 512.
             * @param height The height of the texture the HTML will be rendered to. Default 512.
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            htmlTexture(
                key: string | FileTypes.HTMLTextureFileConfig | FileTypes.HTMLTextureFileConfig[],
                url?: string,
                width?: integer,
                height?: integer,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds an Image, or array of Images, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.image('logo', 'images/phaserLogo.png');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
             * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback
             * of animated gifs to Canvas elements.
             *
             * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Texture Manager first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.image({
             *     key: 'logo',
             *     url: 'images/AtariLogo.png'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.ImageFileConfig` for more details.
             *
             * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:
             *
             * ```javascript
             * this.load.image('logo', 'images/AtariLogo.png');
             * // and later in your game ...
             * this.add.image(x, y, 'logo');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
             * this is what you would use to retrieve the image from the Texture Manager.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
             * then you can specify it by providing an array as the `url` where the second element is the normal map:
             *
             * ```javascript
             * this.load.image('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ]);
             * ```
             *
             * Or, if you are using a config object use the `normalMap` property:
             *
             * ```javascript
             * this.load.image({
             *     key: 'logo',
             *     url: 'images/AtariLogo.png',
             *     normalMap: 'images/AtariLogo-n.png'
             * });
             * ```
             *
             * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
             * Normal maps are a WebGL only feature.
             *
             * Note: The ability to load this interface of file will only be available if the Image File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            image(
                key: string | FileTypes.ImageFileConfig | FileTypes.ImageFileConfig[],
                url?: string | string[],
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a JSON file, or array of JSON files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.json('wavedata', 'files/AlienWaveData.json');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the JSON Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.json({
             *     key: 'wavedata',
             *     url: 'files/AlienWaveData.json'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.JSONFileConfig` for more details.
             *
             * Once the file has finished loading you can access it from its Cache using its key:
             *
             * ```javascript
             * this.load.json('wavedata', 'files/AlienWaveData.json');
             * // and later in your game ...
             * var data = this.cache.json.get('wavedata');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and
             * this is what you would use to retrieve the text from the JSON Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "data"
             * and no URL is given then the Loader will set the URL to be "data.json". It will always add `.json` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,
             * rather than the whole file. For example, if your JSON data had a structure like this:
             *
             * ```json
             * {
             *     "level1": {
             *         "baddies": {
             *             "aliens": {},
             *             "boss": {}
             *         }
             *     },
             *     "level2": {},
             *     "level3": {}
             * }
             * ```
             *
             * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.
             *
             * Note: The ability to load this interface of file will only be available if the JSON File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
             * @param dataKey When the JSON file loads only this property will be stored in the Cache.
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            json(
                key: string | FileTypes.JSONFileConfig | FileTypes.JSONFileConfig[],
                url?: string,
                dataKey?: string,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a Multi Texture Atlas, or array of multi atlases, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.multiatlas('level1', 'images/Level1.json');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
             * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
             *
             * Phaser expects the atlas data to be provided in a JSON file as exported from the application Texture Packer,
             * version 4.6.3 or above, where you have made sure to use the Phaser 3 Export option.
             *
             * The way it works internally is that you provide a URL to the JSON file. Phaser then loads this JSON, parses it and
             * extracts which texture files it also needs to load to complete the process. If the JSON also defines normal maps,
             * Phaser will load those as well.
             *
             * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Texture Manager first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.multiatlas({
             *     key: 'level1',
             *     atlasURL: 'images/Level1.json'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.MultiAtlasFileConfig` for more details.
             *
             * Instead of passing a URL for the atlas JSON data you can also pass in a well formed JSON object instead.
             *
             * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:
             *
             * ```javascript
             * this.load.multiatlas('level1', 'images/Level1.json');
             * // and later in your game ...
             * this.add.image(x, y, 'level1', 'background');
             * ```
             *
             * To get a list of all available frames within an atlas please consult your Texture Atlas software.
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
             * this is what you would use to retrieve the image from the Texture Manager.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the Multi Atlas File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param atlasURL The absolute or relative URL to load the texture atlas json data file from.
             * If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
             * @param path Optional path to use when loading the textures defined in the atlas data.
             * @param baseURL Optional Base URL to use when loading the textures defined in the atlas data.
             * @param atlasXhrSettings An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.
             */
            multiatlas(
                key: string | FileTypes.MultiAtlasFileConfig | FileTypes.MultiAtlasFileConfig[],
                atlasURL?: string,
                path?: string,
                baseURL?: string,
                atlasXhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a JSON File Pack, or array of packs, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.pack('level1', 'data/Level1Files.json');
             * }
             * ```
             *
             * A File Pack is a JSON file (or object) that contains details about other files that should be added into the Loader.
             * Here is a small example:
             *
             * ```json
             * {
             *    "test1": {
             *        "files": [
             *            {
             *                "interface": "image",
             *                "key": "taikodrummaster",
             *                "url": "assets/pics/taikodrummaster.jpg"
             *            },
             *            {
             *                "interface": "image",
             *                "key": "sukasuka-chtholly",
             *                "url": "assets/pics/sukasuka-chtholly.png"
             *            }
             *        ]
             *    },
             *    "meta": {
             *        "generated": "1401380327373",
             *        "app": "Phaser 3 Asset Packer",
             *        "url": "https://phaser.io",
             *        "version": "1.0",
             *        "copyright": "Photon Storm Ltd. 2018"
             *    }
             * }
             * ```
             *
             * The pack can be split into sections. In the example above you'll see a section called `test1. You can tell
             * the `load.pack` method to parse only a particular section of a pack. The pack is stored in the JSON Cache,
             * so you can pass it to the Loader to process additional sections as needed in your game, or you can just load
             * them all at once without specifying anything.
             *
             * The pack file can contain an entry for any interface of file that Phaser can load. The object structures exactly
             * match that of the file interface configs, and all properties available within the file interface configs can be used
             * in the pack file too.
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
             * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
             *
             * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the JSON Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.pack({
             *     key: 'level1',
             *     url: 'data/Level1Files.json'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.PackFileConfig` for more details.
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and
             * this is what you would use to retrieve the text from the JSON Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "data"
             * and no URL is given then the Loader will set the URL to be "data.json". It will always add `.json` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,
             * rather than the whole file. For example, if your JSON data had a structure like this:
             *
             * ```json
             * {
             *     "level1": {
             *         "baddies": {
             *             "aliens": {},
             *             "boss": {}
             *         }
             *     },
             *     "level2": {},
             *     "level3": {}
             * }
             * ```
             *
             * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.
             *
             * Note: The ability to load this interface of file will only be available if the Pack File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
             * @param dataKey When the JSON file loads only this property will be stored in the Cache.
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            pack(
                key: string | FileTypes.PackFileConfig | FileTypes.PackFileConfig[],
                url?: string,
                dataKey?: string,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a Plugin Script file, or array of plugin files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.plugin('modplayer', 'plugins/ModPlayer.js');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String and not already in-use by another file in the Loader.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.plugin({
             *     key: 'modplayer',
             *     url: 'plugins/ModPlayer.js'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.PluginFileConfig` for more details.
             *
             * Once the file has finished loading it will automatically be converted into a script element
             * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to
             * false and then the resulting element will be appended to `document.head`. Any code then in the
             * script will be executed. It will then be passed to the Phaser PluginCache.register method.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.js". It will always add `.js` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the Plugin File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from.
             * If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js". Or, a plugin function.
             * @param start Automatically start the plugin after loading?
             * @param mapping If this plugin is to be injected into the Scene, this is the property key used.
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            plugin(
                key: string | FileTypes.PluginFileConfig | FileTypes.PluginFileConfig[],
                url?: string | CallbackFn,
                start?: boolean,
                mapping?: string,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds an external Scene file, or array of Scene files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.sceneFile('Level1', 'src/Level1.js');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global Scene Manager upon a successful load.
             *
             * For a Scene File it's vitally important that the key matches the class name in the JavaScript file.
             *
             * For example here is the source file:
             *
             * ```javascript
             * class ExternalScene extends Phaser.Scene {
             *
             *     constructor ()
             *     {
             *         super('myScene');
             *     }
             *
             * }
             * ```
             *
             * Because the class is called `ExternalScene` that is the exact same key you must use when loading it:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.sceneFile('ExternalScene', 'src/yourScene.js');
             * }
             * ```
             *
             * The key that is used within the Scene Manager can either be set to the same, or you can override it in the Scene
             * constructor, as we've done in the example above, where the Scene key was changed to `myScene`.
             *
             * The key should be unique both in terms of files being loaded and Scenes already present in the Scene Manager.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Scene Manager first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.sceneFile({
             *     key: 'Level1',
             *     url: 'src/Level1.js'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.SceneFileConfig` for more details.
             *
             * Once the file has finished loading it will be added to the Scene Manager.
             *
             * ```javascript
             * this.load.sceneFile('Level1', 'src/Level1.js');
             * // and later in your game ...
             * this.scene.start('Level1');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `WORLD1.` and the key was `Story` the final key will be `WORLD1.Story` and
             * this is what you would use to retrieve the text from the Scene Manager.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "story"
             * and no URL is given then the Loader will set the URL to be "story.js". It will always add `.js` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the Scene File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js".
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            sceneFile(
                key: string | FileTypes.SceneFileConfig | FileTypes.SceneFileConfig[],
                url?: string,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a Scene Plugin Script file, or array of plugin files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.scenePlugin('ModPlayer', 'plugins/ModPlayer.js', 'modPlayer', 'mods');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String and not already in-use by another file in the Loader.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.scenePlugin({
             *     key: 'modplayer',
             *     url: 'plugins/ModPlayer.js'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.ScenePluginFileConfig` for more details.
             *
             * Once the file has finished loading it will automatically be converted into a script element
             * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to
             * false and then the resulting element will be appended to `document.head`. Any code then in the
             * script will be executed. It will then be passed to the Phaser PluginCache.register method.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.js". It will always add `.js` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the Script File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from.
             * If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js". Or, set to a plugin function.
             * @param systemKey If this plugin is to be added to Scene.Systems, this is the property key for it.
             * @param sceneKey If this plugin is to be added to the Scene, this is the property key for it.
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            scenePlugin(
                key: string | FileTypes.ScenePluginFileConfig | FileTypes.ScenePluginFileConfig[],
                url?: string | CallbackFn,
                systemKey?: string,
                sceneKey?: string,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a Script file, or array of Script files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.script('aliens', 'lib/aliens.js');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String and not already in-use by another file in the Loader.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.script({
             *     key: 'aliens',
             *     url: 'lib/aliens.js'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.ScriptFileConfig` for more details.
             *
             * Once the file has finished loading it will automatically be converted into a script element
             * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to
             * false and then the resulting element will be appended to `document.head`. Any code then in the
             * script will be executed.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.js". It will always add `.js` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the Script File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was "alien" then the URL will be "alien.js".
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            script(
                key: string | FileTypes.ScriptFileConfig | FileTypes.ScriptFileConfig[],
                url?: string,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a Sprite Sheet Image, or array of Sprite Sheet Images, to the current load queue.
             *
             * The term 'Sprite Sheet' in Phaser means a fixed-size sheet. Where every frame in the sheet is the exact same size,
             * and you reference those frames using numbers, not frame names. This is not the same thing as a Texture Atlas, where
             * the frames are packed in a way where they take up the least amount of space, and are referenced by their names,
             * not numbers. Some articles and software use the term 'Sprite Sheet' to mean Texture Atlas, so please be aware of
             * what sort of file you're actually trying to load.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.spritesheet('bot', 'images/robot.png', { frameWidth: 32, frameHeight: 38 });
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
             * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback
             * of animated gifs to Canvas elements.
             *
             * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Texture Manager first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.spritesheet({
             *     key: 'bot',
             *     url: 'images/robot.png',
             *     frameConfig: {
             *         frameWidth: 32,
             *         frameHeight: 38,
             *         startFrame: 0,
             *         endFrame: 8
             *     }
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.SpriteSheetFileConfig` for more details.
             *
             * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:
             *
             * ```javascript
             * this.load.spritesheet('bot', 'images/robot.png', { frameWidth: 32, frameHeight: 38 });
             * // and later in your game ...
             * this.add.image(x, y, 'bot', 0);
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `PLAYER.` and the key was `Running` the final key will be `PLAYER.Running` and
             * this is what you would use to retrieve the image from the Texture Manager.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
             * then you can specify it by providing an array as the `url` where the second element is the normal map:
             *
             * ```javascript
             * this.load.spritesheet('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ], { frameWidth: 256, frameHeight: 80 });
             * ```
             *
             * Or, if you are using a config object use the `normalMap` property:
             *
             * ```javascript
             * this.load.spritesheet({
             *     key: 'logo',
             *     url: 'images/AtariLogo.png',
             *     normalMap: 'images/AtariLogo-n.png',
             *     frameConfig: {
             *         frameWidth: 256,
             *         frameHeight: 80
             *     }
             * });
             * ```
             *
             * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
             * Normal maps are a WebGL only feature.
             *
             * Note: The ability to load this interface of file will only be available if the Sprite Sheet File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
             * @param frameConfig The frame configuration object. At a minimum it should have a `frameWidth` property.
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            spritesheet(
                key: string | FileTypes.SpriteSheetFileConfig | FileTypes.SpriteSheetFileConfig[],
                url?: string,
                frameConfig?: FileTypes.ImageFrameConfig,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds an SVG File, or array of SVG Files, to the current load queue. When the files are loaded they
             * will be rendered to bitmap textures and stored in the Texture Manager.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.svg('morty', 'images/Morty.svg');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Texture Manager first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.svg({
             *     key: 'morty',
             *     url: 'images/Morty.svg'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.SVGFileConfig` for more details.
             *
             * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:
             *
             * ```javascript
             * this.load.svg('morty', 'images/Morty.svg');
             * // and later in your game ...
             * this.add.image(x, y, 'morty');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
             * this is what you would use to retrieve the image from the Texture Manager.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.html". It will always add `.html` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * You can optionally pass an SVG Resize Configuration object when you load an SVG file. By default the SVG will be rendered to a texture
             * at the same size defined in the SVG file attributes. However, this isn't always desirable. You may wish to resize the SVG (either down
             * or up) to improve texture clarity, or reduce texture memory consumption. You can either specify an exact width and height to resize
             * the SVG to:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.svg('morty', 'images/Morty.svg', { width: 300, height: 600 });
             * }
             * ```
             *
             * Or when using a configuration object:
             *
             * ```javascript
             * this.load.svg({
             *     key: 'morty',
             *     url: 'images/Morty.svg',
             *     svgConfig: {
             *         width: 300,
             *         height: 600
             *     }
             * });
             * ```
             *
             * Alternatively, you can just provide a scale factor instead:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.svg('morty', 'images/Morty.svg', { scale: 2.5 });
             * }
             * ```
             *
             * Or when using a configuration object:
             *
             * ```javascript
             * this.load.svg({
             *     key: 'morty',
             *     url: 'images/Morty.svg',
             *     svgConfig: {
             *         scale: 2.5
             *     }
             * });
             * ```
             *
             * If scale, width and height values are all given, the scale has priority and the width and height values are ignored.
             *
             * Note: The ability to load this interface of file will only be available if the SVG File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.svg`, i.e. if `key` was "alien" then the URL will be "alien.svg".
             * @param svgConfig The svg size configuration object.
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            svg(
                key: string | FileTypes.SVGFileConfig | FileTypes.SVGFileConfig[],
                url?: string,
                svgConfig?: FileTypes.SVGSizeConfig,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a Text file, or array of Text files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.text('story', 'files/IntroStory.txt');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global Text Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Text Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Text Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.text({
             *     key: 'story',
             *     url: 'files/IntroStory.txt'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.TextFileConfig` for more details.
             *
             * Once the file has finished loading you can access it from its Cache using its key:
             *
             * ```javascript
             * this.load.text('story', 'files/IntroStory.txt');
             * // and later in your game ...
             * var data = this.cache.text.get('story');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and
             * this is what you would use to retrieve the text from the Text Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "story"
             * and no URL is given then the Loader will set the URL to be "story.txt". It will always add `.txt` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the Text File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was "alien" then the URL will be "alien.txt".
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            text(key: string | FileTypes.TextFileConfig | FileTypes.TextFileConfig[], url?: string, xhrSettings?: XHRSettingsObject): LoaderPlugin;

            /**
             * Adds a CSV Tilemap file, or array of CSV files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.tilemapCSV('level1', 'maps/Level1.csv');
             * }
             * ```
             *
             * Tilemap CSV data can be created in a text editor, or a 3rd party app that exports as CSV.
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Text Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.tilemapCSV({
             *     key: 'level1',
             *     url: 'maps/Level1.csv'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.TilemapCSVFileConfig` for more details.
             *
             * Once the file has finished loading you can access it from its Cache using its key:
             *
             * ```javascript
             * this.load.tilemapCSV('level1', 'maps/Level1.csv');
             * // and later in your game ...
             * var map = this.make.tilemap({ key: 'level1' });
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and
             * this is what you would use to retrieve the text from the Tilemap Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "level"
             * and no URL is given then the Loader will set the URL to be "level.csv". It will always add `.csv` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the Tilemap CSV File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.csv`, i.e. if `key` was "alien" then the URL will be "alien.csv".
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            tilemapCSV(
                key: string | FileTypes.TilemapCSVFileConfig | FileTypes.TilemapCSVFileConfig[],
                url?: string,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds an Impact.js Tilemap file, or array of map files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.tilemapImpact('level1', 'maps/Level1.json');
             * }
             * ```
             *
             * Impact Tilemap data is created the Impact.js Map Editor called Weltmeister.
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Text Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.tilemapImpact({
             *     key: 'level1',
             *     url: 'maps/Level1.json'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.TilemapImpactFileConfig` for more details.
             *
             * Once the file has finished loading you can access it from its Cache using its key:
             *
             * ```javascript
             * this.load.tilemapImpact('level1', 'maps/Level1.json');
             * // and later in your game ...
             * var map = this.make.tilemap({ key: 'level1' });
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and
             * this is what you would use to retrieve the text from the Tilemap Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "level"
             * and no URL is given then the Loader will set the URL to be "level.json". It will always add `.json` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the Tilemap Impact File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            tilemapImpact(
                key: string | FileTypes.TilemapImpactFileConfig | FileTypes.TilemapImpactFileConfig[],
                url?: string,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a Tiled JSON Tilemap file, or array of map files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.tilemapTiledJSON('level1', 'maps/Level1.json');
             * }
             * ```
             *
             * The Tilemap data is created using the Tiled Map Editor and selecting JSON as the export format.
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Text Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.tilemapTiledJSON({
             *     key: 'level1',
             *     url: 'maps/Level1.json'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.TilemapJSONFileConfig` for more details.
             *
             * Once the file has finished loading you can access it from its Cache using its key:
             *
             * ```javascript
             * this.load.tilemapTiledJSON('level1', 'maps/Level1.json');
             * // and later in your game ...
             * var map = this.make.tilemap({ key: 'level1' });
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and
             * this is what you would use to retrieve the text from the Tilemap Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "level"
             * and no URL is given then the Loader will set the URL to be "level.json". It will always add `.json` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the Tilemap JSON File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was "alien" then the URL will be "alien.json".
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            tilemapTiledJSON(
                key: string | FileTypes.TilemapJSONFileConfig | FileTypes.TilemapJSONFileConfig[],
                url?: string,
                xhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds a Unity YAML based Texture Atlas, or array of atlases, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.txt');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring
             * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.
             *
             * Phaser expects the atlas data to be provided in a YAML formatted text file as exported from Unity.
             *
             * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
             *
             * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the Texture Manager first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.unityAtlas({
             *     key: 'mainmenu',
             *     textureURL: 'images/MainMenu.png',
             *     atlasURL: 'images/MainMenu.txt'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.UnityAtlasFileConfig` for more details.
             *
             * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:
             *
             * ```javascript
             * this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');
             * // and later in your game ...
             * this.add.image(x, y, 'mainmenu', 'background');
             * ```
             *
             * To get a list of all available frames within an atlas please consult your Texture Atlas software.
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and
             * this is what you would use to retrieve the image from the Texture Manager.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
             * and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,
             * then you can specify it by providing an array as the `url` where the second element is the normal map:
             *
             * ```javascript
             * this.load.unityAtlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.txt');
             * ```
             *
             * Or, if you are using a config object use the `normalMap` property:
             *
             * ```javascript
             * this.load.unityAtlas({
             *     key: 'mainmenu',
             *     textureURL: 'images/MainMenu.png',
             *     normalMap: 'images/MainMenu-n.png',
             *     atlasURL: 'images/MainMenu.txt'
             * });
             * ```
             *
             * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.
             * Normal maps are a WebGL only feature.
             *
             * Note: The ability to load this interface of file will only be available if the Unity Atlas File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param textureURL The absolute or relative URL to load the texture image file from.
             * If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was "alien" then the URL will be "alien.png".
             * @param atlasURL The absolute or relative URL to load the texture atlas data file from.
             * If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was "alien" then the URL will be "alien.txt".
             * @param textureXhrSettings An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.
             * @param atlasXhrSettings An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.
             */
            unityAtlas(
                key: string | FileTypes.UnityAtlasFileConfig | FileTypes.UnityAtlasFileConfig[],
                textureURL?: string | string[],
                atlasURL?: string,
                textureXhrSettings?: XHRSettingsObject,
                atlasXhrSettings?: XHRSettingsObject
            ): LoaderPlugin;

            /**
             * Adds an XML file, or array of XML files, to the current load queue.
             *
             * You can call this method from within your Scene's `preload`, along with any other files you wish to load:
             *
             * ```javascript
             * function preload ()
             * {
             *     this.load.xml('wavedata', 'files/AlienWaveData.xml');
             * }
             * ```
             *
             * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,
             * or if it's already running, when the next free load slot becomes available. This happens automatically if you
             * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued
             * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.
             * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the
             * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been
             * loaded.
             *
             * The key must be a unique String. It is used to add the file to the global XML Cache upon a successful load.
             * The key should be unique both in terms of files being loaded and files already present in the XML Cache.
             * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file
             * then remove it from the XML Cache first, before loading a new one.
             *
             * Instead of passing arguments you can pass a configuration object, such as:
             *
             * ```javascript
             * this.load.xml({
             *     key: 'wavedata',
             *     url: 'files/AlienWaveData.xml'
             * });
             * ```
             *
             * See the documentation for `Phaser.Loader.FileTypes.XMLFileConfig` for more details.
             *
             * Once the file has finished loading you can access it from its Cache using its key:
             *
             * ```javascript
             * this.load.xml('wavedata', 'files/AlienWaveData.xml');
             * // and later in your game ...
             * var data = this.cache.xml.get('wavedata');
             * ```
             *
             * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files
             * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and
             * this is what you would use to retrieve the text from the XML Cache.
             *
             * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
             *
             * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "data"
             * and no URL is given then the Loader will set the URL to be "data.xml". It will always add `.xml` as the extension, although
             * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.
             *
             * Note: The ability to load this interface of file will only be available if the XML File interface has been built into Phaser.
             * It is available in the default build but can be excluded from custom builds.
             * @param key The key to use for this file, or a file configuration object, or array of them.
             * @param url The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was "alien" then the URL will be "alien.xml".
             * @param xhrSettings An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.
             */
            xml(key: string | FileTypes.XMLFileConfig | FileTypes.XMLFileConfig[], url?: string, xhrSettings?: XHRSettingsObject): LoaderPlugin;

            /**
             * The Scene which owns this Loader instance.
             */
            scene: Scene;

            /**
             * A reference to the Scene Systems.
             */
            systems: Scenes.Systems;

            /**
             * A reference to the global Cache Manager.
             */
            cacheManager: Cache.CacheManager;

            /**
             * A reference to the global Texture Manager.
             */
            textureManager: Textures.TextureManager;

            /**
             * A reference to the global Scene Manager.
             */
            protected sceneManager: Scenes.SceneManager;

            /**
             * An optional prefix that is automatically prepended to the start of every file key.
             * If prefix was `MENU.` and you load an image with the key 'Background' the resulting key would be `MENU.Background`.
             * You can set this directly, or call `Loader.setPrefix()`. It will then affect every file added to the Loader
             * from that point on. It does _not_ change any file already in the load queue.
             */
            prefix: string;

            /**
             * The value of `path`, if set, is placed before any _relative_ file path given. For example:
             *
             * ```javascript
             * this.load.path = "images/sprites/";
             * this.load.image("ball", "ball.png");
             * this.load.image("tree", "level1/oaktree.png");
             * this.load.image("boom", "http://server.com/explode.png");
             * ```
             *
             * Would load the `ball` file from `images/sprites/ball.png` and the tree from
             * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL
             * given as it's an absolute URL.
             *
             * Please note that the path is added before the filename but *after* the baseURL (if set.)
             *
             * If you set this property directly then it _must_ end with a "/". Alternatively, call `setPath()` and it'll do it for you.
             */
            path: string;

            /**
             * If you want to append a URL before the path of any asset you can set this here.
             *
             * Useful if allowing the asset base url to be configured outside of the game code.
             *
             * If you set this property directly then it _must_ end with a "/". Alternatively, call `setBaseURL()` and it'll do it for you.
             */
            baseURL: string;

            /**
             * The number of concurrent / parallel resources to try and fetch at once.
             *
             * Old browsers limit 6 requests per domain; modern ones, especially those with HTTP/2 don't limit it at all.
             *
             * The default is 32 but you can change this in your Game Config, or by changing this property before the Loader starts.
             */
            maxParallelDownloads: integer;

            /**
             * xhr specific global settings (can be overridden on a per-file basis)
             */
            xhr: XHRSettingsObject;

            /**
             * The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'.
             */
            crossOrigin: string;

            /**
             * The total number of files to load. It may not always be accurate because you may add to the Loader during the process
             * of loading, especially if you load a Pack File. Therefore this value can change, but in most cases remains static.
             */
            totalToLoad: integer;

            /**
             * The progress of the current load queue, as a float value between 0 and 1.
             * This is updated automatically as files complete loading.
             * Note that it is possible for this value to go down again if you add content to the current load queue during a load.
             */
            progress: number;

            /**
             * Files are placed in this Set when they're added to the Loader via `addFile`.
             *
             * They are moved to the `inflight` Set when they start loading, and assuming a successful
             * load, to the `queue` Set for further processing.
             *
             * By the end of the load process this Set will be empty.
             */
            list: Structs.Set<File>;

            /**
             * Files are stored in this Set while they're in the process of being loaded.
             *
             * Upon a successful load they are moved to the `queue` Set.
             *
             * By the end of the load process this Set will be empty.
             */
            inflight: Structs.Set<File>;

            /**
             * Files are stored in this Set while they're being processed.
             *
             * If the process is successful they are moved to their final destination, which could be
             * a Cache or the Texture Manager.
             *
             * At the end of the load process this Set will be empty.
             */
            queue: Structs.Set<File>;

            /**
             * The total number of files that failed to load during the most recent load.
             * This value is reset when you call `Loader.start`.
             */
            totalFailed: integer;

            /**
             * The total number of files that successfully loaded during the most recent load.
             * This value is reset when you call `Loader.start`.
             */
            totalComplete: integer;

            /**
             * The current state of the Loader.
             */
            readonly state: integer;

            /**
             * If you want to append a URL before the path of any asset you can set this here.
             *
             * Useful if allowing the asset base url to be configured outside of the game code.
             *
             * Once a base URL is set it will affect every file loaded by the Loader from that point on. It does _not_ change any
             * file _already_ being loaded. To reset it, call this method with no arguments.
             * @param url The URL to use. Leave empty to reset.
             */
            setBaseURL(url?: string): LoaderPlugin;

            /**
             * The value of `path`, if set, is placed before any _relative_ file path given. For example:
             *
             * ```javascript
             * this.load.setPath("images/sprites/");
             * this.load.image("ball", "ball.png");
             * this.load.image("tree", "level1/oaktree.png");
             * this.load.image("boom", "http://server.com/explode.png");
             * ```
             *
             * Would load the `ball` file from `images/sprites/ball.png` and the tree from
             * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL
             * given as it's an absolute URL.
             *
             * Please note that the path is added before the filename but *after* the baseURL (if set.)
             *
             * Once a path is set it will then affect every file added to the Loader from that point on. It does _not_ change any
             * file _already_ in the load queue. To reset it, call this method with no arguments.
             * @param path The path to use. Leave empty to reset.
             */
            setPath(path?: string): LoaderPlugin;

            /**
             * An optional prefix that is automatically prepended to the start of every file key.
             *
             * If prefix was `MENU.` and you load an image with the key 'Background' the resulting key would be `MENU.Background`.
             *
             * Once a prefix is set it will then affect every file added to the Loader from that point on. It does _not_ change any
             * file _already_ in the load queue. To reset it, call this method with no arguments.
             * @param prefix The prefix to use. Leave empty to reset.
             */
            setPrefix(prefix?: string): LoaderPlugin;

            /**
             * Sets the Cross Origin Resource Sharing value used when loading files.
             *
             * Files can override this value on a per-file basis by specifying an alternative `crossOrigin` value in their file config.
             *
             * Once CORs is set it will then affect every file loaded by the Loader from that point on, as long as they don't have
             * their own CORs setting. To reset it, call this method with no arguments.
             *
             * For more details about CORs see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
             * @param crossOrigin The value to use for the `crossOrigin` property in the load request.
             */
            setCORS(crossOrigin?: string): LoaderPlugin;

            /**
             * Adds a file, or array of files, into the load queue.
             *
             * The file must be an instance of `Phaser.Loader.File`, or a class that extends it. The Loader will check that the key
             * used by the file won't conflict with any other key either in the loader, the inflight queue or the target cache.
             * If allowed it will then add the file into the pending list, read for the load to start. Or, if the load has already
             * started, ready for the next batch of files to be pulled from the list to the inflight queue.
             *
             * You should not normally call this method directly, but rather use one of the Loader methods like `image` or `atlas`,
             * however you can call this as long as the file given to it is well formed.
             * @param file The file, or array of files, to be added to the load queue.
             */
            addFile(file: File | File[]): void;

            /**
             * Checks the key and interface of the given file to see if it will conflict with anything already
             * in a Cache, the Texture Manager, or the list or inflight queues.
             * @param file The file to check the key of.
             */
            keyExists(file: File): boolean;

            /**
             * Takes a well formed, fully parsed pack file object and adds its entries into the load queue. Usually you do not call
             * this method directly, but instead use `Loader.pack` and supply a path to a JSON file that holds the
             * pack data. However, if you've got the data prepared you can pass it to this method.
             *
             * You can also provide an optional key. If you do then it will only add the entries from that part of the pack into
             * to the load queue. If not specified it will add all entries it finds. For more details about the pack file format
             * see the `LoaderPlugin.pack` method.
             * @param data The Pack File data to be parsed and each entry of it to added to the load queue.
             * @param packKey An optional key to use from the pack file data.
             */
            addPack(data: any, packKey?: string): boolean;

            /**
             * Is the Loader actively loading, or processing loaded files?
             */
            isLoading(): boolean;

            /**
             * Is the Loader ready to start a new load?
             */
            isReady(): boolean;

            /**
             * Starts the Loader running. This will reset the progress and totals and then emit a `start` event.
             * If there is nothing in the queue the Loader will immediately complete, otherwise it will start
             * loading the first batch of files.
             *
             * The Loader is started automatically if the queue is populated within your Scenes `preload` method.
             *
             * However, outside of this, you need to call this method to start it.
             *
             * If the Loader is already running this method will simply return.
             */
            start(): void;

            /**
             * Called automatically during the load process.
             * It updates the `progress` value and then emits a progress event, which you can use to
             * display a loading bar in your game.
             */
            updateProgress(): void;

            /**
             * Called automatically during the load process.
             */
            update(): void;

            /**
             * An internal method called automatically by the XHRLoader belong to a File.
             *
             * This method will remove the given file from the inflight Set and update the load progress.
             * If the file was successful its `onProcess` method is called, otherwise it is added to the delete queue.
             * @param file The File that just finished loading, or errored during load.
             * @param success `true` if the file loaded successfully, otherwise `false`.
             */
            nextFile(file: File, success: boolean): void;

            /**
             * An internal method that is called automatically by the File when it has finished processing.
             *
             * If the process was successful, and the File isn't part of a MultiFile, its `addToCache` method is called.
             *
             * It this then removed from the queue. If there are no more files to load `loadComplete` is called.
             * @param file The file that has finished processing.
             */
            fileProcessComplete(file: File): void;

            /**
             * Called at the end when the load queue is exhausted and all files have either loaded or errored.
             * By this point every loaded file will now be in its associated cache and ready for use.
             *
             * Also clears down the Sets, puts progress to 1 and clears the deletion queue.
             */
            loadComplete(): void;

            /**
             * Adds a File into the pending-deletion queue.
             * @param file The File to be queued for deletion when the Loader completes.
             */
            flagForRemoval(file: File): void;

            /**
             * Converts the given JSON data into a file that the browser then prompts you to download so you can save it locally.
             *
             * The data must be well formed JSON and ready-parsed, not a JavaScript object.
             * @param data The JSON data, ready parsed.
             * @param filename The name to save the JSON file as. Default file.json.
             */
            saveJSON(data: any, filename?: string): LoaderPlugin;

            /**
             * Causes the browser to save the given data as a file to its default Downloads folder.
             *
             * Creates a DOM level anchor link, assigns it as being a `download` anchor, sets the href
             * to be an ObjectURL based on the given data, and then invokes a click event.
             * @param data The data to be saved. Will be passed through URL.createObjectURL.
             * @param filename The filename to save the file as. Default file.json.
             * @param fileinterface The file interface to use when saving the file. Defaults to JSON. Default application/json.
             */
            save(data: any, filename?: string, fileinterface?: string): LoaderPlugin;

            /**
             * Resets the Loader.
             *
             * This will clear all lists and reset the base URL, path and prefix.
             *
             * Warning: If the Loader is currently downloading files, or has files in its queue, they will be aborted.
             */
            reset(): void;
        }

        /**
         * Takes two XHRSettings Objects and creates a new XHRSettings object from them.
         *
         * The new object is seeded by the values given in the global settings, but any setting in
         * the local object overrides the global ones.
         * @param global The global XHRSettings object.
         * @param local The local XHRSettings object.
         */
        function MergeXHRSettings(global: XHRSettingsObject, local: XHRSettingsObject): XHRSettingsObject;

        /**
         * A MultiFile is a special kind of parent that contains two, or more, Files as children and looks after
         * the loading and processing of them all. It is commonly extended and used as a base class for file types such as AtlasJSON or BitmapFont.
         *
         * You shouldn't create an instance of a MultiFile directly, but should extend it with your own class, setting a custom interface and processing methods.
         */
        class MultiFile {
            /**
             *
             * @param loader The Loader that is going to load this File.
             * @param interface The file interface string for sorting within the Loader.
             * @param key The key of the file within the loader.
             * @param files An array of Files that make-up this MultiFile.
             */
            constructor(loader: LoaderPlugin, interface: string, key: string, files: File[]);

            /**
             * A reference to the Loader that is going to load this file.
             */
            loader: LoaderPlugin;

            /**
             * The file interface string for sorting within the Loader.
             */
            interface: string;

            /**
             * Unique cache key (unique within its file interface)
             */
            key: string;

            /**
             * Array of files that make up this MultiFile.
             */
            files: File[];

            /**
             * The completion status of this MultiFile.
             */
            complete: boolean;

            /**
             * The number of files to load.
             */
            pending: integer;

            /**
             * The number of files that failed to load.
             */
            failed: integer;

            /**
             * A storage container for transient data that the loading files need.
             */
            config: any;

            /**
             * Checks if this MultiFile is ready to process its children or not.
             */
            isReadyToProcess(): boolean;

            /**
             * Adds another child to this MultiFile, increases the pending count and resets the completion status.
             * @param files The File to add to this MultiFile.
             */
            addToMultiFile(files: File): MultiFile;

            /**
             * Called by each File when it finishes loading.
             * @param file The File that has completed processing.
             */
            onFileComplete(file: File): void;

            /**
             * Called by each File that fails to load.
             * @param file The File that has failed to load.
             */
            onFileFailed(file: File): void;
        }

        /**
         * Creates a new XMLHttpRequest (xhr) object based on the given File and XHRSettings
         * and starts the download of it. It uses the Files own XHRSettings and merges them
         * with the global XHRSettings object to set the xhr values before download.
         * @param file The File to download.
         * @param globalXHRSettings The global XHRSettings object.
         */
        function XHRLoader(file: File, globalXHRSettings: XHRSettingsObject): XMLHttpRequest;

        /**
         * Creates an XHRSettings Object with default values.
         * @param responseinterface The responseinterface, such as 'text'. Default ''.
         * @param async Should the XHR request use async or not? Default true.
         * @param user Optional username for the XHR request. Default ''.
         * @param password Optional password for the XHR request. Default ''.
         * @param timeout Optional XHR timeout value. Default 0.
         */
        function XHRSettings(responseinterface?: XMLHttpRequestResponseType, async?: boolean, user?: string, password?: string, timeout?: integer): XHRSettingsObject;
    }

    namespace Math {
        namespace Angle {
            /**
             * Find the angle of a segment from (x1, y1) -> (x2, y2).
             * @param x1 The x coordinate of the first point.
             * @param y1 The y coordinate of the first point.
             * @param x2 The x coordinate of the second point.
             * @param y2 The y coordinate of the second point.
             */
            function Between(x1: number, y1: number, x2: number, y2: number): number;

            /**
             * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).
             *
             * Calculates the angle of the vector from the first point to the second point.
             * @param point1 The first point.
             * @param point2 The second point.
             */
            function BetweenPoints(point1: Geom.Point | object, point2: Geom.Point | object): number;

            /**
             * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).
             *
             * The difference between this method and {@link Phaser.Math.Angle.BetweenPoints} is that this assumes the y coordinate
             * travels down the screen.
             * @param point1 The first point.
             * @param point2 The second point.
             */
            function BetweenPointsY(point1: Geom.Point | object, point2: Geom.Point | object): number;

            /**
             * Find the angle of a segment from (x1, y1) -> (x2, y2).
             *
             * The difference between this method and {@link Phaser.Math.Angle.Between} is that this assumes the y coordinate
             * travels down the screen.
             * @param x1 The x coordinate of the first point.
             * @param y1 The y coordinate of the first point.
             * @param x2 The x coordinate of the second point.
             * @param y2 The y coordinate of the second point.
             */
            function BetweenY(x1: number, y1: number, x2: number, y2: number): number;

            /**
             * Takes an angle in Phasers default clockwise format and converts it so that
             * 0 is North, 90 is West, 180 is South and 270 is East,
             * therefore running counter-clockwise instead of clockwise.
             *
             * You can pass in the angle from a Game Object using:
             *
             * ```javascript
             * var converted = CounterClockwise(gameobject.rotation);
             * ```
             *
             * All values for this function are in radians.
             * @param angle The angle to convert, in radians.
             */
            function CounterClockwise(angle: number): number;

            /**
             * Normalize an angle to the [0, 2pi] range.
             * @param angle The angle to normalize, in radians.
             */
            function Normalize(angle: number): number;

            /**
             * Reverse the given angle.
             * @param angle The angle to reverse, in radians.
             */
            function Reverse(angle: number): number;

            /**
             * Rotates `currentAngle` towards `targetAngle`, taking the shortest rotation distance. The `lerp` argument is the amount to rotate by in this call.
             * @param currentAngle The current angle, in radians.
             * @param targetAngle The target angle to rotate to, in radians.
             * @param lerp The lerp value to add to the current angle. Default 0.05.
             */
            function RotateTo(currentAngle: number, targetAngle: number, lerp?: number): number;

            /**
             * Gets the shortest angle between `angle1` and `angle2`.
             *
             * Both angles must be in the range -180 to 180, which is the same clamped
             * range that `sprite.angle` uses, so you can pass in two sprite angles to
             * this method and get the shortest angle back between the two of them.
             *
             * The angle returned will be in the same range. If the returned angle is
             * greater than 0 then it's a counter-clockwise rotation, if < 0 then it's
             * a clockwise rotation.
             *
             * TODO: Wrap the angles in this function?
             * @param angle1 The first angle in the range -180 to 180.
             * @param angle2 The second angle in the range -180 to 180.
             */
            function ShortestBetween(angle1: number, angle2: number): number;

            /**
             * Wrap an angle.
             *
             * Wraps the angle to a value in the range of -PI to PI.
             * @param angle The angle to wrap, in radians.
             */
            function Wrap(angle: number): number;

            /**
             * Wrap an angle in degrees.
             *
             * Wraps the angle to a value in the range of -180 to 180.
             * @param angle The angle to wrap, in degrees.
             */
            function WrapDegrees(angle: number): number;
        }

        /**
         * Calculate the mean average of the given values.
         * @param values The values to average.
         */
        function Average(values: number[]): number;

        /**
         * [description]
         * @param n [description]
         * @param i [description]
         */
        function Bernstein(n: number, i: number): number;

        /**
         * Compute a random integer between the `min` and `max` values, inclusive.
         * @param min The minimum value.
         * @param max The maximum value.
         */
        function Between(min: integer, max: integer): integer;

        /**
         * Calculates a Catmull-Rom value.
         * @param t [description]
         * @param p0 [description]
         * @param p1 [description]
         * @param p2 [description]
         * @param p3 [description]
         */
        function CatmullRom(t: number, p0: number, p1: number, p2: number, p3: number): number;

        /**
         * Ceils to some place comparative to a `base`, default is 10 for decimal place.
         *
         * The `place` is represented by the power applied to `base` to get that place.
         * @param value The value to round.
         * @param place The place to round to. Default 0.
         * @param base The base to round in. Default is 10 for decimal. Default 10.
         */
        function CeilTo(value: number, place?: number, base?: integer): number;

        /**
         * Force a value within the boundaries by clamping it to the range `min`, `max`.
         * @param value The value to be clamped.
         * @param min The minimum bounds.
         * @param max The maximum bounds.
         */
        function Clamp(value: number, min: number, max: number): number;

        /**
         * The value of PI * 2.
         */
        const PI2: number;

        /**
         * The value of PI * 0.5.
         */
        const TAU: number;

        /**
         * An epsilon value (1.0e-6)
         */
        const EPSILON: number;

        /**
         * For converting degrees to radians (PI / 180)
         */
        const DEG_TO_RAD: number;

        /**
         * For converting radians to degrees (180 / PI)
         */
        const RAD_TO_DEG: number;

        /**
         * An instance of the Random Number Generator.
         * This is not set until the Game boots.
         */
        const RND: RandomDataGenerator;

        /**
         * Convert the given angle from degrees, to the equivalent angle in radians.
         * @param degrees The angle (in degrees) to convert to radians.
         */
        function DegToRad(degrees: integer): number;

        /**
         * Calculates the positive difference of two given numbers.
         * @param a The first number in the calculation.
         * @param b The second number in the calculation.
         */
        function Difference(a: number, b: number): number;

        namespace Distance {
            /**
             * Calculate the distance between two sets of coordinates (points).
             * @param x1 The x coordinate of the first point.
             * @param y1 The y coordinate of the first point.
             * @param x2 The x coordinate of the second point.
             * @param y2 The y coordinate of the second point.
             */
            function Between(x1: number, y1: number, x2: number, y2: number): number;

            /**
             * Calculate the distance between two sets of coordinates (points) to the power of `pow`.
             * @param x1 The x coordinate of the first point.
             * @param y1 The y coordinate of the first point.
             * @param x2 The x coordinate of the second point.
             * @param y2 The y coordinate of the second point.
             * @param pow The exponent.
             */
            function Power(x1: number, y1: number, x2: number, y2: number, pow: number): number;

            /**
             * Calculate the distance between two sets of coordinates (points), squared.
             * @param x1 The x coordinate of the first point.
             * @param y1 The y coordinate of the first point.
             * @param x2 The x coordinate of the second point.
             * @param y2 The y coordinate of the second point.
             */
            function Squared(x1: number, y1: number, x2: number, y2: number): number;
        }

        namespace Easing {
            namespace Back {
                /**
                 * Back ease-in.
                 * @param v The value to be tweened.
                 * @param overshoot The overshoot amount. Default 1.70158.
                 */
                function In(v: number, overshoot?: number): number;

                /**
                 * Back ease-in/out.
                 * @param v The value to be tweened.
                 * @param overshoot The overshoot amount. Default 1.70158.
                 */
                function InOut(v: number, overshoot?: number): number;

                /**
                 * Back ease-out.
                 * @param v The value to be tweened.
                 * @param overshoot The overshoot amount. Default 1.70158.
                 */
                function Out(v: number, overshoot?: number): number;
            }

            namespace Bounce {
                /**
                 * Bounce ease-in.
                 * @param v The value to be tweened.
                 */
                function In(v: number): number;

                /**
                 * Bounce ease-in/out.
                 * @param v The value to be tweened.
                 */
                function InOut(v: number): number;

                /**
                 * Bounce ease-out.
                 * @param v The value to be tweened.
                 */
                function Out(v: number): number;
            }

            namespace Circular {
                /**
                 * Circular ease-in.
                 * @param v The value to be tweened.
                 */
                function In(v: number): number;

                /**
                 * Circular ease-in/out.
                 * @param v The value to be tweened.
                 */
                function InOut(v: number): number;

                /**
                 * Circular ease-out.
                 * @param v The value to be tweened.
                 */
                function Out(v: number): number;
            }

            namespace Cubic {
                /**
                 * Cubic ease-in.
                 * @param v The value to be tweened.
                 */
                function In(v: number): number;

                /**
                 * Cubic ease-in/out.
                 * @param v The value to be tweened.
                 */
                function InOut(v: number): number;

                /**
                 * Cubic ease-out.
                 * @param v The value to be tweened.
                 */
                function Out(v: number): number;
            }

            namespace Elastic {
                /**
                 * Elastic ease-in.
                 * @param v The value to be tweened.
                 * @param amplitude The amplitude of the elastic ease. Default 0.1.
                 * @param period Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles. Default 0.1.
                 */
                function In(v: number, amplitude?: number, period?: number): number;

                /**
                 * Elastic ease-in/out.
                 * @param v The value to be tweened.
                 * @param amplitude The amplitude of the elastic ease. Default 0.1.
                 * @param period Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles. Default 0.1.
                 */
                function InOut(v: number, amplitude?: number, period?: number): number;

                /**
                 * Elastic ease-out.
                 * @param v The value to be tweened.
                 * @param amplitude The amplitude of the elastic ease. Default 0.1.
                 * @param period Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles. Default 0.1.
                 */
                function Out(v: number, amplitude?: number, period?: number): number;
            }

            namespace Expo {
                /**
                 * Exponential ease-in.
                 * @param v The value to be tweened.
                 */
                function In(v: number): number;

                /**
                 * Exponential ease-in/out.
                 * @param v The value to be tweened.
                 */
                function InOut(v: number): number;

                /**
                 * Exponential ease-out.
                 * @param v The value to be tweened.
                 */
                function Out(v: number): number;
            }

            namespace Linear {
                /**
                 * Linear easing (no variation).
                 * @param v The value to be tweened.
                 */
                function Linear(v: number): number;
            }

            namespace Quadratic {
                /**
                 * Quadratic ease-in.
                 * @param v The value to be tweened.
                 */
                function In(v: number): number;

                /**
                 * Quadratic ease-in/out.
                 * @param v The value to be tweened.
                 */
                function InOut(v: number): number;

                /**
                 * Quadratic ease-out.
                 * @param v The value to be tweened.
                 */
                function Out(v: number): number;
            }

            namespace Quartic {
                /**
                 * Quartic ease-in.
                 * @param v The value to be tweened.
                 */
                function In(v: number): number;

                /**
                 * Quartic ease-in/out.
                 * @param v The value to be tweened.
                 */
                function InOut(v: number): number;

                /**
                 * Quartic ease-out.
                 * @param v The value to be tweened.
                 */
                function Out(v: number): number;
            }

            namespace Quintic {
                /**
                 * Quintic ease-in.
                 * @param v The value to be tweened.
                 */
                function In(v: number): number;

                /**
                 * Quintic ease-in/out.
                 * @param v The value to be tweened.
                 */
                function InOut(v: number): number;

                /**
                 * Quintic ease-out.
                 * @param v The value to be tweened.
                 */
                function Out(v: number): number;
            }

            namespace Sine {
                /**
                 * Sinusoidal ease-in.
                 * @param v The value to be tweened.
                 */
                function In(v: number): number;

                /**
                 * Sinusoidal ease-in/out.
                 * @param v The value to be tweened.
                 */
                function InOut(v: number): number;

                /**
                 * Sinusoidal ease-out.
                 * @param v The value to be tweened.
                 */
                function Out(v: number): number;
            }

            namespace Stepped {
                /**
                 * Stepped easing.
                 * @param v The value to be tweened.
                 * @param steps The number of steps in the ease. Default 1.
                 */
                function Stepped(v: number, steps?: number): number;
            }
        }

        /**
         * Calculates the factorial of a given number for integer values greater than 0.
         * @param value A positive integer to calculate the factorial of.
         */
        function Factorial(value: number): number;

        /**
         * Generate a random floating point number between the two given bounds, minimum inclusive, maximum exclusive.
         * @param min The lower bound for the float, inclusive.
         * @param max The upper bound for the float exclusive.
         */
        function FloatBetween(min: number, max: number): number;

        /**
         * Floors to some place comparative to a `base`, default is 10 for decimal place.
         *
         * The `place` is represented by the power applied to `base` to get that place.
         * @param value The value to round.
         * @param place The place to round to. Default 0.
         * @param base The base to round in. Default is 10 for decimal. Default 10.
         */
        function FloorTo(value: number, place?: integer, base?: integer): number;

        /**
         * Return a value based on the range between `min` and `max` and the percentage given.
         * @param percent A value between 0 and 1 representing the percentage.
         * @param min The minimum value.
         * @param max The maximum value.
         */
        function FromPercent(percent: number, min: number, max?: number): number;

        namespace Fuzzy {
            /**
             * Calculate the fuzzy ceiling of the given value.
             * @param value The value.
             * @param epsilon The epsilon. Default 0.0001.
             */
            function Ceil(value: number, epsilon?: number): number;

            /**
             * Check whether the given values are fuzzily equal.
             *
             * Two numbers are fuzzily equal if their difference is less than `epsilon`.
             * @param a The first value.
             * @param b The second value.
             * @param epsilon The epsilon. Default 0.0001.
             */
            function Equal(a: number, b: number, epsilon?: number): boolean;

            /**
             * Calculate the fuzzy floor of the given value.
             * @param value The value.
             * @param epsilon The epsilon. Default 0.0001.
             */
            function Floor(value: number, epsilon?: number): number;

            /**
             * Check whether `a` is fuzzily greater than `b`.
             *
             * `a` is fuzzily greater than `b` if it is more than `b - epsilon`.
             * @param a The first value.
             * @param b The second value.
             * @param epsilon The epsilon. Default 0.0001.
             */
            function GreaterThan(a: number, b: number, epsilon?: number): boolean;

            /**
             * Check whether `a` is fuzzily less than `b`.
             *
             * `a` is fuzzily less than `b` if it is less than `b + epsilon`.
             * @param a The first value.
             * @param b The second value.
             * @param epsilon The epsilon. Default 0.0001.
             */
            function LessThan(a: number, b: number, epsilon?: number): boolean;
        }

        /**
         * Calculate the speed required to cover a distance in the time given.
         * @param distance The distance to travel in pixels.
         * @param time The time, in ms, to cover the distance in.
         */
        function GetSpeed(distance: number, time: integer): number;

        namespace Interpolation {
            /**
             * A bezier interpolation method.
             * @param v The input array of values to interpolate between.
             * @param k The percentage of interpolation, between 0 and 1.
             */
            function Bezier(v: number[], k: number): number;

            /**
             * A Catmull-Rom interpolation method.
             * @param v The input array of values to interpolate between.
             * @param k The percentage of interpolation, between 0 and 1.
             */
            function CatmullRom(v: number[], k: number): number;

            /**
             * A cubic bezier interpolation method.
             * @param t The percentage of interpolation, between 0 and 1.
             * @param p0 The start point.
             * @param p1 The first control point.
             * @param p2 The second control point.
             * @param p3 The end point.
             */
            function CubicBezier(t: number, p0: number, p1: number, p2: number, p3: number): number;

            /**
             * A linear interpolation method.
             * @param v The input array of values to interpolate between.
             * @param k The percentage of interpolation, between 0 and 1.
             */
            function Linear(v: number[], k: number): number;

            /**
             * A quadratic bezier interpolation method.
             * @param t The percentage of interpolation, between 0 and 1.
             * @param p0 The start point.
             * @param p1 The control point.
             * @param p2 The end point.
             */
            function QuadraticBezier(t: number, p0: number, p1: number, p2: number): number;

            /**
             * A Smoother Step interpolation method.
             * @param t The percentage of interpolation, between 0 and 1.
             * @param min The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.
             * @param max The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.
             */
            function SmootherStep(t: number, min: number, max: number): number;

            /**
             * A Smooth Step interpolation method.
             * @param t The percentage of interpolation, between 0 and 1.
             * @param min The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.
             * @param max The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.
             */
            function SmoothStep(t: number, min: number, max: number): number;
        }

        /**
         * Check if a given value is an even number.
         * @param value The number to perform the check with.
         */
        function IsEven(value: number): boolean;

        /**
         * Check if a given value is an even number using a strict interface check.
         * @param value The number to perform the check with.
         */
        function IsEvenStrict(value: number): boolean;

        /**
         * Calculates a linear (interpolation) value over t.
         * @param p0 The first point.
         * @param p1 The second point.
         * @param t The percentage between p0 and p1 to return, represented as a number between 0 and 1.
         */
        function Linear(p0: number, p1: number, t: number): number;

        /**
         * A three-dimensional matrix.
         *
         * Defaults to the identity matrix when instantiated.
         */
        class Matrix3 {
            /**
             *
             * @param m Optional Matrix3 to copy values from.
             */
            constructor(m?: Matrix3);

            /**
             * The matrix values.
             */
            val: Float32Array;

            /**
             * Make a clone of this Matrix3.
             */
            clone(): Matrix3;

            /**
             * This method is an alias for `Matrix3.copy`.
             * @param src The Matrix to set the values of this Matrix's from.
             */
            set(src: Matrix3): Matrix3;

            /**
             * Copy the values of a given Matrix into this Matrix.
             * @param src The Matrix to copy the values from.
             */
            copy(src: Matrix3): Matrix3;

            /**
             * Copy the values of a given Matrix4 into this Matrix3.
             * @param m The Matrix4 to copy the values from.
             */
            fromMat4(m: Matrix4): Matrix3;

            /**
             * Set the values of this Matrix from the given array.
             * @param a The array to copy the values from.
             */
            fromArray(a: any[]): Matrix3;

            /**
             * Reset this Matrix to an identity (default) matrix.
             */
            identity(): Matrix3;

            /**
             * Transpose this Matrix.
             */
            transpose(): Matrix3;

            /**
             * Invert this Matrix.
             */
            invert(): Matrix3;

            /**
             * Calculate the adjoint, or adjugate, of this Matrix.
             */
            adjoint(): Matrix3;

            /**
             * Calculate the determinant of this Matrix.
             */
            determinant(): number;

            /**
             * Multiply this Matrix by the given Matrix.
             * @param src The Matrix to multiply this Matrix by.
             */
            multiply(src: Matrix3): Matrix3;

            /**
             * Translate this Matrix using the given Vector.
             * @param v The Vector to translate this Matrix with.
             */
            translate(v: Vector2 | Vector3 | Vector4): Matrix3;

            /**
             * Apply a rotation transformation to this Matrix.
             * @param rad The angle in radians to rotate by.
             */
            rotate(rad: number): Matrix3;

            /**
             * Apply a scale transformation to this Matrix.
             *
             * Uses the `x` and `y` components of the given Vector to scale the Matrix.
             * @param v The Vector to scale this Matrix with.
             */
            scale(v: Vector2 | Vector3 | Vector4): Matrix3;

            /**
             * Set the values of this Matrix from the given Quaternion.
             * @param q The Quaternion to set the values of this Matrix from.
             */
            fromQuat(q: Quaternion): Matrix3;

            /**
             * [description]
             * @param m [description]
             */
            normalFromMat4(m: Matrix4): Matrix3;
        }

        /**
         * A four-dimensional matrix.
         */
        class Matrix4 {
            /**
             *
             * @param m Optional Matrix4 to copy values from.
             */
            constructor(m?: Matrix4);

            /**
             * The matrix values.
             */
            val: Float32Array;

            /**
             * Make a clone of this Matrix4.
             */
            clone(): Matrix4;

            /**
             * This method is an alias for `Matrix4.copy`.
             * @param src The Matrix to set the values of this Matrix's from.
             */
            set(src: Matrix4): Matrix4;

            /**
             * Copy the values of a given Matrix into this Matrix.
             * @param src The Matrix to copy the values from.
             */
            copy(src: Matrix4): Matrix4;

            /**
             * Set the values of this Matrix from the given array.
             * @param a The array to copy the values from.
             */
            fromArray(a: any[]): Matrix4;

            /**
             * Reset this Matrix.
             *
             * Sets all values to `0`.
             */
            zero(): Matrix4;

            /**
             * Set the `x`, `y` and `z` values of this Matrix.
             * @param x The x value.
             * @param y The y value.
             * @param z The z value.
             */
            xyz(x: number, y: number, z: number): Matrix4;

            /**
             * Set the scaling values of this Matrix.
             * @param x The x scaling value.
             * @param y The y scaling value.
             * @param z The z scaling value.
             */
            scaling(x: number, y: number, z: number): Matrix4;

            /**
             * Reset this Matrix to an identity (default) matrix.
             */
            identity(): Matrix4;

            /**
             * Transpose this Matrix.
             */
            transpose(): Matrix4;

            /**
             * Invert this Matrix.
             */
            invert(): Matrix4;

            /**
             * Calculate the adjoint, or adjugate, of this Matrix.
             */
            adjoint(): Matrix4;

            /**
             * Calculate the determinant of this Matrix.
             */
            determinant(): number;

            /**
             * Multiply this Matrix by the given Matrix.
             * @param src The Matrix to multiply this Matrix by.
             */
            multiply(src: Matrix4): Matrix4;

            /**
             * [description]
             * @param src [description]
             */
            multiplyLocal(src: Matrix4): Matrix4;

            /**
             * Translate this Matrix using the given Vector.
             * @param v The Vector to translate this Matrix with.
             */
            translate(v: Vector3 | Vector4): Matrix4;

            /**
             * Translate this Matrix using the given values.
             * @param x The x component.
             * @param y The y component.
             * @param z The z component.
             */
            translateXYZ(x: number, y: number, z: number): Matrix4;

            /**
             * Apply a scale transformation to this Matrix.
             *
             * Uses the `x`, `y` and `z` components of the given Vector to scale the Matrix.
             * @param v The Vector to scale this Matrix with.
             */
            scale(v: Vector3 | Vector4): Matrix4;

            /**
             * Apply a scale transformation to this Matrix.
             * @param x The x component.
             * @param y The y component.
             * @param z The z component.
             */
            scaleXYZ(x: number, y: number, z: number): Matrix4;

            /**
             * Derive a rotation matrix around the given axis.
             * @param axis The rotation axis.
             * @param angle The rotation angle in radians.
             */
            makeRotationAxis(axis: Vector3 | Vector4, angle: number): Matrix4;

            /**
             * Apply a rotation transformation to this Matrix.
             * @param rad The angle in radians to rotate by.
             * @param axis The axis to rotate upon.
             */
            rotate(rad: number, axis: Vector3): Matrix4;

            /**
             * Rotate this matrix on its X axis.
             * @param rad The angle in radians to rotate by.
             */
            rotateX(rad: number): Matrix4;

            /**
             * Rotate this matrix on its Y axis.
             * @param rad The angle to rotate by, in radians.
             */
            rotateY(rad: number): Matrix4;

            /**
             * Rotate this matrix on its Z axis.
             * @param rad The angle to rotate by, in radians.
             */
            rotateZ(rad: number): Matrix4;

            /**
             * Set the values of this Matrix from the given rotation Quaternion and translation Vector.
             * @param q The Quaternion to set rotation from.
             * @param v The Vector to set translation from.
             */
            fromRotationTranslation(q: Quaternion, v: Vector3): Matrix4;

            /**
             * Set the values of this Matrix from the given Quaternion.
             * @param q The Quaternion to set the values of this Matrix from.
             */
            fromQuat(q: Quaternion): Matrix4;

            /**
             * Generate a frustum matrix with the given bounds.
             * @param left The left bound of the frustum.
             * @param right The right bound of the frustum.
             * @param bottom The bottom bound of the frustum.
             * @param top The top bound of the frustum.
             * @param near The near bound of the frustum.
             * @param far The far bound of the frustum.
             */
            frustum(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;

            /**
             * Generate a perspective projection matrix with the given bounds.
             * @param fovy Vertical field of view in radians
             * @param aspect Aspect ratio. Typically viewport width  /height.
             * @param near Near bound of the frustum.
             * @param far Far bound of the frustum.
             */
            perspective(fovy: number, aspect: number, near: number, far: number): Matrix4;

            /**
             * Generate a perspective projection matrix with the given bounds.
             * @param width The width of the frustum.
             * @param height The height of the frustum.
             * @param near Near bound of the frustum.
             * @param far Far bound of the frustum.
             */
            perspectiveLH(width: number, height: number, near: number, far: number): Matrix4;

            /**
             * Generate an orthogonal projection matrix with the given bounds.
             * @param left The left bound of the frustum.
             * @param right The right bound of the frustum.
             * @param bottom The bottom bound of the frustum.
             * @param top The top bound of the frustum.
             * @param near The near bound of the frustum.
             * @param far The far bound of the frustum.
             */
            ortho(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;

            /**
             * Generate a look-at matrix with the given eye position, focal point, and up axis.
             * @param eye Position of the viewer
             * @param center Point the viewer is looking at
             * @param up vec3 pointing up.
             */
            lookAt(eye: Vector3, center: Vector3, up: Vector3): Matrix4;

            /**
             * Set the values of this matrix from the given `yaw`, `pitch` and `roll` values.
             * @param yaw [description]
             * @param pitch [description]
             * @param roll [description]
             */
            yawPitchRoll(yaw: number, pitch: number, roll: number): Matrix4;

            /**
             * Generate a world matrix from the given rotation, position, scale, view matrix and projection matrix.
             * @param rotation The rotation of the world matrix.
             * @param position The position of the world matrix.
             * @param scale The scale of the world matrix.
             * @param viewMatrix The view matrix.
             * @param projectionMatrix The projection matrix.
             */
            setWorldMatrix(
                rotation: Vector3,
                position: Vector3,
                scale: Vector3,
                viewMatrix?: Matrix4,
                projectionMatrix?: Matrix4
            ): Matrix4;
        }

        /**
         * Add an `amount` to a `value`, limiting the maximum result to `max`.
         * @param value The value to add to.
         * @param amount The amount to add.
         * @param max The maximum value to return.
         */
        function MaxAdd(value: number, amount: number, max: number): number;

        /**
         * Subtract an `amount` from `value`, limiting the minimum result to `min`.
         * @param value The value to subtract from.
         * @param amount The amount to subtract.
         * @param min The minimum value to return.
         */
        function MinSub(value: number, amount: number, min: number): number;

        /**
         * Work out what percentage `value` is of the range between `min` and `max`.
         * If `max` isn't given then it will return the percentage of `value` to `min`.
         *
         * You can optionally specify an `upperMax` value, which is a mid-way point in the range that represents 100%, after which the % starts to go down to zero again.
         * @param value The value to determine the percentage of.
         * @param min The minimum value.
         * @param max The maximum value.
         * @param upperMax The mid-way point in the range that represents 100%.
         */
        function Percent(value: number, min: number, max?: number, upperMax?: number): number;

        namespace Pow2 {
            /**
             * Returns the nearest power of 2 to the given `value`.
             * @param value The value.
             */
            function GetPowerOfTwo(value: number): integer;

            /**
             * Checks if the given `width` and `height` are a power of two.
             * Useful for checking texture dimensions.
             * @param width The width.
             * @param height The height.
             */
            function IsSizePowerOfTwo(width: number, height: number): boolean;

            /**
             * Tests the value and returns `true` if it is a power of two.
             * @param value The value to check if it's a power of two.
             */
            function IsValuePowerOfTwo(value: number): boolean;
        }

        /**
         * A quaternion.
         */
        class Quaternion {
            /**
             *
             * @param x The x component.
             * @param y The y component.
             * @param z The z component.
             * @param w The w component.
             */
            constructor(x?: number, y?: number, z?: number, w?: number);

            /**
             * The x component of this Quaternion.
             */
            x: number;

            /**
             * The y component of this Quaternion.
             */
            y: number;

            /**
             * The z component of this Quaternion.
             */
            z: number;

            /**
             * The w component of this Quaternion.
             */
            w: number;

            /**
             * Copy the components of a given Quaternion or Vector into this Quaternion.
             * @param src The Quaternion or Vector to copy the components from.
             */
            copy(src: Quaternion | Vector4): Quaternion;

            /**
             * Set the components of this Quaternion.
             * @param x The x component, or an object containing x, y, z, and w components. Default 0.
             * @param y The y component. Default 0.
             * @param z The z component. Default 0.
             * @param w The w component. Default 0.
             */
            set(x?: number | object, y?: number, z?: number, w?: number): Quaternion;

            /**
             * Add a given Quaternion or Vector to this Quaternion. Addition is component-wise.
             * @param v The Quaternion or Vector to add to this Quaternion.
             */
            add(v: Quaternion | Vector4): Quaternion;

            /**
             * Subtract a given Quaternion or Vector from this Quaternion. Subtraction is component-wise.
             * @param v The Quaternion or Vector to subtract from this Quaternion.
             */
            subtract(v: Quaternion | Vector4): Quaternion;

            /**
             * Scale this Quaternion by the given value.
             * @param scale The value to scale this Quaternion by.
             */
            scale(scale: number): Quaternion;

            /**
             * Calculate the length of this Quaternion.
             */
            length(): number;

            /**
             * Calculate the length of this Quaternion squared.
             */
            lengthSq(): number;

            /**
             * Normalize this Quaternion.
             */
            normalize(): Quaternion;

            /**
             * Calculate the dot product of this Quaternion and the given Quaternion or Vector.
             * @param v The Quaternion or Vector to dot product with this Quaternion.
             */
            dot(v: Quaternion | Vector4): number;

            /**
             * Linearly interpolate this Quaternion towards the given Quaternion or Vector.
             * @param v The Quaternion or Vector to interpolate towards.
             * @param t The percentage of interpolation. Default 0.
             */
            lerp(v: Quaternion | Vector4, t?: number): Quaternion;

            /**
             * [description]
             * @param a [description]
             * @param b [description]
             */
            rotationTo(a: Vector3, b: Vector3): Quaternion;

            /**
             * Set the axes of this Quaternion.
             * @param view The view axis.
             * @param right The right axis.
             * @param up The upwards axis.
             */
            setAxes(view: Vector3, right: Vector3, up: Vector3): Quaternion;

            /**
             * Reset this Matrix to an identity (default) Quaternion.
             */
            identity(): Quaternion;

            /**
             * Set the axis angle of this Quaternion.
             * @param axis The axis.
             * @param rad The angle in radians.
             */
            setAxisAngle(axis: Vector3, rad: number): Quaternion;

            /**
             * Multiply this Quaternion by the given Quaternion or Vector.
             * @param b The Quaternion or Vector to multiply this Quaternion by.
             */
            multiply(b: Quaternion | Vector4): Quaternion;

            /**
             * Smoothly linearly interpolate this Quaternion towards the given Quaternion or Vector.
             * @param b The Quaternion or Vector to interpolate towards.
             * @param t The percentage of interpolation.
             */
            slerp(b: Quaternion | Vector4, t: number): Quaternion;

            /**
             * Invert this Quaternion.
             */
            invert(): Quaternion;

            /**
             * Convert this Quaternion into its conjugate.
             *
             * Sets the x, y and z components.
             */
            conjugate(): Quaternion;

            /**
             * Rotate this Quaternion on the X axis.
             * @param rad The rotation angle in radians.
             */
            rotateX(rad: number): Quaternion;

            /**
             * Rotate this Quaternion on the Y axis.
             * @param rad The rotation angle in radians.
             */
            rotateY(rad: number): Quaternion;

            /**
             * Rotate this Quaternion on the Z axis.
             * @param rad The rotation angle in radians.
             */
            rotateZ(rad: number): Quaternion;

            /**
             * Create a unit (or rotation) Quaternion from its x, y, and z components.
             *
             * Sets the w component.
             */
            calculateW(): Quaternion;

            /**
             * Convert the given Matrix into this Quaternion.
             * @param mat The Matrix to convert from.
             */
            fromMat3(mat: Matrix3): Quaternion;
        }

        /**
         * Convert the given angle in radians, to the equivalent angle in degrees.
         * @param radians The angle in radians to convert ot degrees.
         */
        function RadToDeg(radians: number): integer;

        /**
         * A seeded Random Data Generator.
         *
         * Access via `Phaser.Math.RND` which is an instance of this class pre-defined
         * by Phaser. Or, create your own instance to use as you require.
         *
         * The `Math.RND` generator is seeded by the Game Config property value `seed`.
         * If no such config property exists, a random number is used.
         *
         * If you create your own instance of this class you should provide a seed for it.
         * If no seed is given it will use a 'random' one based on Date.now.
         */
        class RandomDataGenerator {
            /**
             *
             * @param seeds The seeds to use for the random number generator.
             */
            constructor(seeds?: string | string[]);

            /**
             * Signs to choose from.
             */
            signs: number[];

            /**
             * Initialize the state of the random data generator.
             * @param seeds The seeds to initialize the random data generator with.
             */
            init(seeds: string | string[]): void;

            /**
             * Reset the seed of the random data generator.
             *
             * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
             * @param seeds The array of seeds: the `toString()` of each value is used.
             */
            sow(seeds: string[]): void;

            /**
             * Returns a random integer between 0 and 2^32.
             */
            integer(): number;

            /**
             * Returns a random real number between 0 and 1.
             */
            frac(): number;

            /**
             * Returns a random real number between 0 and 2^32.
             */
            real(): number;

            /**
             * Returns a random integer between and including min and max.
             * @param min The minimum value in the range.
             * @param max The maximum value in the range.
             */
            integerInRange(min: number, max: number): number;

            /**
             * Returns a random integer between and including min and max.
             * This method is an alias for RandomDataGenerator.integerInRange.
             * @param min The minimum value in the range.
             * @param max The maximum value in the range.
             */
            between(min: number, max: number): number;

            /**
             * Returns a random real number between min and max.
             * @param min The minimum value in the range.
             * @param max The maximum value in the range.
             */
            realInRange(min: number, max: number): number;

            /**
             * Returns a random real number between -1 and 1.
             */
            normal(): number;

            /**
             * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
             */
            uuid(): string;

            /**
             * Returns a random element from within the given array.
             * @param array The array to pick a random element from.
             */
            pick(array: any[]): any;

            /**
             * Returns a sign to be used with multiplication operator.
             */
            sign(): number;

            /**
             * Returns a random element from within the given array, favoring the earlier entries.
             * @param array The array to pick a random element from.
             */
            weightedPick(array: any[]): any;

            /**
             * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
             * @param min The minimum value in the range.
             * @param max The maximum value in the range.
             */
            timestamp(min: number, max: number): number;

            /**
             * Returns a random angle between -180 and 180.
             */
            angle(): number;

            /**
             * Returns a random rotation in radians, between -3.141 and 3.141
             */
            rotation(): number;

            /**
             * Gets or Sets the state of the generator. This allows you to retain the values
             * that the generator is using between games, i.e. in a game save file.
             *
             * To seed this generator with a previously saved state you can pass it as the
             * `seed` value in your game config, or call this method directly after Phaser has booted.
             *
             * Call this method with no parameters to return the current state.
             *
             * If providing a state it should match the same format that this method
             * returns, which is a string with a header `!rnd` followed by the `c`,
             * `s0`, `s1` and `s2` values respectively, each comma-delimited.
             * @param state Generator state to be set.
             */
            state(state?: string): string;

            /**
             * Shuffles the given array, using the current seed.
             * @param array The array to be shuffled.
             */
            shuffle(array?: any[]): any[];
        }

        /**
         * Compute a random unit vector.
         *
         * Computes random values for the given vector between -1 and 1 that can be used to represent a direction.
         *
         * Optionally accepts a scale value to scale the resulting vector by.
         * @param vector The Vector to compute random values for.
         * @param scale The scale of the random values. Default 1.
         */
        function RandomXY(vector: Vector2, scale?: number): Vector2;

        /**
         * Compute a random position vector in a spherical area, optionally defined by the given radius.
         * @param vec3 The Vector to compute random values for.
         * @param radius The radius. Default 1.
         */
        function RandomXYZ(vec3: Vector3, radius?: number): Vector3;

        /**
         * Compute a random four-dimensional vector.
         * @param vec4 The Vector to compute random values for.
         * @param scale The scale of the random values. Default 1.
         */
        function RandomXYZW(vec4: Vector4, scale?: number): Vector4;

        /**
         * Rotate a given point by a given angle around the origin (0, 0), in an anti-clockwise direction.
         * @param point The point to be rotated.
         * @param angle The angle to be rotated by in an anticlockwise direction.
         */
        function Rotate(point: Geom.Point | object, angle: number): Geom.Point;

        /**
         * Rotate a `point` around `x` and `y` by the given `angle`.
         * @param point The point to be rotated.
         * @param x The horizontal coordinate to rotate around.
         * @param y The vertical coordinate to rotate around.
         * @param angle The angle of rotation in radians.
         */
        function RotateAround(point: Geom.Point | object, x: number, y: number, angle: number): Geom.Point;

        /**
         * Rotate a `point` around `x` and `y` by the given `angle` and `distance`.
         * @param point The point to be rotated.
         * @param x The horizontal coordinate to rotate around.
         * @param y The vertical coordinate to rotate around.
         * @param angle The angle of rotation in radians.
         * @param distance The distance from (x, y) to place the point at.
         */
        function RotateAroundDistance(point: Geom.Point | object, x: number, y: number, angle: number, distance: number): Geom.Point;

        /**
         * Rotates a vector in place by axis angle.
         *
         * This is the same as transforming a point by an
         * axis-angle quaternion, but it has higher precision.
         * @param vec The vector to be rotated.
         * @param axis The axis to rotate around.
         * @param radians The angle of rotation in radians.
         */
        function RotateVec3(vec: Vector3, axis: Vector3, radians: number): Vector3;

        /**
         * Round a given number so it is further away from zero. That is, positive numbers are rounded up, and negative numbers are rounded down.
         * @param value The number to round.
         */
        function RoundAwayFromZero(value: number): number;

        /**
         * Round a value to a given decimal place.
         * @param value The value to round.
         * @param place The place to round to. Default 0.
         * @param base The base to round in. Default is 10 for decimal. Default 10.
         */
        function RoundTo(value: number, place?: integer, base?: integer): number;

        /**
         * Generate a series of sine and cosine values.
         * @param length The number of values to generate.
         * @param sinAmp The sine value amplitude. Default 1.
         * @param cosAmp The cosine value amplitude. Default 1.
         * @param frequency The frequency of the values. Default 1.
         */
        function SinCosTableGenerator(length: number, sinAmp?: number, cosAmp?: number, frequency?: number): SinCosTable;

        /**
         * Calculate a smoother interpolation percentage of `x` between `min` and `max`.
         *
         * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,
         * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,
         * between 0 and 1 otherwise.
         *
         * Produces an even smoother interpolation than {@link Phaser.Math.SmoothStep}.
         * @param x The input value.
         * @param min The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.
         * @param max The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.
         */
        function SmootherStep(x: number, min: number, max: number): number;

        /**
         * Calculate a smooth interpolation percentage of `x` between `min` and `max`.
         *
         * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,
         * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,
         * between 0 and 1 otherwise.
         * @param x The input value.
         * @param min The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.
         * @param max The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.
         */
        function SmoothStep(x: number, min: number, max: number): number;

        namespace Snap {
            /**
             * Snap a value to nearest grid slice, using ceil.
             *
             * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `15`.
             * As will `14` snap to `15`... but `16` will snap to `20`.
             * @param value The value to snap.
             * @param gap The interval gap of the grid.
             * @param start Optional starting offset for gap. Default 0.
             * @param divide If `true` it will divide the snapped value by the gap before returning. Default false.
             */
            function Ceil(value: number, gap: number, start?: number, divide?: boolean): number;

            /**
             * Snap a value to nearest grid slice, using floor.
             *
             * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10`.
             * As will `14` snap to `10`... but `16` will snap to `15`.
             * @param value The value to snap.
             * @param gap The interval gap of the grid.
             * @param start Optional starting offset for gap. Default 0.
             * @param divide If `true` it will divide the snapped value by the gap before returning. Default false.
             */
            function Floor(value: number, gap: number, start?: number, divide?: boolean): number;

            /**
             * Snap a value to nearest grid slice, using rounding.
             *
             * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10` whereas `14` will snap to `15`.
             * @param value The value to snap.
             * @param gap The interval gap of the grid.
             * @param start Optional starting offset for gap. Default 0.
             * @param divide If `true` it will divide the snapped value by the gap before returning. Default false.
             */
            function To(value: number, gap: number, start?: number, divide?: boolean): number;
        }

        /**
         * Takes the `x` and `y` coordinates and transforms them into the same space as
         * defined by the position, rotation and scale values.
         * @param x The x coordinate to be transformed.
         * @param y The y coordinate to be transformed.
         * @param positionX Horizontal position of the transform point.
         * @param positionY Vertical position of the transform point.
         * @param rotation Rotation of the transform point, in radians.
         * @param scaleX Horizontal scale of the transform point.
         * @param scaleY Vertical scale of the transform point.
         * @param output The output vector, point or object for the translated coordinates.
         */
        function TransformXY(
            x: number,
            y: number,
            positionX: number,
            positionY: number,
            rotation: number,
            scaleX: number,
            scaleY: number,
            output?: Vector2 | Geom.Point | object
        ): Vector2 | Geom.Point | object;

        /**
         * A representation of a vector in 2D space.
         *
         * A two-component vector.
         */
        class Vector2 {
            /**
             *
             * @param x The x component, or an object with `x` and `y` properties.
             * @param y The y component.
             */
            constructor(x?: number | Vector2Like, y?: number);

            /**
             * The x component of this Vector.
             */
            x: number;

            /**
             * The y component of this Vector.
             */
            y: number;

            /**
             * Make a clone of this Vector2.
             */
            clone(): Vector2;

            /**
             * Copy the components of a given Vector into this Vector.
             * @param src The Vector to copy the components from.
             */
            copy(src: Vector2): Vector2;

            /**
             * Set the component values of this Vector from a given Vector2Like object.
             * @param obj The object containing the component values to set for this Vector.
             */
            setFromObject(obj: Vector2Like): Vector2;

            /**
             * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.
             * @param x The x value to set for this Vector.
             * @param y The y value to set for this Vector. Default x.
             */
            set(x: number, y?: number): Vector2;

            /**
             * This method is an alias for `Vector2.set`.
             * @param x The x value to set for this Vector.
             * @param y The y value to set for this Vector. Default x.
             */
            setTo(x: number, y?: number): Vector2;

            /**
             * Sets the `x` and `y` values of this object from a given polar coordinate.
             * @param azimuth The angular coordinate, in radians.
             * @param radius The radial coordinate (length). Default 1.
             */
            setToPolar(azimuth: number, radius?: number): Vector2;

            /**
             * Check whether this Vector is equal to a given Vector.
             *
             * Performs a strict equality check against each Vector's components.
             * @param v The vector to compare with this Vector.
             */
            equals(v: Vector2): boolean;

            /**
             * Calculate the angle between this Vector and the positive x-axis, in radians.
             */
            angle(): number;

            /**
             * Add a given Vector to this Vector. Addition is component-wise.
             * @param src The Vector to add to this Vector.
             */
            add(src: Vector2): Vector2;

            /**
             * Subtract the given Vector from this Vector. Subtraction is component-wise.
             * @param src The Vector to subtract from this Vector.
             */
            subtract(src: Vector2): Vector2;

            /**
             * Perform a component-wise multiplication between this Vector and the given Vector.
             *
             * Multiplies this Vector by the given Vector.
             * @param src The Vector to multiply this Vector by.
             */
            multiply(src: Vector2): Vector2;

            /**
             * Scale this Vector by the given value.
             * @param value The value to scale this Vector by.
             */
            scale(value: number): Vector2;

            /**
             * Perform a component-wise division between this Vector and the given Vector.
             *
             * Divides this Vector by the given Vector.
             * @param src The Vector to divide this Vector by.
             */
            divide(src: Vector2): Vector2;

            /**
             * Negate the `x` and `y` components of this Vector.
             */
            negate(): Vector2;

            /**
             * Calculate the distance between this Vector and the given Vector.
             * @param src The Vector to calculate the distance to.
             */
            distance(src: Vector2): number;

            /**
             * Calculate the distance between this Vector and the given Vector, squared.
             * @param src The Vector to calculate the distance to.
             */
            distanceSq(src: Vector2): number;

            /**
             * Calculate the length (or magnitude) of this Vector.
             */
            length(): number;

            /**
             * Calculate the length of this Vector squared.
             */
            lengthSq(): number;

            /**
             * Normalize this Vector.
             *
             * Makes the vector a unit length vector (magnitude of 1) in the same direction.
             */
            normalize(): Vector2;

            /**
             * Right-hand normalize (make unit length) this Vector.
             */
            normalizeRightHand(): Vector2;

            /**
             * Calculate the dot product of this Vector and the given Vector.
             * @param src The Vector2 to dot product with this Vector2.
             */
            dot(src: Vector2): number;

            /**
             * Calculate the cross product of this Vector and the given Vector.
             * @param src The Vector2 to cross with this Vector2.
             */
            cross(src: Vector2): number;

            /**
             * Linearly interpolate between this Vector and the given Vector.
             *
             * Interpolates this Vector towards the given Vector.
             * @param src The Vector2 to interpolate towards.
             * @param t The interpolation percentage, between 0 and 1. Default 0.
             */
            lerp(src: Vector2, t?: number): Vector2;

            /**
             * Transform this Vector with the given Matrix.
             * @param mat The Matrix3 to transform this Vector2 with.
             */
            transformMat3(mat: Matrix3): Vector2;

            /**
             * Transform this Vector with the given Matrix.
             * @param mat The Matrix4 to transform this Vector2 with.
             */
            transformMat4(mat: Matrix4): Vector2;

            /**
             * Make this Vector the zero vector (0, 0).
             */
            reset(): Vector2;

            /**
             * A static zero Vector2 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly ZERO: Vector2;

            /**
             * A static right Vector2 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly RIGHT: Vector2;

            /**
             * A static left Vector2 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly LEFT: Vector2;

            /**
             * A static up Vector2 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly UP: Vector2;

            /**
             * A static down Vector2 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly DOWN: Vector2;

            /**
             * A static one Vector2 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly ONE: Vector2;
        }

        /**
         * A representation of a vector in 3D space.
         *
         * A three-component vector.
         */
        class Vector3 {
            /**
             *
             * @param x The x component.
             * @param y The y component.
             * @param z The z component.
             */
            constructor(x?: number, y?: number, z?: number);

            /**
             * The x component of this Vector.
             */
            x: number;

            /**
             * The y component of this Vector.
             */
            y: number;

            /**
             * The z component of this Vector.
             */
            z: number;

            /**
             * Set this Vector to point up.
             *
             * Sets the y component of the vector to 1, and the others to 0.
             */
            up(): Vector3;

            /**
             * Make a clone of this Vector3.
             */
            clone(): Vector3;

            /**
             * Calculate the cross (vector) product of two given Vectors.
             * @param a The first Vector to multiply.
             * @param b The second Vector to multiply.
             */
            crossVectors(a: Vector3, b: Vector3): Vector3;

            /**
             * Check whether this Vector is equal to a given Vector.
             *
             * Performs a strict equality check against each Vector's components.
             * @param v The Vector3 to compare against.
             */
            equals(v: Vector3): boolean;

            /**
             * Copy the components of a given Vector into this Vector.
             * @param src The Vector to copy the components from.
             */
            copy(src: Vector2 | Vector3): Vector3;

            /**
             * Set the `x`, `y`, and `z` components of this Vector to the given `x`, `y`, and `z` values.
             * @param x The x value to set for this Vector, or an object containing x, y and z components.
             * @param y The y value to set for this Vector.
             * @param z The z value to set for this Vector.
             */
            set(x: number | object, y?: number, z?: number): Vector3;

            /**
             * Add a given Vector to this Vector. Addition is component-wise.
             * @param v The Vector to add to this Vector.
             */
            add(v: Vector2 | Vector3): Vector3;

            /**
             * Subtract the given Vector from this Vector. Subtraction is component-wise.
             * @param v The Vector to subtract from this Vector.
             */
            subtract(v: Vector2 | Vector3): Vector3;

            /**
             * Perform a component-wise multiplication between this Vector and the given Vector.
             *
             * Multiplies this Vector by the given Vector.
             * @param v The Vector to multiply this Vector by.
             */
            multiply(v: Vector2 | Vector3): Vector3;

            /**
             * Scale this Vector by the given value.
             * @param scale The value to scale this Vector by.
             */
            scale(scale: number): Vector3;

            /**
             * Perform a component-wise division between this Vector and the given Vector.
             *
             * Divides this Vector by the given Vector.
             * @param v The Vector to divide this Vector by.
             */
            divide(v: Vector2 | Vector3): Vector3;

            /**
             * Negate the `x`, `y` and `z` components of this Vector.
             */
            negate(): Vector3;

            /**
             * Calculate the distance between this Vector and the given Vector.
             * @param v The Vector to calculate the distance to.
             */
            distance(v: Vector2 | Vector3): number;

            /**
             * Calculate the distance between this Vector and the given Vector, squared.
             * @param v The Vector to calculate the distance to.
             */
            distanceSq(v: Vector2 | Vector3): number;

            /**
             * Calculate the length (or magnitude) of this Vector.
             */
            length(): number;

            /**
             * Calculate the length of this Vector squared.
             */
            lengthSq(): number;

            /**
             * Normalize this Vector.
             *
             * Makes the vector a unit length vector (magnitude of 1) in the same direction.
             */
            normalize(): Vector3;

            /**
             * Calculate the dot product of this Vector and the given Vector.
             * @param v The Vector3 to dot product with this Vector3.
             */
            dot(v: Vector3): number;

            /**
             * Calculate the cross (vector) product of this Vector (which will be modified) and the given Vector.
             * @param v The Vector to cross product with.
             */
            cross(v: Vector3): Vector3;

            /**
             * Linearly interpolate between this Vector and the given Vector.
             *
             * Interpolates this Vector towards the given Vector.
             * @param v The Vector3 to interpolate towards.
             * @param t The interpolation percentage, between 0 and 1. Default 0.
             */
            lerp(v: Vector3, t?: number): Vector3;

            /**
             * Transform this Vector with the given Matrix.
             * @param mat The Matrix3 to transform this Vector3 with.
             */
            transformMat3(mat: Matrix3): Vector3;

            /**
             * Transform this Vector with the given Matrix.
             * @param mat The Matrix4 to transform this Vector3 with.
             */
            transformMat4(mat: Matrix4): Vector3;

            /**
             * Transforms the coordinates of this Vector3 with the given Matrix4.
             * @param mat The Matrix4 to transform this Vector3 with.
             */
            transformCoordinates(mat: Matrix4): Vector3;

            /**
             * Transform this Vector with the given Quaternion.
             * @param q The Quaternion to transform this Vector with.
             */
            transformQuat(q: Quaternion): Vector3;

            /**
             * Multiplies this Vector3 by the specified matrix, applying a W divide. This is useful for projection,
             * e.g. unprojecting a 2D point into 3D space.
             * @param mat The Matrix4 to multiply this Vector3 with.
             */
            project(mat: Matrix4): Vector3;

            /**
             * Unproject this point from 2D space to 3D space.
             * The point should have its x and y properties set to
             * 2D screen space, and the z either at 0 (near plane)
             * or 1 (far plane). The provided matrix is assumed to already
             * be combined, i.e. projection * view * model.
             *
             * After this operation, this vector's (x, y, z) components will
             * represent the unprojected 3D coordinate.
             * @param viewport Screen x, y, width and height in pixels.
             * @param invProjectionView Combined projection and view matrix.
             */
            unproject(viewport: Vector4, invProjectionView: Matrix4): Vector3;

            /**
             * Make this Vector the zero vector (0, 0, 0).
             */
            reset(): Vector3;

            /**
             * A static zero Vector3 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly ZERO: Vector3;

            /**
             * A static right Vector3 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly RIGHT: Vector3;

            /**
             * A static left Vector3 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly LEFT: Vector3;

            /**
             * A static up Vector3 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly UP: Vector3;

            /**
             * A static down Vector3 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly DOWN: Vector3;

            /**
             * A static forward Vector3 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly FORWARD: Vector3;

            /**
             * A static back Vector3 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly BACK: Vector3;

            /**
             * A static one Vector3 for use by reference.
             *
             * This constant is meant for comparison operations and should not be modified directly.
             */
            static readonly ONE: Vector3;
        }

        /**
         * A representation of a vector in 4D space.
         *
         * A four-component vector.
         */
        class Vector4 {
            /**
             *
             * @param x The x component.
             * @param y The y component.
             * @param z The z component.
             * @param w The w component.
             */
            constructor(x?: number, y?: number, z?: number, w?: number);

            /**
             * The x component of this Vector.
             */
            x: number;

            /**
             * The y component of this Vector.
             */
            y: number;

            /**
             * The z component of this Vector.
             */
            z: number;

            /**
             * The w component of this Vector.
             */
            w: number;

            /**
             * Make a clone of this Vector4.
             */
            clone(): Vector4;

            /**
             * Copy the components of a given Vector into this Vector.
             * @param src The Vector to copy the components from.
             */
            copy(src: Vector4): Vector4;

            /**
             * Check whether this Vector is equal to a given Vector.
             *
             * Performs a strict quality check against each Vector's components.
             * @param v The vector to check equality with.
             */
            equals(v: Vector4): boolean;

            /**
             * Set the `x`, `y`, `z` and `w` components of the this Vector to the given `x`, `y`, `z` and `w` values.
             * @param x The x value to set for this Vector, or an object containing x, y, z and w components.
             * @param y The y value to set for this Vector.
             * @param z The z value to set for this Vector.
             * @param w The z value to set for this Vector.
             */
            set(x: number | object, y: number, z: number, w: number): Vector4;

            /**
             * Add a given Vector to this Vector. Addition is component-wise.
             * @param v The Vector to add to this Vector.
             */
            add(v: Vector2 | Vector3 | Vector4): Vector4;

            /**
             * Subtract the given Vector from this Vector. Subtraction is component-wise.
             * @param v The Vector to subtract from this Vector.
             */
            subtract(v: Vector2 | Vector3 | Vector4): Vector4;

            /**
             * Scale this Vector by the given value.
             * @param scale The value to scale this Vector by.
             */
            scale(scale: number): Vector4;

            /**
             * Calculate the length (or magnitude) of this Vector.
             */
            length(): number;

            /**
             * Calculate the length of this Vector squared.
             */
            lengthSq(): number;

            /**
             * Normalize this Vector.
             *
             * Makes the vector a unit length vector (magnitude of 1) in the same direction.
             */
            normalize(): Vector4;

            /**
             * Calculate the dot product of this Vector and the given Vector.
             * @param v The Vector4 to dot product with this Vector4.
             */
            dot(v: Vector4): number;

            /**
             * Linearly interpolate between this Vector and the given Vector.
             *
             * Interpolates this Vector towards the given Vector.
             * @param v The Vector4 to interpolate towards.
             * @param t The interpolation percentage, between 0 and 1. Default 0.
             */
            lerp(v: Vector4, t?: number): Vector4;

            /**
             * Perform a component-wise multiplication between this Vector and the given Vector.
             *
             * Multiplies this Vector by the given Vector.
             * @param v The Vector to multiply this Vector by.
             */
            multiply(v: Vector2 | Vector3 | Vector4): Vector4;

            /**
             * Perform a component-wise division between this Vector and the given Vector.
             *
             * Divides this Vector by the given Vector.
             * @param v The Vector to divide this Vector by.
             */
            divide(v: Vector2 | Vector3 | Vector4): Vector4;

            /**
             * Calculate the distance between this Vector and the given Vector.
             * @param v The Vector to calculate the distance to.
             */
            distance(v: Vector2 | Vector3 | Vector4): number;

            /**
             * Calculate the distance between this Vector and the given Vector, squared.
             * @param v The Vector to calculate the distance to.
             */
            distanceSq(v: Vector2 | Vector3 | Vector4): number;

            /**
             * Negate the `x`, `y`, `z` and `w` components of this Vector.
             */
            negate(): Vector4;

            /**
             * Transform this Vector with the given Matrix.
             * @param mat The Matrix4 to transform this Vector4 with.
             */
            transformMat4(mat: Matrix4): Vector4;

            /**
             * Transform this Vector with the given Quaternion.
             * @param q The Quaternion to transform this Vector with.
             */
            transformQuat(q: Quaternion): Vector4;

            /**
             * Make this Vector the zero vector (0, 0, 0, 0).
             */
            reset(): Vector4;
        }

        /**
         * Checks if the two values are within the given `tolerance` of each other.
         * @param a The first value to use in the calculation.
         * @param b The second value to use in the calculation.
         * @param tolerance The tolerance. Anything equal to or less than this value is considered as being within range.
         */
        function Within(a: number, b: number, tolerance: number): boolean;

        /**
         * Wrap the given `value` between `min` and `max.
         * @param value The value to wrap.
         * @param min The minimum value.
         * @param max The maximum value.
         */
        function Wrap(value: number, min: number, max: number): number;
    }

    namespace Physics {
        namespace Arcade {
            /**
             * An Arcade Physics Image is an Image with an Arcade Physics body and related components.
             * The body can be dynamic or static.
             *
             * The main difference between an Arcade Image and an Arcade Sprite is that you cannot animate an Arcade Image.
             */
            class Image extends GameObjects.Image
                implements
                    Components.Acceleration,
                    Components.Angular,
                    Components.Bounce,
                    Components.Debug,
                    Components.Drag,
                    Components.Enable,
                    Components.Friction,
                    Components.Gravity,
                    Components.Immovable,
                    Components.Mass,
                    Components.Size,
                    Components.Velocity,
                    GameObjects.Components.Alpha,
                    GameObjects.Components.BlendMode,
                    GameObjects.Components.Depth,
                    GameObjects.Components.Flip,
                    GameObjects.Components.GetBounds,
                    GameObjects.Components.Origin,
                    GameObjects.Components.Pipeline,
                    GameObjects.Components.ScaleMode,
                    GameObjects.Components.ScrollFactor,
                    GameObjects.Components.Size,
                    GameObjects.Components.Texture,
                    GameObjects.Components.Tint,
                    GameObjects.Components.Transform,
                    GameObjects.Components.Visible {
                /**
                 *
                 * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                constructor(scene: Scene, x: number, y: number, texture: string, frame?: string | integer);

                /**
                 * This Game Object's Physics Body.
                 */
                body: Body | StaticBody;

                /**
                 * Clears all alpha values associated with this Game Object.
                 *
                 * Immediately sets the alpha levels back to 1 (fully opaque).
                 */
                clearAlpha(): this;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 *
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

                /**
                 * The alpha value of the Game Object.
                 *
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | BlendModes): this;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): this;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): this;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): this;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): this;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): this;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): this;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): this;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Geom.Rectangle>(output?: O): O;

                /**
                 * The Mask this Game Object is using during render.
                 */
                mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

                /**
                 * Sets the mask that this Game Object will use to render with.
                 *
                 * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
                 * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
                 *
                 * If a mask is already set on this Game Object it will be immediately replaced.
                 *
                 * Masks are positioned in global space and are not relative to the Game Object to which they
                 * are applied. The reason for this is that multiple Game Objects can all share the same mask.
                 *
                 * Masks have no impact on physics or input detection. They are purely a rendering component
                 * that allows you to limit what is visible during the render pass.
                 * @param mask The mask this Game Object will use when rendering.
                 */
                setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

                /**
                 * Clears the mask that this Game Object was using.
                 * @param destroyMask Destroy the mask before clearing it? Default false.
                 */
                clearMask(destroyMask?: boolean): this;

                /**
                 * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a renderable Game Object.
                 * A renderable Game Object is one that uses a texture to render with, such as an
                 * Image, Sprite, Render Texture or BitmapText.
                 *
                 * If you do not provide a renderable object, and this Game Object has a texture,
                 * it will use itself as the object. This means you can call this method to create
                 * a Bitmap Mask from any renderable Game Object.
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                createBitmapMask(renderable?: GameObjects.GameObject): Display.Masks.BitmapMask;

                /**
                 * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a Graphics Game Object.
                 *
                 * If you do not provide a graphics object, and this Game Object is an instance
                 * of a Graphics object, then it will use itself to create the mask.
                 *
                 * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
                 * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
                 */
                createGeometryMask(graphics?: GameObjects.Graphics): Display.Masks.GeometryMask;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 *
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): this;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): this;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): this;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): this;

                /**
                 * The initial WebGL pipeline of this Game Object.
                 */
                defaultPipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * The current WebGL pipeline of this Game Object.
                 */
                pipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
                 */
                initPipeline(pipelineName?: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): this;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: ScaleModes): this;

                /**
                 * The horizontal scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): this;

                /**
                 * The native (un-scaled) width of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayWidth` property.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayHeight` property.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Textures.Frame): this;

                /**
                 * Sets the internal size of this Game Object, as used for frame or physics body creation.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): this;

                /**
                 * Sets the display size of this Game Object.
                 *
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): this;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Textures.Texture | Textures.CanvasTexture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Textures.Frame;

                /**
                 * A boolean flag indicating if this Game Object is being cropped or not.
                 * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
                 * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
                 */
                isCropped: boolean;

                /**
                 * Applies a crop to a texture based Game Object, such as a Sprite or Image.
                 *
                 * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
                 *
                 * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
                 * changes what is shown when rendered.
                 *
                 * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
                 *
                 * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
                 * half of it, you could call `setCrop(0, 0, 400, 600)`.
                 *
                 * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
                 * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
                 *
                 * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
                 *
                 * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
                 *
                 * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
                 * the renderer to skip several internal calculations.
                 * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
                 * @param y The y coordinate to start the crop from.
                 * @param width The width of the crop rectangle in pixels.
                 * @param height The height of the crop rectangle in pixels.
                 */
                setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 *
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): this;

                /**
                 * Sets the frame this Game Object will use to render with.
                 *
                 * The Frame has to belong to the current Texture being used.
                 *
                 * It can be either a string or an index.
                 *
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

                /**
                 * Fill or additive?
                 */
                tintFill: boolean;

                /**
                 * Clears all tint values associated with this Game Object.
                 *
                 * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
                 * which results in no visible change to the texture.
                 */
                clearTint(): this;

                /**
                 * Sets an additive tint on this Game Object.
                 *
                 * The tint works by taking the pixel color values from the Game Objects texture, and then
                 * multiplying it by the color value of the tint. You can provide either one color value,
                 * in which case the whole Game Object will be tinted in that color. Or you can provide a color
                 * per corner. The colors are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * Sets a fill-based tint on this Game Object.
                 *
                 * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
                 * with those in the tint. You can use this for effects such as making a player flash 'white'
                 * if hit by something. You can provide either one color value, in which case the whole
                 * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
                 * are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
                 * @param topLeft The tint being applied to the top-left of the Game Object.
                 * If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * Does this Game Object have a tint applied to it or not?
                 */
                readonly isTinted: boolean;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 *
                 * Where 0 is to the right, 90 is down, 180 is left.
                 *
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 *
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): this;

                /**
                 * Sets the position of this Game Object to be a random position within the confines of
                 * the given area.
                 *
                 * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
                 *
                 * The position does not factor in the size of this Game Object, meaning that only the origin is
                 * guaranteed to be within the area.
                 * @param x The x position of the top-left of the random area. Default 0.
                 * @param y The y position of the top-left of the random area. Default 0.
                 * @param width The width of the random area.
                 * @param height The height of the random area.
                 */
                setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): this;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): this;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): this;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): this;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): this;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): this;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): this;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: GameObjects.Components.TransformMatrix): GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 * @param parentMatrix A temporary matrix to hold parent values during the calculations.
                 */
                getWorldTransformMatrix(
                    tempMatrix?: GameObjects.Components.TransformMatrix,
                    parentMatrix?: GameObjects.Components.TransformMatrix
                ): GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): this;

                /**
                 * Sets the body's horizontal and vertical acceleration.
                 * If the vertical acceleration value is not provided, the vertical acceleration is set to the same value as the horizontal acceleration.
                 * @param x The horizontal acceleration
                 * @param y The vertical acceleration Default x.
                 */
                setAcceleration(x: number, y?: number): this;

                /**
                 * Sets the body's horizontal acceleration.
                 * @param value The horizontal acceleration
                 */
                setAccelerationX(value: number): this;

                /**
                 * Sets the body's vertical acceleration.
                 * @param value The vertical acceleration
                 */
                setAccelerationY(value: number): this;

                /**
                 * Sets the angular velocity of the body.
                 *
                 * In Arcade Physics, bodies cannot rotate. They are always axis-aligned.
                 * However, they can have angular motion, which is passed on to the Game Object bound to the body,
                 * causing them to visually rotate, even though the body remains axis-aligned.
                 * @param value The amount of angular velocity.
                 */
                setAngularVelocity(value: number): this;

                /**
                 * Sets the angular acceleration of the body.
                 *
                 * In Arcade Physics, bodies cannot rotate. They are always axis-aligned.
                 * However, they can have angular motion, which is passed on to the Game Object bound to the body,
                 * causing them to visually rotate, even though the body remains axis-aligned.
                 * @param value The amount of angular acceleration.
                 */
                setAngularAcceleration(value: number): this;

                /**
                 * Sets the angular drag of the body. Drag is applied to the current velocity, providing a form of deceleration.
                 * @param value The amount of drag.
                 */
                setAngularDrag(value: number): this;

                /**
                 * Sets the bounce values of this body.
                 *
                 * Bounce is the amount of restitution, or elasticity, the body has when it collides with another object.
                 * A value of 1 means that it will retain its full velocity after the rebound. A value of 0 means it will not rebound at all.
                 * @param x The amount of horizontal bounce to apply on collision. A float, typically between 0 and 1.
                 * @param y The amount of vertical bounce to apply on collision. A float, typically between 0 and 1. Default x.
                 */
                setBounce(x: number, y?: number): this;

                /**
                 * Sets the horizontal bounce value for this body.
                 * @param value The amount of horizontal bounce to apply on collision. A float, typically between 0 and 1.
                 */
                setBounceX(value: number): this;

                /**
                 * Sets the vertical bounce value for this body.
                 * @param value The amount of vertical bounce to apply on collision. A float, typically between 0 and 1.
                 */
                setBounceY(value: number): this;

                /**
                 * Sets if this body should collide with the world bounds or not.
                 * @param value `true` if this body should collide with the world bounds, otherwise `false`.
                 */
                setCollideWorldBounds(value: boolean): this;

                /**
                 * Sets the debug values of this body.
                 *
                 * Bodies will only draw their debug if debug has been enabled for Arcade Physics as a whole.
                 * Note that there is a performance cost in drawing debug displays. It should never be used in production.
                 * @param showBody Set to `true` to have this body render its outline to the debug display.
                 * @param showVelocity Set to `true` to have this body render a velocity marker to the debug display.
                 * @param bodyColor The color of the body outline when rendered to the debug display.
                 */
                setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): this;

                /**
                 * Sets the color of the body outline when it renders to the debug display.
                 * @param value The color of the body outline when rendered to the debug display.
                 */
                setDebugBodyColor(value: number): this;

                /**
                 * Set to `true` to have this body render its outline to the debug display.
                 */
                debugShowBody: boolean;

                /**
                 * Set to `true` to have this body render a velocity marker to the debug display.
                 */
                debugShowVelocity: boolean;

                /**
                 * The color of the body outline when it renders to the debug display.
                 */
                debugBodyColor: number;

                /**
                 * Sets the body's horizontal and vertical drag. If the vertical drag value is not provided, the vertical drag is set to the same value as the horizontal drag.
                 *
                 * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
                 * It is the absolute loss of velocity due to movement, in pixels per second squared.
                 * The x and y components are applied separately.
                 *
                 * When `useDamping` is true, this is 1 minus the damping factor.
                 * A value of 1 means the Body loses no velocity.
                 * A value of 0.95 means the Body loses 5% of its velocity per step.
                 * A value of 0.5 means the Body loses 50% of its velocity per step.
                 *
                 * Drag is applied only when `acceleration` is zero.
                 * @param x The amount of horizontal drag to apply.
                 * @param y The amount of vertical drag to apply. Default x.
                 */
                setDrag(x: number, y?: number): this;

                /**
                 * Sets the body's horizontal drag.
                 *
                 * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
                 * It is the absolute loss of velocity due to movement, in pixels per second squared.
                 * The x and y components are applied separately.
                 *
                 * When `useDamping` is true, this is 1 minus the damping factor.
                 * A value of 1 means the Body loses no velocity.
                 * A value of 0.95 means the Body loses 5% of its velocity per step.
                 * A value of 0.5 means the Body loses 50% of its velocity per step.
                 *
                 * Drag is applied only when `acceleration` is zero.
                 * @param value The amount of horizontal drag to apply.
                 */
                setDragX(value: number): this;

                /**
                 * Sets the body's vertical drag.
                 *
                 * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
                 * It is the absolute loss of velocity due to movement, in pixels per second squared.
                 * The x and y components are applied separately.
                 *
                 * When `useDamping` is true, this is 1 minus the damping factor.
                 * A value of 1 means the Body loses no velocity.
                 * A value of 0.95 means the Body loses 5% of its velocity per step.
                 * A value of 0.5 means the Body loses 50% of its velocity per step.
                 *
                 * Drag is applied only when `acceleration` is zero.
                 * @param value The amount of vertical drag to apply.
                 */
                setDragY(value: number): this;

                /**
                 * If this Body is using `drag` for deceleration this function controls how the drag is applied.
                 * If set to `true` drag will use a damping effect rather than a linear approach. If you are
                 * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in
                 * the game Asteroids) then you will get a far smoother and more visually correct deceleration
                 * by using damping, avoiding the axis-drift that is prone with linear deceleration.
                 *
                 * If you enable this property then you should use far smaller `drag` values than with linear, as
                 * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow
                 * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.
                 * @param value `true` to use damping for deceleration, or `false` to use linear deceleration.
                 */
                setDamping(value: boolean): this;

                /**
                 * Enables this Game Object's Body.
                 * @param reset Also reset the Body and place it at (x, y).
                 * @param x The horizontal position to place the Game Object and Body.
                 * @param y The horizontal position to place the Game Object and Body.
                 * @param enableGameObject Also activate this Game Object.
                 * @param showGameObject Also show this Game Object.
                 */
                enableBody(reset: boolean, x: number, y: number, enableGameObject: boolean, showGameObject: boolean): this;

                /**
                 * Stops and disables this Game Object's Body.
                 * @param disableGameObject Also deactivate this Game Object. Default false.
                 * @param hideGameObject Also hide this Game Object. Default false.
                 */
                disableBody(disableGameObject?: boolean, hideGameObject?: boolean): this;

                /**
                 * Syncs the Body's position and size with its parent Game Object.
                 * You don't need to call this for Dynamic Bodies, as it happens automatically.
                 * But for Static bodies it's a useful way of modifying the position of a Static Body
                 * in the Physics World, based on its Game Object.
                 */
                refreshBody(): this;

                /**
                 * Sets the friction (e.g. the amount of velocity reduced over time) of the physics body when moving.
                 * The higher than friction, the faster the body will slow down once force stops being applied to it.
                 * @param x The amount of horizontal friction to apply.
                 * @param y The amount of vertical friction to apply. Default x.
                 */
                setFriction(x: number, y?: number): this;

                /**
                 * Sets the friction (e.g. the amount of velocity reduced over time) of the physics body when moving horizontally in the X axis.
                 * The higher than friction, the faster the body will slow down once force stops being applied to it.
                 * @param x The amount of friction to apply.
                 */
                setFrictionX(x: number): this;

                /**
                 * Sets the friction (e.g. the amount of velocity reduced over time) of the physics body when moving vertically in the Y axis.
                 * The higher than friction, the faster the body will slow down once force stops being applied to it.
                 * @param x The amount of friction to apply.
                 */
                setFrictionY(x: number): this;

                /**
                 * Set the X and Y values of the gravitational pull to act upon this Arcade Physics Game Object. Values can be positive or negative. Larger values result in a stronger effect.
                 *
                 * If only one value is provided, this value will be used for both the X and Y axis.
                 * @param x The gravitational force to be applied to the X-axis.
                 * @param y The gravitational force to be applied to the Y-axis. If this is not specified, the X value will be used. Default x.
                 */
                setGravity(x: number, y?: number): this;

                /**
                 * Set the gravitational force to be applied to the X axis. Value can be positive or negative. Larger values result in a stronger effect.
                 * @param x The gravitational force to be applied to the X-axis.
                 */
                setGravityX(x: number): this;

                /**
                 * Set the gravitational force to be applied to the Y axis. Value can be positive or negative. Larger values result in a stronger effect.
                 * @param y The gravitational force to be applied to the Y-axis.
                 */
                setGravityY(y: number): this;

                /**
                 * Sets Whether this Body can be moved by collisions with another Body.
                 * @param value Sets if this body can be moved by collisions with another Body. Default true.
                 */
                setImmovable(value?: boolean): this;

                /**
                 * Sets the mass of the physics body
                 * @param value New value for the mass of the body.
                 */
                setMass(value: number): this;

                /**
                 * Sets the body offset. This allows you to adjust the difference between the center of the body
                 * and the x and y coordinates of the parent Game Object.
                 * @param x The amount to offset the body from the parent Game Object along the x-axis.
                 * @param y The amount to offset the body from the parent Game Object along the y-axis. Defaults to the value given for the x-axis. Default x.
                 */
                setOffset(x: number, y?: number): this;

                /**
                 * Sets this physics body to use a circle for collision instead of a rectangle.
                 * @param radius The radius of the physics body, in pixels.
                 * @param offsetX The amount to offset the body from the parent Game Object along the x-axis.
                 * @param offsetY The amount to offset the body from the parent Game Object along the y-axis.
                 */
                setCircle(radius: number, offsetX?: number, offsetY?: number): this;

                /**
                 * Sets the velocity of the Body.
                 * @param x The horizontal velocity of the body. Positive values move the body to the right, while negative values move it to the left.
                 * @param y The vertical velocity of the body. Positive values move the body down, while negative values move it up. Default x.
                 */
                setVelocity(x: number, y?: number): this;

                /**
                 * Sets the horizontal component of the body's velocity.
                 *
                 * Positive values move the body to the right, while negative values move it to the left.
                 * @param x The new horizontal velocity.
                 */
                setVelocityX(x: number): this;

                /**
                 * Sets the vertical component of the body's velocity.
                 *
                 * Positive values move the body down, while negative values move it up.
                 * @param y The new vertical velocity of the body.
                 */
                setVelocityY(y: number): this;

                /**
                 * Sets the maximum velocity of the body.
                 * @param x The new maximum horizontal velocity.
                 * @param y The new maximum vertical velocity. Default x.
                 */
                setMaxVelocity(x: number, y?: number): this;
            }

            /**
             * The Arcade Physics Plugin belongs to a Scene and sets up and manages the Scene's physics simulation.
             * It also holds some useful methods for moving and rotating Arcade Physics Bodies.
             *
             * You can access it from within a Scene using `this.physics`.
             */
            class ArcadePhysics {
                /**
                 *
                 * @param scene The Scene that this Plugin belongs to.
                 */
                constructor(scene: Scene);

                /**
                 * The Scene that this Plugin belongs to.
                 */
                scene: Scene;

                /**
                 * The Scene's Systems.
                 */
                systems: Scenes.Systems;

                /**
                 * A configuration object. Union of the `physics.arcade.*` properties of the GameConfig and SceneConfig objects.
                 */
                config: object;

                /**
                 * The physics simulation.
                 */
                world: World;

                /**
                 * An object holding the Arcade Physics factory methods.
                 */
                add: Factory;

                /**
                 * Creates the physics configuration for the current Scene.
                 */
                getConfig(): object;

                /**
                 * Tests if Game Objects overlap. See {@link Phaser.Physics.Arcade.World#overlap}
                 * @param object1 The first object or array of objects to check.
                 * @param object2 The second object or array of objects to check, or `undefined`.
                 * @param collideCallback An optional callback function that is called if the objects collide.
                 * @param processCallback An optional callback function that lets you perform additional checks against the two objects if they overlap.
                 * If this is set then `collideCallback` will only be called if this callback returns `true`.
                 * @param callbackContext The context in which to run the callbacks.
                 */
                overlap(object1: ArcadeColliderType, object2?: ArcadeColliderType, collideCallback?: ArcadePhysicsCallback, processCallback?: ArcadePhysicsCallback, callbackContext?: any): boolean;

                /**
                 * Tests if Game Objects overlap and separates them (if possible). See {@link Phaser.Physics.Arcade.World#collide}.
                 * @param object1 The first object or array of objects to check.
                 * @param object2 The second object or array of objects to check, or `undefined`.
                 * @param collideCallback An optional callback function that is called if the objects collide.
                 * @param processCallback An optional callback function that lets you perform additional checks against the two objects if they collide.
                 * If this is set then `collideCallback` will only be called if this callback returns `true`.
                 * @param callbackContext The context in which to run the callbacks.
                 */
                collide(object1: ArcadeColliderType, object2?: ArcadeColliderType, collideCallback?: ArcadePhysicsCallback, processCallback?: ArcadePhysicsCallback, callbackContext?: any): boolean;

                /**
                 * Pauses the simulation.
                 */
                pause(): World;

                /**
                 * Resumes the simulation (if paused).
                 */
                resume(): World;

                /**
                 * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)
                 *
                 * You must give a maximum speed value, beyond which the game object won't go any faster.
                 *
                 * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.
                 * Note: The game object doesn't stop moving once it reaches the destination coordinates.
                 * @param gameObject Any Game Object with an Arcade Physics body.
                 * @param x The x coordinate to accelerate towards.
                 * @param y The y coordinate to accelerate towards.
                 * @param speed The acceleration (change in speed) in pixels per second squared. Default 60.
                 * @param xSpeedMax The maximum x velocity the game object can reach. Default 500.
                 * @param ySpeedMax The maximum y velocity the game object can reach. Default 500.
                 */
                accelerateTo(gameObject: GameObjects.GameObject, x: number, y: number, speed?: number, xSpeedMax?: number, ySpeedMax?: number): number;

                /**
                 * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)
                 *
                 * You must give a maximum speed value, beyond which the game object won't go any faster.
                 *
                 * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.
                 * Note: The game object doesn't stop moving once it reaches the destination coordinates.
                 * @param gameObject Any Game Object with an Arcade Physics body.
                 * @param destination The Game Object to move towards. Can be any object but must have visible x/y properties.
                 * @param speed The acceleration (change in speed) in pixels per second squared. Default 60.
                 * @param xSpeedMax The maximum x velocity the game object can reach. Default 500.
                 * @param ySpeedMax The maximum y velocity the game object can reach. Default 500.
                 */
                accelerateToObject(gameObject: GameObjects.GameObject, destination: GameObjects.GameObject, speed?: number, xSpeedMax?: number, ySpeedMax?: number): number;

                /**
                 * Finds the Body closest to a source point or object.
                 * @param source Any object with public `x` and `y` properties, such as a Game Object or Geometry object.
                 */
                closest(source: object): Body;

                /**
                 * Finds the Body farthest from a source point or object.
                 * @param source Any object with public `x` and `y` properties, such as a Game Object or Geometry object.
                 */
                furthest(source: object): Body;

                /**
                 * Move the given display object towards the x/y coordinates at a steady velocity.
                 * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
                 * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
                 * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
                 * Note: The display object doesn't stop moving once it reaches the destination coordinates.
                 * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)
                 * @param gameObject Any Game Object with an Arcade Physics body.
                 * @param x The x coordinate to move towards.
                 * @param y The y coordinate to move towards.
                 * @param speed The speed it will move, in pixels per second (default is 60 pixels/sec) Default 60.
                 * @param maxTime Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms. Default 0.
                 */
                moveTo(gameObject: GameObjects.GameObject, x: number, y: number, speed?: number, maxTime?: number): number;

                /**
                 * Move the given display object towards the destination object at a steady velocity.
                 * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.
                 * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
                 * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
                 * Note: The display object doesn't stop moving once it reaches the destination coordinates.
                 * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)
                 * @param gameObject Any Game Object with an Arcade Physics body.
                 * @param destination Any object with public `x` and `y` properties, such as a Game Object or Geometry object.
                 * @param speed The speed it will move, in pixels per second (default is 60 pixels/sec) Default 60.
                 * @param maxTime Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms. Default 0.
                 */
                moveToObject(gameObject: GameObjects.GameObject, destination: object, speed?: number, maxTime?: number): number;

                /**
                 * Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object.
                 * One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.
                 * @param angle The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
                 * @param speed The speed it will move, in pixels per second squared. Default 60.
                 * @param vec2 The Vector2 in which the x and y properties will be set to the calculated velocity.
                 */
                velocityFromAngle(angle: number, speed?: number, vec2?: Math.Vector2): Math.Vector2;

                /**
                 * Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object.
                 * One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.
                 * @param rotation The angle in radians.
                 * @param speed The speed it will move, in pixels per second squared Default 60.
                 * @param vec2 The Vector2 in which the x and y properties will be set to the calculated velocity.
                 */
                velocityFromRotation(rotation: number, speed?: number, vec2?: Math.Vector2): Math.Vector2;

                /**
                 * The Scene that owns this plugin is shutting down.
                 * We need to kill and reset all internal properties as well as stop listening to Scene events.
                 */
                shutdown(): void;

                /**
                 * The Scene that owns this plugin is being destroyed.
                 * We need to shutdown and then kill off all external references.
                 */
                destroy(): void;
            }

            /**
             * An Arcade Physics Sprite is a Sprite with an Arcade Physics body and related components.
             * The body can be dynamic or static.
             *
             * The main difference between an Arcade Sprite and an Arcade Image is that you cannot animate an Arcade Image.
             * If you do not require animation then you can safely use Arcade Images instead of Arcade Sprites.
             */
            class Sprite extends GameObjects.Sprite
                implements
                    Components.Acceleration,
                    Components.Angular,
                    Components.Bounce,
                    Components.Debug,
                    Components.Drag,
                    Components.Enable,
                    Components.Friction,
                    Components.Gravity,
                    Components.Immovable,
                    Components.Mass,
                    Components.Size,
                    Components.Velocity,
                    GameObjects.Components.Alpha,
                    GameObjects.Components.BlendMode,
                    GameObjects.Components.Depth,
                    GameObjects.Components.Flip,
                    GameObjects.Components.GetBounds,
                    GameObjects.Components.Origin,
                    GameObjects.Components.Pipeline,
                    GameObjects.Components.ScaleMode,
                    GameObjects.Components.ScrollFactor,
                    GameObjects.Components.Size,
                    GameObjects.Components.Texture,
                    GameObjects.Components.Tint,
                    GameObjects.Components.Transform,
                    GameObjects.Components.Visible {
                /**
                 *
                 * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                constructor(scene: Scene, x: number, y: number, texture: string, frame?: string | integer);

                /**
                 * This Game Object's Physics Body.
                 */
                body: Body | StaticBody;

                /**
                 * Clears all alpha values associated with this Game Object.
                 *
                 * Immediately sets the alpha levels back to 1 (fully opaque).
                 */
                clearAlpha(): this;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 *
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

                /**
                 * The alpha value of the Game Object.
                 *
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | BlendModes): this;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): this;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): this;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): this;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): this;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): this;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): this;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): this;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Geom.Rectangle>(output?: O): O;

                /**
                 * The Mask this Game Object is using during render.
                 */
                mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

                /**
                 * Sets the mask that this Game Object will use to render with.
                 *
                 * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
                 * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
                 *
                 * If a mask is already set on this Game Object it will be immediately replaced.
                 *
                 * Masks are positioned in global space and are not relative to the Game Object to which they
                 * are applied. The reason for this is that multiple Game Objects can all share the same mask.
                 *
                 * Masks have no impact on physics or input detection. They are purely a rendering component
                 * that allows you to limit what is visible during the render pass.
                 * @param mask The mask this Game Object will use when rendering.
                 */
                setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

                /**
                 * Clears the mask that this Game Object was using.
                 * @param destroyMask Destroy the mask before clearing it? Default false.
                 */
                clearMask(destroyMask?: boolean): this;

                /**
                 * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a renderable Game Object.
                 * A renderable Game Object is one that uses a texture to render with, such as an
                 * Image, Sprite, Render Texture or BitmapText.
                 *
                 * If you do not provide a renderable object, and this Game Object has a texture,
                 * it will use itself as the object. This means you can call this method to create
                 * a Bitmap Mask from any renderable Game Object.
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                createBitmapMask(renderable?: GameObjects.GameObject): Display.Masks.BitmapMask;

                /**
                 * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a Graphics Game Object.
                 *
                 * If you do not provide a graphics object, and this Game Object is an instance
                 * of a Graphics object, then it will use itself to create the mask.
                 *
                 * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
                 * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
                 */
                createGeometryMask(graphics?: GameObjects.Graphics): Display.Masks.GeometryMask;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 *
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): this;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): this;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): this;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): this;

                /**
                 * The initial WebGL pipeline of this Game Object.
                 */
                defaultPipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * The current WebGL pipeline of this Game Object.
                 */
                pipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
                 */
                initPipeline(pipelineName?: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): this;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: ScaleModes): this;

                /**
                 * The horizontal scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): this;

                /**
                 * The native (un-scaled) width of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayWidth` property.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayHeight` property.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Textures.Frame): this;

                /**
                 * Sets the internal size of this Game Object, as used for frame or physics body creation.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): this;

                /**
                 * Sets the display size of this Game Object.
                 *
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): this;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Textures.Texture | Textures.CanvasTexture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Textures.Frame;

                /**
                 * A boolean flag indicating if this Game Object is being cropped or not.
                 * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
                 * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
                 */
                isCropped: boolean;

                /**
                 * Applies a crop to a texture based Game Object, such as a Sprite or Image.
                 *
                 * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
                 *
                 * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
                 * changes what is shown when rendered.
                 *
                 * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
                 *
                 * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
                 * half of it, you could call `setCrop(0, 0, 400, 600)`.
                 *
                 * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
                 * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
                 *
                 * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
                 *
                 * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
                 *
                 * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
                 * the renderer to skip several internal calculations.
                 * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
                 * @param y The y coordinate to start the crop from.
                 * @param width The width of the crop rectangle in pixels.
                 * @param height The height of the crop rectangle in pixels.
                 */
                setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 *
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): this;

                /**
                 * Sets the frame this Game Object will use to render with.
                 *
                 * The Frame has to belong to the current Texture being used.
                 *
                 * It can be either a string or an index.
                 *
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

                /**
                 * Fill or additive?
                 */
                tintFill: boolean;

                /**
                 * Clears all tint values associated with this Game Object.
                 *
                 * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
                 * which results in no visible change to the texture.
                 */
                clearTint(): this;

                /**
                 * Sets an additive tint on this Game Object.
                 *
                 * The tint works by taking the pixel color values from the Game Objects texture, and then
                 * multiplying it by the color value of the tint. You can provide either one color value,
                 * in which case the whole Game Object will be tinted in that color. Or you can provide a color
                 * per corner. The colors are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * Sets a fill-based tint on this Game Object.
                 *
                 * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
                 * with those in the tint. You can use this for effects such as making a player flash 'white'
                 * if hit by something. You can provide either one color value, in which case the whole
                 * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
                 * are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
                 * @param topLeft The tint being applied to the top-left of the Game Object.
                 * If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * Does this Game Object have a tint applied to it or not?
                 */
                readonly isTinted: boolean;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 *
                 * Where 0 is to the right, 90 is down, 180 is left.
                 *
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 *
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): this;

                /**
                 * Sets the position of this Game Object to be a random position within the confines of
                 * the given area.
                 *
                 * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
                 *
                 * The position does not factor in the size of this Game Object, meaning that only the origin is
                 * guaranteed to be within the area.
                 * @param x The x position of the top-left of the random area. Default 0.
                 * @param y The y position of the top-left of the random area. Default 0.
                 * @param width The width of the random area.
                 * @param height The height of the random area.
                 */
                setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): this;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): this;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): this;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): this;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): this;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): this;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): this;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: GameObjects.Components.TransformMatrix): GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 * @param parentMatrix A temporary matrix to hold parent values during the calculations.
                 */
                getWorldTransformMatrix(
                    tempMatrix?: GameObjects.Components.TransformMatrix,
                    parentMatrix?: GameObjects.Components.TransformMatrix
                ): GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): this;

                /**
                 * Sets the body's horizontal and vertical acceleration.
                 * If the vertical acceleration value is not provided, the vertical acceleration is set to the same value as the horizontal acceleration.
                 * @param x The horizontal acceleration
                 * @param y The vertical acceleration Default x.
                 */
                setAcceleration(x: number, y?: number): this;

                /**
                 * Sets the body's horizontal acceleration.
                 * @param value The horizontal acceleration
                 */
                setAccelerationX(value: number): this;

                /**
                 * Sets the body's vertical acceleration.
                 * @param value The vertical acceleration
                 */
                setAccelerationY(value: number): this;

                /**
                 * Sets the angular velocity of the body.
                 *
                 * In Arcade Physics, bodies cannot rotate. They are always axis-aligned.
                 * However, they can have angular motion, which is passed on to the Game Object bound to the body,
                 * causing them to visually rotate, even though the body remains axis-aligned.
                 * @param value The amount of angular velocity.
                 */
                setAngularVelocity(value: number): this;

                /**
                 * Sets the angular acceleration of the body.
                 *
                 * In Arcade Physics, bodies cannot rotate. They are always axis-aligned.
                 * However, they can have angular motion, which is passed on to the Game Object bound to the body,
                 * causing them to visually rotate, even though the body remains axis-aligned.
                 * @param value The amount of angular acceleration.
                 */
                setAngularAcceleration(value: number): this;

                /**
                 * Sets the angular drag of the body. Drag is applied to the current velocity, providing a form of deceleration.
                 * @param value The amount of drag.
                 */
                setAngularDrag(value: number): this;

                /**
                 * Sets the bounce values of this body.
                 *
                 * Bounce is the amount of restitution, or elasticity, the body has when it collides with another object.
                 * A value of 1 means that it will retain its full velocity after the rebound. A value of 0 means it will not rebound at all.
                 * @param x The amount of horizontal bounce to apply on collision. A float, typically between 0 and 1.
                 * @param y The amount of vertical bounce to apply on collision. A float, typically between 0 and 1. Default x.
                 */
                setBounce(x: number, y?: number): this;

                /**
                 * Sets the horizontal bounce value for this body.
                 * @param value The amount of horizontal bounce to apply on collision. A float, typically between 0 and 1.
                 */
                setBounceX(value: number): this;

                /**
                 * Sets the vertical bounce value for this body.
                 * @param value The amount of vertical bounce to apply on collision. A float, typically between 0 and 1.
                 */
                setBounceY(value: number): this;

                /**
                 * Sets if this body should collide with the world bounds or not.
                 * @param value `true` if this body should collide with the world bounds, otherwise `false`.
                 */
                setCollideWorldBounds(value: boolean): this;

                /**
                 * Sets the debug values of this body.
                 *
                 * Bodies will only draw their debug if debug has been enabled for Arcade Physics as a whole.
                 * Note that there is a performance cost in drawing debug displays. It should never be used in production.
                 * @param showBody Set to `true` to have this body render its outline to the debug display.
                 * @param showVelocity Set to `true` to have this body render a velocity marker to the debug display.
                 * @param bodyColor The color of the body outline when rendered to the debug display.
                 */
                setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): this;

                /**
                 * Sets the color of the body outline when it renders to the debug display.
                 * @param value The color of the body outline when rendered to the debug display.
                 */
                setDebugBodyColor(value: number): this;

                /**
                 * Set to `true` to have this body render its outline to the debug display.
                 */
                debugShowBody: boolean;

                /**
                 * Set to `true` to have this body render a velocity marker to the debug display.
                 */
                debugShowVelocity: boolean;

                /**
                 * The color of the body outline when it renders to the debug display.
                 */
                debugBodyColor: number;

                /**
                 * Sets the body's horizontal and vertical drag. If the vertical drag value is not provided, the vertical drag is set to the same value as the horizontal drag.
                 *
                 * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
                 * It is the absolute loss of velocity due to movement, in pixels per second squared.
                 * The x and y components are applied separately.
                 *
                 * When `useDamping` is true, this is 1 minus the damping factor.
                 * A value of 1 means the Body loses no velocity.
                 * A value of 0.95 means the Body loses 5% of its velocity per step.
                 * A value of 0.5 means the Body loses 50% of its velocity per step.
                 *
                 * Drag is applied only when `acceleration` is zero.
                 * @param x The amount of horizontal drag to apply.
                 * @param y The amount of vertical drag to apply. Default x.
                 */
                setDrag(x: number, y?: number): this;

                /**
                 * Sets the body's horizontal drag.
                 *
                 * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
                 * It is the absolute loss of velocity due to movement, in pixels per second squared.
                 * The x and y components are applied separately.
                 *
                 * When `useDamping` is true, this is 1 minus the damping factor.
                 * A value of 1 means the Body loses no velocity.
                 * A value of 0.95 means the Body loses 5% of its velocity per step.
                 * A value of 0.5 means the Body loses 50% of its velocity per step.
                 *
                 * Drag is applied only when `acceleration` is zero.
                 * @param value The amount of horizontal drag to apply.
                 */
                setDragX(value: number): this;

                /**
                 * Sets the body's vertical drag.
                 *
                 * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
                 * It is the absolute loss of velocity due to movement, in pixels per second squared.
                 * The x and y components are applied separately.
                 *
                 * When `useDamping` is true, this is 1 minus the damping factor.
                 * A value of 1 means the Body loses no velocity.
                 * A value of 0.95 means the Body loses 5% of its velocity per step.
                 * A value of 0.5 means the Body loses 50% of its velocity per step.
                 *
                 * Drag is applied only when `acceleration` is zero.
                 * @param value The amount of vertical drag to apply.
                 */
                setDragY(value: number): this;

                /**
                 * If this Body is using `drag` for deceleration this function controls how the drag is applied.
                 * If set to `true` drag will use a damping effect rather than a linear approach. If you are
                 * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in
                 * the game Asteroids) then you will get a far smoother and more visually correct deceleration
                 * by using damping, avoiding the axis-drift that is prone with linear deceleration.
                 *
                 * If you enable this property then you should use far smaller `drag` values than with linear, as
                 * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow
                 * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.
                 * @param value `true` to use damping for deceleration, or `false` to use linear deceleration.
                 */
                setDamping(value: boolean): this;

                /**
                 * Enables this Game Object's Body.
                 * @param reset Also reset the Body and place it at (x, y).
                 * @param x The horizontal position to place the Game Object and Body.
                 * @param y The horizontal position to place the Game Object and Body.
                 * @param enableGameObject Also activate this Game Object.
                 * @param showGameObject Also show this Game Object.
                 */
                enableBody(reset: boolean, x: number, y: number, enableGameObject: boolean, showGameObject: boolean): this;

                /**
                 * Stops and disables this Game Object's Body.
                 * @param disableGameObject Also deactivate this Game Object. Default false.
                 * @param hideGameObject Also hide this Game Object. Default false.
                 */
                disableBody(disableGameObject?: boolean, hideGameObject?: boolean): this;

                /**
                 * Syncs the Body's position and size with its parent Game Object.
                 * You don't need to call this for Dynamic Bodies, as it happens automatically.
                 * But for Static bodies it's a useful way of modifying the position of a Static Body
                 * in the Physics World, based on its Game Object.
                 */
                refreshBody(): this;

                /**
                 * Sets the friction (e.g. the amount of velocity reduced over time) of the physics body when moving.
                 * The higher than friction, the faster the body will slow down once force stops being applied to it.
                 * @param x The amount of horizontal friction to apply.
                 * @param y The amount of vertical friction to apply. Default x.
                 */
                setFriction(x: number, y?: number): this;

                /**
                 * Sets the friction (e.g. the amount of velocity reduced over time) of the physics body when moving horizontally in the X axis.
                 * The higher than friction, the faster the body will slow down once force stops being applied to it.
                 * @param x The amount of friction to apply.
                 */
                setFrictionX(x: number): this;

                /**
                 * Sets the friction (e.g. the amount of velocity reduced over time) of the physics body when moving vertically in the Y axis.
                 * The higher than friction, the faster the body will slow down once force stops being applied to it.
                 * @param x The amount of friction to apply.
                 */
                setFrictionY(x: number): this;

                /**
                 * Set the X and Y values of the gravitational pull to act upon this Arcade Physics Game Object. Values can be positive or negative. Larger values result in a stronger effect.
                 *
                 * If only one value is provided, this value will be used for both the X and Y axis.
                 * @param x The gravitational force to be applied to the X-axis.
                 * @param y The gravitational force to be applied to the Y-axis. If this is not specified, the X value will be used. Default x.
                 */
                setGravity(x: number, y?: number): this;

                /**
                 * Set the gravitational force to be applied to the X axis. Value can be positive or negative. Larger values result in a stronger effect.
                 * @param x The gravitational force to be applied to the X-axis.
                 */
                setGravityX(x: number): this;

                /**
                 * Set the gravitational force to be applied to the Y axis. Value can be positive or negative. Larger values result in a stronger effect.
                 * @param y The gravitational force to be applied to the Y-axis.
                 */
                setGravityY(y: number): this;

                /**
                 * Sets Whether this Body can be moved by collisions with another Body.
                 * @param value Sets if this body can be moved by collisions with another Body. Default true.
                 */
                setImmovable(value?: boolean): this;

                /**
                 * Sets the mass of the physics body
                 * @param value New value for the mass of the body.
                 */
                setMass(value: number): this;

                /**
                 * Sets the body offset. This allows you to adjust the difference between the center of the body
                 * and the x and y coordinates of the parent Game Object.
                 * @param x The amount to offset the body from the parent Game Object along the x-axis.
                 * @param y The amount to offset the body from the parent Game Object along the y-axis. Defaults to the value given for the x-axis. Default x.
                 */
                setOffset(x: number, y?: number): this;

                /**
                 * Sets this physics body to use a circle for collision instead of a rectangle.
                 * @param radius The radius of the physics body, in pixels.
                 * @param offsetX The amount to offset the body from the parent Game Object along the x-axis.
                 * @param offsetY The amount to offset the body from the parent Game Object along the y-axis.
                 */
                setCircle(radius: number, offsetX?: number, offsetY?: number): this;

                /**
                 * Sets the velocity of the Body.
                 * @param x The horizontal velocity of the body. Positive values move the body to the right, while negative values move it to the left.
                 * @param y The vertical velocity of the body. Positive values move the body down, while negative values move it up. Default x.
                 */
                setVelocity(x: number, y?: number): this;

                /**
                 * Sets the horizontal component of the body's velocity.
                 *
                 * Positive values move the body to the right, while negative values move it to the left.
                 * @param x The new horizontal velocity.
                 */
                setVelocityX(x: number): this;

                /**
                 * Sets the vertical component of the body's velocity.
                 *
                 * Positive values move the body down, while negative values move it up.
                 * @param y The new vertical velocity of the body.
                 */
                setVelocityY(y: number): this;

                /**
                 * Sets the maximum velocity of the body.
                 * @param x The new maximum horizontal velocity.
                 * @param y The new maximum vertical velocity. Default x.
                 */
                setMaxVelocity(x: number, y?: number): this;
            }

            /**
             * A Dynamic Arcade Body.
             *
             * Its static counterpart is {@link Phaser.Physics.Arcade.StaticBody}.
             */
            class Body {
                /**
                 *
                 * @param world The Arcade Physics simulation this Body belongs to.
                 * @param gameObject The Game Object this Body belongs to.
                 */
                constructor(world: World, gameObject: GameObjects.GameObject);

                /**
                 * The Arcade Physics simulation this Body belongs to.
                 */
                world: World;

                /**
                 * The Game Object this Body belongs to.
                 */
                gameObject: GameObjects.GameObject;

                /**
                 * Transformations applied to this Body.
                 */
                transform: object;

                /**
                 * Whether the Body's boundary is drawn to the debug display.
                 */
                debugShowBody: boolean;

                /**
                 * Whether the Body's velocity is drawn to the debug display.
                 */
                debugShowVelocity: boolean;

                /**
                 * The color of this Body on the debug display.
                 */
                debugBodyColor: integer;

                /**
                 * Whether this Body is updated by the physics simulation.
                 */
                enable: boolean;

                /**
                 * Whether this Body's boundary is circular (true) or rectangular (false).
                 */
                isCircle: boolean;

                /**
                 * If this Body is circular, this is the unscaled radius of the Body's boundary, as set by setCircle(), in source pixels.
                 * The true radius is equal to `halfWidth`.
                 */
                radius: number;

                /**
                 * The offset of this Body's position from its Game Object's position, in source pixels.
                 */
                offset: Math.Vector2;

                /**
                 * The position of this Body within the simulation.
                 */
                position: Math.Vector2;

                /**
                 * The position of this Body during the previous step.
                 */
                prev: Math.Vector2;

                /**
                 * Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.
                 */
                allowRotation: boolean;

                /**
                 * This body's rotation, in degrees, based on its angular acceleration and angular velocity.
                 * The Body's rotation controls the `angle` of its Game Object.
                 * It doesn't rotate the Body's boundary, which is always an axis-aligned rectangle or a circle.
                 */
                rotation: number;

                /**
                 * The Body's rotation, in degrees, during the previous step.
                 */
                preRotation: number;

                /**
                 * The width of the Body's boundary, in pixels.
                 * If the Body is circular, this is also the Body's diameter.
                 */
                width: number;

                /**
                 * The height of the Body's boundary, in pixels.
                 * If the Body is circular, this is also the Body's diameter.
                 */
                height: number;

                /**
                 * The unscaled width of the Body, in source pixels, as set by setSize().
                 * The default is the width of the Body's Game Object's texture frame.
                 */
                sourceWidth: number;

                /**
                 * The unscaled height of the Body, in source pixels, as set by setSize().
                 * The default is the height of the Body's Game Object's texture frame.
                 */
                sourceHeight: number;

                /**
                 * Half the Body's width, in pixels.
                 */
                halfWidth: number;

                /**
                 * Half the Body's height, in pixels.
                 */
                halfHeight: number;

                /**
                 * The center of the Body's boundary.
                 * The midpoint of its `position` (top-left corner) and its bottom-right corner.
                 */
                center: Math.Vector2;

                /**
                 * The Body's velocity, in pixels per second.
                 */
                velocity: Math.Vector2;

                /**
                 * The Body's calculated velocity, in pixels per second, at the last step.
                 */
                readonly newVelocity: Math.Vector2;

                /**
                 * The Body's absolute maximum change in position, in pixels per step.
                 */
                deltaMax: Math.Vector2;

                /**
                 * The Body's change in velocity, in pixels per second squared.
                 */
                acceleration: Math.Vector2;

                /**
                 * Whether this Body's velocity is affected by its `drag`.
                 */
                allowDrag: boolean;

                /**
                 * Absolute loss of velocity due to movement, in pixels per second squared.
                 * The x and y components are applied separately.
                 *
                 * When `useDamping` is true, this is 1 minus the damping factor.
                 * A value of 1 means the Body loses no velocity.
                 * A value of 0.95 means the Body loses 5% of its velocity per step.
                 * A value of 0.5 means the Body loses 50% of its velocity per step.
                 *
                 * Drag is applied only when `acceleration` is zero.
                 */
                drag: Math.Vector2 | number;

                /**
                 * Whether this Body's position is affected by gravity (local or world).
                 */
                allowGravity: boolean;

                /**
                 * Acceleration due to gravity (specific to this Body), in pixels per second squared.
                 * Total gravity is the sum of this vector and the simulation's `gravity`.
                 */
                gravity: Math.Vector2;

                /**
                 * Rebound following a collision, relative to 1.
                 */
                bounce: Math.Vector2;

                /**
                 * Rebound following a collision with the world boundary, relative to 1.
                 * If null, `bounce` is used instead.
                 */
                worldBounce: Math.Vector2;

                /**
                 * Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary (and `collideWorldBounds` is also true).
                 */
                onWorldBounds: boolean;

                /**
                 * Whether the simulation emits a `collide` event when this Body collides with another.
                 */
                onCollide: boolean;

                /**
                 * Whether the simulation emits an `overlap` event when this Body overlaps with another.
                 */
                onOverlap: boolean;

                /**
                 * The Body's absolute maximum velocity, in pixels per second.
                 * The horizontal and vertical components are applied separately.
                 */
                maxVelocity: Math.Vector2;

                /**
                 * The maximum speed this Body is allowed to reach.
                 *
                 * If not negative it limits the scalar value of speed.
                 *
                 * Any negative value means no maximum is being applied.
                 */
                maxSpeed: number;

                /**
                 * If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.
                 * The default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.
                 * The horizontal component (x) is applied only when two colliding Bodies are separated vertically.
                 * The vertical component (y) is applied only when two colliding Bodies are separated horizontally.
                 */
                friction: Math.Vector2;

                /**
                 * If this Body is using `drag` for deceleration this property controls how the drag is applied.
                 * If set to `true` drag will use a damping effect rather than a linear approach. If you are
                 * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in
                 * the game Asteroids) then you will get a far smoother and more visually correct deceleration
                 * by using damping, avoiding the axis-drift that is prone with linear deceleration.
                 *
                 * If you enable this property then you should use far smaller `drag` values than with linear, as
                 * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow
                 * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.
                 */
                useDamping: boolean;

                /**
                 * The rate of change of this Body's `rotation`, in degrees per second.
                 */
                angularVelocity: number;

                /**
                 * The Body's angular acceleration (change in angular velocity), in degrees per second squared.
                 */
                angularAcceleration: number;

                /**
                 * Loss of angular velocity due to angular movement, in degrees per second.
                 *
                 * Angular drag is applied only when angular acceleration is zero.
                 */
                angularDrag: number;

                /**
                 * The Body's maximum angular velocity, in degrees per second.
                 */
                maxAngular: number;

                /**
                 * The Body's inertia, relative to a default unit (1).
                 * With `bounce`, this affects the exchange of momentum (velocities) during collisions.
                 */
                mass: number;

                /**
                 * The calculated angle of this Body's velocity vector, in degrees, during the last step.
                 */
                angle: number;

                /**
                 * The calculated magnitude of the Body's velocity, in pixels per second, during the last step.
                 */
                speed: number;

                /**
                 * The direction of the Body's velocity, as calculated during the last step.
                 * If the Body is moving on both axes (diagonally), this describes motion on the vertical axis only.
                 */
                facing: integer;

                /**
                 * Whether this Body can be moved by collisions with another Body.
                 */
                immovable: boolean;

                /**
                 * Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.
                 */
                moves: boolean;

                /**
                 * A flag disabling the default horizontal separation of colliding bodies.
                 * Pass your own `collideCallback` to the collider.
                 */
                customSeparateX: boolean;

                /**
                 * A flag disabling the default vertical separation of colliding bodies.
                 * Pass your own `collideCallback` to the collider.
                 */
                customSeparateY: boolean;

                /**
                 * The amount of horizontal overlap (before separation), if this Body is colliding with another.
                 */
                overlapX: number;

                /**
                 * The amount of vertical overlap (before separation), if this Body is colliding with another.
                 */
                overlapY: number;

                /**
                 * The amount of overlap (before separation), if this Body is circular and colliding with another circular body.
                 */
                overlapR: number;

                /**
                 * Whether this Body is overlapped with another and both are not moving.
                 */
                embedded: boolean;

                /**
                 * Whether this Body interacts with the world boundary.
                 */
                collideWorldBounds: boolean;

                /**
                 * Whether this Body is checked for collisions and for which directions.
                 * You can set `checkCollision.none = true` to disable collision checks.
                 */
                checkCollision: ArcadeBodyCollision;

                /**
                 * Whether this Body is colliding with another and in which direction.
                 */
                touching: ArcadeBodyCollision;

                /**
                 * Whether this Body was colliding with another during the last step, and in which direction.
                 */
                wasTouching: ArcadeBodyCollision;

                /**
                 * Whether this Body is colliding with a tile or the world boundary.
                 */
                blocked: ArcadeBodyCollision;

                /**
                 * Whether to automatically synchronize this Body's dimensions to the dimensions of its Game Object's visual bounds.
                 */
                syncBounds: boolean;

                /**
                 * Whether this Body is being moved by the `moveTo` or `moveFrom` methods.
                 */
                isMoving: boolean;

                /**
                 * Whether this Body's movement by `moveTo` or `moveFrom` will be stopped by collisions with other bodies.
                 */
                stopVelocityOnCollide: boolean;

                /**
                 * The Body's physics interface (dynamic or static).
                 */
                readonly physicsinterface: integer;

                /**
                 * Updates the Body's `transform`, `width`, `height`, and `center` from its Game Object.
                 * The Body's `position` isn't changed.
                 */
                updateBounds(): void;

                /**
                 * Updates the Body's `center` from its `position`, `width`, and `height`.
                 */
                updateCenter(): void;

                /**
                 * Updates the Body.
                 * @param delta The delta time, in seconds, elapsed since the last frame.
                 */
                update(delta: number): void;

                /**
                 * Feeds the Body results back into the parent Game Object.
                 * @param resetDelta Reset the delta properties?
                 */
                postUpdate(resetDelta: boolean): void;

                /**
                 * Checks for collisions between this Body and the world boundary and separates them.
                 */
                checkWorldBounds(): boolean;

                /**
                 * Sets the offset of the Body's position from its Game Object's position.
                 * @param x The horizontal offset, in source pixels.
                 * @param y The vertical offset, in source pixels. Default x.
                 */
                setOffset(x: number, y?: number): Body;

                /**
                 * Sizes and positions this Body's boundary, as a rectangle.
                 * Modifies the Body `offset` if `center` is true (the default).
                 * Resets the width and height to match current frame, if no width and height provided and a frame is found.
                 * @param width The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.
                 * @param height The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.
                 * @param center Modify the Body's `offset`, placing the Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method. Default true.
                 */
                setSize(width?: integer, height?: integer, center?: boolean): Body;

                /**
                 * Sizes and positions this Body's boundary, as a circle.
                 * @param radius The radius of the Body, in source pixels.
                 * @param offsetX The horizontal offset of the Body from its Game Object, in source pixels.
                 * @param offsetY The vertical offset of the Body from its Game Object, in source pixels.
                 */
                setCircle(radius: number, offsetX?: number, offsetY?: number): Body;

                /**
                 * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.
                 * If the Body had any velocity or acceleration it is lost as a result of calling this.
                 * @param x The horizontal position to place the Game Object and Body.
                 * @param y The vertical position to place the Game Object and Body.
                 */
                reset(x: number, y: number): void;

                /**
                 * Sets acceleration, velocity, and speed to zero.
                 */
                stop(): Body;

                /**
                 * Copies the coordinates of this Body's edges into an object.
                 * @param obj An object to copy the values into.
                 */
                getBounds(obj: ArcadeBodyBounds): ArcadeBodyBounds;

                /**
                 * Tests if the coordinates are within this Body's boundary.
                 * @param x The horizontal coordinate.
                 * @param y The vertical coordinate.
                 */
                hitTest(x: number, y: number): boolean;

                /**
                 * Whether this Body is touching a tile or the world boundary while moving down.
                 */
                onFloor(): boolean;

                /**
                 * Whether this Body is touching a tile or the world boundary while moving up.
                 */
                onCeiling(): boolean;

                /**
                 * Whether this Body is touching a tile or the world boundary while moving left or right.
                 */
                onWall(): boolean;

                /**
                 * The absolute (non-negative) change in this Body's horizontal position from the previous step.
                 */
                deltaAbsX(): number;

                /**
                 * The absolute (non-negative) change in this Body's vertical position from the previous step.
                 */
                deltaAbsY(): number;

                /**
                 * The change in this Body's horizontal position from the previous step.
                 * This value is set during the Body's update phase.
                 */
                deltaX(): number;

                /**
                 * The change in this Body's vertical position from the previous step.
                 * This value is set during the Body's update phase.
                 */
                deltaY(): number;

                /**
                 * The change in this Body's rotation from the previous step, in degrees.
                 */
                deltaZ(): number;

                /**
                 * Disables this Body and marks it for deletion by the simulation.
                 */
                destroy(): void;

                /**
                 * Draws this Body's boundary and velocity, if enabled.
                 * @param graphic The Graphics object to draw on.
                 */
                drawDebug(graphic: GameObjects.Graphics): void;

                /**
                 * Whether this Body will be drawn to the debug display.
                 */
                willDrawDebug(): boolean;

                /**
                 * Sets whether this Body collides with the world boundary.
                 * @param value True (collisions) or false (no collisions). Default true.
                 */
                setCollideWorldBounds(value?: boolean): Body;

                /**
                 * Sets the Body's velocity.
                 * @param x The horizontal velocity, in pixels per second.
                 * @param y The vertical velocity, in pixels per second. Default x.
                 */
                setVelocity(x: number, y?: number): Body;

                /**
                 * Sets the Body's horizontal velocity.
                 * @param value The velocity, in pixels per second.
                 */
                setVelocityX(value: number): Body;

                /**
                 * Sets the Body's vertical velocity.
                 * @param value The velocity, in pixels per second.
                 */
                setVelocityY(value: number): Body;

                /**
                 * Sets the Body's maximum velocity.
                 * @param x The horizontal velocity, in pixels per second.
                 * @param y The vertical velocity, in pixels per second. Default x.
                 */
                setMaxVelocity(x: number, y?: number): Body;

                /**
                 * Sets the maximum speed the Body can move.
                 * @param value The maximum speed value, in pixels per second. Set to a negative value to disable.
                 */
                setMaxSpeed(value: number): Body;

                /**
                 * Sets the Body's bounce.
                 * @param x The horizontal bounce, relative to 1.
                 * @param y The vertical bounce, relative to 1.
                 */
                setBounce(x: number, y: number): Body;

                /**
                 * Sets the Body's horizontal bounce.
                 * @param value The bounce, relative to 1.
                 */
                setBounceX(value: number): Body;

                /**
                 * Sets the Body's vertical bounce.
                 * @param value The bounce, relative to 1.
                 */
                setBounceY(value: number): Body;

                /**
                 * Sets the Body's acceleration.
                 * @param x The horizontal component, in pixels per second squared.
                 * @param y The vertical component, in pixels per second squared.
                 */
                setAcceleration(x: number, y: number): Body;

                /**
                 * Sets the Body's horizontal acceleration.
                 * @param value The acceleration, in pixels per second squared.
                 */
                setAccelerationX(value: number): Body;

                /**
                 * Sets the Body's vertical acceleration.
                 * @param value The acceleration, in pixels per second squared.
                 */
                setAccelerationY(value: number): Body;

                /**
                 * Enables or disables drag.
                 * @param value `true` to allow drag on this body, or `false` to disable it. Default true.
                 */
                setAllowDrag(value?: boolean): Body;

                /**
                 * Enables or disables gravity's effect on this Body.
                 * @param value `true` to allow gravity on this body, or `false` to disable it. Default true.
                 */
                setAllowGravity(value?: boolean): Body;

                /**
                 * Enables or disables rotation.
                 * @param value `true` to allow rotation on this body, or `false` to disable it. Default true.
                 */
                setAllowRotation(value?: boolean): Body;

                /**
                 * Sets the Body's drag.
                 * @param x The horizontal component, in pixels per second squared.
                 * @param y The vertical component, in pixels per second squared.
                 */
                setDrag(x: number, y: number): Body;

                /**
                 * Sets the Body's horizontal drag.
                 * @param value The drag, in pixels per second squared.
                 */
                setDragX(value: number): Body;

                /**
                 * Sets the Body's vertical drag.
                 * @param value The drag, in pixels per second squared.
                 */
                setDragY(value: number): Body;

                /**
                 * Sets the Body's gravity.
                 * @param x The horizontal component, in pixels per second squared.
                 * @param y The vertical component, in pixels per second squared.
                 */
                setGravity(x: number, y: number): Body;

                /**
                 * Sets the Body's horizontal gravity.
                 * @param value The gravity, in pixels per second squared.
                 */
                setGravityX(value: number): Body;

                /**
                 * Sets the Body's vertical gravity.
                 * @param value The gravity, in pixels per second squared.
                 */
                setGravityY(value: number): Body;

                /**
                 * Sets the Body's friction.
                 * @param x The horizontal component, relative to 1.
                 * @param y The vertical component, relative to 1.
                 */
                setFriction(x: number, y: number): Body;

                /**
                 * Sets the Body's horizontal friction.
                 * @param value The friction value, relative to 1.
                 */
                setFrictionX(value: number): Body;

                /**
                 * Sets the Body's vertical friction.
                 * @param value The friction value, relative to 1.
                 */
                setFrictionY(value: number): Body;

                /**
                 * Sets the Body's angular velocity.
                 * @param value The velocity, in degrees per second.
                 */
                setAngularVelocity(value: number): Body;

                /**
                 * Sets the Body's angular acceleration.
                 * @param value The acceleration, in degrees per second squared.
                 */
                setAngularAcceleration(value: number): Body;

                /**
                 * Sets the Body's angular drag.
                 * @param value The drag, in degrees per second squared.
                 */
                setAngularDrag(value: number): Body;

                /**
                 * Sets the Body's mass.
                 * @param value The mass value, relative to 1.
                 */
                setMass(value: number): Body;

                /**
                 * Sets the Body's `immovable` property.
                 * @param value The value to assign to `immovable`. Default true.
                 */
                setImmovable(value?: boolean): Body;

                /**
                 * Sets the Body's `enable` property.
                 * @param value The value to assign to `enable`. Default true.
                 */
                setEnable(value?: boolean): Body;

                /**
                 * The Body's horizontal position (left edge).
                 */
                x: number;

                /**
                 * The Body's vertical position (top edge).
                 */
                y: number;

                /**
                 * The left edge of the Body's boundary. Identical to x.
                 */
                readonly left: number;

                /**
                 * The right edge of the Body's boundary.
                 */
                readonly right: number;

                /**
                 * The top edge of the Body's boundary. Identical to y.
                 */
                readonly top: number;

                /**
                 * The bottom edge of this Body's boundary.
                 */
                readonly bottom: number;
            }

            /**
             * An Arcade Physics Collider will automatically check for collision, or overlaps, between two objects
             * every step. If a collision, or overlap, occurs it will invoke the given callbacks.
             */
            class Collider {
                /**
                 *
                 * @param world The Arcade physics World that will manage the collisions.
                 * @param overlapOnly Whether to check for collisions or overlap.
                 * @param object1 The first object to check for collision.
                 * @param object2 The second object to check for collision.
                 * @param collideCallback The callback to invoke when the two objects collide.
                 * @param processCallback The callback to invoke when the two objects collide. Must return a boolean.
                 * @param callbackContext The scope in which to call the callbacks.
                 */
                constructor(
                    world: World,
                    overlapOnly: boolean,
                    object1: ArcadeColliderType,
                    object2: ArcadeColliderType,
                    collideCallback: ArcadePhysicsCallback,
                    processCallback: ArcadePhysicsCallback,
                    callbackContext: any
                );

                /**
                 * The world in which the bodies will collide.
                 */
                world: World;

                /**
                 * The name of the collider (unused by Phaser).
                 */
                name: string;

                /**
                 * Whether the collider is active.
                 */
                active: boolean;

                /**
                 * Whether to check for collisions or overlaps.
                 */
                overlapOnly: boolean;

                /**
                 * The first object to check for collision.
                 */
                object1: ArcadeColliderType;

                /**
                 * The second object to check for collision.
                 */
                object2: ArcadeColliderType;

                /**
                 * The callback to invoke when the two objects collide.
                 */
                collideCallback: ArcadePhysicsCallback;

                /**
                 * If a processCallback exists it must return true or collision checking will be skipped.
                 */
                processCallback: ArcadePhysicsCallback;

                /**
                 * The context the collideCallback and processCallback will run in.
                 */
                callbackContext: object;

                /**
                 * A name for the Collider.
                 *
                 * Phaser does not use this value, it's for your own reference.
                 * @param name The name to assign to the Collider.
                 */
                setName(name: string): Collider;

                /**
                 * Called by World as part of its step processing, initial operation of collision checking.
                 */
                update(): void;

                /**
                 * Removes Collider from World and disposes of its resources.
                 */
                destroy(): void;
            }

            namespace Components {
                /**
                 * Provides methods used for setting the acceleration properties of an Arcade Physics Body.
                 */
                interface Acceleration {
                    /**
                     * Sets the body's horizontal and vertical acceleration.
                     * If the vertical acceleration value is not provided, the vertical acceleration is set to the same value as the horizontal acceleration.
                     * @param x The horizontal acceleration
                     * @param y The vertical acceleration Default x.
                     */
                    setAcceleration(x: number, y?: number): this;
                    /**
                     * Sets the body's horizontal acceleration.
                     * @param value The horizontal acceleration
                     */
                    setAccelerationX(value: number): this;
                    /**
                     * Sets the body's vertical acceleration.
                     * @param value The vertical acceleration
                     */
                    setAccelerationY(value: number): this;
                }

                /**
                 * Provides methods used for setting the angular acceleration properties of an Arcade Physics Body.
                 */
                interface Angular {
                    /**
                     * Sets the angular velocity of the body.
                     *
                     * In Arcade Physics, bodies cannot rotate. They are always axis-aligned.
                     * However, they can have angular motion, which is passed on to the Game Object bound to the body,
                     * causing them to visually rotate, even though the body remains axis-aligned.
                     * @param value The amount of angular velocity.
                     */
                    setAngularVelocity(value: number): this;
                    /**
                     * Sets the angular acceleration of the body.
                     *
                     * In Arcade Physics, bodies cannot rotate. They are always axis-aligned.
                     * However, they can have angular motion, which is passed on to the Game Object bound to the body,
                     * causing them to visually rotate, even though the body remains axis-aligned.
                     * @param value The amount of angular acceleration.
                     */
                    setAngularAcceleration(value: number): this;
                    /**
                     * Sets the angular drag of the body. Drag is applied to the current velocity, providing a form of deceleration.
                     * @param value The amount of drag.
                     */
                    setAngularDrag(value: number): this;
                }

                /**
                 * Provides methods used for setting the bounce properties of an Arcade Physics Body.
                 */
                interface Bounce {
                    /**
                     * Sets the bounce values of this body.
                     *
                     * Bounce is the amount of restitution, or elasticity, the body has when it collides with another object.
                     * A value of 1 means that it will retain its full velocity after the rebound. A value of 0 means it will not rebound at all.
                     * @param x The amount of horizontal bounce to apply on collision. A float, typically between 0 and 1.
                     * @param y The amount of vertical bounce to apply on collision. A float, typically between 0 and 1. Default x.
                     */
                    setBounce(x: number, y?: number): this;
                    /**
                     * Sets the horizontal bounce value for this body.
                     * @param value The amount of horizontal bounce to apply on collision. A float, typically between 0 and 1.
                     */
                    setBounceX(value: number): this;
                    /**
                     * Sets the vertical bounce value for this body.
                     * @param value The amount of vertical bounce to apply on collision. A float, typically between 0 and 1.
                     */
                    setBounceY(value: number): this;
                    /**
                     * Sets if this body should collide with the world bounds or not.
                     * @param value `true` if this body should collide with the world bounds, otherwise `false`.
                     */
                    setCollideWorldBounds(value: boolean): this;
                }

                /**
                 * Provides methods used for setting the debug properties of an Arcade Physics Body.
                 */
                interface Debug {
                    /**
                     * Sets the debug values of this body.
                     *
                     * Bodies will only draw their debug if debug has been enabled for Arcade Physics as a whole.
                     * Note that there is a performance cost in drawing debug displays. It should never be used in production.
                     * @param showBody Set to `true` to have this body render its outline to the debug display.
                     * @param showVelocity Set to `true` to have this body render a velocity marker to the debug display.
                     * @param bodyColor The color of the body outline when rendered to the debug display.
                     */
                    setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): this;
                    /**
                     * Sets the color of the body outline when it renders to the debug display.
                     * @param value The color of the body outline when rendered to the debug display.
                     */
                    setDebugBodyColor(value: number): this;
                    /**
                     * Set to `true` to have this body render its outline to the debug display.
                     */
                    debugShowBody: boolean;
                    /**
                     * Set to `true` to have this body render a velocity marker to the debug display.
                     */
                    debugShowVelocity: boolean;
                    /**
                     * The color of the body outline when it renders to the debug display.
                     */
                    debugBodyColor: number;
                }

                /**
                 * Provides methods used for setting the drag properties of an Arcade Physics Body.
                 */
                interface Drag {
                    /**
                     * Sets the body's horizontal and vertical drag. If the vertical drag value is not provided, the vertical drag is set to the same value as the horizontal drag.
                     *
                     * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
                     * It is the absolute loss of velocity due to movement, in pixels per second squared.
                     * The x and y components are applied separately.
                     *
                     * When `useDamping` is true, this is 1 minus the damping factor.
                     * A value of 1 means the Body loses no velocity.
                     * A value of 0.95 means the Body loses 5% of its velocity per step.
                     * A value of 0.5 means the Body loses 50% of its velocity per step.
                     *
                     * Drag is applied only when `acceleration` is zero.
                     * @param x The amount of horizontal drag to apply.
                     * @param y The amount of vertical drag to apply. Default x.
                     */
                    setDrag(x: number, y?: number): this;
                    /**
                     * Sets the body's horizontal drag.
                     *
                     * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
                     * It is the absolute loss of velocity due to movement, in pixels per second squared.
                     * The x and y components are applied separately.
                     *
                     * When `useDamping` is true, this is 1 minus the damping factor.
                     * A value of 1 means the Body loses no velocity.
                     * A value of 0.95 means the Body loses 5% of its velocity per step.
                     * A value of 0.5 means the Body loses 50% of its velocity per step.
                     *
                     * Drag is applied only when `acceleration` is zero.
                     * @param value The amount of horizontal drag to apply.
                     */
                    setDragX(value: number): this;
                    /**
                     * Sets the body's vertical drag.
                     *
                     * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.
                     * It is the absolute loss of velocity due to movement, in pixels per second squared.
                     * The x and y components are applied separately.
                     *
                     * When `useDamping` is true, this is 1 minus the damping factor.
                     * A value of 1 means the Body loses no velocity.
                     * A value of 0.95 means the Body loses 5% of its velocity per step.
                     * A value of 0.5 means the Body loses 50% of its velocity per step.
                     *
                     * Drag is applied only when `acceleration` is zero.
                     * @param value The amount of vertical drag to apply.
                     */
                    setDragY(value: number): this;
                    /**
                     * If this Body is using `drag` for deceleration this function controls how the drag is applied.
                     * If set to `true` drag will use a damping effect rather than a linear approach. If you are
                     * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in
                     * the game Asteroids) then you will get a far smoother and more visually correct deceleration
                     * by using damping, avoiding the axis-drift that is prone with linear deceleration.
                     *
                     * If you enable this property then you should use far smaller `drag` values than with linear, as
                     * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow
                     * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.
                     * @param value `true` to use damping for deceleration, or `false` to use linear deceleration.
                     */
                    setDamping(value: boolean): this;
                }

                /**
                 * Provides methods used for setting the enable properties of an Arcade Physics Body.
                 */
                interface Enable {
                    /**
                     * Enables this Game Object's Body.
                     * @param reset Also reset the Body and place it at (x, y).
                     * @param x The horizontal position to place the Game Object and Body.
                     * @param y The horizontal position to place the Game Object and Body.
                     * @param enableGameObject Also activate this Game Object.
                     * @param showGameObject Also show this Game Object.
                     */
                    enableBody(reset: boolean, x: number, y: number, enableGameObject: boolean, showGameObject: boolean): this;
                    /**
                     * Stops and disables this Game Object's Body.
                     * @param disableGameObject Also deactivate this Game Object. Default false.
                     * @param hideGameObject Also hide this Game Object. Default false.
                     */
                    disableBody(disableGameObject?: boolean, hideGameObject?: boolean): this;
                    /**
                     * Syncs the Body's position and size with its parent Game Object.
                     * You don't need to call this for Dynamic Bodies, as it happens automatically.
                     * But for Static bodies it's a useful way of modifying the position of a Static Body
                     * in the Physics World, based on its Game Object.
                     */
                    refreshBody(): this;
                }

                /**
                 * Sets the friction (e.g. the amount of velocity reduced over time) of the physics body when moving horizontally in the X axis.
                 * The higher than friction, the faster the body will slow down once force stops being applied to it.
                 */
                interface Friction {
                    /**
                     * Sets the friction (e.g. the amount of velocity reduced over time) of the physics body when moving.
                     * The higher than friction, the faster the body will slow down once force stops being applied to it.
                     * @param x The amount of horizontal friction to apply.
                     * @param y The amount of vertical friction to apply. Default x.
                     */
                    setFriction(x: number, y?: number): this;
                    /**
                     * Sets the friction (e.g. the amount of velocity reduced over time) of the physics body when moving horizontally in the X axis.
                     * The higher than friction, the faster the body will slow down once force stops being applied to it.
                     * @param x The amount of friction to apply.
                     */
                    setFrictionX(x: number): this;
                    /**
                     * Sets the friction (e.g. the amount of velocity reduced over time) of the physics body when moving vertically in the Y axis.
                     * The higher than friction, the faster the body will slow down once force stops being applied to it.
                     * @param x The amount of friction to apply.
                     */
                    setFrictionY(x: number): this;
                }

                /**
                 * Provides methods for setting the gravity properties of an Arcade Physics Game Object.
                 * Should be applied as a mixin and not used directly.
                 */
                interface Gravity {
                    /**
                     * Set the X and Y values of the gravitational pull to act upon this Arcade Physics Game Object. Values can be positive or negative. Larger values result in a stronger effect.
                     *
                     * If only one value is provided, this value will be used for both the X and Y axis.
                     * @param x The gravitational force to be applied to the X-axis.
                     * @param y The gravitational force to be applied to the Y-axis. If this is not specified, the X value will be used. Default x.
                     */
                    setGravity(x: number, y?: number): this;
                    /**
                     * Set the gravitational force to be applied to the X axis. Value can be positive or negative. Larger values result in a stronger effect.
                     * @param x The gravitational force to be applied to the X-axis.
                     */
                    setGravityX(x: number): this;
                    /**
                     * Set the gravitational force to be applied to the Y axis. Value can be positive or negative. Larger values result in a stronger effect.
                     * @param y The gravitational force to be applied to the Y-axis.
                     */
                    setGravityY(y: number): this;
                }

                /**
                 * Provides methods used for setting the immovable properties of an Arcade Physics Body.
                 */
                interface Immovable {
                    /**
                     * Sets Whether this Body can be moved by collisions with another Body.
                     * @param value Sets if this body can be moved by collisions with another Body. Default true.
                     */
                    setImmovable(value?: boolean): this;
                }

                /**
                 * Provides methods used for setting the mass properties of an Arcade Physics Body.
                 */
                interface Mass {
                    /**
                     * Sets the mass of the physics body
                     * @param value New value for the mass of the body.
                     */
                    setMass(value: number): this;
                }

                /**
                 * Provides methods for setting the size of an Arcade Physics Game Object.
                 * Should be applied as a mixin and not used directly.
                 */
                interface Size {
                    /**
                     * Sets the body offset. This allows you to adjust the difference between the center of the body
                     * and the x and y coordinates of the parent Game Object.
                     * @param x The amount to offset the body from the parent Game Object along the x-axis.
                     * @param y The amount to offset the body from the parent Game Object along the y-axis. Defaults to the value given for the x-axis. Default x.
                     */
                    setOffset(x: number, y?: number): this;
                    /**
                     * Sets the size of this physics body. Setting the size does not adjust the dimensions
                     * of the parent Game Object.
                     * @param width The new width of the physics body, in pixels.
                     * @param height The new height of the physics body, in pixels.
                     * @param center Should the body be re-positioned so its center aligns with the parent Game Object? Default true.
                     */
                    setSize(width: number, height: number, center?: boolean): this;
                    /**
                     * Sets this physics body to use a circle for collision instead of a rectangle.
                     * @param radius The radius of the physics body, in pixels.
                     * @param offsetX The amount to offset the body from the parent Game Object along the x-axis.
                     * @param offsetY The amount to offset the body from the parent Game Object along the y-axis.
                     */
                    setCircle(radius: number, offsetX?: number, offsetY?: number): this;
                }

                /**
                 * Provides methods for modifying the velocity of an Arcade Physics body.
                 *
                 * Should be applied as a mixin and not used directly.
                 */
                interface Velocity {
                    /**
                     * Sets the velocity of the Body.
                     * @param x The horizontal velocity of the body. Positive values move the body to the right, while negative values move it to the left.
                     * @param y The vertical velocity of the body. Positive values move the body down, while negative values move it up. Default x.
                     */
                    setVelocity(x: number, y?: number): this;
                    /**
                     * Sets the horizontal component of the body's velocity.
                     *
                     * Positive values move the body to the right, while negative values move it to the left.
                     * @param x The new horizontal velocity.
                     */
                    setVelocityX(x: number): this;
                    /**
                     * Sets the vertical component of the body's velocity.
                     *
                     * Positive values move the body down, while negative values move it up.
                     * @param y The new vertical velocity of the body.
                     */
                    setVelocityY(y: number): this;
                    /**
                     * Sets the maximum velocity of the body.
                     * @param x The new maximum horizontal velocity.
                     * @param y The new maximum vertical velocity. Default x.
                     */
                    setMaxVelocity(x: number, y?: number): this;
                }
            }

            /**
             * Dynamic Body.
             */
            const DYNAMIC_BODY: number;

            /**
             * Static Body.
             */
            const STATIC_BODY: number;

            /**
             * Arcade Physics Group containing Dynamic Bodies.
             */
            const GROUP: number;

            /**
             * A Tilemap Layer.
             */
            const TILEMAPLAYER: number;

            /**
             * Facing no direction (initial value).
             */
            const FACING_NONE: number;

            /**
             * Facing up.
             */
            const FACING_UP: number;

            /**
             * Facing down.
             */
            const FACING_DOWN: number;

            /**
             * Facing left.
             */
            const FACING_LEFT: number;

            /**
             * Facing right.
             */
            const FACING_RIGHT: number;

            namespace Events {
                /**
                 * The Arcade Physics World Collide Event.
                 *
                 * This event is dispatched by an Arcade Physics World instance if two bodies collide _and_ at least
                 * one of them has their [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.
                 *
                 * It provides an alternative means to handling collide events rather than using the callback approach.
                 *
                 * Listen to it from a Scene using: `this.physics.world.on('collide', listener)`.
                 *
                 * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.
                 */
                const COLLIDE: any;

                /**
                 * The Arcade Physics World Overlap Event.
                 *
                 * This event is dispatched by an Arcade Physics World instance if two bodies overlap _and_ at least
                 * one of them has their [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.
                 *
                 * It provides an alternative means to handling overlap events rather than using the callback approach.
                 *
                 * Listen to it from a Scene using: `this.physics.world.on('overlap', listener)`.
                 *
                 * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.
                 */
                const OVERLAP: any;

                /**
                 * The Arcade Physics World Pause Event.
                 *
                 * This event is dispatched by an Arcade Physics World instance when it is paused.
                 *
                 * Listen to it from a Scene using: `this.physics.world.on('pause', listener)`.
                 */
                const PAUSE: any;

                /**
                 * The Arcade Physics World Resume Event.
                 *
                 * This event is dispatched by an Arcade Physics World instance when it resumes from a paused state.
                 *
                 * Listen to it from a Scene using: `this.physics.world.on('resume', listener)`.
                 */
                const RESUME: any;

                /**
                 * The Arcade Physics Tile Collide Event.
                 *
                 * This event is dispatched by an Arcade Physics World instance if a body collides with a Tile _and_
                 * has its [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.
                 *
                 * It provides an alternative means to handling collide events rather than using the callback approach.
                 *
                 * Listen to it from a Scene using: `this.physics.world.on('tilecollide', listener)`.
                 *
                 * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.
                 */
                const TILE_COLLIDE: any;

                /**
                 * The Arcade Physics Tile Overlap Event.
                 *
                 * This event is dispatched by an Arcade Physics World instance if a body overlaps with a Tile _and_
                 * has its [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.
                 *
                 * It provides an alternative means to handling overlap events rather than using the callback approach.
                 *
                 * Listen to it from a Scene using: `this.physics.world.on('tileoverlap', listener)`.
                 *
                 * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.
                 */
                const TILE_OVERLAP: any;

                /**
                 * The Arcade Physics World Bounds Event.
                 *
                 * This event is dispatched by an Arcade Physics World instance if a body makes contact with the world bounds _and_
                 * it has its [onWorldBounds]{@link Phaser.Physics.Arcade.Body#onWorldBounds} property set to `true`.
                 *
                 * It provides an alternative means to handling collide events rather than using the callback approach.
                 *
                 * Listen to it from a Scene using: `this.physics.world.on('worldbounds', listener)`.
                 */
                const WORLD_BOUNDS: any;
            }

            /**
             * The Arcade Physics Factory allows you to easily create Arcade Physics enabled Game Objects.
             * Objects that are created by this Factory are automatically added to the physics world.
             */
            class Factory {
                /**
                 *
                 * @param world The Arcade Physics World instance.
                 */
                constructor(world: World);

                /**
                 * A reference to the Arcade Physics World.
                 */
                world: World;

                /**
                 * A reference to the Scene this Arcade Physics instance belongs to.
                 */
                scene: Scene;

                /**
                 * A reference to the Scene.Systems this Arcade Physics instance belongs to.
                 */
                sys: Scenes.Systems;

                /**
                 * Creates a new Arcade Physics Collider object.
                 * @param object1 The first object to check for collision.
                 * @param object2 The second object to check for collision.
                 * @param collideCallback The callback to invoke when the two objects collide.
                 * @param processCallback The callback to invoke when the two objects collide. Must return a boolean.
                 * @param callbackContext The scope in which to call the callbacks.
                 */
                collider(
                    object1: GameObjects.GameObject | GameObjects.GameObject[] | GameObjects.Group | GameObjects.Group[],
                    object2: GameObjects.GameObject | GameObjects.GameObject[] | GameObjects.Group | GameObjects.Group[],
                    collideCallback?: ArcadePhysicsCallback,
                    processCallback?: ArcadePhysicsCallback,
                    callbackContext?: any
                ): Collider;

                /**
                 * Creates a new Arcade Physics Collider Overlap object.
                 * @param object1 The first object to check for overlap.
                 * @param object2 The second object to check for overlap.
                 * @param collideCallback The callback to invoke when the two objects collide.
                 * @param processCallback The callback to invoke when the two objects collide. Must return a boolean.
                 * @param callbackContext The scope in which to call the callbacks.
                 */
                overlap(
                    object1: GameObjects.GameObject | GameObjects.GameObject[] | GameObjects.Group | GameObjects.Group[],
                    object2: GameObjects.GameObject | GameObjects.GameObject[] | GameObjects.Group | GameObjects.Group[],
                    collideCallback?: ArcadePhysicsCallback,
                    processCallback?: ArcadePhysicsCallback,
                    callbackContext?: any
                ): Collider;

                /**
                 * Adds an Arcade Physics Body to the given Game Object.
                 * @param gameObject A Game Object.
                 * @param isStatic Create a Static body (true) or Dynamic body (false). Default false.
                 */
                existing(gameObject: GameObjects.GameObject, isStatic?: boolean): GameObjects.GameObject;

                /**
                 * Creates a new Arcade Image object with a Static body.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                staticImage(x: number, y: number, texture: string, frame?: string | integer): Image;

                /**
                 * Creates a new Arcade Image object with a Dynamic body.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                image(x: number, y: number, texture: string, frame?: string | integer): Image;

                /**
                 * Creates a new Arcade Sprite object with a Static body.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                staticSprite(x: number, y: number, texture: string, frame?: string | integer): Sprite;

                /**
                 * Creates a new Arcade Sprite object with a Dynamic body.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                sprite(x: number, y: number, key: string, frame?: string | integer): Sprite;

                /**
                 * Creates a Static Physics Group object.
                 * All Game Objects created by this Group will automatically be static Arcade Physics objects.
                 * @param children Game Objects to add to this group; or the `config` argument.
                 * @param config Settings for this group.
                 */
                staticGroup(children?: GameObjects.GameObject[] | GroupConfig | GroupCreateConfig, config?: GroupConfig | GroupCreateConfig): StaticGroup;

                /**
                 * Creates a Physics Group object.
                 * All Game Objects created by this Group will automatically be dynamic Arcade Physics objects.
                 * @param children Game Objects to add to this group; or the `config` argument.
                 * @param config Settings for this group.
                 */
                group(children?: GameObjects.GameObject[] | PhysicsGroupConfig | GroupCreateConfig, config?: PhysicsGroupConfig | GroupCreateConfig): Group;

                /**
                 * Destroys this Factory.
                 */
                destroy(): void;
            }

            /**
             * Calculates and returns the horizontal overlap between two arcade physics bodies and sets their properties
             * accordingly, including: `touching.left`, `touching.right`, `touching.none` and `overlapX'.
             * @param body1 The first Body to separate.
             * @param body2 The second Body to separate.
             * @param overlapOnly Is this an overlap only check, or part of separation?
             * @param bias A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).
             */
            function GetOverlapX(body1: Body, body2: Body, overlapOnly: boolean, bias: number): number;

            /**
             * Calculates and returns the vertical overlap between two arcade physics bodies and sets their properties
             * accordingly, including: `touching.up`, `touching.down`, `touching.none` and `overlapY'.
             * @param body1 The first Body to separate.
             * @param body2 The second Body to separate.
             * @param overlapOnly Is this an overlap only check, or part of separation?
             * @param bias A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).
             */
            function GetOverlapY(body1: Body, body2: Body, overlapOnly: boolean, bias: number): number;

            /**
             * An Arcade Physics Group object.
             *
             * All Game Objects created by this Group will automatically be given dynamic Arcade Physics bodies.
             *
             * Its static counterpart is {@link Phaser.Physics.Arcade.StaticGroup}.
             */
            class Group extends GameObjects.Group {
                /**
                 *
                 * @param world The physics simulation.
                 * @param scene The scene this group belongs to.
                 * @param children Game Objects to add to this group; or the `config` argument.
                 * @param config Settings for this group.
                 */
                constructor(
                    world: World,
                    scene: Scene,
                    children?: GameObjects.GameObject[] | PhysicsGroupConfig | GroupCreateConfig,
                    config?: PhysicsGroupConfig | GroupCreateConfig
                );

                /**
                 * The physics simulation.
                 */
                world: World;

                /**
                 * The class to create new Group members from.
                 *
                 * This should be either `Phaser.Physics.Arcade.Image`, `Phaser.Physics.Arcade.Sprite`, or a class extending one of those.
                 */
                classinterface: GroupClassinterfaceConstructor;

                /**
                 * The physics interface of the Group's members.
                 */
                physicsinterface: integer;

                /**
                 * Default physics properties applied to Game Objects added to the Group or created by the Group. Derived from the `config` argument.
                 */
                defaults: PhysicsGroupDefaults;

                /**
                 * Enables a Game Object's Body and assigns `defaults`. Called when a Group member is added or created.
                 * @param child The Game Object being added.
                 */
                createCallbackHandler(child: GameObjects.GameObject): void;

                /**
                 * Disables a Game Object's Body. Called when a Group member is removed.
                 * @param child The Game Object being removed.
                 */
                removeCallbackHandler(child: GameObjects.GameObject): void;

                /**
                 * Sets the velocity of each Group member.
                 * @param x The horizontal velocity.
                 * @param y The vertical velocity.
                 * @param step The velocity increment. When set, the first member receives velocity (x, y), the second (x + step, y + step), and so on. Default 0.
                 */
                setVelocity(x: number, y: number, step?: number): Group;

                /**
                 * Sets the horizontal velocity of each Group member.
                 * @param value The velocity value.
                 * @param step The velocity increment. When set, the first member receives velocity (x), the second (x + step), and so on. Default 0.
                 */
                setVelocityX(value: number, step?: number): Group;

                /**
                 * Sets the vertical velocity of each Group member.
                 * @param value The velocity value.
                 * @param step The velocity increment. When set, the first member receives velocity (y), the second (y + step), and so on. Default 0.
                 */
                setVelocityY(value: number, step?: number): Group;
            }

            /**
             * Separates two overlapping bodies on the X-axis (horizontally).
             *
             * Separation involves moving two overlapping bodies so they don't overlap anymore and adjusting their velocities based on their mass. This is a core part of collision detection.
             *
             * The bodies won't be separated if there is no horizontal overlap between them, if they are static, or if either one uses custom logic for its separation.
             * @param body1 The first Body to separate.
             * @param body2 The second Body to separate.
             * @param overlapOnly If `true`, the bodies will only have their overlap data set and no separation will take place.
             * @param bias A value to add to the delta value during overlap checking. Used to prevent sprite tunneling.
             */
            function SeparateX(body1: Body, body2: Body, overlapOnly: boolean, bias: number): boolean;

            /**
             * Separates two overlapping bodies on the Y-axis (vertically).
             *
             * Separation involves moving two overlapping bodies so they don't overlap anymore and adjusting their velocities based on their mass. This is a core part of collision detection.
             *
             * The bodies won't be separated if there is no vertical overlap between them, if they are static, or if either one uses custom logic for its separation.
             * @param body1 The first Body to separate.
             * @param body2 The second Body to separate.
             * @param overlapOnly If `true`, the bodies will only have their overlap data set and no separation will take place.
             * @param bias A value to add to the delta value during overlap checking. Used to prevent sprite tunneling.
             */
            function SeparateY(body1: Body, body2: Body, overlapOnly: boolean, bias: number): boolean;

            /**
             * A Static Arcade Physics Body.
             *
             * A Static Body never moves, and isn't automatically synchronized with its parent Game Object.
             * That means if you make any change to the parent's origin, position, or scale after creating or adding the body, you'll need to update the Body manually.
             *
             * A Static Body can collide with other Bodies, but is never moved by collisions.
             *
             * Its dynamic counterpart is {@link Phaser.Physics.Arcade.Body}.
             */
            class StaticBody {
                /**
                 *
                 * @param world The Arcade Physics simulation this Static Body belongs to.
                 * @param gameObject The Game Object this Static Body belongs to.
                 */
                constructor(world: World, gameObject: GameObjects.GameObject);

                /**
                 * The Arcade Physics simulation this Static Body belongs to.
                 */
                world: World;

                /**
                 * The Game Object this Static Body belongs to.
                 */
                gameObject: GameObjects.GameObject;

                /**
                 * Whether the Static Body's boundary is drawn to the debug display.
                 */
                debugShowBody: boolean;

                /**
                 * The color of this Static Body on the debug display.
                 */
                debugBodyColor: integer;

                /**
                 * Whether this Static Body is updated by the physics simulation.
                 */
                enable: boolean;

                /**
                 * Whether this Static Body's boundary is circular (`true`) or rectangular (`false`).
                 */
                isCircle: boolean;

                /**
                 * If this Static Body is circular, this is the unscaled radius of the Static Body's boundary, as set by {@link #setCircle}, in source pixels.
                 * The true radius is equal to `halfWidth`.
                 */
                radius: number;

                /**
                 * The offset of this Static Body's actual position from any updated position.
                 *
                 * Unlike a dynamic Body, a Static Body does not follow its Game Object. As such, this offset is only applied when resizing the Static Body.
                 */
                offset: Math.Vector2;

                /**
                 * The position of this Static Body within the simulation.
                 */
                position: Math.Vector2;

                /**
                 * The width of the Static Body's boundary, in pixels.
                 * If the Static Body is circular, this is also the Static Body's diameter.
                 */
                width: number;

                /**
                 * The height of the Static Body's boundary, in pixels.
                 * If the Static Body is circular, this is also the Static Body's diameter.
                 */
                height: number;

                /**
                 * Half the Static Body's width, in pixels.
                 * If the Static Body is circular, this is also the Static Body's radius.
                 */
                halfWidth: number;

                /**
                 * Half the Static Body's height, in pixels.
                 * If the Static Body is circular, this is also the Static Body's radius.
                 */
                halfHeight: number;

                /**
                 * The center of the Static Body's boundary.
                 * This is the midpoint of its `position` (top-left corner) and its bottom-right corner.
                 */
                center: Math.Vector2;

                /**
                 * A constant zero velocity used by the Arcade Physics simulation for calculations.
                 */
                readonly velocity: Math.Vector2;

                /**
                 * A constant `false` value expected by the Arcade Physics simulation.
                 */
                readonly allowGravity: boolean;

                /**
                 * Gravitational force applied specifically to this Body. Values are in pixels per second squared. Always zero for a Static Body.
                 */
                readonly gravity: Math.Vector2;

                /**
                 * Rebound, or restitution, following a collision, relative to 1. Always zero for a Static Body.
                 */
                readonly bounce: Math.Vector2;

                /**
                 * Whether the simulation emits a `worldbounds` event when this StaticBody collides with the world boundary.
                 * Always false for a Static Body. (Static Bodies never collide with the world boundary and never trigger a `worldbounds` event.)
                 */
                readonly onWorldBounds: boolean;

                /**
                 * Whether the simulation emits a `collide` event when this StaticBody collides with another.
                 */
                onCollide: boolean;

                /**
                 * Whether the simulation emits an `overlap` event when this StaticBody overlaps with another.
                 */
                onOverlap: boolean;

                /**
                 * The StaticBody's inertia, relative to a default unit (1). With `bounce`, this affects the exchange of momentum (velocities) during collisions.
                 */
                mass: number;

                /**
                 * Whether this object can be moved by collisions with another body.
                 */
                immovable: boolean;

                /**
                 * A flag disabling the default horizontal separation of colliding bodies. Pass your own `collideHandler` to the collider.
                 */
                customSeparateX: boolean;

                /**
                 * A flag disabling the default vertical separation of colliding bodies. Pass your own `collideHandler` to the collider.
                 */
                customSeparateY: boolean;

                /**
                 * The amount of horizontal overlap (before separation), if this Body is colliding with another.
                 */
                overlapX: number;

                /**
                 * The amount of vertical overlap (before separation), if this Body is colliding with another.
                 */
                overlapY: number;

                /**
                 * The amount of overlap (before separation), if this StaticBody is circular and colliding with another circular body.
                 */
                overlapR: number;

                /**
                 * Whether this StaticBody has ever overlapped with another while both were not moving.
                 */
                embedded: boolean;

                /**
                 * Whether this StaticBody interacts with the world boundary.
                 * Always false for a Static Body. (Static Bodies never collide with the world boundary.)
                 */
                readonly collideWorldBounds: boolean;

                /**
                 * Whether this StaticBody is checked for collisions and for which directions. You can set `checkCollision.none = false` to disable collision checks.
                 */
                checkCollision: ArcadeBodyCollision;

                /**
                 * Whether this StaticBody has ever collided with another body and in which direction.
                 */
                touching: ArcadeBodyCollision;

                /**
                 * Whether this StaticBody was colliding with another body during the last step or any previous step, and in which direction.
                 */
                wasTouching: ArcadeBodyCollision;

                /**
                 * Whether this StaticBody has ever collided with a tile or the world boundary.
                 */
                blocked: ArcadeBodyCollision;

                /**
                 * The StaticBody's physics interface (static by default).
                 */
                physicsinterface: integer;

                /**
                 * Changes the Game Object this Body is bound to.
                 * First it removes its reference from the old Game Object, then sets the new one.
                 * You can optionally update the position and dimensions of this Body to reflect that of the new Game Object.
                 * @param gameObject The new Game Object that will own this Body.
                 * @param update Reposition and resize this Body to match the new Game Object? Default true.
                 */
                setGameObject(gameObject: GameObjects.GameObject, update?: boolean): StaticBody;

                /**
                 * Updates this Static Body so that its position and dimensions are updated
                 * based on the current Game Object it is bound to.
                 */
                updateFromGameObject(): StaticBody;

                /**
                 * Sets the offset of the body.
                 * @param x The horizontal offset of the Body from the Game Object's center.
                 * @param y The vertical offset of the Body from the Game Object's center.
                 */
                setOffset(x: number, y: number): StaticBody;

                /**
                 * Sets the size of the body.
                 * Resets the width and height to match current frame, if no width and height provided and a frame is found.
                 * @param width The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.
                 * @param height The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.
                 * @param offsetX The horizontal offset of the Body from the Game Object's center.
                 * @param offsetY The vertical offset of the Body from the Game Object's center.
                 */
                setSize(width?: integer, height?: integer, offsetX?: number, offsetY?: number): StaticBody;

                /**
                 * Sets this Static Body to have a circular body and sets its sizes and position.
                 * @param radius The radius of the StaticBody, in pixels.
                 * @param offsetX The horizontal offset of the StaticBody from its Game Object, in pixels.
                 * @param offsetY The vertical offset of the StaticBody from its Game Object, in pixels.
                 */
                setCircle(radius: number, offsetX?: number, offsetY?: number): StaticBody;

                /**
                 * Updates the StaticBody's `center` from its `position` and dimensions.
                 */
                updateCenter(): void;

                /**
                 * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.
                 * Similar to `updateFromGameObject`, but doesn't modify the Body's dimensions.
                 * @param x The x coordinate to reset the body to. If not given will use the parent Game Object's coordinate.
                 * @param y The y coordinate to reset the body to. If not given will use the parent Game Object's coordinate.
                 */
                reset(x?: number, y?: number): void;

                /**
                 * NOOP function. A Static Body cannot be stopped.
                 */
                stop(): StaticBody;

                /**
                 * Returns the x and y coordinates of the top left and bottom right points of the StaticBody.
                 * @param obj The object which will hold the coordinates of the bounds.
                 */
                getBounds(obj: ArcadeBodyBounds): ArcadeBodyBounds;

                /**
                 * Checks to see if a given x,y coordinate is colliding with this Static Body.
                 * @param x The x coordinate to check against this body.
                 * @param y The y coordinate to check against this body.
                 */
                hitTest(x: number, y: number): boolean;

                /**
                 * NOOP
                 */
                postUpdate(): void;

                /**
                 * The absolute (non-negative) change in this StaticBody's horizontal position from the previous step. Always zero.
                 */
                deltaAbsX(): number;

                /**
                 * The absolute (non-negative) change in this StaticBody's vertical position from the previous step. Always zero.
                 */
                deltaAbsY(): number;

                /**
                 * The change in this StaticBody's horizontal position from the previous step. Always zero.
                 */
                deltaX(): number;

                /**
                 * The change in this StaticBody's vertical position from the previous step. Always zero.
                 */
                deltaY(): number;

                /**
                 * The change in this StaticBody's rotation from the previous step. Always zero.
                 */
                deltaZ(): number;

                /**
                 * Disables this Body and marks it for destruction during the next step.
                 */
                destroy(): void;

                /**
                 * Draws a graphical representation of the StaticBody for visual debugging purposes.
                 * @param graphic The Graphics object to use for the debug drawing of the StaticBody.
                 */
                drawDebug(graphic: GameObjects.Graphics): void;

                /**
                 * Indicates whether the StaticBody is going to be showing a debug visualization during postUpdate.
                 */
                willDrawDebug(): boolean;

                /**
                 * Sets the Mass of the StaticBody. Will set the Mass to 0.1 if the value passed is less than or equal to zero.
                 * @param value The value to set the Mass to. Values of zero or less are changed to 0.1.
                 */
                setMass(value: number): StaticBody;

                /**
                 * The x coordinate of the StaticBody.
                 */
                x: number;

                /**
                 * The y coordinate of the StaticBody.
                 */
                y: number;

                /**
                 * Returns the left-most x coordinate of the area of the StaticBody.
                 */
                readonly left: number;

                /**
                 * The right-most x coordinate of the area of the StaticBody.
                 */
                readonly right: number;

                /**
                 * The highest y coordinate of the area of the StaticBody.
                 */
                readonly top: number;

                /**
                 * The lowest y coordinate of the area of the StaticBody. (y + height)
                 */
                readonly bottom: number;
            }

            /**
             * An Arcade Physics Static Group object.
             *
             * All Game Objects created by this Group will automatically be given static Arcade Physics bodies.
             *
             * Its dynamic counterpart is {@link Phaser.Physics.Arcade.Group}.
             */
            class StaticGroup extends GameObjects.Group {
                /**
                 *
                 * @param world The physics simulation.
                 * @param scene The scene this group belongs to.
                 * @param children Game Objects to add to this group; or the `config` argument.
                 * @param config Settings for this group.
                 */
                constructor(
                    world: World,
                    scene: Scene,
                    children?: GameObjects.GameObject[] | GroupConfig | GroupCreateConfig,
                    config?: GroupConfig | GroupCreateConfig
                );

                /**
                 * The physics simulation.
                 */
                world: World;

                /**
                 * The scene this group belongs to.
                 */
                physicsinterface: integer;

                /**
                 * Adds a static physics body to the new group member (if it lacks one) and adds it to the simulation.
                 * @param child The new group member.
                 */
                createCallbackHandler(child: GameObjects.GameObject): void;

                /**
                 * Disables the group member's physics body, removing it from the simulation.
                 * @param child The group member being removed.
                 */
                removeCallbackHandler(child: GameObjects.GameObject): void;

                /**
                 * Refreshes the group.
                 * @param entries The newly created group members.
                 */
                createMultipleCallbackHandler(entries: GameObjects.GameObject[]): void;

                /**
                 * Resets each Body to the position of its parent Game Object.
                 * Body sizes aren't changed (use {@link Phaser.Physics.Arcade.Components.Enable#refreshBody} for that).
                 */
                refresh(): StaticGroup;
            }

            namespace Tilemap {
                /**
                 * A function to process the collision callbacks between a single tile and an Arcade Physics enabled Game Object.
                 * @param tile The Tile to process.
                 * @param sprite The Game Object to process with the Tile.
                 */
                function ProcessTileCallbacks(tile: Tilemaps.Tile, sprite: GameObjects.Sprite): boolean;

                /**
                 * Internal function to process the separation of a physics body from a tile.
                 * @param body The Body object to separate.
                 * @param x The x separation amount.
                 */
                function ProcessTileSeparationX(body: Body, x: number): void;

                /**
                 * Internal function to process the separation of a physics body from a tile.
                 * @param body The Body object to separate.
                 * @param y The y separation amount.
                 */
                function ProcessTileSeparationY(body: Body, y: number): void;

                /**
                 * The core separation function to separate a physics body and a tile.
                 * @param i The index of the tile within the map data.
                 * @param body The Body object to separate.
                 * @param tile The tile to collide against.
                 * @param tileWorldRect A rectangle-like object defining the dimensions of the tile.
                 * @param tilemapLayer The tilemapLayer to collide against.
                 * @param tileBias The tile bias value. Populated by the `World.TILE_BIAS` constant.
                 */
                function SeparateTile(
                    i: number,
                    body: Body,
                    tile: Tilemaps.Tile,
                    tileWorldRect: Geom.Rectangle,
                    tilemapLayer: Tilemaps.DynamicTilemapLayer | Tilemaps.StaticTilemapLayer,
                    tileBias: number
                ): boolean;

                /**
                 * Check the body against the given tile on the X axis.
                 * Used internally by the SeparateTile function.
                 * @param body The Body object to separate.
                 * @param tile The tile to check.
                 * @param tileLeft The left position of the tile within the tile world.
                 * @param tileRight The right position of the tile within the tile world.
                 * @param tileBias The tile bias value. Populated by the `World.TILE_BIAS` constant.
                 */
                function TileCheckX(body: Body, tile: Tilemaps.Tile, tileLeft: number, tileRight: number, tileBias: number): number;

                /**
                 * Check the body against the given tile on the Y axis.
                 * Used internally by the SeparateTile function.
                 * @param body The Body object to separate.
                 * @param tile The tile to check.
                 * @param tileTop The top position of the tile within the tile world.
                 * @param tileBottom The bottom position of the tile within the tile world.
                 * @param tileBias The tile bias value. Populated by the `World.TILE_BIAS` constant.
                 */
                function TileCheckY(body: Body, tile: Tilemaps.Tile, tileTop: number, tileBottom: number, tileBias: number): number;

                /**
                 * Checks for intersection between the given tile rectangle-like object and an Arcade Physics body.
                 * @param tileWorldRect A rectangle object that defines the tile placement in the world.
                 * @param body The body to check for intersection against.
                 */
                function TileIntersectsBody(tileWorldRect: object, body: Body): boolean;
            }

            /**
             * The Arcade Physics World.
             *
             * The World is responsible for creating, managing, colliding and updating all of the bodies within it.
             *
             * An instance of the World belongs to a Phaser.Scene and is accessed via the property `physics.world`.
             */
            class World extends Phaser.Events.EventEmitter {
                /**
                 *
                 * @param scene The Scene to which this World instance belongs.
                 * @param config An Arcade Physics Configuration object.
                 */
                constructor(scene: Scene, config: ArcadeWorldConfig);

                /**
                 * The Scene this simulation belongs to.
                 */
                scene: Scene;

                /**
                 * Dynamic Bodies in this simulation.
                 */
                bodies: Structs.Set<Body>;

                /**
                 * Static Bodies in this simulation.
                 */
                staticBodies: Structs.Set<StaticBody>;

                /**
                 * Static Bodies marked for deletion.
                 */
                pendingDestroy: Structs.Set<Body | StaticBody>;

                /**
                 * This simulation's collision processors.
                 */
                colliders: Structs.ProcessQueue<Collider>;

                /**
                 * Acceleration of Bodies due to gravity, in pixels per second.
                 */
                gravity: Math.Vector2;

                /**
                 * A boundary constraining Bodies.
                 */
                bounds: Geom.Rectangle;

                /**
                 * The boundary edges that Bodies can collide with.
                 */
                checkCollision: CheckCollisionObject;

                /**
                 * The number of physics steps to be taken per second.
                 *
                 * This property is read-only. Use the `setFPS` method to modify it at run-time.
                 */
                readonly fps: number;

                /**
                 * The number of steps that took place in the last frame.
                 */
                readonly stepsLastFrame: number;

                /**
                 * Scaling factor applied to the frame rate.
                 *
                 * - 1.0 = normal speed
                 * - 2.0 = half speed
                 * - 0.5 = double speed
                 */
                timeScale: any;

                /**
                 * The maximum absolute difference of a Body's per-step velocity and its overlap with another Body that will result in separation on *each axis*.
                 * Larger values favor separation.
                 * Smaller values favor no separation.
                 */
                OVERLAP_BIAS: number;

                /**
                 * The maximum absolute value of a Body's overlap with a tile that will result in separation on *each axis*.
                 * Larger values favor separation.
                 * Smaller values favor no separation.
                 * The optimum value may be similar to the tile size.
                 */
                TILE_BIAS: number;

                /**
                 * Always separate overlapping Bodies horizontally before vertically.
                 * False (the default) means Bodies are first separated on the axis of greater gravity, or the vertical axis if neither is greater.
                 */
                forceX: boolean;

                /**
                 * Whether the simulation advances with the game loop.
                 */
                isPaused: boolean;

                /**
                 * Enables the debug display.
                 */
                drawDebug: boolean;

                /**
                 * The graphics object drawing the debug display.
                 */
                debugGraphic: GameObjects.Graphics;

                /**
                 * Default debug display settings for new Bodies.
                 */
                defaults: ArcadeWorldDefaults;

                /**
                 * The maximum number of items per node on the RTree.
                 *
                 * This is ignored if `useTree` is `false`. If you have a large number of bodies in
                 * your world then you may find search performance improves by increasing this value,
                 * to allow more items per node and less node division.
                 */
                maxEntries: integer;

                /**
                 * Should this Arcade Physics World use an RTree for Dynamic Physics bodies or not?
                 *
                 * An RTree is a fast way of spatially sorting of all the moving bodies in the world.
                 * However, at certain limits, the cost of clearing and inserting the bodies into the
                 * tree every frame becomes more expensive than the search speed gains it provides.
                 *
                 * If you have a large number of dynamic bodies in your world then it may be best to
                 * disable the use of the RTree by setting this property to `true`.
                 * The number it can cope with depends on browser and device, but a conservative estimate
                 * of around 5,000 bodies should be considered the max before disabling it.
                 *
                 * Note this only applies to dynamic bodies. Static bodies are always kept in an RTree,
                 * because they don't have to be cleared every frame, so you benefit from the
                 * massive search speeds all the time.
                 */
                useTree: boolean;

                /**
                 * The spatial index of Dynamic Bodies.
                 */
                tree: Structs.RTree;

                /**
                 * The spatial index of Static Bodies.
                 */
                staticTree: Structs.RTree;

                /**
                 * Recycled input for tree searches.
                 */
                treeMinMax: ArcadeWorldTreeMinMax;

                /**
                 * Adds an Arcade Physics Body to a Game Object, an array of Game Objects, or the children of a Group.
                 *
                 * The difference between this and the `enableBody` method is that you can pass arrays or Groups
                 * to this method.
                 *
                 * You can specify if the bodies are to be Dynamic or Static. A dynamic body can move via velocity and
                 * acceleration. A static body remains fixed in place and as such is able to use an optimized search
                 * tree, making it ideal for static elements such as level objects. You can still collide and overlap
                 * with static bodies.
                 *
                 * Normally, rather than calling this method directly, you'd use the helper methods available in the
                 * Arcade Physics Factory, such as:
                 *
                 * ```javascript
                 * this.physics.add.image(x, y, textureKey);
                 * this.physics.add.sprite(x, y, textureKey);
                 * ```
                 *
                 * Calling factory methods encapsulates the creation of a Game Object and the creation of its
                 * body at the same time. If you are creating custom classes then you can pass them to this
                 * method to have their bodies created.
                 * @param object The object, or objects, on which to create the bodies.
                 * @param bodyinterface The interface of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.
                 */
                enable(object: GameObjects.GameObject | GameObjects.GameObject[] | GameObjects.Group | GameObjects.Group[], bodyinterface?: integer): void;

                /**
                 * Creates an Arcade Physics Body on a single Game Object.
                 *
                 * If the Game Object already has a body, this method will simply add it back into the simulation.
                 *
                 * You can specify if the body is Dynamic or Static. A dynamic body can move via velocity and
                 * acceleration. A static body remains fixed in place and as such is able to use an optimized search
                 * tree, making it ideal for static elements such as level objects. You can still collide and overlap
                 * with static bodies.
                 *
                 * Normally, rather than calling this method directly, you'd use the helper methods available in the
                 * Arcade Physics Factory, such as:
                 *
                 * ```javascript
                 * this.physics.add.image(x, y, textureKey);
                 * this.physics.add.sprite(x, y, textureKey);
                 * ```
                 *
                 * Calling factory methods encapsulates the creation of a Game Object and the creation of its
                 * body at the same time. If you are creating custom classes then you can pass them to this
                 * method to have their bodies created.
                 * @param object The Game Object on which to create the body.
                 * @param bodyinterface The interface of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.
                 */
                enableBody(object: GameObjects.GameObject, bodyinterface?: integer): GameObjects.GameObject;

                /**
                 * Adds an existing Arcade Physics Body or StaticBody to the simulation.
                 *
                 * The body is enabled and added to the local search trees.
                 * @param body The Body to be added to the simulation.
                 */
                add(body: Body | StaticBody): Body | StaticBody;

                /**
                 * Disables the Arcade Physics Body of a Game Object, an array of Game Objects, or the children of a Group.
                 *
                 * The difference between this and the `disableBody` method is that you can pass arrays or Groups
                 * to this method.
                 *
                 * The body itself is not deleted, it just has its `enable` property set to false, which
                 * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.
                 * @param object The object, or objects, on which to disable the bodies.
                 */
                disable(object: GameObjects.GameObject | GameObjects.GameObject[] | GameObjects.Group | GameObjects.Group[]): void;

                /**
                 * Disables an existing Arcade Physics Body or StaticBody and removes it from the simulation.
                 *
                 * The body is disabled and removed from the local search trees.
                 *
                 * The body itself is not deleted, it just has its `enable` property set to false, which
                 * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.
                 * @param body The Body to be disabled.
                 */
                disableBody(body: Body | StaticBody): void;

                /**
                 * Removes an existing Arcade Physics Body or StaticBody from the simulation.
                 *
                 * The body is disabled and removed from the local search trees.
                 *
                 * The body itself is not deleted, it just has its `enabled` property set to false, which
                 * means you can re-enable it again at any point by passing it to enable `enable` or `add`.
                 * @param body The body to be removed from the simulation.
                 */
                remove(body: Body | StaticBody): void;

                /**
                 * Creates a Graphics Game Object that the world will use to render the debug display to.
                 *
                 * This is called automatically when the World is instantiated if the `debug` config property
                 * was set to `true`. However, you can call it at any point should you need to display the
                 * debug Graphic from a fixed point.
                 *
                 * You can control which objects are drawn to the Graphics object, and the colors they use,
                 * by setting the debug properties in the physics config.
                 *
                 * You should not typically use this in a production game. Use it to aid during debugging.
                 */
                createDebugGraphic(): GameObjects.Graphics;

                /**
                 * Sets the position, size and properties of the World boundary.
                 *
                 * The World boundary is an invisible rectangle that defines the edges of the World.
                 * If a Body is set to collide with the world bounds then it will automatically stop
                 * when it reaches any of the edges. You can optionally set which edges of the boundary
                 * should be checked against.
                 * @param x The top-left x coordinate of the boundary.
                 * @param y The top-left y coordinate of the boundary.
                 * @param width The width of the boundary.
                 * @param height The height of the boundary.
                 * @param checkLeft Should bodies check against the left edge of the boundary?
                 * @param checkRight Should bodies check against the right edge of the boundary?
                 * @param checkUp Should bodies check against the top edge of the boundary?
                 * @param checkDown Should bodies check against the bottom edge of the boundary?
                 */
                setBounds(x: number, y: number, width: number, height: number, checkLeft?: boolean, checkRight?: boolean, checkUp?: boolean, checkDown?: boolean): World;

                /**
                 * Enables or disables collisions on each edge of the World boundary.
                 * @param left Should bodies check against the left edge of the boundary? Default true.
                 * @param right Should bodies check against the right edge of the boundary? Default true.
                 * @param up Should bodies check against the top edge of the boundary? Default true.
                 * @param down Should bodies check against the bottom edge of the boundary? Default true.
                 */
                setBoundsCollision(left?: boolean, right?: boolean, up?: boolean, down?: boolean): World;

                /**
                 * Pauses the simulation.
                 *
                 * A paused simulation does not update any existing bodies, or run any Colliders.
                 *
                 * However, you can still enable and disable bodies within it, or manually run collide or overlap
                 * checks.
                 */
                pause(): World;

                /**
                 * Resumes the simulation, if paused.
                 */
                resume(): World;

                /**
                 * Creates a new Collider object and adds it to the simulation.
                 *
                 * A Collider is a way to automatically perform collision checks between two objects,
                 * calling the collide and process callbacks if they occur.
                 *
                 * Colliders are run as part of the World update, after all of the Bodies have updated.
                 *
                 * By creating a Collider you don't need then call `World.collide` in your `update` loop,
                 * as it will be handled for you automatically.
                 * @param object1 The first object to check for collision.
                 * @param object2 The second object to check for collision.
                 * @param collideCallback The callback to invoke when the two objects collide.
                 * @param processCallback The callback to invoke when the two objects collide. Must return a boolean.
                 * @param callbackContext The scope in which to call the callbacks.
                 */
                addCollider(
                    object1: ArcadeColliderType,
                    object2: ArcadeColliderType,
                    collideCallback?: ArcadePhysicsCallback,
                    processCallback?: ArcadePhysicsCallback,
                    callbackContext?: any
                ): Collider;

                /**
                 * Creates a new Overlap Collider object and adds it to the simulation.
                 *
                 * A Collider is a way to automatically perform overlap checks between two objects,
                 * calling the collide and process callbacks if they occur.
                 *
                 * Colliders are run as part of the World update, after all of the Bodies have updated.
                 *
                 * By creating a Collider you don't need then call `World.overlap` in your `update` loop,
                 * as it will be handled for you automatically.
                 * @param object1 The first object to check for overlap.
                 * @param object2 The second object to check for overlap.
                 * @param collideCallback The callback to invoke when the two objects overlap.
                 * @param processCallback The callback to invoke when the two objects overlap. Must return a boolean.
                 * @param callbackContext The scope in which to call the callbacks.
                 */
                addOverlap(
                    object1: ArcadeColliderType,
                    object2: ArcadeColliderType,
                    collideCallback?: ArcadePhysicsCallback,
                    processCallback?: ArcadePhysicsCallback,
                    callbackContext?: any
                ): Collider;

                /**
                 * Removes a Collider from the simulation so it is no longer processed.
                 *
                 * This method does not destroy the Collider. If you wish to add it back at a later stage you can call
                 * `World.colliders.add(Collider)`.
                 *
                 * If you no longer need the Collider you can call the `Collider.destroy` method instead, which will
                 * automatically clear all of its references and then remove it from the World. If you call destroy on
                 * a Collider you _don't_ need to pass it to this method too.
                 * @param collider The Collider to remove from the simulation.
                 */
                removeCollider(collider: Collider): World;

                /**
                 * Sets the frame rate to run the simulation at.
                 *
                 * The frame rate value is used to simulate a fixed update time step. This fixed
                 * time step allows for a straightforward implementation of a deterministic game state.
                 *
                 * This frame rate is independent of the frequency at which the game is rendering. The
                 * higher you set the fps, the more physics simulation steps will occur per game step.
                 * Conversely, the lower you set it, the less will take place.
                 *
                 * You can optionally advance the simulation directly yourself by calling the `step` method.
                 * @param framerate The frame rate to advance the simulation at.
                 */
                setFPS(framerate: integer): this;

                /**
                 * Advances the simulation based on the elapsed time and fps rate.
                 *
                 * This is called automatically by your Scene and does not need to be invoked directly.
                 * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                protected update(time: number, delta: number): void;

                /**
                 * Advances the simulation by a time increment.
                 * @param delta The delta time amount, in seconds, by which to advance the simulation.
                 */
                step(delta: number): void;

                /**
                 * Updates bodies, draws the debug display, and handles pending queue operations.
                 */
                postUpdate(): void;

                /**
                 * Calculates a Body's velocity and updates its position.
                 * @param body The Body to be updated.
                 * @param delta The delta value to be used in the motion calculations, in seconds.
                 */
                updateMotion(body: Body, delta: number): void;

                /**
                 * Calculates a Body's angular velocity.
                 * @param body The Body to compute the velocity for.
                 * @param delta The delta value to be used in the calculation, in seconds.
                 */
                computeAngularVelocity(body: Body, delta: number): void;

                /**
                 * Calculates a Body's per-axis velocity.
                 * @param body The Body to compute the velocity for.
                 * @param delta The delta value to be used in the calculation, in seconds.
                 */
                computeVelocity(body: Body, delta: number): void;

                /**
                 * Separates two Bodies.
                 * @param body1 The first Body to be separated.
                 * @param body2 The second Body to be separated.
                 * @param processCallback The process callback.
                 * @param callbackContext The context in which to invoke the callback.
                 * @param overlapOnly If this a collide or overlap check?
                 */
                separate(body1: Body, body2: Body, processCallback?: ArcadePhysicsCallback, callbackContext?: any, overlapOnly?: boolean): boolean;

                /**
                 * Separates two Bodies, when both are circular.
                 * @param body1 The first Body to be separated.
                 * @param body2 The second Body to be separated.
                 * @param overlapOnly If this a collide or overlap check?
                 * @param bias A small value added to the calculations.
                 */
                separateCircle(body1: Body, body2: Body, overlapOnly?: boolean, bias?: number): boolean;

                /**
                 * Checks to see if two Bodies intersect at all.
                 * @param body1 The first body to check.
                 * @param body2 The second body to check.
                 */
                intersects(body1: Body, body2: Body): boolean;

                /**
                 * Tests if a circular Body intersects with another Body.
                 * @param circle The circular body to test.
                 * @param body The rectangular body to test.
                 */
                circleBodyIntersects(circle: Body, body: Body): boolean;

                /**
                 * Tests if Game Objects overlap.
                 * @param object1 The first object or array of objects to check.
                 * @param object2 The second object or array of objects to check, or `undefined`.
                 * @param overlapCallback An optional callback function that is called if the objects overlap.
                 * @param processCallback An optional callback function that lets you perform additional checks against the two objects if they overlap.
                 * If this is set then `overlapCallback` will only be called if this callback returns `true`.
                 * @param callbackContext The context in which to run the callbacks.
                 */
                overlap(object1: ArcadeColliderType, object2?: ArcadeColliderType, overlapCallback?: ArcadePhysicsCallback, processCallback?: ArcadePhysicsCallback, callbackContext?: any): boolean;

                /**
                 * Performs a collision check and separation between the two physics enabled objects given, which can be single
                 * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.
                 *
                 * If you don't require separation then use {@link #overlap} instead.
                 *
                 * If two Groups or arrays are passed, each member of one will be tested against each member of the other.
                 *
                 * If one Group **only** is passed (as `object1`), each member of the Group will be collided against the other members.
                 *
                 * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding
                 * objects are passed to it.
                 *
                 * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable
                 * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.
                 * The separation that stops two objects penetrating may create a new penetration against a different object. If you
                 * require a high level of stability please consider using an alternative physics system, such as Matter.js.
                 * @param object1 The first object or array of objects to check.
                 * @param object2 The second object or array of objects to check, or `undefined`.
                 * @param collideCallback An optional callback function that is called if the objects collide.
                 * @param processCallback An optional callback function that lets you perform additional checks against the two objects if they collide.
                 * If this is set then `collideCallback` will only be called if this callback returns `true`.
                 * @param callbackContext The context in which to run the callbacks.
                 */
                collide(object1: ArcadeColliderType, object2?: ArcadeColliderType, collideCallback?: ArcadePhysicsCallback, processCallback?: ArcadePhysicsCallback, callbackContext?: any): boolean;

                /**
                 * Internal handler for Sprite vs. Tilemap collisions.
                 * Please use Phaser.Physics.Arcade.World#collide instead.
                 * @param sprite The first object to check for collision.
                 * @param tilemapLayer The second object to check for collision.
                 * @param collideCallback An optional callback function that is called if the objects collide.
                 * @param processCallback An optional callback function that lets you perform additional checks against the two objects if they collide.
                 * If this is set then `collideCallback` will only be called if this callback returns `true`.
                 * @param callbackContext The context in which to run the callbacks.
                 * @param overlapOnly Whether this is a collision or overlap check.
                 */
                collideSpriteVsTilemapLayer(
                    sprite: GameObjects.GameObject,
                    tilemapLayer: Tilemaps.DynamicTilemapLayer | Tilemaps.StaticTilemapLayer,
                    collideCallback?: ArcadePhysicsCallback,
                    processCallback?: ArcadePhysicsCallback,
                    callbackContext?: any,
                    overlapOnly?: boolean
                ): boolean;

                /**
                 * Wrap an object's coordinates (or several objects' coordinates) within {@link Phaser.Physics.Arcade.World#bounds}.
                 *
                 * If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior).
                 * @param object A Game Object, a Group, an object with `x` and `y` coordinates, or an array of such objects.
                 * @param padding An amount added to each boundary edge during the operation. Default 0.
                 */
                wrap(object: any, padding?: number): void;

                /**
                 * Wrap each object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.
                 * @param objects An array of objects to be wrapped.
                 * @param padding An amount added to the boundary. Default 0.
                 */
                wrapArray(objects: any[], padding?: number): void;

                /**
                 * Wrap an object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.
                 * @param object A Game Object, a Physics Body, or any object with `x` and `y` coordinates
                 * @param padding An amount added to the boundary. Default 0.
                 */
                wrapObject(object: any, padding?: number): void;

                /**
                 * Shuts down the simulation, clearing physics data and removing listeners.
                 */
                shutdown(): void;

                /**
                 * Shuts down the simulation and disconnects it from the current scene.
                 */
                destroy(): void;
            }
        }

        /**
         * An Impact.js compatible physics world, body and solver, for those who are used
         * to the Impact way of defining and controlling physics bodies. Also works with
         * the new Loader support for Weltmeister map data.
         *
         * World updated to run off the Phaser main loop.
         * Body extended to support additional setter functions.
         *
         * To create the map data you'll need Weltmeister, which comes with Impact
         * and can be purchased from http://impactjs.com
         *
         * My thanks to Dominic Szablewski for his permission to support Impact in Phaser.
         */
        namespace Impact {
            /**
             * An Impact.js compatible physics body.
             * This re-creates the properties you'd get on an Entity and the math needed to update them.
             */
            class Body {
                /**
                 *
                 * @param world [description]
                 * @param x [description]
                 * @param y [description]
                 * @param sx [description] Default 16.
                 * @param sy [description] Default 16.
                 */
                constructor(world: World, x: number, y: number, sx?: number, sy?: number);

                /**
                 * [description]
                 */
                world: World;

                /**
                 * [description]
                 */
                gameObject: GameObjects.GameObject;

                /**
                 * [description]
                 */
                enabled: boolean;

                /**
                 * The ImpactBody, ImpactSprite or ImpactImage object that owns this Body, if any.
                 */
                parent: ImpactBody | ImpactImage | ImpactSprite;

                /**
                 * [description]
                 */
                id: integer;

                /**
                 * [description]
                 */
                name: string;

                /**
                 * [description]
                 */
                size: object;

                /**
                 * [description]
                 */
                offset: object;

                /**
                 * [description]
                 */
                pos: object;

                /**
                 * [description]
                 */
                last: object;

                /**
                 * [description]
                 */
                vel: object;

                /**
                 * [description]
                 */
                accel: object;

                /**
                 * [description]
                 */
                friction: object;

                /**
                 * [description]
                 */
                maxVel: object;

                /**
                 * [description]
                 */
                standing: boolean;

                /**
                 * [description]
                 */
                gravityFactor: number;

                /**
                 * [description]
                 */
                bounciness: number;

                /**
                 * [description]
                 */
                minBounceVelocity: number;

                /**
                 * [description]
                 */
                accelGround: number;

                /**
                 * [description]
                 */
                accelAir: number;

                /**
                 * [description]
                 */
                jumpSpeed: number;

                /**
                 * [description]
                 */
                interface: interface;

                /**
                 * [description]
                 */
                checkAgainst: interface;

                /**
                 * [description]
                 */
                collides: COLLIDES;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: integer;

                /**
                 * [description]
                 */
                updateCallback: BodyUpdateCallback;

                /**
                 * min 44 deg, max 136 deg
                 */
                slopeStanding: object;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                reset(x: number, y: number): void;

                /**
                 * [description]
                 * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
                 */
                update(delta: number): void;

                /**
                 * [description]
                 * @param graphic [description]
                 */
                drawDebug(graphic: GameObjects.Graphics): void;

                /**
                 * [description]
                 */
                willDrawDebug(): boolean;

                /**
                 * [description]
                 */
                skipHash(): boolean;

                /**
                 * Determines whether the body collides with the `other` one or not.
                 * @param other [description]
                 */
                touches(other: Body): boolean;

                /**
                 * Reset the size and position of the physics body.
                 * @param x The x coordinate to position the body.
                 * @param y The y coordinate to position the body.
                 * @param width The width of the body.
                 * @param height The height of the body.
                 */
                resetSize(x: number, y: number, width: number, height: number): Body;

                /**
                 * Export this body object to JSON.
                 */
                toJSON(): JSONImpactBody;

                /**
                 * [description]
                 * @param config [description]
                 */
                fromJSON(config: object): void;

                /**
                 * Can be overridden by user code
                 * @param other [description]
                 */
                check(other: Body): void;

                /**
                 * Can be overridden by user code
                 * @param other [description]
                 * @param axis [description]
                 */
                collideWith(other: Body, axis: string): void;

                /**
                 * Can be overridden by user code but must return a boolean.
                 * @param res [description]
                 */
                handleMovementTrace(res: number): boolean;

                /**
                 * [description]
                 */
                destroy(): void;
            }

            /**
             * Collision types - Determine if and how entities collide with each other.
             *
             * In ACTIVE vs. LITE or FIXED vs. ANY collisions, only the "weak" entity moves,
             * while the other one stays fixed. In ACTIVE vs. ACTIVE and ACTIVE vs. PASSIVE
             * collisions, both entities are moved. LITE or PASSIVE entities don't collide
             * with other LITE or PASSIVE entities at all. The behavior for FIXED vs.
             * FIXED collisions is undefined.
             */
            enum COLLIDES {
                /**
                 * Never collides.
                 */
                NEVER,
                /**
                 * Lite collision.
                 */
                LITE,
                /**
                 * Passive collision.
                 */
                PASSIVE,
                /**
                 * Active collision.
                 */
                ACTIVE,
                /**
                 * Fixed collision.
                 */
                FIXED
            }

            /**
             * [description]
             */
            class CollisionMap {
                /**
                 *
                 * @param tilesize [description] Default 32.
                 * @param data [description]
                 */
                constructor(tilesize?: integer, data?: any[]);

                /**
                 * [description]
                 */
                tilesize: integer;

                /**
                 * [description]
                 */
                data: any[];

                /**
                 * [description]
                 */
                width: number;

                /**
                 * [description]
                 */
                height: number;

                /**
                 * [description]
                 */
                lastSlope: integer;

                /**
                 * [description]
                 */
                tiledef: object;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param vx [description]
                 * @param vy [description]
                 * @param objectWidth [description]
                 * @param objectHeight [description]
                 */
                trace(x: number, y: number, vx: number, vy: number, objectWidth: number, objectHeight: number): boolean;

                /**
                 * [description]
                 * @param res [description]
                 * @param x [description]
                 * @param y [description]
                 * @param vx [description]
                 * @param vy [description]
                 * @param width [description]
                 * @param height [description]
                 * @param rvx [description]
                 * @param rvy [description]
                 * @param step [description]
                 */
                step(res: object, x: number, y: number, vx: number, vy: number, width: number, height: number, rvx: number, rvy: number, step: number): void;

                /**
                 * [description]
                 * @param res [description]
                 * @param t [description]
                 * @param x [description]
                 * @param y [description]
                 * @param vx [description]
                 * @param vy [description]
                 * @param width [description]
                 * @param height [description]
                 * @param tileX [description]
                 * @param tileY [description]
                 */
                checkDef(res: object, t: number, x: number, y: number, vx: number, vy: number, width: number, height: number, tileX: number, tileY: number): boolean;
            }

            namespace Components {
                /**
                 * The Impact Acceleration component.
                 * Should be applied as a mixin.
                 */
                interface Acceleration {
                    /**
                     * Sets the horizontal acceleration of this body.
                     * @param x The amount of acceleration to apply.
                     */
                    setAccelerationX(x: number): this;
                    /**
                     * Sets the vertical acceleration of this body.
                     * @param y The amount of acceleration to apply.
                     */
                    setAccelerationY(y: number): this;
                    /**
                     * Sets the horizontal and vertical acceleration of this body.
                     * @param x The amount of horizontal acceleration to apply.
                     * @param y The amount of vertical acceleration to apply.
                     */
                    setAcceleration(x: number, y: number): this;
                }

                /**
                 * The Impact Body Scale component.
                 * Should be applied as a mixin.
                 */
                interface BodyScale {
                    /**
                     * Sets the size of the physics body.
                     * @param width The width of the body in pixels.
                     * @param height The height of the body in pixels. Default width.
                     */
                    setBodySize(width: number, height?: number): this;
                    /**
                     * Sets the scale of the physics body.
                     * @param scaleX The horizontal scale of the body.
                     * @param scaleY The vertical scale of the body. If not given, will use the horizontal scale value.
                     */
                    setBodyScale(scaleX: number, scaleY?: number): this;
                }

                /**
                 * The Impact Body interface component.
                 * Should be applied as a mixin.
                 */
                interface Bodyinterface {
                    /**
                     * [description]
                     */
                    getBodyinterface(): number;
                    /**
                     * [description]
                     */
                    setinterfaceNone(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setinterfaceA(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setinterfaceB(): GameObjects.GameObject;
                }

                /**
                 * The Impact Bounce component.
                 * Should be applied as a mixin.
                 */
                interface Bounce {
                    /**
                     * Sets the impact physics bounce, or restitution, value.
                     * @param value A value between 0 (no rebound) and 1 (full rebound)
                     */
                    setBounce(value: number): GameObjects.GameObject;
                    /**
                     * Sets the minimum velocity the body is allowed to be moving to be considered for rebound.
                     * @param value The minimum allowed velocity.
                     */
                    setMinBounceVelocity(value: number): GameObjects.GameObject;
                    /**
                     * The bounce, or restitution, value of this body.
                     * A value between 0 (no rebound) and 1 (full rebound)
                     */
                    bounce: number;
                }

                /**
                 * The Impact Check Against component.
                 * Should be applied as a mixin.
                 */
                interface CheckAgainst {
                    /**
                     * [description]
                     */
                    setAvsB(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setBvsA(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setCheckAgainstNone(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setCheckAgainstA(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setCheckAgainstB(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    checkAgainst: number;
                }

                /**
                 * The Impact Collides component.
                 * Should be applied as a mixin.
                 */
                interface Collides {
                    /**
                     * [description]
                     * @param callback [description]
                     * @param scope [description]
                     */
                    setCollideCallback(callback: CollideCallback, scope: any): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setCollidesNever(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setLiteCollision(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setPassiveCollision(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setActiveCollision(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setFixedCollision(): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    collides: number;
                }

                /**
                 * The Impact Debug component.
                 * Should be applied as a mixin.
                 */
                interface Debug {
                    /**
                     * [description]
                     * @param showBody [description]
                     * @param showVelocity [description]
                     * @param bodyColor [description]
                     */
                    setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setDebugBodyColor(value: number): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    debugShowBody: boolean;
                    /**
                     * [description]
                     */
                    debugShowVelocity: boolean;
                    /**
                     * [description]
                     */
                    debugBodyColor: number;
                }

                /**
                 * The Impact Friction component.
                 * Should be applied as a mixin.
                 */
                interface Friction {
                    /**
                     * [description]
                     * @param x [description]
                     */
                    setFrictionX(x: number): GameObjects.GameObject;
                    /**
                     * [description]
                     * @param y [description]
                     */
                    setFrictionY(y: number): GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description]
                     */
                    setFriction(x: number, y: number): GameObjects.GameObject;
                }

                /**
                 * The Impact Gravity component.
                 * Should be applied as a mixin.
                 */
                interface Gravity {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setGravity(value: number): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    gravity: number;
                }

                /**
                 * The Impact Offset component.
                 * Should be applied as a mixin.
                 */
                interface Offset {
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description]
                     * @param width [description]
                     * @param height [description]
                     */
                    setOffset(x: number, y: number, width?: number, height?: number): GameObjects.GameObject;
                }

                /**
                 * The Impact Set Game Object component.
                 * Should be applied as a mixin.
                 */
                interface SetGameObject {
                    /**
                     * [description]
                     * @param gameObject [description]
                     * @param sync [description] Default true.
                     */
                    setGameObject(gameObject: GameObjects.GameObject, sync?: boolean): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    syncGameObject(): GameObjects.GameObject;
                }

                /**
                 * The Impact Velocity component.
                 * Should be applied as a mixin.
                 */
                interface Velocity {
                    /**
                     * Sets the horizontal velocity of the physics body.
                     * @param x The horizontal velocity value.
                     */
                    setVelocityX(x: number): this;
                    /**
                     * Sets the vertical velocity of the physics body.
                     * @param y The vertical velocity value.
                     */
                    setVelocityY(y: number): this;
                    /**
                     * Sets the horizontal and vertical velocities of the physics body.
                     * @param x The horizontal velocity value.
                     * @param y The vertical velocity value. If not given, defaults to the horizontal value. Default x.
                     */
                    setVelocity(x: number, y?: number): this;
                    /**
                     * Sets the maximum velocity this body can travel at.
                     * @param x The maximum allowed horizontal velocity.
                     * @param y The maximum allowed vertical velocity. If not given, defaults to the horizontal value. Default x.
                     */
                    setMaxVelocity(x: number, y?: number): this;
                }
            }

            namespace Events {
                /**
                 * The Impact Physics World Collide Event.
                 *
                 * This event is dispatched by an Impact Physics World instance if two bodies collide.
                 *
                 * Listen to it from a Scene using: `this.impact.world.on('collide', listener)`.
                 */
                const COLLIDE: any;

                /**
                 * The Impact Physics World Pause Event.
                 *
                 * This event is dispatched by an Impact Physics World instance when it is paused.
                 *
                 * Listen to it from a Scene using: `this.impact.world.on('pause', listener)`.
                 */
                const PAUSE: any;

                /**
                 * The Impact Physics World Resume Event.
                 *
                 * This event is dispatched by an Impact Physics World instance when it resumes from a paused state.
                 *
                 * Listen to it from a Scene using: `this.impact.world.on('resume', listener)`.
                 */
                const RESUME: any;
            }

            /**
             * The Impact Physics Factory allows you to easily create Impact Physics enabled Game Objects.
             * Objects that are created by this Factory are automatically added to the physics world.
             */
            class Factory {
                /**
                 *
                 * @param world A reference to the Impact Physics world.
                 */
                constructor(world: World);

                /**
                 * A reference to the Impact Physics world.
                 */
                world: World;

                /**
                 * A reference to the Scene.Systems this Impact Physics instance belongs to.
                 */
                sys: Scenes.Systems;

                /**
                 * Creates a new ImpactBody object and adds it to the physics simulation.
                 * @param x The horizontal position of the body in the physics world.
                 * @param y The vertical position of the body in the physics world.
                 * @param width The width of the body.
                 * @param height The height of the body.
                 */
                body(x: number, y: number, width: number, height: number): ImpactBody;

                /**
                 * Adds an Impact Physics Body to the given Game Object.
                 * @param gameObject The Game Object to receive the physics body.
                 */
                existing(gameObject: GameObjects.GameObject): GameObjects.GameObject;

                /**
                 * Creates a new ImpactImage object and adds it to the physics world.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                image(x: number, y: number, key: string, frame?: string | integer): ImpactImage;

                /**
                 * Creates a new ImpactSprite object and adds it to the physics world.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                sprite(x: number, y: number, key: string, frame?: string | integer): ImpactSprite;

                /**
                 * Destroys this Factory.
                 */
                destroy(): void;
            }

            /**
             * [description]
             * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
             * @param vel [description]
             * @param accel [description]
             * @param friction [description]
             * @param max [description]
             */
            function GetVelocity(delta: number, vel: number, accel: number, friction: number, max: number): number;

            /**
             * [description]
             */
            class ImpactBody
                implements
                    Components.Acceleration,
                    Components.BodyScale,
                    Components.Bodyinterface,
                    Components.Bounce,
                    Components.CheckAgainst,
                    Components.Collides,
                    Components.Debug,
                    Components.Friction,
                    Components.Gravity,
                    Components.Offset,
                    Components.SetGameObject,
                    Components.Velocity {
                /**
                 *
                 * @param world [description]
                 * @param x x - The horizontal position of this physics body in the world.
                 * @param y y - The vertical position of this physics body in the world.
                 * @param width The width of the physics body in the world.
                 * @param height [description]
                 */
                constructor(world: World, x: number, y: number, width: number, height: number);

                /**
                 * [description]
                 */
                body: Body;

                /**
                 * [description]
                 */
                size: object;

                /**
                 * [description]
                 */
                offset: object;

                /**
                 * [description]
                 */
                vel: object;

                /**
                 * [description]
                 */
                accel: object;

                /**
                 * [description]
                 */
                friction: object;

                /**
                 * [description]
                 */
                maxVel: object;

                /**
                 * Sets the horizontal acceleration of this body.
                 * @param x The amount of acceleration to apply.
                 */
                setAccelerationX(x: number): this;

                /**
                 * Sets the vertical acceleration of this body.
                 * @param y The amount of acceleration to apply.
                 */
                setAccelerationY(y: number): this;

                /**
                 * Sets the horizontal and vertical acceleration of this body.
                 * @param x The amount of horizontal acceleration to apply.
                 * @param y The amount of vertical acceleration to apply.
                 */
                setAcceleration(x: number, y: number): this;

                /**
                 * Sets the size of the physics body.
                 * @param width The width of the body in pixels.
                 * @param height The height of the body in pixels. Default width.
                 */
                setBodySize(width: number, height?: number): this;

                /**
                 * Sets the scale of the physics body.
                 * @param scaleX The horizontal scale of the body.
                 * @param scaleY The vertical scale of the body. If not given, will use the horizontal scale value.
                 */
                setBodyScale(scaleX: number, scaleY?: number): this;

                /**
                 * [description]
                 */
                getBodyinterface(): number;

                /**
                 * [description]
                 */
                setinterfaceNone(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setinterfaceA(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setinterfaceB(): GameObjects.GameObject;

                /**
                 * Sets the impact physics bounce, or restitution, value.
                 * @param value A value between 0 (no rebound) and 1 (full rebound)
                 */
                setBounce(value: number): GameObjects.GameObject;

                /**
                 * Sets the minimum velocity the body is allowed to be moving to be considered for rebound.
                 * @param value The minimum allowed velocity.
                 */
                setMinBounceVelocity(value: number): GameObjects.GameObject;

                /**
                 * The bounce, or restitution, value of this body.
                 * A value between 0 (no rebound) and 1 (full rebound)
                 */
                bounce: number;

                /**
                 * [description]
                 */
                setAvsB(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setBvsA(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstNone(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstA(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstB(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                checkAgainst: number;

                /**
                 * [description]
                 * @param callback [description]
                 * @param scope [description]
                 */
                setCollideCallback(callback: CollideCallback, scope: any): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCollidesNever(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setLiteCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setPassiveCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setActiveCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setFixedCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                collides: number;

                /**
                 * [description]
                 * @param showBody [description]
                 * @param showVelocity [description]
                 * @param bodyColor [description]
                 */
                setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDebugBodyColor(value: number): GameObjects.GameObject;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: number;

                /**
                 * [description]
                 * @param x [description]
                 */
                setFrictionX(x: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setFrictionY(y: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setFriction(x: number, y: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setGravity(value: number): GameObjects.GameObject;

                /**
                 * [description]
                 */
                gravity: number;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                setOffset(x: number, y: number, width?: number, height?: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param gameObject [description]
                 * @param sync [description] Default true.
                 */
                setGameObject(gameObject: GameObjects.GameObject, sync?: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 */
                syncGameObject(): GameObjects.GameObject;

                /**
                 * Sets the horizontal velocity of the physics body.
                 * @param x The horizontal velocity value.
                 */
                setVelocityX(x: number): this;

                /**
                 * Sets the vertical velocity of the physics body.
                 * @param y The vertical velocity value.
                 */
                setVelocityY(y: number): this;

                /**
                 * Sets the horizontal and vertical velocities of the physics body.
                 * @param x The horizontal velocity value.
                 * @param y The vertical velocity value. If not given, defaults to the horizontal value. Default x.
                 */
                setVelocity(x: number, y?: number): this;

                /**
                 * Sets the maximum velocity this body can travel at.
                 * @param x The maximum allowed horizontal velocity.
                 * @param y The maximum allowed vertical velocity. If not given, defaults to the horizontal value. Default x.
                 */
                setMaxVelocity(x: number, y?: number): this;
            }

            /**
             * An Impact Physics Image Game Object.
             *
             * An Image is a light-weight Game Object useful for the display of static images in your game,
             * such as logos, backgrounds, scenery or other non-animated elements. Images can have input
             * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an
             * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.
             */
            class ImpactImage extends GameObjects.Image
                implements
                    Components.Acceleration,
                    Components.BodyScale,
                    Components.Bodyinterface,
                    Components.Bounce,
                    Components.CheckAgainst,
                    Components.Collides,
                    Components.Debug,
                    Components.Friction,
                    Components.Gravity,
                    Components.Offset,
                    Components.SetGameObject,
                    Components.Velocity,
                    GameObjects.Components.Alpha,
                    GameObjects.Components.BlendMode,
                    GameObjects.Components.Depth,
                    GameObjects.Components.Flip,
                    GameObjects.Components.GetBounds,
                    GameObjects.Components.Origin,
                    GameObjects.Components.Pipeline,
                    GameObjects.Components.ScaleMode,
                    GameObjects.Components.ScrollFactor,
                    GameObjects.Components.Size,
                    GameObjects.Components.Texture,
                    GameObjects.Components.Tint,
                    GameObjects.Components.Transform,
                    GameObjects.Components.Visible {
                /**
                 *
                 * @param world The physics world of the Impact physics system.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                constructor(world: World, x: number, y: number, texture: string, frame?: string | integer);

                /**
                 * The Physics Body linked to an ImpactImage.
                 */
                body: Body;

                /**
                 * The size of the physics Body.
                 */
                size: object;

                /**
                 * The X and Y offset of the Body from the left and top of the Image.
                 */
                offset: object;

                /**
                 * The velocity, or rate of change the Body's position. Measured in pixels per second.
                 */
                vel: object;

                /**
                 * The acceleration is the rate of change of the velocity. Measured in pixels per second squared.
                 */
                accel: object;

                /**
                 * Friction between colliding bodies.
                 */
                friction: object;

                /**
                 * The maximum velocity of the body.
                 */
                maxVel: object;

                /**
                 * Clears all alpha values associated with this Game Object.
                 *
                 * Immediately sets the alpha levels back to 1 (fully opaque).
                 */
                clearAlpha(): this;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 *
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

                /**
                 * The alpha value of the Game Object.
                 *
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | BlendModes): this;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): this;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): this;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): this;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): this;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): this;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): this;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): this;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Geom.Rectangle>(output?: O): O;

                /**
                 * The Mask this Game Object is using during render.
                 */
                mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

                /**
                 * Sets the mask that this Game Object will use to render with.
                 *
                 * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
                 * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
                 *
                 * If a mask is already set on this Game Object it will be immediately replaced.
                 *
                 * Masks are positioned in global space and are not relative to the Game Object to which they
                 * are applied. The reason for this is that multiple Game Objects can all share the same mask.
                 *
                 * Masks have no impact on physics or input detection. They are purely a rendering component
                 * that allows you to limit what is visible during the render pass.
                 * @param mask The mask this Game Object will use when rendering.
                 */
                setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

                /**
                 * Clears the mask that this Game Object was using.
                 * @param destroyMask Destroy the mask before clearing it? Default false.
                 */
                clearMask(destroyMask?: boolean): this;

                /**
                 * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a renderable Game Object.
                 * A renderable Game Object is one that uses a texture to render with, such as an
                 * Image, Sprite, Render Texture or BitmapText.
                 *
                 * If you do not provide a renderable object, and this Game Object has a texture,
                 * it will use itself as the object. This means you can call this method to create
                 * a Bitmap Mask from any renderable Game Object.
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                createBitmapMask(renderable?: GameObjects.GameObject): Display.Masks.BitmapMask;

                /**
                 * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a Graphics Game Object.
                 *
                 * If you do not provide a graphics object, and this Game Object is an instance
                 * of a Graphics object, then it will use itself to create the mask.
                 *
                 * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
                 * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
                 */
                createGeometryMask(graphics?: GameObjects.Graphics): Display.Masks.GeometryMask;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 *
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): this;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): this;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): this;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): this;

                /**
                 * The initial WebGL pipeline of this Game Object.
                 */
                defaultPipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * The current WebGL pipeline of this Game Object.
                 */
                pipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
                 */
                initPipeline(pipelineName?: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): this;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: ScaleModes): this;

                /**
                 * The horizontal scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): this;

                /**
                 * The native (un-scaled) width of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayWidth` property.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayHeight` property.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Textures.Frame): this;

                /**
                 * Sets the internal size of this Game Object, as used for frame or physics body creation.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): this;

                /**
                 * Sets the display size of this Game Object.
                 *
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): this;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Textures.Texture | Textures.CanvasTexture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Textures.Frame;

                /**
                 * A boolean flag indicating if this Game Object is being cropped or not.
                 * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
                 * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
                 */
                isCropped: boolean;

                /**
                 * Applies a crop to a texture based Game Object, such as a Sprite or Image.
                 *
                 * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
                 *
                 * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
                 * changes what is shown when rendered.
                 *
                 * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
                 *
                 * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
                 * half of it, you could call `setCrop(0, 0, 400, 600)`.
                 *
                 * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
                 * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
                 *
                 * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
                 *
                 * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
                 *
                 * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
                 * the renderer to skip several internal calculations.
                 * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
                 * @param y The y coordinate to start the crop from.
                 * @param width The width of the crop rectangle in pixels.
                 * @param height The height of the crop rectangle in pixels.
                 */
                setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 *
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): this;

                /**
                 * Sets the frame this Game Object will use to render with.
                 *
                 * The Frame has to belong to the current Texture being used.
                 *
                 * It can be either a string or an index.
                 *
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

                /**
                 * Fill or additive?
                 */
                tintFill: boolean;

                /**
                 * Clears all tint values associated with this Game Object.
                 *
                 * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
                 * which results in no visible change to the texture.
                 */
                clearTint(): this;

                /**
                 * Sets an additive tint on this Game Object.
                 *
                 * The tint works by taking the pixel color values from the Game Objects texture, and then
                 * multiplying it by the color value of the tint. You can provide either one color value,
                 * in which case the whole Game Object will be tinted in that color. Or you can provide a color
                 * per corner. The colors are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * Sets a fill-based tint on this Game Object.
                 *
                 * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
                 * with those in the tint. You can use this for effects such as making a player flash 'white'
                 * if hit by something. You can provide either one color value, in which case the whole
                 * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
                 * are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
                 * @param topLeft The tint being applied to the top-left of the Game Object.
                 * If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * Does this Game Object have a tint applied to it or not?
                 */
                readonly isTinted: boolean;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 *
                 * Where 0 is to the right, 90 is down, 180 is left.
                 *
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 *
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): this;

                /**
                 * Sets the position of this Game Object to be a random position within the confines of
                 * the given area.
                 *
                 * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
                 *
                 * The position does not factor in the size of this Game Object, meaning that only the origin is
                 * guaranteed to be within the area.
                 * @param x The x position of the top-left of the random area. Default 0.
                 * @param y The y position of the top-left of the random area. Default 0.
                 * @param width The width of the random area.
                 * @param height The height of the random area.
                 */
                setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): this;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): this;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): this;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): this;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): this;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): this;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): this;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: GameObjects.Components.TransformMatrix): GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 * @param parentMatrix A temporary matrix to hold parent values during the calculations.
                 */
                getWorldTransformMatrix(
                    tempMatrix?: GameObjects.Components.TransformMatrix,
                    parentMatrix?: GameObjects.Components.TransformMatrix
                ): GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): this;

                /**
                 * Sets the horizontal acceleration of this body.
                 * @param x The amount of acceleration to apply.
                 */
                setAccelerationX(x: number): this;

                /**
                 * Sets the vertical acceleration of this body.
                 * @param y The amount of acceleration to apply.
                 */
                setAccelerationY(y: number): this;

                /**
                 * Sets the horizontal and vertical acceleration of this body.
                 * @param x The amount of horizontal acceleration to apply.
                 * @param y The amount of vertical acceleration to apply.
                 */
                setAcceleration(x: number, y: number): this;

                /**
                 * Sets the size of the physics body.
                 * @param width The width of the body in pixels.
                 * @param height The height of the body in pixels. Default width.
                 */
                setBodySize(width: number, height?: number): this;

                /**
                 * Sets the scale of the physics body.
                 * @param scaleX The horizontal scale of the body.
                 * @param scaleY The vertical scale of the body. If not given, will use the horizontal scale value.
                 */
                setBodyScale(scaleX: number, scaleY?: number): this;

                /**
                 * [description]
                 */
                getBodyinterface(): number;

                /**
                 * [description]
                 */
                setinterfaceNone(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setinterfaceA(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setinterfaceB(): GameObjects.GameObject;

                /**
                 * Sets the impact physics bounce, or restitution, value.
                 * @param value A value between 0 (no rebound) and 1 (full rebound)
                 */
                setBounce(value: number): GameObjects.GameObject;

                /**
                 * Sets the minimum velocity the body is allowed to be moving to be considered for rebound.
                 * @param value The minimum allowed velocity.
                 */
                setMinBounceVelocity(value: number): GameObjects.GameObject;

                /**
                 * The bounce, or restitution, value of this body.
                 * A value between 0 (no rebound) and 1 (full rebound)
                 */
                bounce: number;

                /**
                 * [description]
                 */
                setAvsB(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setBvsA(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstNone(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstA(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstB(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                checkAgainst: number;

                /**
                 * [description]
                 * @param callback [description]
                 * @param scope [description]
                 */
                setCollideCallback(callback: CollideCallback, scope: any): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCollidesNever(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setLiteCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setPassiveCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setActiveCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setFixedCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                collides: number;

                /**
                 * [description]
                 * @param showBody [description]
                 * @param showVelocity [description]
                 * @param bodyColor [description]
                 */
                setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDebugBodyColor(value: number): GameObjects.GameObject;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: number;

                /**
                 * [description]
                 * @param x [description]
                 */
                setFrictionX(x: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setFrictionY(y: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setFriction(x: number, y: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setGravity(value: number): GameObjects.GameObject;

                /**
                 * [description]
                 */
                gravity: number;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                setOffset(x: number, y: number, width?: number, height?: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param gameObject [description]
                 * @param sync [description] Default true.
                 */
                setGameObject(gameObject: GameObjects.GameObject, sync?: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 */
                syncGameObject(): GameObjects.GameObject;

                /**
                 * Sets the horizontal velocity of the physics body.
                 * @param x The horizontal velocity value.
                 */
                setVelocityX(x: number): this;

                /**
                 * Sets the vertical velocity of the physics body.
                 * @param y The vertical velocity value.
                 */
                setVelocityY(y: number): this;

                /**
                 * Sets the horizontal and vertical velocities of the physics body.
                 * @param x The horizontal velocity value.
                 * @param y The vertical velocity value. If not given, defaults to the horizontal value. Default x.
                 */
                setVelocity(x: number, y?: number): this;

                /**
                 * Sets the maximum velocity this body can travel at.
                 * @param x The maximum allowed horizontal velocity.
                 * @param y The maximum allowed vertical velocity. If not given, defaults to the horizontal value. Default x.
                 */
                setMaxVelocity(x: number, y?: number): this;
            }

            /**
             * [description]
             */
            class ImpactPhysics {
                /**
                 *
                 * @param scene [description]
                 */
                constructor(scene: Scene);

                /**
                 * [description]
                 */
                scene: Scene;

                /**
                 * [description]
                 */
                systems: Scenes.Systems;

                /**
                 * [description]
                 */
                config: object;

                /**
                 * [description]
                 */
                world: World;

                /**
                 * [description]
                 */
                add: Factory;

                /**
                 * [description]
                 */
                getConfig(): object;

                /**
                 * [description]
                 */
                pause(): World;

                /**
                 * [description]
                 */
                resume(): World;
            }

            /**
             * An Impact Physics Sprite Game Object.
             *
             * A Sprite Game Object is used for the display of both static and animated images in your game.
             * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled
             * and animated.
             *
             * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.
             * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation
             * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.
             */
            class ImpactSprite extends GameObjects.Sprite
                implements
                    Components.Acceleration,
                    Components.BodyScale,
                    Components.Bodyinterface,
                    Components.Bounce,
                    Components.CheckAgainst,
                    Components.Collides,
                    Components.Debug,
                    Components.Friction,
                    Components.Gravity,
                    Components.Offset,
                    Components.SetGameObject,
                    Components.Velocity,
                    GameObjects.Components.Alpha,
                    GameObjects.Components.BlendMode,
                    GameObjects.Components.Depth,
                    GameObjects.Components.Flip,
                    GameObjects.Components.GetBounds,
                    GameObjects.Components.Origin,
                    GameObjects.Components.Pipeline,
                    GameObjects.Components.ScaleMode,
                    GameObjects.Components.ScrollFactor,
                    GameObjects.Components.Size,
                    GameObjects.Components.Texture,
                    GameObjects.Components.Tint,
                    GameObjects.Components.Transform,
                    GameObjects.Components.Visible {
                /**
                 *
                 * @param world [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                constructor(world: World, x: number, y: number, texture: string, frame?: string | integer);

                /**
                 * [description]
                 */
                body: Body;

                /**
                 * [description]
                 */
                size: object;

                /**
                 * [description]
                 */
                offset: object;

                /**
                 * [description]
                 */
                vel: object;

                /**
                 * [description]
                 */
                accel: object;

                /**
                 * [description]
                 */
                friction: object;

                /**
                 * [description]
                 */
                maxVel: object;

                /**
                 * Clears all alpha values associated with this Game Object.
                 *
                 * Immediately sets the alpha levels back to 1 (fully opaque).
                 */
                clearAlpha(): this;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 *
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

                /**
                 * The alpha value of the Game Object.
                 *
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | BlendModes): this;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): this;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): this;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): this;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): this;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): this;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): this;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): this;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Geom.Rectangle>(output?: O): O;

                /**
                 * The Mask this Game Object is using during render.
                 */
                mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

                /**
                 * Sets the mask that this Game Object will use to render with.
                 *
                 * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
                 * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
                 *
                 * If a mask is already set on this Game Object it will be immediately replaced.
                 *
                 * Masks are positioned in global space and are not relative to the Game Object to which they
                 * are applied. The reason for this is that multiple Game Objects can all share the same mask.
                 *
                 * Masks have no impact on physics or input detection. They are purely a rendering component
                 * that allows you to limit what is visible during the render pass.
                 * @param mask The mask this Game Object will use when rendering.
                 */
                setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

                /**
                 * Clears the mask that this Game Object was using.
                 * @param destroyMask Destroy the mask before clearing it? Default false.
                 */
                clearMask(destroyMask?: boolean): this;

                /**
                 * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a renderable Game Object.
                 * A renderable Game Object is one that uses a texture to render with, such as an
                 * Image, Sprite, Render Texture or BitmapText.
                 *
                 * If you do not provide a renderable object, and this Game Object has a texture,
                 * it will use itself as the object. This means you can call this method to create
                 * a Bitmap Mask from any renderable Game Object.
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                createBitmapMask(renderable?: GameObjects.GameObject): Display.Masks.BitmapMask;

                /**
                 * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a Graphics Game Object.
                 *
                 * If you do not provide a graphics object, and this Game Object is an instance
                 * of a Graphics object, then it will use itself to create the mask.
                 *
                 * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
                 * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
                 */
                createGeometryMask(graphics?: GameObjects.Graphics): Display.Masks.GeometryMask;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 *
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): this;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): this;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): this;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): this;

                /**
                 * The initial WebGL pipeline of this Game Object.
                 */
                defaultPipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * The current WebGL pipeline of this Game Object.
                 */
                pipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
                 */
                initPipeline(pipelineName?: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): this;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: ScaleModes): this;

                /**
                 * The horizontal scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): this;

                /**
                 * The native (un-scaled) width of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayWidth` property.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayHeight` property.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Textures.Frame): this;

                /**
                 * Sets the internal size of this Game Object, as used for frame or physics body creation.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): this;

                /**
                 * Sets the display size of this Game Object.
                 *
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): this;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Textures.Texture | Textures.CanvasTexture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Textures.Frame;

                /**
                 * A boolean flag indicating if this Game Object is being cropped or not.
                 * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
                 * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
                 */
                isCropped: boolean;

                /**
                 * Applies a crop to a texture based Game Object, such as a Sprite or Image.
                 *
                 * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
                 *
                 * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
                 * changes what is shown when rendered.
                 *
                 * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
                 *
                 * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
                 * half of it, you could call `setCrop(0, 0, 400, 600)`.
                 *
                 * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
                 * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
                 *
                 * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
                 *
                 * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
                 *
                 * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
                 * the renderer to skip several internal calculations.
                 * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
                 * @param y The y coordinate to start the crop from.
                 * @param width The width of the crop rectangle in pixels.
                 * @param height The height of the crop rectangle in pixels.
                 */
                setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 *
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): this;

                /**
                 * Sets the frame this Game Object will use to render with.
                 *
                 * The Frame has to belong to the current Texture being used.
                 *
                 * It can be either a string or an index.
                 *
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

                /**
                 * Fill or additive?
                 */
                tintFill: boolean;

                /**
                 * Clears all tint values associated with this Game Object.
                 *
                 * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
                 * which results in no visible change to the texture.
                 */
                clearTint(): this;

                /**
                 * Sets an additive tint on this Game Object.
                 *
                 * The tint works by taking the pixel color values from the Game Objects texture, and then
                 * multiplying it by the color value of the tint. You can provide either one color value,
                 * in which case the whole Game Object will be tinted in that color. Or you can provide a color
                 * per corner. The colors are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
                 * @param topLeft The tint being applied to the top-left of the Game Object.
                 * If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * Sets a fill-based tint on this Game Object.
                 *
                 * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
                 * with those in the tint. You can use this for effects such as making a player flash 'white'
                 * if hit by something. You can provide either one color value, in which case the whole
                 * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
                 * are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
                 * @param topLeft The tint being applied to the top-left of the Game Object.
                 * If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * Does this Game Object have a tint applied to it or not?
                 */
                readonly isTinted: boolean;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 *
                 * Where 0 is to the right, 90 is down, 180 is left.
                 *
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 *
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): this;

                /**
                 * Sets the position of this Game Object to be a random position within the confines of
                 * the given area.
                 *
                 * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
                 *
                 * The position does not factor in the size of this Game Object, meaning that only the origin is
                 * guaranteed to be within the area.
                 * @param x The x position of the top-left of the random area. Default 0.
                 * @param y The y position of the top-left of the random area. Default 0.
                 * @param width The width of the random area.
                 * @param height The height of the random area.
                 */
                setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): this;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): this;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): this;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): this;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): this;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): this;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): this;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: GameObjects.Components.TransformMatrix): GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 * @param parentMatrix A temporary matrix to hold parent values during the calculations.
                 */
                getWorldTransformMatrix(
                    tempMatrix?: GameObjects.Components.TransformMatrix,
                    parentMatrix?: GameObjects.Components.TransformMatrix
                ): GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): this;

                /**
                 * Sets the horizontal acceleration of this body.
                 * @param x The amount of acceleration to apply.
                 */
                setAccelerationX(x: number): this;

                /**
                 * Sets the vertical acceleration of this body.
                 * @param y The amount of acceleration to apply.
                 */
                setAccelerationY(y: number): this;

                /**
                 * Sets the horizontal and vertical acceleration of this body.
                 * @param x The amount of horizontal acceleration to apply.
                 * @param y The amount of vertical acceleration to apply.
                 */
                setAcceleration(x: number, y: number): this;

                /**
                 * Sets the size of the physics body.
                 * @param width The width of the body in pixels.
                 * @param height The height of the body in pixels. Default width.
                 */
                setBodySize(width: number, height?: number): this;

                /**
                 * Sets the scale of the physics body.
                 * @param scaleX The horizontal scale of the body.
                 * @param scaleY The vertical scale of the body. If not given, will use the horizontal scale value.
                 */
                setBodyScale(scaleX: number, scaleY?: number): this;

                /**
                 * [description]
                 */
                getBodyinterface(): number;

                /**
                 * [description]
                 */
                setinterfaceNone(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setinterfaceA(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setinterfaceB(): GameObjects.GameObject;

                /**
                 * Sets the impact physics bounce, or restitution, value.
                 * @param value A value between 0 (no rebound) and 1 (full rebound)
                 */
                setBounce(value: number): GameObjects.GameObject;

                /**
                 * Sets the minimum velocity the body is allowed to be moving to be considered for rebound.
                 * @param value The minimum allowed velocity.
                 */
                setMinBounceVelocity(value: number): GameObjects.GameObject;

                /**
                 * The bounce, or restitution, value of this body.
                 * A value between 0 (no rebound) and 1 (full rebound)
                 */
                bounce: number;

                /**
                 * [description]
                 */
                setAvsB(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setBvsA(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstNone(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstA(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstB(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                checkAgainst: number;

                /**
                 * [description]
                 * @param callback [description]
                 * @param scope [description]
                 */
                setCollideCallback(callback: CollideCallback, scope: any): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCollidesNever(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setLiteCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setPassiveCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setActiveCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                setFixedCollision(): GameObjects.GameObject;

                /**
                 * [description]
                 */
                collides: number;

                /**
                 * [description]
                 * @param showBody [description]
                 * @param showVelocity [description]
                 * @param bodyColor [description]
                 */
                setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDebugBodyColor(value: number): GameObjects.GameObject;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: number;

                /**
                 * [description]
                 * @param x [description]
                 */
                setFrictionX(x: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setFrictionY(y: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setFriction(x: number, y: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setGravity(value: number): GameObjects.GameObject;

                /**
                 * [description]
                 */
                gravity: number;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                setOffset(x: number, y: number, width?: number, height?: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param gameObject [description]
                 * @param sync [description] Default true.
                 */
                setGameObject(gameObject: GameObjects.GameObject, sync?: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 */
                syncGameObject(): GameObjects.GameObject;

                /**
                 * Sets the horizontal velocity of the physics body.
                 * @param x The horizontal velocity value.
                 */
                setVelocityX(x: number): this;

                /**
                 * Sets the vertical velocity of the physics body.
                 * @param y The vertical velocity value.
                 */
                setVelocityY(y: number): this;

                /**
                 * Sets the horizontal and vertical velocities of the physics body.
                 * @param x The horizontal velocity value.
                 * @param y The vertical velocity value. If not given, defaults to the horizontal value. Default x.
                 */
                setVelocity(x: number, y?: number): this;

                /**
                 * Sets the maximum velocity this body can travel at.
                 * @param x The maximum allowed horizontal velocity.
                 * @param y The maximum allowed vertical velocity. If not given, defaults to the horizontal value. Default x.
                 */
                setMaxVelocity(x: number, y?: number): this;
            }

            /**
             * [description]
             * @param world [description]
             * @param left [description]
             * @param right [description]
             * @param weak [description]
             */
            function SeparateX(world: World, left: Body, right: Body, weak?: Body): void;

            /**
             * [description]
             * @param world [description]
             * @param top [description]
             * @param bottom [description]
             * @param weak [description]
             */
            function SeparateY(world: World, top: Body, bottom: Body, weak?: Body): void;

            /**
             * Impact Physics Solver
             * @param world The Impact simulation to run the solver in.
             * @param bodyA The first body in the collision.
             * @param bodyB The second body in the collision.
             */
            function Solver(world: World, bodyA: Body, bodyB: Body): void;

            /**
             * Collision types - Determine if and how entities collide with each other.
             *
             * In ACTIVE vs. LITE or FIXED vs. ANY collisions, only the "weak" entity moves,
             * while the other one stays fixed. In ACTIVE vs. ACTIVE and ACTIVE vs. PASSIVE
             * collisions, both entities are moved. LITE or PASSIVE entities don't collide
             * with other LITE or PASSIVE entities at all. The behavior for FIXED vs.
             * FIXED collisions is undefined.
             */
            enum interface {
                /**
                 * Collides with nothing.
                 */
                NONE,
                /**
                 * interface A. Collides with interface B.
                 */
                A,
                /**
                 * interface B. Collides with interface A.
                 */
                B,
                /**
                 * Collides with both types A and B.
                 */
                BOTH
            }

            /**
             * Set up the trace-result
             * var res {
             *     collision: {x: false, y: false, slope: false},
             *     pos: {x: x, y: y},
             *     tile: {x: 0, y: 0}
             * }
             * @param body [description]
             * @param res [description]
             */
            function UpdateMotion(body: Body, res: object): void;

            interface WorldConfig {
                /**
                 * Sets {@link Phaser.Physics.Impact.World#gravity}
                 */
                gravity?: number;
                /**
                 * The size of the cells used for the broadphase pass. Increase this value if you have lots of large objects in the world.
                 */
                cellSize?: number;
                /**
                 * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.
                 */
                timeScale?: number;
                /**
                 * [description]
                 */
                maxStep?: number;
                /**
                 * Sets {@link Phaser.Physics.Impact.World#debug}.
                 */
                debug?: boolean;
                /**
                 * The maximum velocity a body can move.
                 */
                maxVelocity?: number;
                /**
                 * Whether the Body's boundary is drawn to the debug display.
                 */
                debugShowBody?: boolean;
                /**
                 * Whether the Body's velocity is drawn to the debug display.
                 */
                debugShowVelocity?: boolean;
                /**
                 * The color of this Body on the debug display.
                 */
                debugBodyColor?: number;
                /**
                 * The color of the Body's velocity on the debug display.
                 */
                debugVelocityColor?: number;
                /**
                 * Maximum X velocity objects can move.
                 */
                maxVelocityX?: number;
                /**
                 * Maximum Y velocity objects can move.
                 */
                maxVelocityY?: number;
                /**
                 * The minimum velocity an object can be moving at to be considered for bounce.
                 */
                minBounceVelocity?: number;
                /**
                 * Gravity multiplier. Set to 0 for no gravity.
                 */
                gravityFactor?: number;
                /**
                 * The default bounce, or restitution, of bodies in the world.
                 */
                bounciness?: number;
                /**
                 * Should the world have bounds enabled by default?
                 */
                setBounds?: object | boolean;
                /**
                 * The x coordinate of the world bounds.
                 */
                "setBounds.x"?: number;
                /**
                 * The y coordinate of the world bounds.
                 */
                "setBounds.y"?: number;
                /**
                 * The width of the world bounds.
                 */
                "setBounds.width"?: number;
                /**
                 * The height of the world bounds.
                 */
                "setBounds.height"?: number;
                /**
                 * The thickness of the walls of the world bounds.
                 */
                "setBounds.thickness"?: number;
                /**
                 * Should the left-side world bounds wall be created?
                 */
                "setBounds.left"?: boolean;
                /**
                 * Should the right-side world bounds wall be created?
                 */
                "setBounds.right"?: boolean;
                /**
                 * Should the top world bounds wall be created?
                 */
                "setBounds.top"?: boolean;
                /**
                 * Should the bottom world bounds wall be created?
                 */
                "setBounds.bottom"?: boolean;
            }

            /**
             * An object containing the 4 wall bodies that bound the physics world.
             */
            interface WorldDefaults {
                /**
                 * Whether the Body's boundary is drawn to the debug display.
                 */
                debugShowBody: boolean;
                /**
                 * Whether the Body's velocity is drawn to the debug display.
                 */
                debugShowVelocity: boolean;
                /**
                 * The color of this Body on the debug display.
                 */
                bodyDebugColor: number;
                /**
                 * The color of the Body's velocity on the debug display.
                 */
                velocityDebugColor: number;
                /**
                 * Maximum X velocity objects can move.
                 */
                maxVelocityX: number;
                /**
                 * Maximum Y velocity objects can move.
                 */
                maxVelocityY: number;
                /**
                 * The minimum velocity an object can be moving at to be considered for bounce.
                 */
                minBounceVelocity: number;
                /**
                 * Gravity multiplier. Set to 0 for no gravity.
                 */
                gravityFactor: number;
                /**
                 * The default bounce, or restitution, of bodies in the world.
                 */
                bounciness: number;
            }

            interface WorldWalls {
                /**
                 * The left-side wall of the world bounds.
                 */
                left: Body;
                /**
                 * The right-side wall of the world bounds.
                 */
                right: Body;
                /**
                 * The top wall of the world bounds.
                 */
                top: Body;
                /**
                 * The bottom wall of the world bounds.
                 */
                bottom: Body;
            }

            /**
             * [description]
             */
            class World extends Phaser.Events.EventEmitter {
                /**
                 *
                 * @param scene The Scene to which this Impact World instance belongs.
                 * @param config [description]
                 */
                constructor(scene: Scene, config: WorldConfig);

                /**
                 * [description]
                 */
                scene: Scene;

                /**
                 * [description]
                 */
                bodies: Structs.Set<Body>;

                /**
                 * [description]
                 */
                gravity: number;

                /**
                 * Spatial hash cell dimensions
                 */
                cellSize: integer;

                /**
                 * [description]
                 */
                collisionMap: CollisionMap;

                /**
                 * [description]
                 */
                timeScale: number;

                /**
                 * Impacts maximum time step is 20 fps.
                 */
                maxStep: number;

                /**
                 * [description]
                 */
                enabled: boolean;

                /**
                 * [description]
                 */
                drawDebug: boolean;

                /**
                 * [description]
                 */
                debugGraphic: GameObjects.Graphics;

                /**
                 * [description]
                 */
                defaults: WorldDefaults;

                /**
                 * An object containing the 4 wall bodies that bound the physics world.
                 */
                walls: WorldWalls;

                /**
                 * [description]
                 */
                delta: number;

                /**
                 * Sets the collision map for the world either from a Weltmeister JSON level in the cache or from
                 * a 2D array. If loading from a Weltmeister level, the map must have a layer called "collision".
                 * @param key Either a string key that corresponds to a Weltmeister level
                 * in the cache, or a 2D array of collision IDs.
                 * @param tileSize The size of a tile. This is optional if loading from a Weltmeister
                 * level in the cache.
                 */
                setCollisionMap(key: string | integer[][], tileSize: integer): CollisionMap;

                /**
                 * Sets the collision map for the world from a tilemap layer. Only tiles that are marked as
                 * colliding will be used. You can specify the mapping from tiles to slope IDs in a couple of
                 * ways. The easiest is to use Tiled and the slopeTileProperty option. Alternatively, you can
                 * manually create a slopeMap that stores the mapping between tile indices and slope IDs.
                 * @param tilemapLayer The tilemap layer to use.
                 * @param options Options for controlling the mapping from tiles to slope IDs.
                 */
                setCollisionMapFromTilemapLayer(tilemapLayer: Tilemaps.DynamicTilemapLayer | Tilemaps.StaticTilemapLayer, options?: CollisionOptions): CollisionMap;

                /**
                 * Sets the bounds of the Physics world to match the given world pixel dimensions.
                 * You can optionally set which 'walls' to create: left, right, top or bottom.
                 * If none of the walls are given it will default to use the walls settings it had previously.
                 * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size
                 * the newly created bounds will also not have the left and right walls.
                 * Explicitly state them in the parameters to override this.
                 * @param x The x coordinate of the top-left corner of the bounds.
                 * @param y The y coordinate of the top-left corner of the bounds.
                 * @param width The width of the bounds.
                 * @param height The height of the bounds.
                 * @param thickness [description] Default 64.
                 * @param left If true will create the left bounds wall. Default true.
                 * @param right If true will create the right bounds wall. Default true.
                 * @param top If true will create the top bounds wall. Default true.
                 * @param bottom If true will create the bottom bounds wall. Default true.
                 */
                setBounds(x?: number, y?: number, width?: number, height?: number, thickness?: number, left?: boolean, right?: boolean, top?: boolean, bottom?: boolean): World;

                /**
                 * position = 'left', 'right', 'top' or 'bottom'
                 * @param add [description]
                 * @param position [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                updateWall(add: boolean, position: string, x: number, y: number, width: number, height: number): void;

                /**
                 * Creates a Graphics Game Object used for debug display and enables the world for debug drawing.
                 */
                createDebugGraphic(): GameObjects.Graphics;

                /**
                 * [description]
                 */
                getNextID(): integer;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param sizeX [description]
                 * @param sizeY [description]
                 */
                create(x: number, y: number, sizeX: number, sizeY: number): Body;

                /**
                 * [description]
                 * @param object The Body to remove from this World.
                 */
                remove(object: Body): void;

                /**
                 * [description]
                 */
                pause(): World;

                /**
                 * [description]
                 */
                resume(): World;

                /**
                 * [description]
                 * @param time The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
                 * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
                 */
                update(time: number, delta: number): void;

                /**
                 * Check the body against the spatial hash.
                 * @param body [description]
                 * @param hash [description]
                 * @param size [description]
                 */
                checkHash(body: Body, hash: object, size: number): void;

                /**
                 * [description]
                 * @param bodyA [description]
                 * @param bodyB [description]
                 */
                checkBodies(bodyA: Body, bodyB: Body): void;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the collides value on.
                 */
                setCollidesNever(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the collides value on.
                 */
                setLite(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the collides value on.
                 */
                setPassive(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the collides value on.
                 */
                setActive(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the collides value on.
                 */
                setFixed(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the interface value on.
                 */
                setinterfaceNone(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the interface value on.
                 */
                setinterfaceA(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the interface value on.
                 */
                setinterfaceB(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the interface value on.
                 */
                setAvsB(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the interface value on.
                 */
                setBvsA(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the interface value on.
                 */
                setCheckAgainstNone(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the interface value on.
                 */
                setCheckAgainstA(bodies: Body[]): World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the interface value on.
                 */
                setCheckAgainstB(bodies: Body[]): World;

                /**
                 * [description]
                 */
                shutdown(): void;

                /**
                 * [description]
                 */
                destroy(): void;
            }
        }

        namespace Matter {
            namespace Components {
                /**
                 * A component to set restitution on objects.
                 */
                interface Bounce {
                    /**
                     * Sets the restitution on the physics object.
                     * @param value A Number that defines the restitution (elasticity) of the body.
                     * The value is always positive and is in the range (0, 1). A value of 0 means collisions may be perfectly inelastic and no bouncing may occur.
                     * A value of 0.8 means the body may bounce back with approximately 80% of its kinetic energy. Note that collision response is based on pairs of bodies,
                     * and that restitution values are combined with the following formula: `Math.max(bodyA.restitution, bodyB.restitution)`
                     */
                    setBounce(value: number): GameObjects.GameObject;
                }

                /**
                 * Contains methods for changing the collision filter of a Matter Body. Should be used as a mixin and not called directly.
                 */
                interface Collision {
                    /**
                     * Sets the collision category of this Game Object's Matter Body.
                     * This number must be a power of two between 2^0 (= 1) and 2^31.
                     * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision categories
                     * are included in their collision masks (see {@link #setCollidesWith}).
                     * @param value Unique category bitfield.
                     */
                    setCollisionCategory(value: number): GameObjects.GameObject;
                    /**
                     * Sets the collision group of this Game Object's Matter Body.
                     * If this is zero or two Matter Bodies have different values,
                     * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).
                     * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value, they will never collide.
                     * @param value Unique group index.
                     */
                    setCollisionGroup(value: number): GameObjects.GameObject;
                    /**
                     * Sets the collision mask for this Game Object's Matter Body.
                     * Two Matter Bodies with different collision groups will only collide if each one includes the other's category in its mask based on a
                     * bitwise AND, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0` are both true.
                     * @param categories A unique category bitfield, or an array of them.
                     */
                    setCollidesWith(categories: number | number[]): GameObjects.GameObject;
                }

                /**
                 * A component to apply force to Matter.js bodies.
                 */
                interface Force {
                    /**
                     * Applies a force to a body.
                     * @param force A Vector that specifies the force to apply.
                     */
                    applyForce(force: Math.Vector2): GameObjects.GameObject;
                    /**
                     * Applies a force to a body from a given position.
                     * @param position The position in which the force comes from.
                     * @param force A Vector that specifies the force to apply.
                     */
                    applyForceFrom(position: Math.Vector2, force: Math.Vector2): GameObjects.GameObject;
                    /**
                     * Apply thrust to the forward position of the body.
                     * @param speed A speed value to be applied to a directional force.
                     */
                    thrust(speed: number): GameObjects.GameObject;
                    /**
                     * Apply thrust to the left position of the body.
                     * @param speed A speed value to be applied to a directional force.
                     */
                    thrustLeft(speed: number): GameObjects.GameObject;
                    /**
                     * Apply thrust to the right position of the body.
                     * @param speed A speed value to be applied to a directional force.
                     */
                    thrustRight(speed: number): GameObjects.GameObject;
                    /**
                     * Apply thrust to the back position of the body.
                     * @param speed A speed value to be applied to a directional force.
                     */
                    thrustBack(speed: number): GameObjects.GameObject;
                }

                /**
                 * Contains methods for changing the friction of a Game Object's Matter Body. Should be used a mixin, not called directly.
                 */
                interface Friction {
                    /**
                     * Sets new friction values for this Game Object's Matter Body.
                     * @param value The new friction of the body, between 0 and 1, where 0 allows the Body to slide indefinitely, while 1 allows it to stop almost immediately after a force is applied.
                     * @param air If provided, the new air resistance of the Body.
                     * The higher the value, the faster the Body will slow as it moves through space. 0 means the body has no air resistance.
                     * @param fstatic If provided, the new static friction of the Body.
                     * The higher the value (e.g. 10), the more force it will take to initially get the Body moving when it is nearly stationary.
                     * 0 means the body will never "stick" when it is nearly stationary.
                     */
                    setFriction(value: number, air?: number, fstatic?: number): GameObjects.GameObject;
                    /**
                     * Sets a new air resistance for this Game Object's Matter Body.
                     * A value of 0 means the Body will never slow as it moves through space. The higher the value, the faster a Body slows when moving through space.
                     * @param value The new air resistance for the Body.
                     */
                    setFrictionAir(value: number): GameObjects.GameObject;
                    /**
                     * Sets a new static friction for this Game Object's Matter Body. A value of 0 means the Body will never "stick" when it is nearly stationary.
                     * The higher the value (e.g. 10), the more force it will take to initially get the Body moving when it is nearly stationary.
                     * @param value The new static friction for the Body.
                     */
                    setFrictionStatic(value: number): GameObjects.GameObject;
                }

                /**
                 * A component to manipulate world gravity for Matter.js bodies.
                 */
                interface Gravity {
                    /**
                     * A togglable function for ignoring world gravity in real-time on the current body.
                     * @param value Set to true to ignore the effect of world gravity, or false to not ignore it.
                     */
                    setIgnoreGravity(value: boolean): GameObjects.GameObject;
                }

                /**
                 * Allows accessing the mass, density, and center of mass of a Matter-enabled Game Object. Should be used as a mixin and not directly.
                 */
                interface Mass {
                    /**
                     * Sets the mass of the Game Object's Matter Body.
                     * @param value The new mass of the body.
                     */
                    setMass(value: number): GameObjects.GameObject;
                    /**
                     * Sets density of the body.
                     * @param value The new density of the body.
                     */
                    setDensity(value: number): GameObjects.GameObject;
                    /**
                     * The body's center of mass.
                     */
                    readonly centerOfMass: any;
                }

                /**
                 * [description]
                 */
                interface Sensor {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setSensor(value: boolean): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    isSensor(): boolean;
                }

                /**
                 * [description]
                 */
                interface SetBody {
                    /**
                     * Set the body on a Game Object to a rectangle.
                     * @param width Width of the rectangle.
                     * @param height Height of the rectangle.
                     * @param options [description]
                     */
                    setRectangle(width: number, height: number, options: object): GameObjects.GameObject;
                    /**
                     * [description]
                     * @param radius [description]
                     * @param options [description]
                     */
                    setCircle(radius: number, options: object): GameObjects.GameObject;
                    /**
                     * Set the body on the Game Object to a polygon shape.
                     * @param radius The radius of the polygon.
                     * @param sides The amount of sides creating the polygon.
                     * @param options A matterjs config object.
                     */
                    setPolygon(radius: number, sides: number, options: object): GameObjects.GameObject;
                    /**
                     * Creates a new matterjs trapezoid body.
                     * @param width The width of the trapezoid.
                     * @param height The height of the trapezoid.
                     * @param slope The angle of slope for the trapezoid.
                     * @param options A matterjs config object for the body.
                     */
                    setTrapezoid(width: number, height: number, slope: number, options: object): GameObjects.GameObject;
                    /**
                     * [description]
                     * @param body [description]
                     * @param addToWorld [description] Default true.
                     */
                    setExistingBody(body: MatterJS.Body, addToWorld?: boolean): GameObjects.GameObject;
                    /**
                     * [description]
                     * @param config [description]
                     * @param options [description]
                     */
                    setBody(config: object, options: object): GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Sleep {
                    /**
                     * [description]
                     * @param value [description] Default 60.
                     */
                    setSleepThreshold(value?: number): GameObjects.GameObject;
                    /**
                     * [description]
                     * @param start [description]
                     * @param end [description]
                     */
                    setSleepEvents(start: boolean, end: boolean): GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setSleepStartEvent(value: boolean): GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setSleepEndEvent(value: boolean): GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Static {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setStatic(value: boolean): GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    isStatic(): boolean;
                }

                /**
                 * Provides methods used for getting and setting the position, scale and rotation of a Game Object.
                 */
                interface Transform {
                    /**
                     * The x position of this Game Object.
                     */
                    x: number;
                    /**
                     * The y position of this Game Object.
                     */
                    y: number;
                    /**
                     * The horizontal scale of this Game Object.
                     */
                    scaleX: number;
                    /**
                     * The vertical scale of this Game Object.
                     */
                    scaleY: number;
                    /**
                     * Use `angle` to set or get rotation of the physics body associated to this GameObject.
                     * Unlike rotation, when using set the value can be in degrees, which will be converted to radians internally.
                     */
                    angle: number;
                    /**
                     * Use `rotation` to set or get the rotation of the physics body associated with this GameObject. The value when set must be in radians.
                     */
                    rotation: number;
                    /**
                     * Sets the position of the physics body along x and y axes. Both the parameters to this function are optional and if not passed any they default to 0.
                     * @param x The horizontal position of the body. Default 0.
                     * @param y The vertical position of the body. Default x.
                     */
                    setPosition(x?: number, y?: number): this;
                    /**
                     * [description]
                     * @param radians [description] Default 0.
                     */
                    setRotation(radians?: number): this;
                    /**
                     * [description]
                     */
                    setFixedRotation(): this;
                    /**
                     * [description]
                     * @param degrees [description] Default 0.
                     */
                    setAngle(degrees?: number): this;
                    /**
                     * Sets the scale of this Game Object.
                     * @param x The horizontal scale of this Game Object. Default 1.
                     * @param y The vertical scale of this Game Object. If not set it will use the x value. Default x.
                     * @param point The point (Vector2) from which scaling will occur.
                     */
                    setScale(x?: number, y?: number, point?: Math.Vector2): this;
                }

                /**
                 * [description]
                 */
                interface Velocity {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setAngularVelocity(value: number): GameObjects.GameObject;
                    /**
                     * Sets the horizontal velocity of the physics body.
                     * @param x The horizontal velocity value.
                     */
                    setVelocityX(x: number): GameObjects.GameObject;
                    /**
                     * Sets vertical velocity of the physics body.
                     * @param y The vertical velocity value.
                     */
                    setVelocityY(y: number): GameObjects.GameObject;
                    /**
                     * Sets both the horizontal and vertical velocity of the physics body.
                     * @param x The horizontal velocity value.
                     * @param y The vertical velocity value, it can be either positive or negative. If not given, it will be the same as the `x` value. Default x.
                     */
                    setVelocity(x: number, y?: number): GameObjects.GameObject;
                }
            }

            namespace Events {
                interface AfterUpdateEvent {
                    /**
                     * The Matter Engine `timing.timestamp` value for the event.
                     */
                    timestamp: number;
                    /**
                     * The source object of the event.
                     */
                    source: any;
                    /**
                     * The name of the event.
                     */
                    name: string;
                }

                /**
                 * The Matter Physics After Update Event.
                 *
                 * This event is dispatched by a Matter Physics World instance after the engine has updated and all collision events have resolved.
                 *
                 * Listen to it from a Scene using: `this.matter.world.on('afterupdate', listener)`.
                 */
                const AFTER_UPDATE: any;

                interface BeforeUpdateEvent {
                    /**
                     * The Matter Engine `timing.timestamp` value for the event.
                     */
                    timestamp: number;
                    /**
                     * The source object of the event.
                     */
                    source: any;
                    /**
                     * The name of the event.
                     */
                    name: string;
                }

                /**
                 * The Matter Physics Before Update Event.
                 *
                 * This event is dispatched by a Matter Physics World instance right before all the collision processing takes place.
                 *
                 * Listen to it from a Scene using: `this.matter.world.on('beforeupdate', listener)`.
                 */
                const BEFORE_UPDATE: any;

                interface CollisionActiveEvent {
                    /**
                     * A list of all affected pairs in the collision.
                     */
                    pairs: any[];
                    /**
                     * The Matter Engine `timing.timestamp` value for the event.
                     */
                    timestamp: number;
                    /**
                     * The source object of the event.
                     */
                    source: any;
                    /**
                     * The name of the event.
                     */
                    name: string;
                }

                /**
                 * The Matter Physics Collision Active Event.
                 *
                 * This event is dispatched by a Matter Physics World instance after the engine has updated.
                 * It provides a list of all pairs that are colliding in the current tick (if any).
                 *
                 * Listen to it from a Scene using: `this.matter.world.on('collisionactive', listener)`.
                 */
                const COLLISION_ACTIVE: any;

                interface CollisionEndEvent {
                    /**
                     * A list of all affected pairs in the collision.
                     */
                    pairs: any[];
                    /**
                     * The Matter Engine `timing.timestamp` value for the event.
                     */
                    timestamp: number;
                    /**
                     * The source object of the event.
                     */
                    source: any;
                    /**
                     * The name of the event.
                     */
                    name: string;
                }

                /**
                 * The Matter Physics Collision End Event.
                 *
                 * This event is dispatched by a Matter Physics World instance after the engine has updated.
                 * It provides a list of all pairs that have finished colliding in the current tick (if any).
                 *
                 * Listen to it from a Scene using: `this.matter.world.on('collisionend', listener)`.
                 */
                const COLLISION_END: any;

                interface CollisionStartEvent {
                    /**
                     * A list of all affected pairs in the collision.
                     */
                    pairs: any[];
                    /**
                     * The Matter Engine `timing.timestamp` value for the event.
                     */
                    timestamp: number;
                    /**
                     * The source object of the event.
                     */
                    source: any;
                    /**
                     * The name of the event.
                     */
                    name: string;
                }

                /**
                 * The Matter Physics Collision Start Event.
                 *
                 * This event is dispatched by a Matter Physics World instance after the engine has updated.
                 * It provides a list of all pairs that have started to collide in the current tick (if any).
                 *
                 * Listen to it from a Scene using: `this.matter.world.on('collisionstart', listener)`.
                 */
                const COLLISION_START: any;

                /**
                 * The Matter Physics World Pause Event.
                 *
                 * This event is dispatched by an Matter Physics World instance when it is paused.
                 *
                 * Listen to it from a Scene using: `this.matter.world.on('pause', listener)`.
                 */
                const PAUSE: any;

                /**
                 * The Matter Physics World Resume Event.
                 *
                 * This event is dispatched by an Matter Physics World instance when it resumes from a paused state.
                 *
                 * Listen to it from a Scene using: `this.matter.world.on('resume', listener)`.
                 */
                const RESUME: any;

                interface SleepEndEvent {
                    /**
                     * The source object of the event.
                     */
                    source: any;
                    /**
                     * The name of the event.
                     */
                    name: string;
                }

                /**
                 * The Matter Physics Sleep End Event.
                 *
                 * This event is dispatched by a Matter Physics World instance when a Body stop sleeping.
                 *
                 * Listen to it from a Scene using: `this.matter.world.on('sleepend', listener)`.
                 */
                const SLEEP_END: any;

                interface SleepStartEvent {
                    /**
                     * The source object of the event.
                     */
                    source: any;
                    /**
                     * The name of the event.
                     */
                    name: string;
                }

                /**
                 * The Matter Physics Sleep Start Event.
                 *
                 * This event is dispatched by a Matter Physics World instance when a Body goes to sleep.
                 *
                 * Listen to it from a Scene using: `this.matter.world.on('sleepstart', listener)`.
                 */
                const SLEEP_START: any;
            }

            /**
             * The Matter Factory can create different types of bodies and them to a physics world.
             */
            class Factory {
                /**
                 *
                 * @param world The Matter World which this Factory adds to.
                 */
                constructor(world: World);

                /**
                 * The Matter World which this Factory adds to.
                 */
                world: World;

                /**
                 * The Scene which this Factory's Matter World belongs to.
                 */
                scene: Scene;

                /**
                 * A reference to the Scene.Systems this Matter Physics instance belongs to.
                 */
                sys: Scenes.Systems;

                /**
                 * Creates a new rigid rectangular Body and adds it to the World.
                 * @param x The X coordinate of the center of the Body.
                 * @param y The Y coordinate of the center of the Body.
                 * @param width The width of the Body.
                 * @param height The height of the Body.
                 * @param options An object of properties to set on the Body. You can also specify a `chamfer` property to automatically adjust the body.
                 */
                rectangle(x: number, y: number, width: number, height: number, options: object): MatterJS.Body;

                /**
                 * Creates a new rigid trapezoidal Body and adds it to the World.
                 * @param x The X coordinate of the center of the Body.
                 * @param y The Y coordinate of the center of the Body.
                 * @param width The width of the trapezoid of the Body.
                 * @param height The height of the trapezoid of the Body.
                 * @param slope The slope of the trapezoid. 0 creates a rectangle, while 1 creates a triangle.
                 * Positive values make the top side shorter, while negative values make the bottom side shorter.
                 * @param options An object of properties to set on the Body. You can also specify a `chamfer` property to automatically adjust the body.
                 */
                trapezoid(x: number, y: number, width: number, height: number, slope: number, options: object): MatterJS.Body;

                /**
                 * Creates a new rigid circular Body and adds it to the World.
                 * @param x The X coordinate of the center of the Body.
                 * @param y The Y coordinate of the center of the Body.
                 * @param radius The radius of the circle.
                 * @param options An object of properties to set on the Body. You can also specify a `chamfer` property to automatically adjust the body.
                 * @param maxSides The maximum amount of sides to use for the polygon which will approximate this circle.
                 */
                circle(x: number, y: number, radius: number, options: object, maxSides: number): MatterJS.Body;

                /**
                 * Creates a new rigid polygonal Body and adds it to the World.
                 * @param x The X coordinate of the center of the Body.
                 * @param y The Y coordinate of the center of the Body.
                 * @param sides The number of sides the polygon will have.
                 * @param radius The "radius" of the polygon, i.e. the distance from its center to any vertex. This is also the radius of its circumcircle.
                 * @param options An object of properties to set on the Body. You can also specify a `chamfer` property to automatically adjust the body.
                 */
                polygon(x: number, y: number, sides: number, radius: number, options: object): MatterJS.Body;

                /**
                 * Creates a body using the supplied vertices (or an array containing multiple sets of vertices) and adds it to the World.
                 * If the vertices are convex, they will pass through as supplied.
                 * Otherwise, if the vertices are concave, they will be decomposed. Note that this process is not guaranteed to support complex sets of vertices, e.g. ones with holes.
                 * @param x The X coordinate of the center of the Body.
                 * @param y The Y coordinate of the center of the Body.
                 * @param vertexSets [description]
                 * @param options [description]
                 * @param flagInternal Flag internal edges (coincident part edges)
                 * @param removeCollinear Whether Matter.js will discard collinear edges (to improve performance).
                 * @param minimumArea During decomposition discard parts that have an area less than this
                 */
                fromVertices(x: number, y: number, vertexSets: any[], options: object, flagInternal: boolean, removeCollinear: boolean, minimumArea: number): MatterJS.Body;

                /**
                 * Create a new composite containing Matter Image objects created in a grid arrangement.
                 * This function uses the body bounds to prevent overlaps.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.
                 * @param x The horizontal position of this composite in the world.
                 * @param y The vertical position of this composite in the world.
                 * @param columns The number of columns in the grid.
                 * @param rows The number of rows in the grid.
                 * @param columnGap The distance between each column. Default 0.
                 * @param rowGap The distance between each row. Default 0.
                 * @param options [description]
                 */
                imageStack(key: string, frame: string | integer, x: number, y: number, columns: number, rows: number, columnGap?: number, rowGap?: number, options?: object): MatterJS.Composite;

                /**
                 * Create a new composite containing bodies created in the callback in a grid arrangement.
                 * This function uses the body bounds to prevent overlaps.
                 * @param x The horizontal position of this composite in the world.
                 * @param y The vertical position of this composite in the world.
                 * @param columns The number of columns in the grid.
                 * @param rows The number of rows in the grid.
                 * @param columnGap The distance between each column.
                 * @param rowGap The distance between each row.
                 * @param callback The callback that creates the stack.
                 */
                stack(x: number, y: number, columns: number, rows: number, columnGap: number, rowGap: number, callback: CallbackFn): MatterJS.Composite;

                /**
                 * Create a new composite containing bodies created in the callback in a pyramid arrangement.
                 * This function uses the body bounds to prevent overlaps.
                 * @param x The horizontal position of this composite in the world.
                 * @param y The vertical position of this composite in the world.
                 * @param columns The number of columns in the pyramid.
                 * @param rows The number of rows in the pyramid.
                 * @param columnGap The distance between each column.
                 * @param rowGap The distance between each row.
                 * @param callback The callback function to be invoked.
                 */
                pyramid(x: number, y: number, columns: number, rows: number, columnGap: number, rowGap: number, callback: CallbackFn): MatterJS.Composite;

                /**
                 * Chains all bodies in the given composite together using constraints.
                 * @param composite [description]
                 * @param xOffsetA [description]
                 * @param yOffsetA [description]
                 * @param xOffsetB [description]
                 * @param yOffsetB [description]
                 * @param options [description]
                 */
                chain(composite: MatterJS.Composite, xOffsetA: number, yOffsetA: number, xOffsetB: number, yOffsetB: number, options: object): MatterJS.Composite;

                /**
                 * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
                 * @param composite [description]
                 * @param columns [description]
                 * @param rows [description]
                 * @param crossBrace [description]
                 * @param options [description]
                 */
                mesh(composite: MatterJS.Composite, columns: number, rows: number, crossBrace: boolean, options: object): MatterJS.Composite;

                /**
                 * Creates a composite with a Newton's Cradle setup of bodies and constraints.
                 * @param x [description]
                 * @param y [description]
                 * @param number [description]
                 * @param size [description]
                 * @param length [description]
                 */
                newtonsCradle(x: number, y: number, number: number, size: number, length: number): MatterJS.Composite;

                /**
                 * Creates a composite with simple car setup of bodies and constraints.
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 * @param wheelSize [description]
                 */
                car(x: number, y: number, width: number, height: number, wheelSize: number): MatterJS.Composite;

                /**
                 * Creates a simple soft body like object.
                 * @param x The horizontal position of this composite in the world.
                 * @param y The vertical position of this composite in the world.
                 * @param columns The number of columns in the Composite.
                 * @param rows The number of rows in the Composite.
                 * @param columnGap The distance between each column.
                 * @param rowGap The distance between each row.
                 * @param crossBrace [description]
                 * @param particleRadius The radius of this circlular composite.
                 * @param particleOptions [description]
                 * @param constraintOptions [description]
                 */
                softBody(
                    x: number,
                    y: number,
                    columns: number,
                    rows: number,
                    columnGap: number,
                    rowGap: number,
                    crossBrace: boolean,
                    particleRadius: number,
                    particleOptions: object,
                    constraintOptions: object
                ): MatterJS.Composite;

                /**
                 * [description]
                 * @param bodyA [description]
                 * @param bodyB [description]
                 * @param length [description]
                 * @param stiffness [description] Default 1.
                 * @param options [description] Default {}.
                 */
                joint(bodyA: MatterJS.Body, bodyB: MatterJS.Body, length: number, stiffness?: number, options?: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param bodyA The first possible `Body` that this constraint is attached to.
                 * @param bodyB The second possible `Body` that this constraint is attached to.
                 * @param length A Number that specifies the target resting length of the constraint.
                 * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`
                 * @param stiffness A Number that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.
                 * A value of `1` means the constraint should be very stiff. A value of `0.2` means the constraint acts as a soft spring. Default 1.
                 * @param options [description] Default {}.
                 */
                spring(bodyA: MatterJS.Body, bodyB: MatterJS.Body, length: number, stiffness?: number, options?: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param bodyA [description]
                 * @param bodyB [description]
                 * @param length [description]
                 * @param stiffness [description] Default 1.
                 * @param options [description] Default {}.
                 */
                constraint(bodyA: MatterJS.Body, bodyB: MatterJS.Body, length: number, stiffness?: number, options?: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param bodyB [description]
                 * @param length [description]
                 * @param stiffness [description] Default 1.
                 * @param options [description] Default {}.
                 */
                worldConstraint(bodyB: MatterJS.Body, length: number, stiffness?: number, options?: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param options [description]
                 */
                mouseSpring(options: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param options [description]
                 */
                pointerConstraint(options: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.
                 * @param options [description] Default {}.
                 */
                image(x: number, y: number, key: string, frame?: string | integer, options?: object): Image;

                /**
                 * [description]
                 * @param tile [description]
                 * @param options [description]
                 */
                tileBody(tile: Tilemaps.Tile, options: object): TileBody;

                /**
                 * [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.
                 * @param options [description] Default {}.
                 */
                sprite(x: number, y: number, key: string, frame?: string | integer, options?: object): Sprite;

                /**
                 * [description]
                 * @param gameObject The Game Object to inject the Matter Body in to.
                 * @param options [description]
                 */
                gameObject(gameObject: GameObjects.GameObject, options: object): GameObjects.GameObject;

                /**
                 * Destroys this Factory.
                 */
                destroy(): void;
            }

            /**
             * [description]
             * @param world The Matter world to add the body to.
             * @param gameObject The Game Object that will have the Matter body applied to it.
             * @param options Matter options config object.
             */
            function MatterGameObject(world: World, gameObject: GameObjects.GameObject, options: object): GameObjects.GameObject;

            /**
             * A Matter Physics Image Game Object.
             *
             * An Image is a light-weight Game Object useful for the display of static images in your game,
             * such as logos, backgrounds, scenery or other non-animated elements. Images can have input
             * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an
             * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.
             */
            class Image extends GameObjects.Image
                implements
                    Components.Bounce,
                    Components.Collision,
                    Components.Force,
                    Components.Friction,
                    Components.Gravity,
                    Components.Mass,
                    Components.Sensor,
                    Components.SetBody,
                    Components.Sleep,
                    Components.Static,
                    Components.Transform,
                    Components.Velocity,
                    GameObjects.Components.Alpha,
                    GameObjects.Components.BlendMode,
                    GameObjects.Components.Depth,
                    GameObjects.Components.Flip,
                    GameObjects.Components.GetBounds,
                    GameObjects.Components.Origin,
                    GameObjects.Components.Pipeline,
                    GameObjects.Components.ScaleMode,
                    GameObjects.Components.ScrollFactor,
                    GameObjects.Components.Size,
                    GameObjects.Components.Texture,
                    GameObjects.Components.Tint,
                    GameObjects.Components.Transform,
                    GameObjects.Components.Visible {
                /**
                 *
                 * @param world [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 * @param options Matter.js configuration object. Default {}.
                 */
                constructor(world: World, x: number, y: number, texture: string, frame?: string | integer, options?: object);

                /**
                 * [description]
                 */
                world: World;

                /**
                 * Clears all alpha values associated with this Game Object.
                 *
                 * Immediately sets the alpha levels back to 1 (fully opaque).
                 */
                clearAlpha(): this;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 *
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

                /**
                 * The alpha value of the Game Object.
                 *
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | BlendModes): this;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): this;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): this;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): this;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): this;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): this;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): this;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): this;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Geom.Rectangle>(output?: O): O;

                /**
                 * The Mask this Game Object is using during render.
                 */
                mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

                /**
                 * Sets the mask that this Game Object will use to render with.
                 *
                 * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
                 * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
                 *
                 * If a mask is already set on this Game Object it will be immediately replaced.
                 *
                 * Masks are positioned in global space and are not relative to the Game Object to which they
                 * are applied. The reason for this is that multiple Game Objects can all share the same mask.
                 *
                 * Masks have no impact on physics or input detection. They are purely a rendering component
                 * that allows you to limit what is visible during the render pass.
                 * @param mask The mask this Game Object will use when rendering.
                 */
                setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

                /**
                 * Clears the mask that this Game Object was using.
                 * @param destroyMask Destroy the mask before clearing it? Default false.
                 */
                clearMask(destroyMask?: boolean): this;

                /**
                 * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a renderable Game Object.
                 * A renderable Game Object is one that uses a texture to render with, such as an
                 * Image, Sprite, Render Texture or BitmapText.
                 *
                 * If you do not provide a renderable object, and this Game Object has a texture,
                 * it will use itself as the object. This means you can call this method to create
                 * a Bitmap Mask from any renderable Game Object.
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                createBitmapMask(renderable?: GameObjects.GameObject): Display.Masks.BitmapMask;

                /**
                 * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a Graphics Game Object.
                 *
                 * If you do not provide a graphics object, and this Game Object is an instance
                 * of a Graphics object, then it will use itself to create the mask.
                 *
                 * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
                 * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
                 */
                createGeometryMask(graphics?: GameObjects.Graphics): Display.Masks.GeometryMask;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 *
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): this;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): this;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): this;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): this;

                /**
                 * The initial WebGL pipeline of this Game Object.
                 */
                defaultPipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * The current WebGL pipeline of this Game Object.
                 */
                pipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
                 */
                initPipeline(pipelineName?: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): this;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: ScaleModes): this;

                /**
                 * The horizontal scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): this;

                /**
                 * The native (un-scaled) width of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayWidth` property.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayHeight` property.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Textures.Frame): this;

                /**
                 * Sets the internal size of this Game Object, as used for frame or physics body creation.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): this;

                /**
                 * Sets the display size of this Game Object.
                 *
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): this;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Textures.Texture | Textures.CanvasTexture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Textures.Frame;

                /**
                 * A boolean flag indicating if this Game Object is being cropped or not.
                 * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
                 * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
                 */
                isCropped: boolean;

                /**
                 * Applies a crop to a texture based Game Object, such as a Sprite or Image.
                 *
                 * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
                 *
                 * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
                 * changes what is shown when rendered.
                 *
                 * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
                 *
                 * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
                 * half of it, you could call `setCrop(0, 0, 400, 600)`.
                 *
                 * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
                 * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
                 *
                 * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
                 *
                 * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
                 *
                 * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
                 * the renderer to skip several internal calculations.
                 * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
                 * @param y The y coordinate to start the crop from.
                 * @param width The width of the crop rectangle in pixels.
                 * @param height The height of the crop rectangle in pixels.
                 */
                setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 *
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): this;

                /**
                 * Sets the frame this Game Object will use to render with.
                 *
                 * The Frame has to belong to the current Texture being used.
                 *
                 * It can be either a string or an index.
                 *
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

                /**
                 * Fill or additive?
                 */
                tintFill: boolean;

                /**
                 * Clears all tint values associated with this Game Object.
                 *
                 * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
                 * which results in no visible change to the texture.
                 */
                clearTint(): this;

                /**
                 * Sets an additive tint on this Game Object.
                 *
                 * The tint works by taking the pixel color values from the Game Objects texture, and then
                 * multiplying it by the color value of the tint. You can provide either one color value,
                 * in which case the whole Game Object will be tinted in that color. Or you can provide a color
                 * per corner. The colors are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * Sets a fill-based tint on this Game Object.
                 *
                 * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
                 * with those in the tint. You can use this for effects such as making a player flash 'white'
                 * if hit by something. You can provide either one color value, in which case the whole
                 * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
                 * are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
                 * @param topLeft The tint being applied to the top-left of the Game Object.
                 * If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * Does this Game Object have a tint applied to it or not?
                 */
                readonly isTinted: boolean;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 *
                 * Where 0 is to the right, 90 is down, 180 is left.
                 *
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 *
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): this;

                /**
                 * Sets the position of this Game Object to be a random position within the confines of
                 * the given area.
                 *
                 * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
                 *
                 * The position does not factor in the size of this Game Object, meaning that only the origin is
                 * guaranteed to be within the area.
                 * @param x The x position of the top-left of the random area. Default 0.
                 * @param y The y position of the top-left of the random area. Default 0.
                 * @param width The width of the random area.
                 * @param height The height of the random area.
                 */
                setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): this;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): this;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): this;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): this;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): this;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): this;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): this;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: GameObjects.Components.TransformMatrix): GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 * @param parentMatrix A temporary matrix to hold parent values during the calculations.
                 */
                getWorldTransformMatrix(
                    tempMatrix?: GameObjects.Components.TransformMatrix,
                    parentMatrix?: GameObjects.Components.TransformMatrix
                ): GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): this;

                /**
                 * Sets the restitution on the physics object.
                 * @param value A Number that defines the restitution (elasticity) of the body.
                 * The value is always positive and is in the range (0, 1).
                 * A value of 0 means collisions may be perfectly inelastic and no bouncing may occur.
                 * A value of 0.8 means the body may bounce back with approximately 80% of its kinetic energy. Note that collision response is based on pairs of bodies,
                 * and that restitution values are combined with the following formula: `Math.max(bodyA.restitution, bodyB.restitution)`
                 */
                setBounce(value: number): GameObjects.GameObject;

                /**
                 * Sets the collision category of this Game Object's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.
                 * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision categories are
                 * included in their collision masks (see {@link #setCollidesWith}).
                 * @param value Unique category bitfield.
                 */
                setCollisionCategory(value: number): GameObjects.GameObject;

                /**
                 * Sets the collision group of this Game Object's Matter Body. If this is zero or two Matter Bodies have different values,
                 * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).
                 * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value, they will never collide.
                 * @param value Unique group index.
                 */
                setCollisionGroup(value: number): GameObjects.GameObject;

                /**
                 * Sets the collision mask for this Game Object's Matter Body. Two Matter Bodies with different collision groups will only collide if each one includes the other's category
                 * in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0` are both true.
                 * @param categories A unique category bitfield, or an array of them.
                 */
                setCollidesWith(categories: number | number[]): GameObjects.GameObject;

                /**
                 * Applies a force to a body.
                 * @param force A Vector that specifies the force to apply.
                 */
                applyForce(force: Math.Vector2): GameObjects.GameObject;

                /**
                 * Applies a force to a body from a given position.
                 * @param position The position in which the force comes from.
                 * @param force A Vector that specifies the force to apply.
                 */
                applyForceFrom(position: Math.Vector2, force: Math.Vector2): GameObjects.GameObject;

                /**
                 * Apply thrust to the forward position of the body.
                 * @param speed A speed value to be applied to a directional force.
                 */
                thrust(speed: number): GameObjects.GameObject;

                /**
                 * Apply thrust to the left position of the body.
                 * @param speed A speed value to be applied to a directional force.
                 */
                thrustLeft(speed: number): GameObjects.GameObject;

                /**
                 * Apply thrust to the right position of the body.
                 * @param speed A speed value to be applied to a directional force.
                 */
                thrustRight(speed: number): GameObjects.GameObject;

                /**
                 * Apply thrust to the back position of the body.
                 * @param speed A speed value to be applied to a directional force.
                 */
                thrustBack(speed: number): GameObjects.GameObject;

                /**
                 * Sets new friction values for this Game Object's Matter Body.
                 * @param value The new friction of the body, between 0 and 1, where 0 allows the Body to slide indefinitely, while 1 allows it to stop almost immediately after a force is applied.
                 * @param air If provided, the new air resistance of the Body. The higher the value, the faster the Body will slow as it moves through space. 0 means the body has no air resistance.
                 * @param fstatic If provided, the new static friction of the Body. The higher the value (e.g. 10),
                 * the more force it will take to initially get the Body moving when it is nearly stationary. 0 means the body will never "stick" when it is nearly stationary.
                 */
                setFriction(value: number, air?: number, fstatic?: number): GameObjects.GameObject;

                /**
                 * Sets a new air resistance for this Game Object's Matter Body. A value of 0 means the Body will never slow as it moves through space.
                 * The higher the value, the faster a Body slows when moving through space.
                 * @param value The new air resistance for the Body.
                 */
                setFrictionAir(value: number): GameObjects.GameObject;

                /**
                 * Sets a new static friction for this Game Object's Matter Body. A value of 0 means the Body will never "stick" when it is nearly stationary.
                 * The higher the value (e.g. 10), the more force it will take to initially get the Body moving when it is nearly stationary.
                 * @param value The new static friction for the Body.
                 */
                setFrictionStatic(value: number): GameObjects.GameObject;

                /**
                 * A togglable function for ignoring world gravity in real-time on the current body.
                 * @param value Set to true to ignore the effect of world gravity, or false to not ignore it.
                 */
                setIgnoreGravity(value: boolean): GameObjects.GameObject;

                /**
                 * Sets the mass of the Game Object's Matter Body.
                 * @param value The new mass of the body.
                 */
                setMass(value: number): GameObjects.GameObject;

                /**
                 * Sets density of the body.
                 * @param value The new density of the body.
                 */
                setDensity(value: number): GameObjects.GameObject;

                /**
                 * The body's center of mass.
                 */
                readonly centerOfMass: any;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSensor(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 */
                isSensor(): boolean;

                /**
                 * Set the body on a Game Object to a rectangle.
                 * @param width Width of the rectangle.
                 * @param height Height of the rectangle.
                 * @param options [description]
                 */
                setRectangle(width: number, height: number, options: object): GameObjects.GameObject;

                /**
                 * [description]
                 * @param radius [description]
                 * @param options [description]
                 */
                setCircle(radius: number, options: object): GameObjects.GameObject;

                /**
                 * Set the body on the Game Object to a polygon shape.
                 * @param radius The radius of the polygon.
                 * @param sides The amount of sides creating the polygon.
                 * @param options A matterjs config object.
                 */
                setPolygon(radius: number, sides: number, options: object): GameObjects.GameObject;

                /**
                 * Creates a new matterjs trapezoid body.
                 * @param width The width of the trapezoid.
                 * @param height The height of the trapezoid.
                 * @param slope The angle of slope for the trapezoid.
                 * @param options A matterjs config object for the body.
                 */
                setTrapezoid(width: number, height: number, slope: number, options: object): GameObjects.GameObject;

                /**
                 * [description]
                 * @param body [description]
                 * @param addToWorld [description] Default true.
                 */
                setExistingBody(body: MatterJS.Body, addToWorld?: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param config [description]
                 * @param options [description]
                 */
                setBody(config: object, options: object): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description] Default 60.
                 */
                setSleepThreshold(value?: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param start [description]
                 * @param end [description]
                 */
                setSleepEvents(start: boolean, end: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepStartEvent(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepEndEvent(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setStatic(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 */
                isStatic(): boolean;

                /**
                 * [description]
                 */
                setFixedRotation(): this;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularVelocity(value: number): GameObjects.GameObject;

                /**
                 * Sets the horizontal velocity of the physics body.
                 * @param x The horizontal velocity value.
                 */
                setVelocityX(x: number): GameObjects.GameObject;

                /**
                 * Sets vertical velocity of the physics body.
                 * @param y The vertical velocity value.
                 */
                setVelocityY(y: number): GameObjects.GameObject;

                /**
                 * Sets both the horizontal and vertical velocity of the physics body.
                 * @param x The horizontal velocity value.
                 * @param y The vertical velocity value, it can be either positive or negative. If not given, it will be the same as the `x` value. Default x.
                 */
                setVelocity(x: number, y?: number): GameObjects.GameObject;
            }

            /**
             * [description]
             */
            class MatterPhysics {
                /**
                 *
                 * @param scene [description]
                 */
                constructor(scene: Scene);

                /**
                 * [description]
                 */
                scene: Scene;

                /**
                 * [description]
                 */
                systems: Scenes.Systems;

                /**
                 * [description]
                 */
                config: object;

                /**
                 * [description]
                 */
                world: World;

                /**
                 * [description]
                 */
                add: Factory;

                /**
                 * A reference to the `Matter.Vertices` module which contains methods for creating and manipulating sets of vertices.
                 * A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
                 * A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
                 */
                verts: MatterJS.Vertices;

                /**
                 * [description]
                 */
                getConfig(): object;

                /**
                 * [description]
                 */
                enableAttractorPlugin(): MatterPhysics;

                /**
                 * [description]
                 */
                enableWrapPlugin(): MatterPhysics;

                /**
                 * [description]
                 */
                pause(): World;

                /**
                 * [description]
                 */
                resume(): World;

                /**
                 * Sets the Matter Engine to run at fixed timestep of 60Hz and enables `autoUpdate`.
                 * If you have set a custom `getDelta` function then this will override it.
                 */
                set60Hz(): MatterPhysics;

                /**
                 * Sets the Matter Engine to run at fixed timestep of 30Hz and enables `autoUpdate`.
                 * If you have set a custom `getDelta` function then this will override it.
                 */
                set30Hz(): MatterPhysics;

                /**
                 * Manually advances the physics simulation by one iteration.
                 *
                 * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.
                 * If undefined they use the Matter defaults of 60Hz and no correction.
                 *
                 * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.
                 *
                 * It also ignores any custom `getDelta` functions, as you should be passing the delta
                 * value in to this call.
                 *
                 * You can adjust the number of iterations that Engine.update performs internally.
                 * Use the Scene Matter Physics config object to set the following properties:
                 *
                 * positionIterations (defaults to 6)
                 * velocityIterations (defaults to 4)
                 * constraintIterations (defaults to 2)
                 *
                 * Adjusting these values can help performance in certain situations, depending on the physics requirements
                 * of your game.
                 * @param delta [description] Default 16.666.
                 * @param correction [description] Default 1.
                 */
                step(delta?: number, correction?: number): void;
            }

            /**
             * A Matter Physics Sprite Game Object.
             *
             * A Sprite Game Object is used for the display of both static and animated images in your game.
             * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled
             * and animated.
             *
             * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.
             * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation
             * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.
             */
            class Sprite extends GameObjects.Sprite
                implements
                    Components.Bounce,
                    Components.Collision,
                    Components.Force,
                    Components.Friction,
                    Components.Gravity,
                    Components.Mass,
                    Components.Sensor,
                    Components.SetBody,
                    Components.Sleep,
                    Components.Static,
                    Components.Transform,
                    Components.Velocity,
                    GameObjects.Components.Alpha,
                    GameObjects.Components.BlendMode,
                    GameObjects.Components.Depth,
                    GameObjects.Components.Flip,
                    GameObjects.Components.GetBounds,
                    GameObjects.Components.Origin,
                    GameObjects.Components.Pipeline,
                    GameObjects.Components.ScaleMode,
                    GameObjects.Components.ScrollFactor,
                    GameObjects.Components.Size,
                    GameObjects.Components.Texture,
                    GameObjects.Components.Tint,
                    GameObjects.Components.Transform,
                    GameObjects.Components.Visible {
                /**
                 *
                 * @param world [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 * @param options Matter.js configuration object. Default {}.
                 */
                constructor(world: World, x: number, y: number, texture: string, frame?: string | integer, options?: object);

                /**
                 * [description]
                 */
                world: World;

                /**
                 * Clears all alpha values associated with this Game Object.
                 *
                 * Immediately sets the alpha levels back to 1 (fully opaque).
                 */
                clearAlpha(): this;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 *
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

                /**
                 * The alpha value of the Game Object.
                 *
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 *
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 *
                 * Under WebGL only the following Blend Modes are available:
                 *
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
                 *
                 * Canvas has more available depending on browser support.
                 *
                 * You can also create your own custom Blend Modes in WebGL.
                 *
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | BlendModes): this;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 *
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 *
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 *
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): this;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): this;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): this;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): this;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): this;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): this;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): this;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Geom.Rectangle>(output?: O): O;

                /**
                 * The Mask this Game Object is using during render.
                 */
                mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask;

                /**
                 * Sets the mask that this Game Object will use to render with.
                 *
                 * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.
                 * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.
                 *
                 * If a mask is already set on this Game Object it will be immediately replaced.
                 *
                 * Masks are positioned in global space and are not relative to the Game Object to which they
                 * are applied. The reason for this is that multiple Game Objects can all share the same mask.
                 *
                 * Masks have no impact on physics or input detection. They are purely a rendering component
                 * that allows you to limit what is visible during the render pass.
                 * @param mask The mask this Game Object will use when rendering.
                 */
                setMask(mask: Display.Masks.BitmapMask | Display.Masks.GeometryMask): this;

                /**
                 * Clears the mask that this Game Object was using.
                 * @param destroyMask Destroy the mask before clearing it? Default false.
                 */
                clearMask(destroyMask?: boolean): this;

                /**
                 * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a renderable Game Object.
                 * A renderable Game Object is one that uses a texture to render with, such as an
                 * Image, Sprite, Render Texture or BitmapText.
                 *
                 * If you do not provide a renderable object, and this Game Object has a texture,
                 * it will use itself as the object. This means you can call this method to create
                 * a Bitmap Mask from any renderable Game Object.
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                createBitmapMask(renderable?: GameObjects.GameObject): Display.Masks.BitmapMask;

                /**
                 * Creates and returns a Geometry Mask. This mask can be used by any Game Object,
                 * including this one.
                 *
                 * To create the mask you need to pass in a reference to a Graphics Game Object.
                 *
                 * If you do not provide a graphics object, and this Game Object is an instance
                 * of a Graphics object, then it will use itself to create the mask.
                 *
                 * This means you can call this method to create a Geometry Mask from any Graphics Game Object.
                 * @param graphics A Graphics Game Object. The geometry within it will be used as the mask.
                 */
                createGeometryMask(graphics?: GameObjects.Graphics): Display.Masks.GeometryMask;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 *
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): this;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): this;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): this;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): this;

                /**
                 * The initial WebGL pipeline of this Game Object.
                 */
                defaultPipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * The current WebGL pipeline of this Game Object.
                 */
                pipeline: Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
                 */
                initPipeline(pipelineName?: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): this;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: ScaleModes): this;

                /**
                 * The horizontal scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 *
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 *
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 *
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 *
                 * Please be aware that scroll factor values other than 1 are not taken in to consideration when
                 * calculating physics collisions. Bodies always collide based on their world position, but changing
                 * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
                 * them from physics bodies if not accounted for in your code.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): this;

                /**
                 * The native (un-scaled) width of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayWidth` property.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 *
                 * Changing this value will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or use
                 * the `displayHeight` property.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 *
                 * This value takes into account the scale factor.
                 *
                 * Setting this value will adjust the Game Object's scale property.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Textures.Frame): this;

                /**
                 * Sets the internal size of this Game Object, as used for frame or physics body creation.
                 *
                 * This will not change the size that the Game Object is rendered in-game.
                 * For that you need to either set the scale of the Game Object (`setScale`) or call the
                 * `setDisplaySize` method, which is the same thing as changing the scale but allows you
                 * to do so by giving pixel values.
                 *
                 * If you have enabled this Game Object for input, changing the size will _not_ change the
                 * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): this;

                /**
                 * Sets the display size of this Game Object.
                 *
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): this;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Textures.Texture | Textures.CanvasTexture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Textures.Frame;

                /**
                 * A boolean flag indicating if this Game Object is being cropped or not.
                 * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.
                 * Equally, calling `setCrop` with no arguments will reset the crop and disable it.
                 */
                isCropped: boolean;

                /**
                 * Applies a crop to a texture based Game Object, such as a Sprite or Image.
                 *
                 * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.
                 *
                 * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just
                 * changes what is shown when rendered.
                 *
                 * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.
                 *
                 * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left
                 * half of it, you could call `setCrop(0, 0, 400, 600)`.
                 *
                 * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop
                 * an area of 200x100 when applied to a Game Object that had a scale factor of 2.
                 *
                 * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.
                 *
                 * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.
                 *
                 * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow
                 * the renderer to skip several internal calculations.
                 * @param x The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.
                 * @param y The y coordinate to start the crop from.
                 * @param width The width of the crop rectangle in pixels.
                 * @param height The height of the crop rectangle in pixels.
                 */
                setCrop(x?: number | Geom.Rectangle, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 *
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): this;

                /**
                 * Sets the frame this Game Object will use to render with.
                 *
                 * The Frame has to belong to the current Texture being used.
                 *
                 * It can be either a string or an index.
                 *
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): this;

                /**
                 * Fill or additive?
                 */
                tintFill: boolean;

                /**
                 * Clears all tint values associated with this Game Object.
                 *
                 * Immediately sets the color values back to 0xffffff and the tint interface to 'additive',
                 * which results in no visible change to the texture.
                 */
                clearTint(): this;

                /**
                 * Sets an additive tint on this Game Object.
                 *
                 * The tint works by taking the pixel color values from the Game Objects texture, and then
                 * multiplying it by the color value of the tint. You can provide either one color value,
                 * in which case the whole Game Object will be tinted in that color. Or you can provide a color
                 * per corner. The colors are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * Sets a fill-based tint on this Game Object.
                 *
                 * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture
                 * with those in the tint. You can use this for effects such as making a player flash 'white'
                 * if hit by something. You can provide either one color value, in which case the whole
                 * Game Object will be rendered in that color. Or you can provide a color per corner. The colors
                 * are blended together across the extent of the Game Object.
                 *
                 * To modify the tint color once set, either call this method again with new values or use the
                 * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,
                 * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.
                 *
                 * To remove a tint call `clearTint`.
                 *
                 * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.
                 * @param topLeft The tint being applied to the top-left of the Game Object.
                 * If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTintFill(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): this;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * Does this Game Object have a tint applied to it or not?
                 */
                readonly isTinted: boolean;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 *
                 * Where 0 is to the right, 90 is down, 180 is left.
                 *
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 *
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): this;

                /**
                 * Sets the position of this Game Object to be a random position within the confines of
                 * the given area.
                 *
                 * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
                 *
                 * The position does not factor in the size of this Game Object, meaning that only the origin is
                 * guaranteed to be within the area.
                 * @param x The x position of the top-left of the random area. Default 0.
                 * @param y The y position of the top-left of the random area. Default 0.
                 * @param width The width of the random area.
                 * @param height The height of the random area.
                 */
                setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): this;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): this;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): this;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): this;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): this;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): this;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): this;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: GameObjects.Components.TransformMatrix): GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 * @param parentMatrix A temporary matrix to hold parent values during the calculations.
                 */
                getWorldTransformMatrix(
                    tempMatrix?: GameObjects.Components.TransformMatrix,
                    parentMatrix?: GameObjects.Components.TransformMatrix
                ): GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 *
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): this;

                /**
                 * Sets the restitution on the physics object.
                 * @param value A Number that defines the restitution (elasticity) of the body.
                 * The value is always positive and is in the range (0, 1).
                 * A value of 0 means collisions may be perfectly inelastic and no bouncing may occur.
                 * A value of 0.8 means the body may bounce back with approximately 80% of its kinetic energy.
                 * Note that collision response is based on pairs of bodies, and that restitution values are combined with the following formula: `Math.max(bodyA.restitution, bodyB.restitution)`
                 */
                setBounce(value: number): GameObjects.GameObject;

                /**
                 * Sets the collision category of this Game Object's Matter Body.
                 * This number must be a power of two between 2^0 (= 1) and 2^31. Two bodies with different collision groups (see {@link #setCollisionGroup})
                 * will only collide if their collision categories are included in their collision masks (see {@link #setCollidesWith}).
                 * @param value Unique category bitfield.
                 */
                setCollisionCategory(value: number): GameObjects.GameObject;

                /**
                 * Sets the collision group of this Game Object's Matter Body.
                 * If this is zero or two Matter Bodies have different values, they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).
                 * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value, they will never collide.
                 * @param value Unique group index.
                 */
                setCollisionGroup(value: number): GameObjects.GameObject;

                /**
                 * Sets the collision mask for this Game Object's Matter Body.
                 * Two Matter Bodies with different collision groups will only collide if each one includes the other's category in its mask based on a bitwise AND,
                 * i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0` are both true.
                 * @param categories A unique category bitfield, or an array of them.
                 */
                setCollidesWith(categories: number | number[]): GameObjects.GameObject;

                /**
                 * Applies a force to a body.
                 * @param force A Vector that specifies the force to apply.
                 */
                applyForce(force: Math.Vector2): GameObjects.GameObject;

                /**
                 * Applies a force to a body from a given position.
                 * @param position The position in which the force comes from.
                 * @param force A Vector that specifies the force to apply.
                 */
                applyForceFrom(position: Math.Vector2, force: Math.Vector2): GameObjects.GameObject;

                /**
                 * Apply thrust to the forward position of the body.
                 * @param speed A speed value to be applied to a directional force.
                 */
                thrust(speed: number): GameObjects.GameObject;

                /**
                 * Apply thrust to the left position of the body.
                 * @param speed A speed value to be applied to a directional force.
                 */
                thrustLeft(speed: number): GameObjects.GameObject;

                /**
                 * Apply thrust to the right position of the body.
                 * @param speed A speed value to be applied to a directional force.
                 */
                thrustRight(speed: number): GameObjects.GameObject;

                /**
                 * Apply thrust to the back position of the body.
                 * @param speed A speed value to be applied to a directional force.
                 */
                thrustBack(speed: number): GameObjects.GameObject;

                /**
                 * Sets new friction values for this Game Object's Matter Body.
                 * @param value The new friction of the body, between 0 and 1, where 0 allows the Body to slide indefinitely, while 1 allows it to stop almost immediately after a force is applied.
                 * @param air If provided, the new air resistance of the Body. The higher the value, the faster the Body will slow as it moves through space. 0 means the body has no air resistance.
                 * @param fstatic If provided, the new static friction of the Body. The higher the value (e.g. 10),
                 * the more force it will take to initially get the Body moving when it is nearly stationary. 0 means the body will never "stick" when it is nearly stationary.
                 */
                setFriction(value: number, air?: number, fstatic?: number): GameObjects.GameObject;

                /**
                 * Sets a new air resistance for this Game Object's Matter Body. A value of 0 means the Body will never slow as it moves through space.
                 * The higher the value, the faster a Body slows when moving through space.
                 * @param value The new air resistance for the Body.
                 */
                setFrictionAir(value: number): GameObjects.GameObject;

                /**
                 * Sets a new static friction for this Game Object's Matter Body.
                 * A value of 0 means the Body will never "stick" when it is nearly stationary.
                 * The higher the value (e.g. 10), the more force it will take to initially get the Body moving when it is nearly stationary.
                 * @param value The new static friction for the Body.
                 */
                setFrictionStatic(value: number): GameObjects.GameObject;

                /**
                 * A togglable function for ignoring world gravity in real-time on the current body.
                 * @param value Set to true to ignore the effect of world gravity, or false to not ignore it.
                 */
                setIgnoreGravity(value: boolean): GameObjects.GameObject;

                /**
                 * Sets the mass of the Game Object's Matter Body.
                 * @param value The new mass of the body.
                 */
                setMass(value: number): GameObjects.GameObject;

                /**
                 * Sets density of the body.
                 * @param value The new density of the body.
                 */
                setDensity(value: number): GameObjects.GameObject;

                /**
                 * The body's center of mass.
                 */
                readonly centerOfMass: any;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSensor(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 */
                isSensor(): boolean;

                /**
                 * Set the body on a Game Object to a rectangle.
                 * @param width Width of the rectangle.
                 * @param height Height of the rectangle.
                 * @param options [description]
                 */
                setRectangle(width: number, height: number, options: object): GameObjects.GameObject;

                /**
                 * [description]
                 * @param radius [description]
                 * @param options [description]
                 */
                setCircle(radius: number, options: object): GameObjects.GameObject;

                /**
                 * Set the body on the Game Object to a polygon shape.
                 * @param radius The radius of the polygon.
                 * @param sides The amount of sides creating the polygon.
                 * @param options A matterjs config object.
                 */
                setPolygon(radius: number, sides: number, options: object): GameObjects.GameObject;

                /**
                 * Creates a new matterjs trapezoid body.
                 * @param width The width of the trapezoid.
                 * @param height The height of the trapezoid.
                 * @param slope The angle of slope for the trapezoid.
                 * @param options A matterjs config object for the body.
                 */
                setTrapezoid(width: number, height: number, slope: number, options: object): GameObjects.GameObject;

                /**
                 * [description]
                 * @param body [description]
                 * @param addToWorld [description] Default true.
                 */
                setExistingBody(body: MatterJS.Body, addToWorld?: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param config [description]
                 * @param options [description]
                 */
                setBody(config: object, options: object): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description] Default 60.
                 */
                setSleepThreshold(value?: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param start [description]
                 * @param end [description]
                 */
                setSleepEvents(start: boolean, end: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepStartEvent(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepEndEvent(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setStatic(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 */
                isStatic(): boolean;

                /**
                 * [description]
                 */
                setFixedRotation(): this;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularVelocity(value: number): GameObjects.GameObject;

                /**
                 * Sets the horizontal velocity of the physics body.
                 * @param x The horizontal velocity value.
                 */
                setVelocityX(x: number): GameObjects.GameObject;

                /**
                 * Sets vertical velocity of the physics body.
                 * @param y The vertical velocity value.
                 */
                setVelocityY(y: number): GameObjects.GameObject;

                /**
                 * Sets both the horizontal and vertical velocity of the physics body.
                 * @param x The horizontal velocity value.
                 * @param y The vertical velocity value, it can be either positive or negative. If not given, it will be the same as the `x` value. Default x.
                 */
                setVelocity(x: number, y?: number): GameObjects.GameObject;
            }

            /**
             * A wrapper around a Tile that provides access to a corresponding Matter body. A tile can only
             * have one Matter body associated with it. You can either pass in an existing Matter body for
             * the tile or allow the constructor to create the corresponding body for you. If the Tile has a
             * collision group (defined in Tiled), those shapes will be used to create the body. If not, the
             * tile's rectangle bounding box will be used.
             *
             * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.
             *
             * Note: not all Tiled collision shapes are supported. See
             * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.
             */
            class TileBody
                implements
                    Components.Bounce,
                    Components.Collision,
                    Components.Friction,
                    Components.Gravity,
                    Components.Mass,
                    Components.Sensor,
                    Components.Sleep,
                    Components.Static {
                /**
                 *
                 * @param world [description]
                 * @param tile The target tile that should have a Matter body.
                 * @param options Options to be used when creating the Matter body.
                 */
                constructor(world: World, tile: Tilemaps.Tile, options?: MatterTileOptions);

                /**
                 * The tile object the body is associated with.
                 */
                tile: Tilemaps.Tile;

                /**
                 * The Matter world the body exists within.
                 */
                world: World;

                /**
                 * Sets the current body to a rectangle that matches the bounds of the tile.
                 * @param options Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.
                 */
                setFromTileRectangle(options?: MatterBodyTileOptions): TileBody;

                /**
                 * Sets the current body from the collision group associated with the Tile. This is typically
                 * set up in Tiled's collision editor.
                 *
                 * Note: Matter doesn't support all shapes from Tiled. Rectangles and polygons are directly
                 * supported. Ellipses are converted into circle bodies. Polylines are treated as if they are
                 * closed polygons. If a tile has multiple shapes, a multi-part body will be created. Concave
                 * shapes are supported if poly-decomp library is included. Decomposition is not guaranteed to
                 * work for complex shapes (e.g. holes), so it's often best to manually decompose a concave
                 * polygon into multiple convex polygons yourself.
                 * @param options Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.
                 */
                setFromTileCollision(options?: MatterBodyTileOptions): TileBody;

                /**
                 * Sets the current body to the given body. This will remove the previous body, if one already
                 * exists.
                 * @param body The new Matter body to use.
                 * @param addToWorld Whether or not to add the body to the Matter world. Default true.
                 */
                setBody(body: MatterJS.Body, addToWorld?: boolean): TileBody;

                /**
                 * Removes the current body from the TileBody and from the Matter world
                 */
                removeBody(): TileBody;

                /**
                 * Removes the current body from the tile and the world.
                 */
                destroy(): TileBody;

                /**
                 * Sets the restitution on the physics object.
                 * @param value A Number that defines the restitution (elasticity) of the body.
                 * The value is always positive and is in the range (0, 1). A value of 0 means collisions may be perfectly inelastic and no bouncing may occur.
                 * A value of 0.8 means the body may bounce back with approximately 80% of its kinetic energy. Note that collision response is based on pairs of bodies,
                 * and that restitution values are combined with the following formula: `Math.max(bodyA.restitution, bodyB.restitution)`
                 */
                setBounce(value: number): GameObjects.GameObject;

                /**
                 * Sets the collision category of this Game Object's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.
                 * Two bodies with different collision groups (see {@link #setCollisionGroup})
                 * will only collide if their collision categories are included in their collision masks (see {@link #setCollidesWith}).
                 * @param value Unique category bitfield.
                 */
                setCollisionCategory(value: number): GameObjects.GameObject;

                /**
                 * Sets the collision group of this Game Object's Matter Body. If this is zero or two Matter Bodies have different values,
                 * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).
                 * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value, they will never collide.
                 * @param value Unique group index.
                 */
                setCollisionGroup(value: number): GameObjects.GameObject;

                /**
                 * Sets the collision mask for this Game Object's Matter Body. Two Matter Bodies with different collision groups will only collide if each one includes the other's category
                 * in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0` are both true.
                 * @param categories A unique category bitfield, or an array of them.
                 */
                setCollidesWith(categories: number | number[]): GameObjects.GameObject;

                /**
                 * Sets new friction values for this Game Object's Matter Body.
                 * @param value The new friction of the body, between 0 and 1, where 0 allows the Body to slide indefinitely, while 1 allows it to stop almost immediately after a force is applied.
                 * @param air If provided, the new air resistance of the Body. The higher the value, the faster the Body will slow as it moves through space. 0 means the body has no air resistance.
                 * @param fstatic If provided, the new static friction of the Body. The higher the value (e.g. 10),
                 * the more force it will take to initially get the Body moving when it is nearly stationary. 0 means the body will never "stick" when it is nearly stationary.
                 */
                setFriction(value: number, air?: number, fstatic?: number): GameObjects.GameObject;

                /**
                 * Sets a new air resistance for this Game Object's Matter Body. A value of 0 means the Body will never slow as it moves through space.
                 * The higher the value, the faster a Body slows when moving through space.
                 * @param value The new air resistance for the Body.
                 */
                setFrictionAir(value: number): GameObjects.GameObject;

                /**
                 * Sets a new static friction for this Game Object's Matter Body. A value of 0 means the Body will never "stick" when it is nearly stationary.
                 * The higher the value (e.g. 10), the more force it will take to initially get the Body moving when it is nearly stationary.
                 * @param value The new static friction for the Body.
                 */
                setFrictionStatic(value: number): GameObjects.GameObject;

                /**
                 * A togglable function for ignoring world gravity in real-time on the current body.
                 * @param value Set to true to ignore the effect of world gravity, or false to not ignore it.
                 */
                setIgnoreGravity(value: boolean): GameObjects.GameObject;

                /**
                 * Sets the mass of the Game Object's Matter Body.
                 * @param value The new mass of the body.
                 */
                setMass(value: number): GameObjects.GameObject;

                /**
                 * Sets density of the body.
                 * @param value The new density of the body.
                 */
                setDensity(value: number): GameObjects.GameObject;

                /**
                 * The body's center of mass.
                 */
                readonly centerOfMass: any;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSensor(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 */
                isSensor(): boolean;

                /**
                 * [description]
                 * @param value [description] Default 60.
                 */
                setSleepThreshold(value?: number): GameObjects.GameObject;

                /**
                 * [description]
                 * @param start [description]
                 * @param end [description]
                 */
                setSleepEvents(start: boolean, end: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepStartEvent(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepEndEvent(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setStatic(value: boolean): GameObjects.GameObject;

                /**
                 * [description]
                 */
                isStatic(): boolean;
            }

            /**
             * Use PhysicsEditorParser.parseBody() to build a Matter body object, based on a physics data file
             * created and exported with PhysicsEditor (https://www.codeandweb.com/physicseditor).
             */
            namespace PhysicsEditorParser {
                /**
                 * Parses a body element exported by PhysicsEditor.
                 * @param x x position.
                 * @param y y position.
                 * @param w width.
                 * @param h height.
                 * @param config body configuration and fixture (child body) definitions.
                 */
                function parseBody(x: number, y: number, w: number, h: number, config: object): object;

                /**
                 * Parses an element of the "fixtures" list exported by PhysicsEditor
                 * @param fixtureConfig the fixture object to parse
                 */
                function parseFixture(fixtureConfig: object): object[];

                /**
                 * Parses the "vertices" lists exported by PhysicsEditor.
                 * @param vertexSets The vertex lists to parse.
                 * @param options Matter body options.
                 */
                function parseVertices(vertexSets: object, options: object): object[];
            }

            /**
             * [description]
             */
            class PointerConstraint {
                /**
                 *
                 * @param scene [description]
                 * @param world [description]
                 * @param options [description]
                 */
                constructor(scene: Scene, world: World, options: object);

                /**
                 * [description]
                 */
                scene: Scene;

                /**
                 * [description]
                 */
                world: World;

                /**
                 * [description]
                 */
                camera: Cameras.Scene2D.Camera;

                /**
                 * [description]
                 */
                pointer: Input.Pointer;

                /**
                 * [description]
                 */
                active: boolean;

                /**
                 * The transformed position.
                 */
                position: Math.Vector2;

                /**
                 * [description]
                 */
                constraint: object;

                /**
                 * [description]
                 * @param pointer [description]
                 */
                onDown(pointer: Input.Pointer): void;

                /**
                 * [description]
                 */
                onUp(): void;

                /**
                 * [description]
                 * @param body [description]
                 * @param position [description]
                 */
                getBodyPart(body: MatterJS.Body, position: Math.Vector2): boolean;

                /**
                 * [description]
                 */
                update(): void;

                /**
                 * [description]
                 */
                destroy(): void;
            }

            /**
             * [description]
             */
            class World extends Phaser.Events.EventEmitter {
                /**
                 *
                 * @param scene The Scene to which this Matter World instance belongs.
                 * @param config [description]
                 */
                constructor(scene: Scene, config: object);

                /**
                 * The Scene to which this Matter World instance belongs.
                 */
                scene: Scene;

                /**
                 * An instance of the MatterJS Engine.
                 */
                engine: MatterJS.Engine;

                /**
                 * A `World` composite object that will contain all simulated bodies and constraints.
                 */
                localWorld: MatterJS.World;

                /**
                 * An object containing the 4 wall bodies that bound the physics world.
                 */
                walls: object;

                /**
                 * A flag that toggles if the world is enabled or not.
                 */
                enabled: boolean;

                /**
                 * The correction argument is an optional Number that specifies the time correction factor to apply to the update.
                 * This can help improve the accuracy of the simulation in cases where delta is changing between updates.
                 * The value of correction is defined as delta / lastDelta, i.e. the percentage change of delta over the last step.
                 * Therefore the value is always 1 (no correction) when delta constant (or when no correction is desired, which is the default).
                 * See the paper on Time Corrected Verlet for more information.
                 */
                correction: number;

                /**
                 * This function is called every time the core game loop steps, which is bound to the
                 * Request Animation Frame frequency unless otherwise modified.
                 *
                 * The function is passed two values: `time` and `delta`, both of which come from the game step values.
                 *
                 * It must return a number. This number is used as the delta value passed to Matter.Engine.update.
                 *
                 * You can override this function with your own to define your own timestep.
                 *
                 * If you need to update the Engine multiple times in a single game step then call
                 * `World.update` as many times as required. Each call will trigger the `getDelta` function.
                 * If you wish to have full control over when the Engine updates then see the property `autoUpdate`.
                 *
                 * You can also adjust the number of iterations that Engine.update performs.
                 * Use the Scene Matter Physics config object to set the following properties:
                 *
                 * positionIterations (defaults to 6)
                 * velocityIterations (defaults to 4)
                 * constraintIterations (defaults to 2)
                 *
                 * Adjusting these values can help performance in certain situations, depending on the physics requirements
                 * of your game.
                 */
                getDelta: CallbackFn;

                /**
                 * Automatically call Engine.update every time the game steps.
                 * If you disable this then you are responsible for calling `World.step` directly from your game.
                 * If you call `set60Hz` or `set30Hz` then `autoUpdate` is reset to `true`.
                 */
                autoUpdate: boolean;

                /**
                 * A flag that controls if the debug graphics will be drawn to or not.
                 */
                drawDebug: boolean;

                /**
                 * An instance of the Graphics object the debug bodies are drawn to, if enabled.
                 */
                debugGraphic: GameObjects.Graphics;

                /**
                 * The default configuration values.
                 */
                defaults: object;

                /**
                 * [description]
                 */
                setEventsProxy(): void;

                /**
                 * Sets the bounds of the Physics world to match the given world pixel dimensions.
                 * You can optionally set which 'walls' to create: left, right, top or bottom.
                 * If none of the walls are given it will default to use the walls settings it had previously.
                 * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size
                 * the newly created bounds will also not have the left and right walls.
                 * Explicitly state them in the parameters to override this.
                 * @param x The x coordinate of the top-left corner of the bounds. Default 0.
                 * @param y The y coordinate of the top-left corner of the bounds. Default 0.
                 * @param width The width of the bounds.
                 * @param height The height of the bounds.
                 * @param thickness The thickness of each wall, in pixels. Default 128.
                 * @param left If true will create the left bounds wall. Default true.
                 * @param right If true will create the right bounds wall. Default true.
                 * @param top If true will create the top bounds wall. Default true.
                 * @param bottom If true will create the bottom bounds wall. Default true.
                 */
                setBounds(x?: number, y?: number, width?: number, height?: number, thickness?: number, left?: boolean, right?: boolean, top?: boolean, bottom?: boolean): World;

                /**
                 * [description]
                 * @param add [description]
                 * @param position [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                updateWall(add: boolean, position: string, x: number, y: number, width: number, height: number): void;

                /**
                 * [description]
                 */
                createDebugGraphic(): GameObjects.Graphics;

                /**
                 * Sets the world's gravity and gravity scale to 0.
                 */
                disableGravity(): World;

                /**
                 * Sets the world's gravity
                 * @param x The world gravity x component. Default 0.
                 * @param y The world gravity y component. Default 1.
                 * @param scale [description]
                 */
                setGravity(x?: number, y?: number, scale?: number): World;

                /**
                 * Creates a rectangle Matter body and adds it to the world.
                 * @param x The horizontal position of the body in the world.
                 * @param y The vertical position of the body in the world.
                 * @param width The width of the body.
                 * @param height The height of the body.
                 * @param options Optional Matter configuration object.
                 */
                create(x: number, y: number, width: number, height: number, options: object): MatterJS.Body;

                /**
                 * Adds an object to the world.
                 * @param object Can be single or an array, and can be a body, composite or constraint
                 */
                add(object: object | object[]): World;

                /**
                 * [description]
                 * @param object The object to be removed from the world.
                 * @param deep [description]
                 */
                remove(object: object, deep: boolean): World;

                /**
                 * [description]
                 * @param constraint [description]
                 * @param deep [description]
                 */
                removeConstraint(constraint: MatterJS.Constraint, deep: boolean): World;

                /**
                 * Adds MatterTileBody instances for all the colliding tiles within the given tilemap layer. Set
                 * the appropriate tiles in your layer to collide before calling this method!
                 * @param tilemapLayer An array of tiles.
                 * @param options Options to be passed to the MatterTileBody constructor. {@ee Phaser.Physics.Matter.TileBody}
                 */
                convertTilemapLayer(tilemapLayer: Tilemaps.DynamicTilemapLayer | Tilemaps.StaticTilemapLayer, options?: object): World;

                /**
                 * Adds MatterTileBody instances for the given tiles. This adds bodies regardless of whether the
                 * tiles are set to collide or not.
                 * @param tiles An array of tiles.
                 * @param options Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}
                 */
                convertTiles(tiles: Tilemaps.Tile[], options?: object): World;

                /**
                 * [description]
                 * @param isNonColliding [description]
                 */
                nextGroup(isNonColliding: boolean): number;

                /**
                 * [description]
                 */
                nextCategory(): number;

                /**
                 * [description]
                 */
                pause(): World;

                /**
                 * [description]
                 */
                resume(): World;

                /**
                 * [description]
                 * @param time The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
                 * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
                 */
                update(time: number, delta: number): void;

                /**
                 * Manually advances the physics simulation by one iteration.
                 *
                 * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.
                 * If undefined they use the Matter defaults of 60Hz and no correction.
                 *
                 * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.
                 *
                 * It also ignores any custom `getDelta` functions, as you should be passing the delta
                 * value in to this call.
                 *
                 * You can adjust the number of iterations that Engine.update performs internally.
                 * Use the Scene Matter Physics config object to set the following properties:
                 *
                 * positionIterations (defaults to 6)
                 * velocityIterations (defaults to 4)
                 * constraintIterations (defaults to 2)
                 *
                 * Adjusting these values can help performance in certain situations, depending on the physics requirements
                 * of your game.
                 * @param delta [description] Default 16.666.
                 * @param correction [description] Default 1.
                 */
                step(delta?: number, correction?: number): void;

                /**
                 * Runs the Matter Engine.update at a fixed timestep of 60Hz.
                 */
                update60Hz(): number;

                /**
                 * Runs the Matter Engine.update at a fixed timestep of 30Hz.
                 */
                update30Hz(): number;

                /**
                 * [description]
                 * @param path [description]
                 * @param points [description]
                 */
                fromPath(path: string, points: any[]): any[];

                /**
                 * Will remove all Matter physics event listeners and clear the matter physics world,
                 * engine and any debug graphics, if any.
                 */
                shutdown(): void;

                /**
                 * Will remove all Matter physics event listeners and clear the matter physics world,
                 * engine and any debug graphics, if any.
                 *
                 * After destroying the world it cannot be re-used again.
                 */
                destroy(): void;
            }
        }
    }

    namespace Plugins {
        /**
         * A Global Plugin is installed just once into the Game owned Plugin Manager.
         * It can listen for Game events and respond to them.
         */
        class BasePlugin {
            /**
             *
             * @param pluginManager A reference to the Plugin Manager.
             */
            constructor(pluginManager: PluginManager);

            /**
             * A handy reference to the Plugin Manager that is responsible for this plugin.
             * Can be used as a route to gain access to game systems and  events.
             */
            protected pluginManager: PluginManager;

            /**
             * A reference to the Game instance this plugin is running under.
             */
            protected game: Game;

            /**
             * A reference to the Scene that has installed this plugin.
             * Only set if it's a Scene Plugin, otherwise `null`.
             * This property is only set when the plugin is instantiated and added to the Scene, not before.
             * You cannot use it during the `init` method, but you can during the `boot` method.
             */
            protected scene: Scene;

            /**
             * A reference to the Scene Systems of the Scene that has installed this plugin.
             * Only set if it's a Scene Plugin, otherwise `null`.
             * This property is only set when the plugin is instantiated and added to the Scene, not before.
             * You cannot use it during the `init` method, but you can during the `boot` method.
             */
            protected systems: Scenes.Systems;

            /**
             * Called by the PluginManager when this plugin is first instantiated.
             * It will never be called again on this instance.
             * In here you can set-up whatever you need for this plugin to run.
             * If a plugin is set to automatically start then `BasePlugin.start` will be called immediately after this.
             * @param data A value specified by the user, if any, from the `data` property of the plugin's configuration object (if started at game boot)
             * or passed in the PluginManager's `install` method (if started manually).
             */
            init(data?: any): void;

            /**
             * Called by the PluginManager when this plugin is started.
             * If a plugin is stopped, and then started again, this will get called again.
             * Typically called immediately after `BasePlugin.init`.
             */
            start(): void;

            /**
             * Called by the PluginManager when this plugin is stopped.
             * The game code has requested that your plugin stop doing whatever it does.
             * It is now considered as 'inactive' by the PluginManager.
             * Handle that process here (i.e. stop listening for events, etc)
             * If the plugin is started again then `BasePlugin.start` will be called again.
             */
            stop(): void;

            /**
             * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.
             * By this point the plugin properties `scene` and `systems` will have already been set.
             * In here you can listen for Scene events and set-up whatever you need for this plugin to run.
             */
            boot(): void;

            /**
             * Game instance has been destroyed.
             * You must release everything in here, all references, all objects, free it all up.
             */
            destroy(): void;
        }

        interface DefaultPlugins {
            /**
             * These are the Global Managers that are created by the Phaser.Game instance.
             */
            Global: any[];
            /**
             * These are the core plugins that are installed into every Scene.Systems instance, no matter what.
             */
            CoreScene: any[];
            /**
             * These plugins are created in Scene.Systems in addition to the CoreScenePlugins.
             */
            DefaultScene: any[];
        }

        /**
         * These are the Global Managers that are created by the Phaser.Game instance.
         * They are referenced from Scene.Systems so that plugins can use them.
         */
        const Global: any[];

        /**
         * These are the core plugins that are installed into every Scene.Systems instance, no matter what.
         * They are optionally exposed in the Scene as well (see the InjectionMap for details)
         *
         * They are created in the order in which they appear in this array and EventEmitter is always first.
         */
        const CoreScene: any[];

        /**
         * These plugins are created in Scene.Systems in addition to the CoreScenePlugins.
         *
         * You can elect not to have these plugins by either creating a DefaultPlugins object as part
         * of the Game Config, by creating a Plugins object as part of a Scene Config, or by modifying this array
         * and building your own bundle.
         *
         * They are optionally exposed in the Scene as well (see the InjectionMap for details)
         *
         * They are always created in the order in which they appear in the array.
         */
        const DefaultScene: any[];

        namespace PluginCache {
            /**
             * Static method called directly by the Core internal Plugins.
             * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)
             * Plugin is the object to instantiate to create the plugin
             * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)
             * @param key A reference used to get this plugin from the plugin cache.
             * @param plugin The plugin to be stored. Should be the core object, not instantiated.
             * @param mapping If this plugin is to be injected into the Scene Systems, this is the property key map used.
             * @param custom Core Scene plugin or a Custom Scene plugin? Default false.
             */
            function register(key: string, plugin: CallbackFn, mapping: string, custom?: boolean): void;

            /**
             * Stores a custom plugin in the global plugin cache.
             * The key must be unique, within the scope of the cache.
             * @param key A reference used to get this plugin from the plugin cache.
             * @param plugin The plugin to be stored. Should be the core object, not instantiated.
             * @param mapping If this plugin is to be injected into the Scene Systems, this is the property key map used.
             * @param data A value to be passed to the plugin's `init` method.
             */
            function registerCustom(key: string, plugin: CallbackFn, mapping: string, data: any): void;

            /**
             * Checks if the given key is already being used in the core plugin cache.
             * @param key The key to check for.
             */
            function hasCore(key: string): boolean;

            /**
             * Checks if the given key is already being used in the custom plugin cache.
             * @param key The key to check for.
             */
            function hasCustom(key: string): boolean;

            /**
             * Returns the core plugin object from the cache based on the given key.
             * @param key The key of the core plugin to get.
             */
            function getCore(key: string): CorePluginContainer;

            /**
             * Returns the custom plugin object from the cache based on the given key.
             * @param key The key of the custom plugin to get.
             */
            function getCustom(key: string): CustomPluginContainer;

            /**
             * Returns an object from the custom cache based on the given key that can be instantiated.
             * @param key The key of the custom plugin to get.
             */
            function getCustomClass(key: string): CallbackFn;

            /**
             * Removes a core plugin based on the given key.
             * @param key The key of the core plugin to remove.
             */
            function remove(key: string): void;

            /**
             * Removes a custom plugin based on the given key.
             * @param key The key of the custom plugin to remove.
             */
            function removeCustom(key: string): void;

            /**
             * Removes all Core Plugins.
             *
             * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.
             * So be sure you only call this if you do not wish to run Phaser again.
             */
            function destroyCorePlugins(): void;

            /**
             * Removes all Custom Plugins.
             */
            function destroyCustomPlugins(): void;
        }

        /**
         * The PluginManager is responsible for installing and adding plugins to Phaser.
         *
         * It is a global system and therefore belongs to the Game instance, not a specific Scene.
         *
         * It works in conjunction with the PluginCache. Core internal plugins automatically register themselves
         * with the Cache, but it's the Plugin Manager that is responsible for injecting them into the Scenes.
         *
         * There are two types of plugin:
         *
         * 1. A Global Plugin
         * 2. A Scene Plugin
         *
         * A Global Plugin is a plugin that lives within the Plugin Manager rather than a Scene. You can get
         * access to it by calling `PluginManager.get` and providing a key. Any Scene that requests a plugin in
         * this way will all get access to the same plugin instance, allowing you to use a single plugin across
         * multiple Scenes.
         *
         * A Scene Plugin is a plugin dedicated to running within a Scene. These are different to Global Plugins
         * in that their instances do not live within the Plugin Manager, but within the Scene Systems class instead.
         * And that every Scene created is given its own unique instance of a Scene Plugin. Examples of core Scene
         * Plugins include the Input Plugin, the Tween Plugin and the physics Plugins.
         *
         * You can add a plugin to Phaser in three different ways:
         *
         * 1. Preload it
         * 2. Include it in your source code and install it via the Game Config
         * 3. Include it in your source code and install it within a Scene
         *
         * For examples of all of these approaches please see the Phaser 3 Examples Repo `plugins` folder.
         *
         * For information on creating your own plugin please see the Phaser 3 Plugin Template.
         */
        class PluginManager {
            /**
             *
             * @param game The game instance that owns this Plugin Manager.
             */
            constructor(game: Game);

            /**
             * The game instance that owns this Plugin Manager.
             */
            game: Game;

            /**
             * The global plugins currently running and managed by this Plugin Manager.
             * A plugin must have been started at least once in order to appear in this list.
             */
            plugins: GlobalPlugin[];

            /**
             * A list of plugin keys that should be installed into Scenes as well as the Core Plugins.
             */
            scenePlugins: string[];

            /**
             * Run once the game has booted and installs all of the plugins configured in the Game Config.
             */
            protected boot(): void;

            /**
             * Called by the Scene Systems class. Tells the plugin manager to install all Scene plugins into it.
             *
             * First it will install global references, i.e. references from the Game systems into the Scene Systems (and Scene if mapped.)
             * Then it will install Core Scene Plugins followed by Scene Plugins registered with the PluginManager.
             * Finally it will install any references to Global Plugins that have a Scene mapping property into the Scene itself.
             * @param sys The Scene Systems class to install all the plugins in to.
             * @param globalPlugins An array of global plugins to install.
             * @param scenePlugins An array of scene plugins to install.
             */
            protected addToScene(sys: Scenes.Systems, globalPlugins: any[], scenePlugins: any[]): void;

            /**
             * Called by the Scene Systems class. Returns a list of plugins to be installed.
             */
            protected getDefaultScenePlugins(): string[];

            /**
             * Installs a new Scene Plugin into the Plugin Manager and optionally adds it
             * to the given Scene as well. A Scene Plugin added to the manager in this way
             * will be automatically installed into all new Scenes using the key and mapping given.
             *
             * The `key` property is what the plugin is injected into Scene.Systems as.
             * The `mapping` property is optional, and if specified is what the plugin is installed into
             * the Scene as. For example:
             *
             * ```javascript
             * this.plugins.installScenePlugin('powerupsPlugin', pluginCode, 'powerups');
             *
             * // and from within the scene:
             * this.sys.powerupsPlugin; // key value
             * this.powerups; // mapping value
             * ```
             *
             * This method is called automatically by Phaser if you install your plugins using either the
             * Game Configuration object, or by preloading them via the Loader.
             * @param key The property key that will be used to add this plugin to Scene.Systems.
             * @param plugin The plugin code. This should be the non-instantiated version.
             * @param mapping If this plugin is injected into the Phaser.Scene class, this is the property key to use.
             * @param addToScene Optionally automatically add this plugin to the given Scene.
             */
            installScenePlugin(key: string, plugin: CallbackFn, mapping?: string, addToScene?: Scene): void;

            /**
             * Installs a new Global Plugin into the Plugin Manager and optionally starts it running.
             * A global plugin belongs to the Plugin Manager, rather than a specific Scene, and can be accessed
             * and used by all Scenes in your game.
             *
             * The `key` property is what you use to access this plugin from the Plugin Manager.
             *
             * ```javascript
             * this.plugins.install('powerupsPlugin', pluginCode);
             *
             * // and from within the scene:
             * this.plugins.get('powerupsPlugin');
             * ```
             *
             * This method is called automatically by Phaser if you install your plugins using either the
             * Game Configuration object, or by preloading them via the Loader.
             *
             * The same plugin can be installed multiple times into the Plugin Manager by simply giving each
             * instance its own unique key.
             * @param key The unique handle given to this plugin within the Plugin Manager.
             * @param plugin The plugin code. This should be the non-instantiated version.
             * @param start Automatically start the plugin running? This is always `true` if you provide a mapping value. Default false.
             * @param mapping If this plugin is injected into the Phaser.Scene class, this is the property key to use.
             * @param data A value passed to the plugin's `init` method.
             */
            install(key: string, plugin: CallbackFn, start?: boolean, mapping?: string, data?: any): BasePlugin;

            /**
             * Gets an index of a global plugin based on the given key.
             * @param key The unique plugin key.
             */
            protected getIndex(key: string): integer;

            /**
             * Gets a global plugin based on the given key.
             * @param key The unique plugin key.
             */
            protected getEntry(key: string): GlobalPlugin;

            /**
             * Checks if the given global plugin, based on its key, is active or not.
             * @param key The unique plugin key.
             */
            isActive(key: string): boolean;

            /**
             * Starts a global plugin running.
             *
             * If the plugin was previously active then calling `start` will reset it to an active state and then
             * call its `start` method.
             *
             * If the plugin has never been run before a new instance of it will be created within the Plugin Manager,
             * its active state set and then both of its `init` and `start` methods called, in that order.
             *
             * If the plugin is already running under the given key then nothing happens.
             * @param key The key of the plugin to start.
             * @param runAs Run the plugin under a new key. This allows you to run one plugin multiple times.
             */
            start(key: string, runAs?: string): BasePlugin;

            /**
             * Stops a global plugin from running.
             *
             * If the plugin is active then its active state will be set to false and the plugins `stop` method
             * will be called.
             *
             * If the plugin is not already running, nothing will happen.
             * @param key The key of the plugin to stop.
             */
            stop(key: string): PluginManager;

            /**
             * Gets a global plugin from the Plugin Manager based on the given key and returns it.
             *
             * If it cannot find an active plugin based on the key, but there is one in the Plugin Cache with the same key,
             * then it will create a new instance of the cached plugin and return that.
             * @param key The key of the plugin to get.
             * @param autoStart Automatically start a new instance of the plugin if found in the cache, but not actively running. Default true.
             */
            get(key: string, autoStart?: boolean): BasePlugin | CallbackFn;

            /**
             * Returns the plugin class from the cache.
             * Used internally by the Plugin Manager.
             * @param key The key of the plugin to get.
             */
            getClass(key: string): BasePlugin;

            /**
             * Removes a global plugin from the Plugin Manager and Plugin Cache.
             *
             * It is up to you to remove all references to this plugin that you may hold within your game code.
             * @param key The key of the plugin to remove.
             */
            removeGlobalPlugin(key: string): void;

            /**
             * Removes a scene plugin from the Plugin Manager and Plugin Cache.
             *
             * This will not remove the plugin from any active Scenes that are already using it.
             *
             * It is up to you to remove all references to this plugin that you may hold within your game code.
             * @param key The key of the plugin to remove.
             */
            removeScenePlugin(key: string): void;

            /**
             * Registers a new interface of Game Object with the global Game Object Factory and / or Creator.
             * This is usually called from within your Plugin code and is a helpful short-cut for creating
             * new Game Objects.
             *
             * The key is the property that will be injected into the factories and used to create the
             * Game Object. For example:
             *
             * ```javascript
             * this.plugins.registerGameObject('clown', clownFactoryCallback, clownCreatorCallback);
             * // later in your game code:
             * this.add.clown();
             * this.make.clown();
             * ```
             *
             * The callbacks are what are called when the factories try to create a Game Object
             * matching the given key. It's important to understand that the callbacks are invoked within
             * the context of the GameObjectFactory. In this context there are several properties available
             * to use:
             *
             * this.scene - A reference to the Scene that owns the GameObjectFactory.
             * this.displayList - A reference to the Display List the Scene owns.
             * this.updateList - A reference to the Update List the Scene owns.
             *
             * See the GameObjectFactory and GameObjectCreator classes for more details.
             * Any public property or method listed is available from your callbacks under `this`.
             * @param key The key of the Game Object that the given callbacks will create, i.e. `image`, `sprite`.
             * @param factoryCallback The callback to invoke when the Game Object Factory is called.
             * @param creatorCallback The callback to invoke when the Game Object Creator is called.
             */
            registerGameObject(key: string, factoryCallback?: CallbackFn, creatorCallback?: CallbackFn): void;

            /**
             * Registers a new file interface with the global File types Manager, making it available to all Loader
             * Plugins created after this.
             *
             * This is usually called from within your Plugin code and is a helpful short-cut for creating
             * new loader file types.
             *
             * The key is the property that will be injected into the Loader Plugin and used to load the
             * files. For example:
             *
             * ```javascript
             * this.plugins.registerFileinterface('wad', doomWadLoaderCallback);
             * // later in your preload code:
             * this.load.wad();
             * ```
             *
             * The callback is what is called when the loader tries to load a file  matching the given key.
             * It's important to understand that the callback is invoked within
             * the context of the LoaderPlugin. In this context there are several properties / methods available
             * to use:
             *
             * this.addFile - A method to add the new file to the load queue.
             * this.scene - The Scene that owns the Loader Plugin instance.
             *
             * See the LoaderPlugin class for more details. Any public property or method listed is available from
             * your callback under `this`.
             * @param key The key of the Game Object that the given callbacks will create, i.e. `image`, `sprite`.
             * @param callback The callback to invoke when the Game Object Factory is called.
             * @param addToScene Optionally add this file interface into the Loader Plugin owned by the given Scene.
             */
            registerFileinterface(key: string, callback: CallbackFn, addToScene?: Scene): void;

            /**
             * Destroys this Plugin Manager and all associated plugins.
             * It will iterate all plugins found and call their `destroy` methods.
             *
             * The PluginCache will remove all custom plugins.
             */
            destroy(): void;
        }

        /**
         * A Scene Level Plugin is installed into every Scene and belongs to that Scene.
         * It can listen for Scene events and respond to them.
         * It can map itself to a Scene property, or into the Scene Systems, or both.
         */
        class ScenePlugin extends BasePlugin {
            /**
             *
             * @param scene A reference to the Scene that has installed this plugin.
             * @param pluginManager A reference to the Plugin Manager.
             */
            constructor(scene: Scene, pluginManager: PluginManager);

            /**
             * This method is called when the Scene boots. It is only ever called once.
             *
             * By this point the plugin properties `scene` and `systems` will have already been set.
             *
             * In here you can listen for Scene events and set-up whatever you need for this plugin to run.
             * Here are the Scene events you can listen to:
             *
             * start
             * ready
             * preupdate
             * update
             * postupdate
             * resize
             * pause
             * resume
             * sleep
             * wake
             * transitioninit
             * transitionstart
             * transitioncomplete
             * transitionout
             * shutdown
             * destroy
             *
             * At the very least you should offer a destroy handler for when the Scene closes down, i.e:
             *
             * ```javascript
             * var eventEmitter = this.systems.events;
             * eventEmitter.once('destroy', this.sceneDestroy, this);
             * ```
             */
            boot(): void;
        }
    }

    /**
     * Phaser Blend Modes.
     */
    enum BlendModes {
        /**
         * Skips the Blend Mode check in the renderer.
         */
        SKIP_CHECK,
        /**
         * Normal blend mode. For Canvas and WebGL.
         * This is the default setting and draws new shapes on top of the existing canvas content.
         */
        NORMAL,
        /**
         * Add blend mode. For Canvas and WebGL.
         * Where both shapes overlap the color is determined by adding color values.
         */
        ADD,
        /**
         * Multiply blend mode. For Canvas and WebGL.
         * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom layer. A darker picture is the result.
         */
        MULTIPLY,
        /**
         * Screen blend mode. For Canvas and WebGL.
         * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result (opposite of multiply)
         */
        SCREEN,
        /**
         * Overlay blend mode. For Canvas only.
         * A combination of multiply and screen. Dark parts on the base layer become darker, and light parts become lighter.
         */
        OVERLAY,
        /**
         * Darken blend mode. For Canvas only.
         * Retains the darkest pixels of both layers.
         */
        DARKEN,
        /**
         * Lighten blend mode. For Canvas only.
         * Retains the lightest pixels of both layers.
         */
        LIGHTEN,
        /**
         * Color Dodge blend mode. For Canvas only.
         * Divides the bottom layer by the inverted top layer.
         */
        COLOR_DODGE,
        /**
         * Color Burn blend mode. For Canvas only.
         * Divides the inverted bottom layer by the top layer, and then inverts the result.
         */
        COLOR_BURN,
        /**
         * Hard Light blend mode. For Canvas only.
         * A combination of multiply and screen like overlay, but with top and bottom layer swapped.
         */
        HARD_LIGHT,
        /**
         * Soft Light blend mode. For Canvas only.
         * A softer version of hard-light. Pure black or white does not result in pure black or white.
         */
        SOFT_LIGHT,
        /**
         * Difference blend mode. For Canvas only.
         * Subtracts the bottom layer from the top layer or the other way round to always get a positive value.
         */
        DIFFERENCE,
        /**
         * Exclusion blend mode. For Canvas only.
         * Like difference, but with lower contrast.
         */
        EXCLUSION,
        /**
         * Hue blend mode. For Canvas only.
         * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.
         */
        HUE,
        /**
         * Saturation blend mode. For Canvas only.
         * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.
         */
        SATURATION,
        /**
         * Color blend mode. For Canvas only.
         * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.
         */
        COLOR,
        /**
         * Luminosity blend mode. For Canvas only.
         * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.
         */
        LUMINOSITY,
        /**
         * Alpha erase blend mode. For Canvas and WebGL.
         */
        ERASE,
        /**
         * Source-in blend mode. For Canvas only.
         * The new shape is drawn only where both the new shape and the destination canvas overlap. Everything else is made transparent.
         */
        SOURCE_IN,
        /**
         * Source-out blend mode. For Canvas only.
         * The new shape is drawn where it doesn't overlap the existing canvas content.
         */
        SOURCE_OUT,
        /**
         * Source-out blend mode. For Canvas only.
         * The new shape is only drawn where it overlaps the existing canvas content.
         */
        SOURCE_ATOP,
        /**
         * Destination-over blend mode. For Canvas only.
         * New shapes are drawn behind the existing canvas content.
         */
        DESTINATION_OVER,
        /**
         * Destination-in blend mode. For Canvas only.
         * The existing canvas content is kept where both the new shape and existing canvas content overlap. Everything else is made transparent.
         */
        DESTINATION_IN,
        /**
         * Destination-out blend mode. For Canvas only.
         * The existing content is kept where it doesn't overlap the new shape.
         */
        DESTINATION_OUT,
        /**
         * Destination-out blend mode. For Canvas only.
         * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn behind the canvas content.
         */
        DESTINATION_ATOP,
        /**
         * Lighten blend mode. For Canvas only.
         * Where both shapes overlap the color is determined by adding color values.
         */
        LIGHTER,
        /**
         * Copy blend mode. For Canvas only.
         * Only the new shape is shown.
         */
        COPY,
        /**
         * xor blend mode. For Canvas only.
         * Shapes are made transparent where both overlap and drawn normal everywhere else.
         */
        XOR
    }

    namespace Renderer {
        namespace Canvas {
            /**
             * The Canvas Renderer is responsible for managing 2D canvas rendering contexts, including the one used by the Game's canvas.
             * It tracks the internal state of a given context and can renderer textured Game Objects to it, taking into account alpha, blending, and scaling.
             */
            class CanvasRenderer {
                /**
                 *
                 * @param game The Phaser Game instance that owns this renderer.
                 */
                constructor(game: Game);

                /**
                 * The Phaser Game instance that owns this renderer.
                 */
                game: Game;

                /**
                 * A constant which allows the renderer to be easily identified as a Canvas Renderer.
                 */
                interface: integer;

                /**
                 * The total number of Game Objects which were rendered in a frame.
                 */
                drawCount: number;

                /**
                 * The width of the canvas being rendered to.
                 */
                width: integer;

                /**
                 * The height of the canvas being rendered to.
                 */
                height: integer;

                /**
                 * The local configuration settings of the CanvasRenderer.
                 */
                config: object;

                /**
                 * The scale mode which should be used by the CanvasRenderer.
                 */
                scaleMode: integer;

                /**
                 * The canvas element which the Game uses.
                 */
                gameCanvas: HTMLCanvasElement;

                /**
                 * The canvas context used to render all Cameras in all Scenes during the game loop.
                 */
                gameContext: CanvasRenderingContext2D;

                /**
                 * The canvas context currently used by the CanvasRenderer for all rendering operations.
                 */
                currentContext: CanvasRenderingContext2D;

                /**
                 * The blend modes supported by the Canvas Renderer.
                 *
                 * This object maps the {@link Phaser.BlendModes} to canvas compositing operations.
                 */
                blendModes: any[];

                /**
                 * The scale mode currently in use by the Canvas Renderer.
                 */
                currentScaleMode: number;

                /**
                 * Details about the currently scheduled snapshot.
                 *
                 * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.
                 */
                snapshotState: SnapshotState;

                /**
                 * Prepares the game canvas for rendering.
                 */
                init(): void;

                /**
                 * The event handler that manages the `resize` event dispatched by the Scale Manager.
                 * @param gameSize The default Game Size object. This is the un-modified game dimensions.
                 * @param baseSize The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.
                 * @param displaySize The display Size object. The size of the canvas style width / height attributes.
                 * @param resolution The Scale Manager resolution setting.
                 */
                onResize(gameSize: Structs.Size, baseSize: Structs.Size, displaySize: Structs.Size, resolution?: number): void;

                /**
                 * Resize the main game canvas.
                 * @param width The new width of the renderer.
                 * @param height The new height of the renderer.
                 */
                resize(width?: number, height?: number): void;

                /**
                 * A NOOP method for handling lost context. Intentionally empty.
                 * @param callback Ignored parameter.
                 */
                onContextLost(callback: CallbackFn): void;

                /**
                 * A NOOP method for handling restored context. Intentionally empty.
                 * @param callback Ignored parameter.
                 */
                onContextRestored(callback: CallbackFn): void;

                /**
                 * Resets the transformation matrix of the current context to the identity matrix, thus resetting any transformation.
                 */
                resetTransform(): void;

                /**
                 * Sets the blend mode (compositing operation) of the current context.
                 * @param blendMode The new blend mode which should be used.
                 */
                setBlendMode(blendMode: string): this;

                /**
                 * Changes the Canvas Rendering Context that all draw operations are performed against.
                 * @param ctx The new Canvas Rendering Context to draw everything to. Leave empty to reset to the Game Canvas.
                 */
                setContext(ctx?: CanvasRenderingContext2D): this;

                /**
                 * Sets the global alpha of the current context.
                 * @param alpha The new alpha to use, where 0 is fully transparent and 1 is fully opaque.
                 */
                setAlpha(alpha: number): this;

                /**
                 * Called at the start of the render loop.
                 */
                preRender(): void;

                /**
                 * Renders the Scene to the given Camera.
                 * @param scene The Scene to render.
                 * @param children The Game Objects within the Scene to be rendered.
                 * @param interpolationPercentage The interpolation percentage to apply. Currently unused.
                 * @param camera The Scene Camera to render with.
                 */
                render(scene: Scene, children: GameObjects.DisplayList, interpolationPercentage: number, camera: Cameras.Scene2D.Camera): void;

                /**
                 * Restores the game context's global settings and takes a snapshot if one is scheduled.
                 *
                 * The post-render step happens after all Cameras in all Scenes have been rendered.
                 */
                postRender(): void;

                /**
                 * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.
                 *
                 * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.
                 *
                 * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then
                 * calling this method will override it.
                 *
                 * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets
                 * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
                 * @param callback The Function to invoke after the snapshot image is created.
                 * @param interface The format of the image to create, usually `image/png` or `image/jpeg`. Default 'image/png'.
                 * @param encoderOptions The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`. Default 0.92.
                 */
                snapshot(callback: SnapshotCallback, interface?: string, encoderOptions?: number): this;

                /**
                 * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.
                 *
                 * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.
                 *
                 * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then
                 * calling this method will override it.
                 *
                 * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets
                 * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
                 * @param x The x coordinate to grab from.
                 * @param y The y coordinate to grab from.
                 * @param width The width of the area to grab.
                 * @param height The height of the area to grab.
                 * @param callback The Function to invoke after the snapshot image is created.
                 * @param interface The format of the image to create, usually `image/png` or `image/jpeg`. Default 'image/png'.
                 * @param encoderOptions The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`. Default 0.92.
                 */
                snapshotArea(x: integer, y: integer, width: integer, height: integer, callback: SnapshotCallback, interface?: string, encoderOptions?: number): this;

                /**
                 * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.
                 *
                 * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.
                 *
                 * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then
                 * calling this method will override it.
                 *
                 * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for
                 * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,
                 * using less memory.
                 * @param x The x coordinate of the pixel to get.
                 * @param y The y coordinate of the pixel to get.
                 * @param callback The Function to invoke after the snapshot pixel data is extracted.
                 */
                snapshotPixel(x: integer, y: integer, callback: SnapshotCallback): this;

                /**
                 * Takes a Sprite Game Object, or any object that extends it, and draws it to the current context.
                 * @param sprite The texture based Game Object to draw.
                 * @param frame The frame to draw, doesn't have to be that owned by the Game Object.
                 * @param camera The Camera to use for the rendering transform.
                 * @param parentTransformMatrix The transform matrix of the parent container, if set.
                 */
                batchSprite(sprite: GameObjects.GameObject, frame: Textures.Frame, camera: Cameras.Scene2D.Camera, parentTransformMatrix?: GameObjects.Components.TransformMatrix): void;

                /**
                 * Destroys all object references in the Canvas Renderer.
                 */
                destroy(): void;
            }

            /**
             * Returns an array which maps the default blend modes to supported Canvas blend modes.
             *
             * If the browser doesn't support a blend mode, it will default to the normal `source-over` blend mode.
             */
            function GetBlendModes(): any[];

            /**
             * Takes a reference to the Canvas Renderer, a Canvas Rendering Context, a Game Object, a Camera and a parent matrix
             * and then performs the following steps:
             *
             * 1. Checks the alpha of the source combined with the Camera alpha. If 0 or less it aborts.
             * 2. Takes the Camera and Game Object matrix and multiplies them, combined with the parent matrix if given.
             * 3. Sets the blend mode of the context to be that used by the Game Object.
             * 4. Sets the alpha value of the context to be that used by the Game Object combined with the Camera.
             * 5. Saves the context state.
             * 6. Sets the final matrix values into the context via setTransform.
             *
             * This function is only meant to be used internally. Most of the Canvas Renderer classes use it.
             * @param renderer A reference to the current active Canvas renderer.
             * @param ctx The canvas context to set the transform on.
             * @param src The Game Object being rendered. Can be any interface that extends the base class.
             * @param camera The Camera that is rendering the Game Object.
             * @param parentMatrix A parent transform matrix to apply to the Game Object before rendering.
             */
            function SetTransform(
                renderer: CanvasRenderer,
                ctx: CanvasRenderingContext2D,
                src: GameObjects.GameObject,
                camera: Cameras.Scene2D.Camera,
                parentMatrix?: GameObjects.Components.TransformMatrix
            ): boolean;
        }

        namespace Snapshot {
            /**
             * Takes a snapshot of an area from the current frame displayed by a canvas.
             *
             * This is then copied to an Image object. When this loads, the results are sent
             * to the callback provided in the Snapshot Configuration object.
             * @param sourceCanvas The canvas to take a snapshot of.
             * @param config The snapshot configuration object.
             */
            function Canvas(sourceCanvas: HTMLCanvasElement, config: SnapshotState): void;

            /**
             * Takes a snapshot of an area from the current frame displayed by a WebGL canvas.
             *
             * This is then copied to an Image object. When this loads, the results are sent
             * to the callback provided in the Snapshot Configuration object.
             * @param sourceCanvas The canvas to take a snapshot of.
             * @param config The snapshot configuration object.
             */
            function WebGL(sourceCanvas: HTMLCanvasElement, config: SnapshotState): void;
        }

        namespace WebGL {
            namespace Pipelines {
                /**
                 * BitmapMaskPipeline handles all bitmap masking rendering in WebGL. It works by using
                 * sampling two texture on the fragment shader and using the fragment's alpha to clip the region.
                 * The config properties are:
                 * - game: Current game instance.
                 * - renderer: Current WebGL renderer.
                 * - topology: This indicates how the primitives are rendered. The default value is GL_TRIANGLES.
                 *              Here is the full list of rendering primitives (https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants).
                 * - vertShader: Source for vertex shader as a string.
                 * - fragShader: Source for fragment shader as a string.
                 * - vertexCapacity: The amount of vertices that shall be allocated
                 * - vertexSize: The size of a single vertex in bytes.
                 */
                class BitmapMaskPipeline extends WebGLPipeline {
                    /**
                     *
                     * @param config Used for overriding shader an pipeline properties if extending this pipeline.
                     */
                    constructor(config: object);

                    /**
                     * Float32 view of the array buffer containing the pipeline's vertices.
                     */
                    vertexViewF32: Float32Array;

                    /**
                     * Size of the batch.
                     */
                    maxQuads: number;

                    /**
                     * Dirty flag to check if resolution properties need to be updated on the
                     * masking shader.
                     */
                    resolutionDirty: boolean;

                    /**
                     * Called every time the pipeline needs to be used.
                     * It binds all necessary resources.
                     */
                    onBind(): this;

                    /**
                     * [description]
                     * @param width [description]
                     * @param height [description]
                     * @param resolution [description]
                     */
                    resize(width: number, height: number, resolution: number): this;

                    /**
                     * Binds necessary resources and renders the mask to a separated framebuffer.
                     * The framebuffer for the masked object is also bound for further use.
                     * @param mask GameObject used as mask.
                     * @param maskedObject GameObject masked by the mask GameObject.
                     * @param camera [description]
                     */
                    beginMask(mask: GameObjects.GameObject, maskedObject: GameObjects.GameObject, camera: Cameras.Scene2D.Camera): void;

                    /**
                     * The masked game object's framebuffer is unbound and it's texture
                     * is bound together with the mask texture and the mask shader and
                     * a draw call with a single quad is processed. Here is where the
                     * masking effect is applied.
                     * @param mask GameObject used as a mask.
                     */
                    endMask(mask: GameObjects.GameObject): void;
                }

                /**
                 * ForwardDiffuseLightPipeline implements a forward rendering approach for 2D lights.
                 * This pipeline extends TextureTintPipeline so it implements all it's rendering functions
                 * and batching system.
                 */
                class ForwardDiffuseLightPipeline extends TextureTintPipeline {
                    /**
                     *
                     * @param config The configuration of the pipeline, same as the {@link Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline}.
                     * The fragment shader will be replaced with the lighting shader.
                     */
                    constructor(config: object);

                    /**
                     * This function sets all the needed resources for each camera pass.
                     * @param scene The Scene being rendered.
                     * @param camera The Scene Camera being rendered with.
                     */
                    onRender(scene: Scene, camera: Cameras.Scene2D.Camera): this;

                    /**
                     * Generic function for batching a textured quad
                     * @param gameObject Source GameObject
                     * @param texture Raw WebGLTexture associated with the quad
                     * @param textureWidth Real texture width
                     * @param textureHeight Real texture height
                     * @param srcX X coordinate of the quad
                     * @param srcY Y coordinate of the quad
                     * @param srcWidth Width of the quad
                     * @param srcHeight Height of the quad
                     * @param scaleX X component of scale
                     * @param scaleY Y component of scale
                     * @param rotation Rotation of the quad
                     * @param flipX Indicates if the quad is horizontally flipped
                     * @param flipY Indicates if the quad is vertically flipped
                     * @param scrollFactorX By which factor is the quad affected by the camera horizontal scroll
                     * @param scrollFactorY By which factor is the quad effected by the camera vertical scroll
                     * @param displayOriginX Horizontal origin in pixels
                     * @param displayOriginY Vertical origin in pixels
                     * @param frameX X coordinate of the texture frame
                     * @param frameY Y coordinate of the texture frame
                     * @param frameWidth Width of the texture frame
                     * @param frameHeight Height of the texture frame
                     * @param tintTL Tint for top left
                     * @param tintTR Tint for top right
                     * @param tintBL Tint for bottom left
                     * @param tintBR Tint for bottom right
                     * @param tintEffect The tint effect (0 for additive, 1 for replacement)
                     * @param uOffset Horizontal offset on texture coordinate
                     * @param vOffset Vertical offset on texture coordinate
                     * @param camera Current used camera
                     * @param parentTransformMatrix Parent container
                     */
                    batchTexture(
                        gameObject: GameObjects.GameObject,
                        texture: WebGLTexture,
                        textureWidth: integer,
                        textureHeight: integer,
                        srcX: number,
                        srcY: number,
                        srcWidth: number,
                        srcHeight: number,
                        scaleX: number,
                        scaleY: number,
                        rotation: number,
                        flipX: boolean,
                        flipY: boolean,
                        scrollFactorX: number,
                        scrollFactorY: number,
                        displayOriginX: number,
                        displayOriginY: number,
                        frameX: number,
                        frameY: number,
                        frameWidth: number,
                        frameHeight: number,
                        tintTL: integer,
                        tintTR: integer,
                        tintBL: integer,
                        tintBR: integer,
                        tintEffect: number,
                        uOffset: number,
                        vOffset: number,
                        camera: Cameras.Scene2D.Camera,
                        parentTransformMatrix: GameObjects.Components.TransformMatrix
                    ): void;

                    /**
                     * Sets the Game Objects normal map as the active texture.
                     * @param gameObject The Game Object to update.
                     */
                    setNormalMap(gameObject: GameObjects.GameObject): void;

                    /**
                     * Rotates the normal map vectors inversely by the given angle.
                     * Only works in 2D space.
                     * @param rotation The angle of rotation in radians.
                     */
                    setNormalMapRotation(rotation: number): void;

                    /**
                     * Takes a Sprite Game Object, or any object that extends it, which has a normal texture and adds it to the batch.
                     * @param sprite The texture-based Game Object to add to the batch.
                     * @param camera The Camera to use for the rendering transform.
                     * @param parentTransformMatrix The transform matrix of the parent container, if set.
                     */
                    batchSprite(sprite: GameObjects.Sprite, camera: Cameras.Scene2D.Camera, parentTransformMatrix: GameObjects.Components.TransformMatrix): void;
                }

                /**
                 * TextureTintPipeline implements the rendering infrastructure
                 * for displaying textured objects
                 * The config properties are:
                 * - game: Current game instance.
                 * - renderer: Current WebGL renderer.
                 * - topology: This indicates how the primitives are rendered. The default value is GL_TRIANGLES.
                 *              Here is the full list of rendering primitives (https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants).
                 * - vertShader: Source for vertex shader as a string.
                 * - fragShader: Source for fragment shader as a string.
                 * - vertexCapacity: The amount of vertices that shall be allocated
                 * - vertexSize: The size of a single vertex in bytes.
                 */
                class TextureTintPipeline extends WebGLPipeline {
                    /**
                     *
                     * @param config The configuration options for this Texture Tint Pipeline, as described above.
                     */
                    constructor(config: object);

                    /**
                     * Float32 view of the array buffer containing the pipeline's vertices.
                     */
                    vertexViewF32: Float32Array;

                    /**
                     * Uint32 view of the array buffer containing the pipeline's vertices.
                     */
                    vertexViewU32: Uint32Array;

                    /**
                     * Size of the batch.
                     */
                    maxQuads: integer;

                    /**
                     * Collection of batch information
                     */
                    batches: any[];

                    /**
                     * Called every time the pipeline needs to be used.
                     * It binds all necessary resources.
                     */
                    onBind(): this;

                    /**
                     * Resizes this pipeline and updates the projection.
                     * @param width The new width.
                     * @param height The new height.
                     * @param resolution The resolution.
                     */
                    resize(width: number, height: number, resolution: number): this;

                    /**
                     * Assigns a texture to the current batch. If a different texture is already set it creates a new batch object.
                     * @param texture WebGLTexture that will be assigned to the current batch. If not given uses blankTexture.
                     * @param unit Texture unit to which the texture needs to be bound. Default 0.
                     */
                    setTexture2D(texture?: WebGLTexture, unit?: integer): TextureTintPipeline;

                    /**
                     * Checks if the current batch has the same texture and texture unit, or if we need to create a new batch.
                     * @param texture WebGLTexture that will be assigned to the current batch. If not given uses blankTexture.
                     * @param unit Texture unit to which the texture needs to be bound.
                     */
                    requireTextureBatch(texture: WebGLTexture, unit: integer): boolean;

                    /**
                     * Creates a new batch object and pushes it to a batch array.
                     * The batch object contains information relevant to the current
                     * vertex batch like the offset in the vertex buffer, vertex count and
                     * the textures used by that batch.
                     * @param texture Optional WebGLTexture that will be assigned to the created batch.
                     * @param unit Texture unit to which the texture needs to be bound.
                     */
                    pushBatch(texture: WebGLTexture, unit: integer): void;

                    /**
                     * Uploads the vertex data and emits a draw call for the current batch of vertices.
                     */
                    flush(): this;

                    /**
                     * Takes a Sprite Game Object, or any object that extends it, and adds it to the batch.
                     * @param sprite The texture based Game Object to add to the batch.
                     * @param camera The Camera to use for the rendering transform.
                     * @param parentTransformMatrix The transform matrix of the parent container, if set.
                     */
                    batchSprite(
                        sprite: GameObjects.Image | GameObjects.Sprite,
                        camera: Cameras.Scene2D.Camera,
                        parentTransformMatrix?: GameObjects.Components.TransformMatrix
                    ): void;

                    /**
                     * Adds the vertices data into the batch and flushes if full.
                     *
                     * Assumes 6 vertices in the following arrangement:
                     *
                     * ```
                     * 0----3
                     * |\  B|
                     * | \  |
                     * |  \ |
                     * | A \|
                     * |    \
                     * 1----2
                     * ```
                     *
                     * Where tx0/ty0 = 0, tx1/ty1 = 1, tx2/ty2 = 2 and tx3/ty3 = 3
                     * @param x0 The top-left x position.
                     * @param y0 The top-left y position.
                     * @param x1 The bottom-left x position.
                     * @param y1 The bottom-left y position.
                     * @param x2 The bottom-right x position.
                     * @param y2 The bottom-right y position.
                     * @param x3 The top-right x position.
                     * @param y3 The top-right y position.
                     * @param u0 UV u0 value.
                     * @param v0 UV v0 value.
                     * @param u1 UV u1 value.
                     * @param v1 UV v1 value.
                     * @param tintTL The top-left tint color value.
                     * @param tintTR The top-right tint color value.
                     * @param tintBL The bottom-left tint color value.
                     * @param tintBR The bottom-right tint color value.
                     * @param tintEffect The tint effect for the shader to use.
                     * @param texture WebGLTexture that will be assigned to the current batch if a flush occurs.
                     * @param unit Texture unit to which the texture needs to be bound. Default 0.
                     */
                    batchQuad(
                        x0: number,
                        y0: number,
                        x1: number,
                        y1: number,
                        x2: number,
                        y2: number,
                        x3: number,
                        y3: number,
                        u0: number,
                        v0: number,
                        u1: number,
                        v1: number,
                        tintTL: number,
                        tintTR: number,
                        tintBL: number,
                        tintBR: number,
                        tintEffect: number | boolean,
                        texture?: WebGLTexture,
                        unit?: integer
                    ): boolean;

                    /**
                     * Adds the vertices data into the batch and flushes if full.
                     *
                     * Assumes 3 vertices in the following arrangement:
                     *
                     * ```
                     * 0
                     * |\
                     * | \
                     * |  \
                     * |   \
                     * |    \
                     * 1-----2
                     * ```
                     * @param x1 The bottom-left x position.
                     * @param y1 The bottom-left y position.
                     * @param x2 The bottom-right x position.
                     * @param y2 The bottom-right y position.
                     * @param x3 The top-right x position.
                     * @param y3 The top-right y position.
                     * @param u0 UV u0 value.
                     * @param v0 UV v0 value.
                     * @param u1 UV u1 value.
                     * @param v1 UV v1 value.
                     * @param tintTL The top-left tint color value.
                     * @param tintTR The top-right tint color value.
                     * @param tintBL The bottom-left tint color value.
                     * @param tintEffect The tint effect for the shader to use.
                     * @param texture WebGLTexture that will be assigned to the current batch if a flush occurs.
                     * @param unit Texture unit to which the texture needs to be bound. Default 0.
                     */
                    batchTri(
                        x1: number,
                        y1: number,
                        x2: number,
                        y2: number,
                        x3: number,
                        y3: number,
                        u0: number,
                        v0: number,
                        u1: number,
                        v1: number,
                        tintTL: number,
                        tintTR: number,
                        tintBL: number,
                        tintEffect: number | boolean,
                        texture?: WebGLTexture,
                        unit?: integer
                    ): boolean;

                    /**
                     * Generic function for batching a textured quad using argument values instead of a Game Object.
                     * @param gameObject Source GameObject.
                     * @param texture Raw WebGLTexture associated with the quad.
                     * @param textureWidth Real texture width.
                     * @param textureHeight Real texture height.
                     * @param srcX X coordinate of the quad.
                     * @param srcY Y coordinate of the quad.
                     * @param srcWidth Width of the quad.
                     * @param srcHeight Height of the quad.
                     * @param scaleX X component of scale.
                     * @param scaleY Y component of scale.
                     * @param rotation Rotation of the quad.
                     * @param flipX Indicates if the quad is horizontally flipped.
                     * @param flipY Indicates if the quad is vertically flipped.
                     * @param scrollFactorX By which factor is the quad affected by the camera horizontal scroll.
                     * @param scrollFactorY By which factor is the quad effected by the camera vertical scroll.
                     * @param displayOriginX Horizontal origin in pixels.
                     * @param displayOriginY Vertical origin in pixels.
                     * @param frameX X coordinate of the texture frame.
                     * @param frameY Y coordinate of the texture frame.
                     * @param frameWidth Width of the texture frame.
                     * @param frameHeight Height of the texture frame.
                     * @param tintTL Tint for top left.
                     * @param tintTR Tint for top right.
                     * @param tintBL Tint for bottom left.
                     * @param tintBR Tint for bottom right.
                     * @param tintEffect The tint effect.
                     * @param uOffset Horizontal offset on texture coordinate.
                     * @param vOffset Vertical offset on texture coordinate.
                     * @param camera Current used camera.
                     * @param parentTransformMatrix Parent container.
                     * @param skipFlip Skip the renderTexture check. Default false.
                     */
                    batchTexture(
                        gameObject: GameObjects.GameObject,
                        texture: WebGLTexture,
                        textureWidth: integer,
                        textureHeight: integer,
                        srcX: number,
                        srcY: number,
                        srcWidth: number,
                        srcHeight: number,
                        scaleX: number,
                        scaleY: number,
                        rotation: number,
                        flipX: boolean,
                        flipY: boolean,
                        scrollFactorX: number,
                        scrollFactorY: number,
                        displayOriginX: number,
                        displayOriginY: number,
                        frameX: number,
                        frameY: number,
                        frameWidth: number,
                        frameHeight: number,
                        tintTL: integer,
                        tintTR: integer,
                        tintBL: integer,
                        tintBR: integer,
                        tintEffect: number,
                        uOffset: number,
                        vOffset: number,
                        camera: Cameras.Scene2D.Camera,
                        parentTransformMatrix: GameObjects.Components.TransformMatrix,
                        skipFlip?: boolean
                    ): void;

                    /**
                     * Adds a Texture Frame into the batch for rendering.
                     * @param frame The Texture Frame to be rendered.
                     * @param x The horizontal position to render the texture at.
                     * @param y The vertical position to render the texture at.
                     * @param tint The tint color.
                     * @param alpha The alpha value.
                     * @param transformMatrix The Transform Matrix to use for the texture.
                     * @param parentTransformMatrix A parent Transform Matrix.
                     */
                    batchTextureFrame(
                        frame: Textures.Frame,
                        x: number,
                        y: number,
                        tint: number,
                        alpha: number,
                        transformMatrix: GameObjects.Components.TransformMatrix,
                        parentTransformMatrix?: GameObjects.Components.TransformMatrix
                    ): void;

                    /**
                     * Pushes a filled rectangle into the vertex batch.
                     * Rectangle has no transform values and isn't transformed into the local space.
                     * Used for directly batching untransformed rectangles, such as Camera background colors.
                     * @param x Horizontal top left coordinate of the rectangle.
                     * @param y Vertical top left coordinate of the rectangle.
                     * @param width Width of the rectangle.
                     * @param height Height of the rectangle.
                     * @param color Color of the rectangle to draw.
                     * @param alpha Alpha value of the rectangle to draw.
                     */
                    drawFillRect(x: number, y: number, width: number, height: number, color: number, alpha: number): void;

                    /**
                     * Pushes a filled rectangle into the vertex batch.
                     * Rectangle factors in the given transform matrices before adding to the batch.
                     * @param x Horizontal top left coordinate of the rectangle.
                     * @param y Vertical top left coordinate of the rectangle.
                     * @param width Width of the rectangle.
                     * @param height Height of the rectangle.
                     * @param currentMatrix The current transform.
                     * @param parentMatrix The parent transform.
                     */
                    batchFillRect(
                        x: number,
                        y: number,
                        width: number,
                        height: number,
                        currentMatrix: GameObjects.Components.TransformMatrix,
                        parentMatrix: GameObjects.Components.TransformMatrix
                    ): void;

                    /**
                     * Pushes a filled triangle into the vertex batch.
                     * Triangle factors in the given transform matrices before adding to the batch.
                     * @param x0 Point 0 x coordinate.
                     * @param y0 Point 0 y coordinate.
                     * @param x1 Point 1 x coordinate.
                     * @param y1 Point 1 y coordinate.
                     * @param x2 Point 2 x coordinate.
                     * @param y2 Point 2 y coordinate.
                     * @param currentMatrix The current transform.
                     * @param parentMatrix The parent transform.
                     */
                    batchFillTriangle(
                        x0: number,
                        y0: number,
                        x1: number,
                        y1: number,
                        x2: number,
                        y2: number,
                        currentMatrix: GameObjects.Components.TransformMatrix,
                        parentMatrix: GameObjects.Components.TransformMatrix
                    ): void;

                    /**
                     * Pushes a stroked triangle into the vertex batch.
                     * Triangle factors in the given transform matrices before adding to the batch.
                     * The triangle is created from 3 lines and drawn using the `batchStrokePath` method.
                     * @param x0 Point 0 x coordinate.
                     * @param y0 Point 0 y coordinate.
                     * @param x1 Point 1 x coordinate.
                     * @param y1 Point 1 y coordinate.
                     * @param x2 Point 2 x coordinate.
                     * @param y2 Point 2 y coordinate.
                     * @param lineWidth The width of the line in pixels.
                     * @param currentMatrix The current transform.
                     * @param parentMatrix The parent transform.
                     */
                    batchStrokeTriangle(
                        x0: number,
                        y0: number,
                        x1: number,
                        y1: number,
                        x2: number,
                        y2: number,
                        lineWidth: number,
                        currentMatrix: GameObjects.Components.TransformMatrix,
                        parentMatrix: GameObjects.Components.TransformMatrix
                    ): void;

                    /**
                     * Adds the given path to the vertex batch for rendering.
                     *
                     * It works by taking the array of path data and then passing it through Earcut, which
                     * creates a list of polygons. Each polygon is then added to the batch.
                     *
                     * The path is always automatically closed because it's filled.
                     * @param path Collection of points that represent the path.
                     * @param currentMatrix The current transform.
                     * @param parentMatrix The parent transform.
                     */
                    batchFillPath(path: any[], currentMatrix: GameObjects.Components.TransformMatrix, parentMatrix: GameObjects.Components.TransformMatrix): void;

                    /**
                     * Adds the given path to the vertex batch for rendering.
                     *
                     * It works by taking the array of path data and calling `batchLine` for each section
                     * of the path.
                     *
                     * The path is optionally closed at the end.
                     * @param path Collection of points that represent the path.
                     * @param lineWidth The width of the line segments in pixels.
                     * @param pathOpen Indicates if the path should be closed or left open.
                     * @param currentMatrix The current transform.
                     * @param parentMatrix The parent transform.
                     */
                    batchStrokePath(
                        path: any[],
                        lineWidth: number,
                        pathOpen: boolean,
                        currentMatrix: GameObjects.Components.TransformMatrix,
                        parentMatrix: GameObjects.Components.TransformMatrix
                    ): void;

                    /**
                     * Creates a quad and adds it to the vertex batch based on the given line values.
                     * @param ax X coordinate to the start of the line
                     * @param ay Y coordinate to the start of the line
                     * @param bx X coordinate to the end of the line
                     * @param by Y coordinate to the end of the line
                     * @param aLineWidth Width of the start of the line
                     * @param bLineWidth Width of the end of the line
                     * @param currentMatrix Parent matrix, generally used by containers
                     */
                    batchLine(ax: number, ay: number, bx: number, by: number, aLineWidth: number, bLineWidth: number, currentMatrix: Float32Array): void;
                }
            }

            namespace Utils {
                /**
                 * Packs four floats on a range from 0.0 to 1.0 into a single Uint32
                 * @param r Red component in a range from 0.0 to 1.0
                 * @param g Green component in a range from 0.0 to 1.0
                 * @param b Blue component in a range from 0.0 to 1.0
                 * @param a Alpha component in a range from 0.0 to 1.0
                 */
                function getTintFromFloats(r: number, g: number, b: number, a: number): number;

                /**
                 * Packs a Uint24, representing RGB components, with a Float32, representing
                 * the alpha component, with a range between 0.0 and 1.0 and return a Uint32
                 * @param rgb Uint24 representing RGB components
                 * @param a Float32 representing Alpha component
                 */
                function getTintAppendFloatAlpha(rgb: number, a: number): number;

                /**
                 * Packs a Uint24, representing RGB components, with a Float32, representing
                 * the alpha component, with a range between 0.0 and 1.0 and return a
                 * swizzled Uint32
                 * @param rgb Uint24 representing RGB components
                 * @param a Float32 representing Alpha component
                 */
                function getTintAppendFloatAlphaAndSwap(rgb: number, a: number): number;

                /**
                 * Unpacks a Uint24 RGB into an array of floats of ranges of 0.0 and 1.0
                 * @param rgb RGB packed as a Uint24
                 */
                function getFloatsFromUintRGB(rgb: number): any[];

                /**
                 * Counts how many attributes of 32 bits a vertex has
                 * @param attributes Array of attributes
                 * @param glContext WebGLContext used for check types
                 */
                function getComponentCount(attributes: any[], glContext: WebGLRenderingContext): number;
            }

            /**
             * WebGLPipeline is a class that describes the way elements will be rendererd
             * in WebGL, specially focused on batching vertices (batching is not provided).
             * Pipelines are mostly used for describing 2D rendering passes but it's
             * flexible enough to be used for any interface of rendering including 3D.
             * Internally WebGLPipeline will handle things like compiling shaders,
             * creating vertex buffers, assigning primitive topology and binding
             * vertex attributes.
             *
             * The config properties are:
             * - game: Current game instance.
             * - renderer: Current WebGL renderer.
             * - gl: Current WebGL context.
             * - topology: This indicates how the primitives are rendered. The default value is GL_TRIANGLES.
             *              Here is the full list of rendering primitives (https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants).
             * - vertShader: Source for vertex shader as a string.
             * - fragShader: Source for fragment shader as a string.
             * - vertexCapacity: The amount of vertices that shall be allocated
             * - vertexSize: The size of a single vertex in bytes.
             * - vertices: An optional buffer of vertices
             * - attributes: An array describing the vertex attributes
             *
             * The vertex attributes properties are:
             * - name : String - Name of the attribute in the vertex shader
             * - size : integer - How many components describe the attribute. For ex: vec3 = size of 3, float = size of 1
             * - interface : GLenum - WebGL interface (gl.BYTE, gl.SHORT, gl.UNSIGNED_BYTE, gl.UNSIGNED_SHORT, gl.FLOAT)
             * - normalized : boolean - Is the attribute normalized
             * - offset : integer - The offset in bytes to the current attribute in the vertex. Equivalent to offsetof(vertex, attrib) in C
             * Here you can find more information of how to describe an attribute:
             * - https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
             */
            class WebGLPipeline {
                /**
                 *
                 * @param config The configuration object for this WebGL Pipeline, as described above.
                 */
                constructor(config: object);

                /**
                 * Name of the Pipeline. Used for identifying
                 */
                name: string;

                /**
                 * The Game which owns this WebGL Pipeline.
                 */
                game: Game;

                /**
                 * The canvas which this WebGL Pipeline renders to.
                 */
                view: HTMLCanvasElement;

                /**
                 * Used to store the current game resolution
                 */
                resolution: number;

                /**
                 * Width of the current viewport
                 */
                width: number;

                /**
                 * Height of the current viewport
                 */
                height: number;

                /**
                 * The WebGL context this WebGL Pipeline uses.
                 */
                gl: WebGLRenderingContext;

                /**
                 * How many vertices have been fed to the current pipeline.
                 */
                vertexCount: number;

                /**
                 * The limit of vertices that the pipeline can hold
                 */
                vertexCapacity: integer;

                /**
                 * The WebGL Renderer which owns this WebGL Pipeline.
                 */
                renderer: WebGLRenderer;

                /**
                 * Raw byte buffer of vertices.
                 */
                vertexData: ArrayBuffer;

                /**
                 * The handle to a WebGL vertex buffer object.
                 */
                vertexBuffer: WebGLBuffer;

                /**
                 * The handle to a WebGL program
                 */
                program: WebGLProgram;

                /**
                 * Array of objects that describe the vertex attributes
                 */
                attributes: object;

                /**
                 * The size in bytes of the vertex
                 */
                vertexSize: integer;

                /**
                 * The primitive topology which the pipeline will use to submit draw calls
                 */
                topology: integer;

                /**
                 * Uint8 view to the vertex raw buffer. Used for uploading vertex buffer resources
                 * to the GPU.
                 */
                bytes: Uint8Array;

                /**
                 * This will store the amount of components of 32 bit length
                 */
                vertexComponentCount: integer;

                /**
                 * Indicates if the current pipeline is flushing the contents to the GPU.
                 * When the variable is set the flush function will be locked.
                 */
                flushLocked: boolean;

                /**
                 * Indicates if the current pipeline is active or not for this frame only.
                 * Reset in the onRender method.
                 */
                active: boolean;

                /**
                 * Called when the Game has fully booted and the Renderer has finished setting up.
                 *
                 * By this stage all Game level systems are now in place and you can perform any final
                 * tasks that the pipeline may need that relied on game systems such as the Texture Manager.
                 */
                boot(): void;

                /**
                 * Adds a description of vertex attribute to the pipeline
                 * @param name Name of the vertex attribute
                 * @param size Vertex component size
                 * @param interface interface of the attribute
                 * @param normalized Is the value normalized to a range
                 * @param offset Byte offset to the beginning of the first element in the vertex
                 */
                addAttribute(name: string, size: integer, interface: integer, normalized: boolean, offset: integer): this;

                /**
                 * Check if the current batch of vertices is full.
                 */
                shouldFlush(): boolean;

                /**
                 * Resizes the properties used to describe the viewport
                 * @param width The new width of this WebGL Pipeline.
                 * @param height The new height of this WebGL Pipeline.
                 * @param resolution The resolution this WebGL Pipeline should be resized to.
                 */
                resize(width: number, height: number, resolution: number): this;

                /**
                 * Binds the pipeline resources, including programs, vertex buffers and binds attributes
                 */
                bind(): this;

                /**
                 * Set whenever this WebGL Pipeline is bound to a WebGL Renderer.
                 *
                 * This method is called every time the WebGL Pipeline is attempted to be bound, even if it already is the current pipeline.
                 */
                onBind(): this;

                /**
                 * Called before each frame is rendered, but after the canvas has been cleared.
                 */
                onPreRender(): this;

                /**
                 * Called before a Scene's Camera is rendered.
                 * @param scene The Scene being rendered.
                 * @param camera The Scene Camera being rendered with.
                 */
                onRender(scene: Scene, camera: Cameras.Scene2D.Camera): this;

                /**
                 * Called after each frame has been completely rendered and snapshots have been taken.
                 */
                onPostRender(): this;

                /**
                 * Uploads the vertex data and emits a draw call
                 * for the current batch of vertices.
                 */
                flush(): this;

                /**
                 * Removes all object references in this WebGL Pipeline and removes its program from the WebGL context.
                 */
                destroy(): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x The new value of the `float` uniform.
                 */
                setFloat1(name: string, x: number): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x The new X component of the `vec2` uniform.
                 * @param y The new Y component of the `vec2` uniform.
                 */
                setFloat2(name: string, x: number, y: number): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x The new X component of the `vec3` uniform.
                 * @param y The new Y component of the `vec3` uniform.
                 * @param z The new Z component of the `vec3` uniform.
                 */
                setFloat3(name: string, x: number, y: number, z: number): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x X component of the uniform
                 * @param y Y component of the uniform
                 * @param z Z component of the uniform
                 * @param w W component of the uniform
                 */
                setFloat4(name: string, x: number, y: number, z: number, w: number): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param arr The new value to be used for the uniform variable.
                 */
                setFloat1v(name: string, arr: Float32Array): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param arr The new value to be used for the uniform variable.
                 */
                setFloat2v(name: string, arr: Float32Array): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param arr The new value to be used for the uniform variable.
                 */
                setFloat3v(name: string, arr: Float32Array): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param arr The new value to be used for the uniform variable.
                 */
                setFloat4v(name: string, arr: Float32Array): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x The new value of the `int` uniform.
                 */
                setInt1(name: string, x: integer): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x The new X component of the `ivec2` uniform.
                 * @param y The new Y component of the `ivec2` uniform.
                 */
                setInt2(name: string, x: integer, y: integer): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x The new X component of the `ivec3` uniform.
                 * @param y The new Y component of the `ivec3` uniform.
                 * @param z The new Z component of the `ivec3` uniform.
                 */
                setInt3(name: string, x: integer, y: integer, z: integer): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x X component of the uniform
                 * @param y Y component of the uniform
                 * @param z Z component of the uniform
                 * @param w W component of the uniform
                 */
                setInt4(name: string, x: integer, y: integer, z: integer, w: integer): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param transpose Whether to transpose the matrix. Should be `false`.
                 * @param matrix The new values for the `mat2` uniform.
                 */
                setMatrix2(name: string, transpose: boolean, matrix: Float32Array): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param transpose Whether to transpose the matrix. Should be `false`.
                 * @param matrix The new values for the `mat3` uniform.
                 */
                setMatrix3(name: string, transpose: boolean, matrix: Float32Array): this;

                /**
                 * Set a uniform value of the current pipeline program.
                 * @param name The name of the uniform to look-up and modify.
                 * @param transpose Should the matrix be transpose
                 * @param matrix Matrix data
                 */
                setMatrix4(name: string, transpose: boolean, matrix: Float32Array): this;
            }

            /**
             * WebGLRenderer is a class that contains the needed functionality to keep the
             * WebGLRenderingContext state clean. The main idea of the WebGLRenderer is to keep track of
             * any context change that happens for WebGL rendering inside of Phaser. This means
             * if raw webgl functions are called outside the WebGLRenderer of the Phaser WebGL
             * rendering ecosystem they might pollute the current WebGLRenderingContext state producing
             * unexpected behavior. It's recommended that WebGL interaction is done through
             * WebGLRenderer and/or WebGLPipeline.
             */
            class WebGLRenderer {
                /**
                 *
                 * @param game The Game instance which owns this WebGL Renderer.
                 */
                constructor(game: Game);

                /**
                 * The local configuration settings of this WebGL Renderer.
                 */
                config: object;

                /**
                 * The Game instance which owns this WebGL Renderer.
                 */
                game: Game;

                /**
                 * A constant which allows the renderer to be easily identified as a WebGL Renderer.
                 */
                interface: integer;

                /**
                 * The width of the canvas being rendered to.
                 * This is populated in the onResize event handler.
                 */
                width: integer;

                /**
                 * The height of the canvas being rendered to.
                 * This is populated in the onResize event handler.
                 */
                height: integer;

                /**
                 * The canvas which this WebGL Renderer draws to.
                 */
                canvas: HTMLCanvasElement;

                /**
                 * An array of functions to invoke if the WebGL context is lost.
                 */
                lostContextCallbacks: WebGLContextCallback[];

                /**
                 * An array of functions to invoke if the WebGL context is restored.
                 */
                restoredContextCallbacks: WebGLContextCallback[];

                /**
                 * An array of blend modes supported by the WebGL Renderer.
                 *
                 * This array includes the default blend modes as well as any custom blend modes added through {@link #addBlendMode}.
                 */
                blendModes: any[];

                /**
                 * Keeps track of any WebGLTexture created with the current WebGLRenderingContext
                 */
                nativeTextures: any[];

                /**
                 * Set to `true` if the WebGL context of the renderer is lost.
                 */
                contextLost: boolean;

                /**
                 * This object will store all pipelines created through addPipeline
                 */
                pipelines: object;

                /**
                 * Details about the currently scheduled snapshot.
                 *
                 * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.
                 */
                snapshotState: SnapshotState;

                /**
                 * Cached value for the last texture unit that was used
                 */
                currentActiveTextureUnit: integer;

                /**
                 * An array of the last texture handles that were bound to the WebGLRenderingContext
                 */
                currentTextures: any[];

                /**
                 * Current framebuffer in use
                 */
                currentFramebuffer: WebGLFramebuffer;

                /**
                 * Current WebGLPipeline in use
                 */
                currentPipeline: WebGLPipeline;

                /**
                 * Current WebGLProgram in use
                 */
                currentProgram: WebGLProgram;

                /**
                 * Current WebGLBuffer (Vertex buffer) in use
                 */
                currentVertexBuffer: WebGLBuffer;

                /**
                 * Current WebGLBuffer (Index buffer) in use
                 */
                currentIndexBuffer: WebGLBuffer;

                /**
                 * Current blend mode in use
                 */
                currentBlendMode: integer;

                /**
                 * Indicates if the the scissor state is enabled in WebGLRenderingContext
                 */
                currentScissorEnabled: boolean;

                /**
                 * Stores the current scissor data
                 */
                currentScissor: Uint32Array;

                /**
                 * Stack of scissor data
                 */
                scissorStack: Uint32Array;

                /**
                 * The underlying WebGL context of the renderer.
                 */
                gl: WebGLRenderingContext;

                /**
                 * Array of strings that indicate which WebGL extensions are supported by the browser
                 */
                supportedExtensions: object;

                /**
                 * Extensions loaded into the current context
                 */
                extensions: object;

                /**
                 * Stores the current WebGL component formats for further use
                 */
                glFormats: any[];

                /**
                 * Stores the supported WebGL texture compression formats.
                 */
                compression: any[];

                /**
                 * Cached drawing buffer height to reduce gl calls.
                 */
                readonly drawingBufferHeight: number;

                /**
                 * A blank 32x32 transparent texture, as used by the Graphics system where needed.
                 * This is set in the `boot` method.
                 */
                readonly blankTexture: WebGLTexture;

                /**
                 * A default Camera used in calls when no other camera has been provided.
                 */
                defaultCamera: Cameras.Scene2D.BaseCamera;

                /**
                 * Creates a new WebGLRenderingContext and initializes all internal state.
                 * @param config The configuration object for the renderer.
                 */
                init(config: object): this;

                /**
                 * The event handler that manages the `resize` event dispatched by the Scale Manager.
                 * @param gameSize The default Game Size object. This is the un-modified game dimensions.
                 * @param baseSize The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.
                 * @param displaySize The display Size object. The size of the canvas style width / height attributes.
                 * @param resolution The Scale Manager resolution setting.
                 */
                onResize(gameSize: Structs.Size, baseSize: Structs.Size, displaySize: Structs.Size, resolution?: number): void;

                /**
                 * Resizes the drawing buffer to match that required by the Scale Manager.
                 * @param width The new width of the renderer.
                 * @param height The new height of the renderer.
                 * @param resolution The new resolution of the renderer.
                 */
                resize(width?: number, height?: number, resolution?: number): this;

                /**
                 * Adds a callback to be invoked when the WebGL context has been restored by the browser.
                 * @param callback The callback to be invoked on context restoration.
                 * @param target The context of the callback.
                 */
                onContextRestored(callback: WebGLContextCallback, target: object): this;

                /**
                 * Adds a callback to be invoked when the WebGL context has been lost by the browser.
                 * @param callback The callback to be invoked on context loss.
                 * @param target The context of the callback.
                 */
                onContextLost(callback: WebGLContextCallback, target: object): this;

                /**
                 * Checks if a WebGL extension is supported
                 * @param extensionName Name of the WebGL extension
                 */
                hasExtension(extensionName: string): boolean;

                /**
                 * Loads a WebGL extension
                 * @param extensionName The name of the extension to load.
                 */
                getExtension(extensionName: string): object;

                /**
                 * Flushes the current pipeline if the pipeline is bound
                 */
                flush(): void;

                /**
                 * Checks if a pipeline is present in the current WebGLRenderer
                 * @param pipelineName The name of the pipeline.
                 */
                hasPipeline(pipelineName: string): boolean;

                /**
                 * Returns the pipeline by name if the pipeline exists
                 * @param pipelineName The name of the pipeline.
                 */
                getPipeline(pipelineName: string): WebGLPipeline;

                /**
                 * Removes a pipeline by name.
                 * @param pipelineName The name of the pipeline to be removed.
                 */
                removePipeline(pipelineName: string): this;

                /**
                 * Adds a pipeline instance into the collection of pipelines
                 * @param pipelineName A unique string-based key for the pipeline.
                 * @param pipelineInstance A pipeline instance which must extend WebGLPipeline.
                 */
                addPipeline(pipelineName: string, pipelineInstance: WebGLPipeline): WebGLPipeline;

                /**
                 * Pushes a new scissor state. This is used to set nested scissor states.
                 * @param x The x position of the scissor.
                 * @param y The y position of the scissor.
                 * @param width The width of the scissor.
                 * @param height The height of the scissor.
                 * @param drawingBufferHeight Optional drawingBufferHeight override value.
                 */
                pushScissor(x: integer, y: integer, width: integer, height: integer, drawingBufferHeight?: integer): integer[];

                /**
                 * Sets the current scissor state.
                 * @param x The x position of the scissor.
                 * @param y The y position of the scissor.
                 * @param width The width of the scissor.
                 * @param height The height of the scissor.
                 * @param drawingBufferHeight Optional drawingBufferHeight override value.
                 */
                setScissor(x: integer, y: integer, width: integer, height: integer, drawingBufferHeight?: integer): void;

                /**
                 * Pops the last scissor state and sets it.
                 */
                popScissor(): void;

                /**
                 * Binds a WebGLPipeline and sets it as the current pipeline to be used.
                 * @param pipelineInstance The pipeline instance to be activated.
                 * @param gameObject The Game Object that invoked this pipeline, if any.
                 */
                setPipeline(pipelineInstance: WebGLPipeline, gameObject?: GameObjects.GameObject): WebGLPipeline;

                /**
                 * Use this to reset the gl context to the state that Phaser requires to continue rendering.
                 * Calling this will:
                 *
                 * * Disable `DEPTH_TEST`, `CULL_FACE` and `STENCIL_TEST`.
                 * * Clear the depth buffer and stencil buffers.
                 * * Reset the viewport size.
                 * * Reset the blend mode.
                 * * Bind a blank texture as the active texture on texture unit zero.
                 * * Rebinds the given pipeline instance.
                 *
                 * You should call this having previously called `clearPipeline` and then wishing to return
                 * control to Phaser again.
                 * @param pipelineInstance The pipeline instance to be activated.
                 */
                rebindPipeline(pipelineInstance: WebGLPipeline): void;

                /**
                 * Flushes the current WebGLPipeline being used and then clears it, along with the
                 * the current shader program and vertex buffer. Then resets the blend mode to NORMAL.
                 * Call this before jumping to your own gl context handler, and then call `rebindPipeline` when
                 * you wish to return control to Phaser again.
                 */
                clearPipeline(): void;

                /**
                 * Sets the blend mode to the value given.
                 *
                 * If the current blend mode is different from the one given, the pipeline is flushed and the new
                 * blend mode is enabled.
                 * @param blendModeId The blend mode to be set. Can be a `BlendModes` const or an integer value.
                 * @param force Force the blend mode to be set, regardless of the currently set blend mode. Default false.
                 */
                setBlendMode(blendModeId: integer, force?: boolean): boolean;

                /**
                 * Creates a new custom blend mode for the renderer.
                 * @param func An array containing the WebGL functions to use for the source and the destination blending factors, respectively.
                 * See the possible constants for {@link WebGLRenderingContext#blendFunc()}.
                 * @param equation The equation to use for combining the RGB and alpha components of a new pixel with a rendered one.
                 * See the possible constants for {@link WebGLRenderingContext#blendEquation()}.
                 */
                addBlendMode(func: CallbackFn, equation: CallbackFn): integer;

                /**
                 * Updates the function bound to a given custom blend mode.
                 * @param index The index of the custom blend mode.
                 * @param func The function to use for the blend mode.
                 * @param equation The equation to use for the blend mode.
                 */
                updateBlendMode(index: integer, func: CallbackFn, equation: CallbackFn): this;

                /**
                 * Removes a custom blend mode from the renderer.
                 * Any Game Objects still using this blend mode will error, so be sure to clear them first.
                 * @param index The index of the custom blend mode to be removed.
                 */
                removeBlendMode(index: integer): this;

                /**
                 * Binds a texture at a texture unit. If a texture is already
                 * bound to that unit it will force a flush on the current pipeline.
                 * @param texture The WebGL texture that needs to be bound.
                 * @param textureUnit The texture unit to which the texture will be bound.
                 * @param flush Will the current pipeline be flushed if this is a new texture, or not? Default true.
                 */
                setTexture2D(texture: WebGLTexture, textureUnit: integer, flush?: boolean): this;

                /**
                 * Binds a framebuffer. If there was another framebuffer already bound it will force a pipeline flush.
                 * @param framebuffer The framebuffer that needs to be bound.
                 * @param updateScissor If a framebuffer is given, set the gl scissor to match the frame buffer size? Or, if `null` given, pop the scissor from the stack. Default false.
                 */
                setFramebuffer(framebuffer: WebGLFramebuffer, updateScissor?: boolean): this;

                /**
                 * Binds a program. If there was another program already bound it will force a pipeline flush.
                 * @param program The program that needs to be bound.
                 */
                setProgram(program: WebGLProgram): this;

                /**
                 * Bounds a vertex buffer. If there is a vertex buffer already bound it'll force a pipeline flush.
                 * @param vertexBuffer The buffer that needs to be bound.
                 */
                setVertexBuffer(vertexBuffer: WebGLBuffer): this;

                /**
                 * Bounds a index buffer. If there is a index buffer already bound it'll force a pipeline flush.
                 * @param indexBuffer The buffer the needs to be bound.
                 */
                setIndexBuffer(indexBuffer: WebGLBuffer): this;

                /**
                 * Creates a texture from an image source. If the source is not valid it creates an empty texture.
                 * @param source The source of the texture.
                 * @param width The width of the texture.
                 * @param height The height of the texture.
                 * @param scaleMode The scale mode to be used by the texture.
                 */
                createTextureFromSource(source: object, width: integer, height: integer, scaleMode: integer): WebGLTexture;

                /**
                 * A wrapper for creating a WebGLTexture. If no pixel data is passed it will create an empty texture.
                 * @param mipLevel Mip level of the texture.
                 * @param minFilter Filtering of the texture.
                 * @param magFilter Filtering of the texture.
                 * @param wrapT Wrapping mode of the texture.
                 * @param wrapS Wrapping mode of the texture.
                 * @param format Which format does the texture use.
                 * @param pixels pixel data.
                 * @param width Width of the texture in pixels.
                 * @param height Height of the texture in pixels.
                 * @param pma Does the texture have premultiplied alpha?
                 */
                createTexture2D(
                    mipLevel: integer,
                    minFilter: integer,
                    magFilter: integer,
                    wrapT: integer,
                    wrapS: integer,
                    format: integer,
                    pixels: object,
                    width: integer,
                    height: integer,
                    pma: boolean
                ): WebGLTexture;

                /**
                 * Wrapper for creating WebGLFramebuffer.
                 * @param width Width in pixels of the framebuffer
                 * @param height Height in pixels of the framebuffer
                 * @param renderTexture The color texture to where the color pixels are written
                 * @param addDepthStencilBuffer Indicates if the current framebuffer support depth and stencil buffers
                 */
                createFramebuffer(width: integer, height: integer, renderTexture: WebGLTexture, addDepthStencilBuffer: boolean): WebGLFramebuffer;

                /**
                 * Wrapper for creating a WebGLProgram
                 * @param vertexShader Source to the vertex shader
                 * @param fragmentShader Source to the fragment shader
                 */
                createProgram(vertexShader: string, fragmentShader: string): WebGLProgram;

                /**
                 * Wrapper for creating a vertex buffer.
                 * @param initialDataOrSize It's either ArrayBuffer or an integer indicating the size of the vbo
                 * @param bufferUsage How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW
                 */
                createVertexBuffer(initialDataOrSize: ArrayBuffer, bufferUsage: integer): WebGLBuffer;

                /**
                 * Wrapper for creating a vertex buffer.
                 * @param initialDataOrSize Either ArrayBuffer or an integer indicating the size of the vbo.
                 * @param bufferUsage How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW.
                 */
                createIndexBuffer(initialDataOrSize: ArrayBuffer, bufferUsage: integer): WebGLBuffer;

                /**
                 * Removes the given texture from the nativeTextures array and then deletes it from the GPU.
                 * @param texture The WebGL Texture to be deleted.
                 */
                deleteTexture(texture: WebGLTexture): this;

                /**
                 * Deletes a WebGLFramebuffer from the GL instance.
                 * @param framebuffer The Framebuffer to be deleted.
                 */
                deleteFramebuffer(framebuffer: WebGLFramebuffer): this;

                /**
                 * Deletes a WebGLProgram from the GL instance.
                 * @param program The shader program to be deleted.
                 */
                deleteProgram(program: WebGLProgram): this;

                /**
                 * Deletes a WebGLBuffer from the GL instance.
                 * @param vertexBuffer The WebGLBuffer to be deleted.
                 */
                deleteBuffer(vertexBuffer: WebGLBuffer): this;

                /**
                 * Controls the pre-render operations for the given camera.
                 * Handles any clipping needed by the camera and renders the background color if a color is visible.
                 * @param camera The Camera to pre-render.
                 */
                preRenderCamera(camera: Cameras.Scene2D.Camera): void;

                /**
                 * Controls the post-render operations for the given camera.
                 * Renders the foreground camera effects like flash and fading. It resets the current scissor state.
                 * @param camera The Camera to post-render.
                 */
                postRenderCamera(camera: Cameras.Scene2D.Camera): void;

                /**
                 * Clears the current vertex buffer and updates pipelines.
                 */
                preRender(): void;

                /**
                 * The core render step for a Scene Camera.
                 *
                 * Iterates through the given Game Object's array and renders them with the given Camera.
                 *
                 * This is called by the `CameraManager.render` method. The Camera Manager instance belongs to a Scene, and is invoked
                 * by the Scene Systems.render method.
                 *
                 * This method is not called if `Camera.visible` is `false`, or `Camera.alpha` is zero.
                 * @param scene The Scene to render.
                 * @param children The Game Object's within the Scene to be rendered.
                 * @param interpolationPercentage The interpolation percentage to apply. Currently un-used.
                 * @param camera The Scene Camera to render with.
                 */
                render(scene: Scene, children: GameObjects.GameObject, interpolationPercentage: number, camera: Cameras.Scene2D.Camera): void;

                /**
                 * The post-render step happens after all Cameras in all Scenes have been rendered.
                 */
                postRender(): void;

                /**
                 * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.
                 *
                 * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.
                 *
                 * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then
                 * calling this method will override it.
                 *
                 * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.
                 * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,
                 * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,
                 * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
                 * @param callback The Function to invoke after the snapshot image is created.
                 * @param interface The format of the image to create, usually `image/png` or `image/jpeg`. Default 'image/png'.
                 * @param encoderOptions The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`. Default 0.92.
                 */
                snapshot(callback: SnapshotCallback, interface?: string, encoderOptions?: number): this;

                /**
                 * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.
                 *
                 * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.
                 *
                 * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then
                 * calling this method will override it.
                 *
                 * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.
                 * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,
                 * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,
                 * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.
                 * @param x The x coordinate to grab from.
                 * @param y The y coordinate to grab from.
                 * @param width The width of the area to grab.
                 * @param height The height of the area to grab.
                 * @param callback The Function to invoke after the snapshot image is created.
                 * @param interface The format of the image to create, usually `image/png` or `image/jpeg`. Default 'image/png'.
                 * @param encoderOptions The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`. Default 0.92.
                 */
                snapshotArea(x: integer, y: integer, width: integer, height: integer, callback: SnapshotCallback, interface?: string, encoderOptions?: number): this;

                /**
                 * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.
                 *
                 * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.
                 *
                 * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then
                 * calling this method will override it.
                 *
                 * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for
                 * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,
                 * using less memory.
                 * @param x The x coordinate of the pixel to get.
                 * @param y The y coordinate of the pixel to get.
                 * @param callback The Function to invoke after the snapshot pixel data is extracted.
                 */
                snapshotPixel(x: integer, y: integer, callback: SnapshotCallback): this;

                /**
                 * Creates a WebGL Texture based on the given canvas element.
                 * @param srcCanvas The Canvas element that will be used to populate the texture.
                 * @param dstTexture Is this going to replace an existing texture? If so, pass it here.
                 * @param noRepeat Should this canvas never be allowed to set REPEAT? (such as for Text objects) Default false.
                 */
                canvasToTexture(srcCanvas: HTMLCanvasElement, dstTexture?: WebGLTexture, noRepeat?: boolean): WebGLTexture;

                /**
                 * Sets the minification and magnification filter for a texture.
                 * @param texture The texture to set the filter for.
                 * @param filter The filter to set. 0 for linear filtering, 1 for nearest neighbor (blocky) filtering.
                 */
                setTextureFilter(texture: integer, filter: integer): this;

                /**
                 * [description]
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x [description]
                 */
                setFloat1(program: WebGLProgram, name: string, x: number): this;

                /**
                 * [description]
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x [description]
                 * @param y [description]
                 */
                setFloat2(program: WebGLProgram, name: string, x: number, y: number): this;

                /**
                 * [description]
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 */
                setFloat3(program: WebGLProgram, name: string, x: number, y: number, z: number): this;

                /**
                 * Sets uniform of a WebGLProgram
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x X component
                 * @param y Y component
                 * @param z Z component
                 * @param w W component
                 */
                setFloat4(program: WebGLProgram, name: string, x: number, y: number, z: number, w: number): this;

                /**
                 * Sets the value of a uniform variable in the given WebGLProgram.
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param arr The new value to be used for the uniform variable.
                 */
                setFloat1v(program: WebGLProgram, name: string, arr: Float32Array): this;

                /**
                 * Sets the value of a uniform variable in the given WebGLProgram.
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param arr The new value to be used for the uniform variable.
                 */
                setFloat2v(program: WebGLProgram, name: string, arr: Float32Array): this;

                /**
                 * Sets the value of a uniform variable in the given WebGLProgram.
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param arr The new value to be used for the uniform variable.
                 */
                setFloat3v(program: WebGLProgram, name: string, arr: Float32Array): this;

                /**
                 * Sets the value of a uniform variable in the given WebGLProgram.
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param arr The new value to be used for the uniform variable.
                 */
                setFloat4v(program: WebGLProgram, name: string, arr: Float32Array): this;

                /**
                 * Sets the value of a uniform variable in the given WebGLProgram.
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x [description]
                 */
                setInt1(program: WebGLProgram, name: string, x: integer): this;

                /**
                 * Sets the value of a uniform variable in the given WebGLProgram.
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x The new X component
                 * @param y The new Y component
                 */
                setInt2(program: WebGLProgram, name: string, x: integer, y: integer): this;

                /**
                 * Sets the value of a uniform variable in the given WebGLProgram.
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x The new X component
                 * @param y The new Y component
                 * @param z The new Z component
                 */
                setInt3(program: WebGLProgram, name: string, x: integer, y: integer, z: integer): this;

                /**
                 * Sets the value of a uniform variable in the given WebGLProgram.
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param x X component
                 * @param y Y component
                 * @param z Z component
                 * @param w W component
                 */
                setInt4(program: WebGLProgram, name: string, x: integer, y: integer, z: integer, w: integer): this;

                /**
                 * Sets the value of a 2x2 matrix uniform variable in the given WebGLProgram.
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param transpose The value indicating whether to transpose the matrix. Must be false.
                 * @param matrix The new matrix value.
                 */
                setMatrix2(program: WebGLProgram, name: string, transpose: boolean, matrix: Float32Array): this;

                /**
                 * [description]
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param transpose [description]
                 * @param matrix [description]
                 */
                setMatrix3(program: WebGLProgram, name: string, transpose: boolean, matrix: Float32Array): this;

                /**
                 * Sets uniform of a WebGLProgram
                 * @param program The target WebGLProgram from which the uniform location will be looked-up.
                 * @param name The name of the uniform to look-up and modify.
                 * @param transpose Is the matrix transposed
                 * @param matrix Matrix data
                 */
                setMatrix4(program: WebGLProgram, name: string, transpose: boolean, matrix: Float32Array): this;

                /**
                 * Returns the maximum number of texture units that can be used in a fragment shader.
                 */
                getMaxTextures(): integer;

                /**
                 * Returns the largest texture size (either width or height) that can be created.
                 * Note that VRAM may not allow a texture of any given size, it just expresses
                 * hardware / driver support for a given size.
                 */
                getMaxTextureSize(): integer;

                /**
                 * Destroy this WebGLRenderer, cleaning up all related resources such as pipelines, native textures, etc.
                 */
                destroy(): void;
            }
        }
    }

    /**
     * Phaser Scale Modes.
     */
    enum ScaleModes {
        /**
         * Default Scale Mode (Linear).
         */
        DEFAULT,
        /**
         * Linear Scale Mode.
         */
        LINEAR,
        /**
         * Nearest Scale Mode.
         */
        NEAREST
    }

    namespace Scale {
        /**
         * Phaser Scale Manager constants for centering the game canvas.
         */
        namespace Center {
            /**
             * The game canvas is not centered within the parent by Phaser.
             * You can still center it yourself via CSS.
             */
            const NO_CENTER: any;

            /**
             * The game canvas is centered both horizontally and vertically within the parent.
             * To do this, the parent has to have a bounds that can be calculated and not be empty.
             *
             * Centering is achieved by setting the margin left and top properties of the
             * game canvas, and does not factor in any other CSS styles you may have applied.
             */
            const CENTER_BOTH: any;

            /**
             * The game canvas is centered horizontally within the parent.
             * To do this, the parent has to have a bounds that can be calculated and not be empty.
             *
             * Centering is achieved by setting the margin left and top properties of the
             * game canvas, and does not factor in any other CSS styles you may have applied.
             */
            const CENTER_HORIZONTALLY: any;

            /**
             * The game canvas is centered both vertically within the parent.
             * To do this, the parent has to have a bounds that can be calculated and not be empty.
             *
             * Centering is achieved by setting the margin left and top properties of the
             * game canvas, and does not factor in any other CSS styles you may have applied.
             */
            const CENTER_VERTICALLY: any;
        }

        /**
         * Phaser Scale Manager constants for centering the game canvas.
         *
         * To find out what each mode does please see [Phaser.Scale.Center]{@link Phaser.Scale.Center}.
         */
        type Centerinterface = () => void;

        /**
         * Phaser Scale Manager constants for orientation.
         */
        namespace Orientation {
            /**
             * A landscape orientation.
             */
            const LANDSCAPE: any;

            /**
             * A portrait orientation.
             */
            const PORTRAIT: any;
        }

        /**
         * Phaser Scale Manager constants for orientation.
         *
         * To find out what each mode does please see [Phaser.Scale.Orientation]{@link Phaser.Scale.Orientation}.
         */
        type Orientationinterface = () => void;

        /**
         * Phaser Scale Manager constants for the different scale modes available.
         */
        namespace ScaleModes {
            /**
             * No scaling happens at all. The canvas is set to the size given in the game config and Phaser doesn't change it
             * again from that point on. If you change the canvas size, either via CSS, or directly via code, then you need
             * to call the Scale Managers `resize` method to give the new dimensions, or input events will stop working.
             */
            const NONE: any;

            /**
             * The height is automatically adjusted based on the width.
             */
            const WIDTH_CONTROLS_HEIGHT: any;

            /**
             * The width is automatically adjusted based on the height.
             */
            const HEIGHT_CONTROLS_WIDTH: any;

            /**
             * The width and height are automatically adjusted to fit inside the given target area,
             * while keeping the aspect ratio. Depending on the aspect ratio there may be some space
             * inside the area which is not covered.
             */
            const FIT: any;

            /**
             * The width and height are automatically adjusted to make the size cover the entire target
             * area while keeping the aspect ratio. This may extend further out than the target size.
             */
            const ENVELOP: any;

            /**
             * The Canvas is resized to fit all available _parent_ space, regardless of aspect ratio.
             */
            const RESIZE: any;
        }

        /**
         * Phaser Scale Manager constants for the different scale modes available.
         *
         * To find out what each mode does please see [Phaser.Scale.ScaleModes]{@link Phaser.Scale.ScaleModes}.
         */
        type ScaleModeinterface = () => void;

        /**
         * Phaser Scale Manager constants for zoom modes.
         */
        namespace Zoom {
            /**
             * The game canvas will not be zoomed by Phaser.
             */
            const NO_ZOOM: any;

            /**
             * The game canvas will be 2x zoomed by Phaser.
             */
            const ZOOM_2X: any;

            /**
             * The game canvas will be 4x zoomed by Phaser.
             */
            const ZOOM_4X: any;

            /**
             * Calculate the zoom value based on the maximum multiplied game size that will
             * fit into the parent, or browser window if no parent is set.
             */
            const MAX_ZOOM: any;
        }

        /**
         * Phaser Scale Manager constants for zoom modes.
         *
         * To find out what each mode does please see [Phaser.Scale.Zoom]{@link Phaser.Scale.Zoom}.
         */
        type Zoominterface = () => void;

        namespace Events {
            /**
             * The Scale Manager Resize Event.
             */
            const ENTER_FULLSCREEN: any;

            /**
             * The Scale Manager Resize Event.
             */
            const FULLSCREEN_UNSUPPORTED: any;

            /**
             * The Scale Manager Resize Event.
             */
            const LEAVE_FULLSCREEN: any;

            /**
             * The Scale Manager Resize Event.
             */
            const ORIENTATION_CHANGE: any;

            /**
             * The Scale Manager Resize Event.
             *
             * This event is dispatched whenever the Scale Manager detects a resize event from the browser.
             * It sends three parameters to the callback, each of them being Size components. You can read
             * the `width`, `height`, `aspectRatio` and other properties of these components to help with
             * scaling your own game content.
             */
            const RESIZE: any;
        }

        /**
         * The Scale Manager handles the scaling, resizing and alignment of the game canvas.
         *
         * The way scaling is handled is by setting the game canvas to a fixed size, which is defined in the
         * game configuration. You also define the parent container in the game config. If no parent is given,
         * it will default to using the document body. The Scale Manager will then look at the available space
         * within the _parent_ and scale the canvas accordingly. Scaling is handled by setting the canvas CSS
         * width and height properties, leaving the width and height of the canvas element itself untouched.
         * Scaling is therefore achieved by keeping the core canvas the same size and 'stretching'
         * it via its CSS properties. This gives the same result and speed as using the `transform-scale` CSS
         * property, without the need for browser prefix handling.
         *
         * The calculations for the scale are heavily influenced by the bounding parent size, which is the computed
         * dimensions of the canvas's parent. The CSS rules of the parent element play an important role in the
         * operation of the Scale Manager. For example, if the parent has no defined width or height, then actions
         * like auto-centering will fail to achieve the required result. The Scale Manager works in tandem with the
         * CSS you set-up on the page hosting your game, rather than taking control of it.
         *
         * #### Parent and Display canvas containment guidelines:
         *
         * - Style the Parent element (of the game canvas) to control the Parent size and thus the games size and layout.
         *
         * - The Parent element's CSS styles should _effectively_ apply maximum (and minimum) bounding behavior.
         *
         * - The Parent element should _not_ apply a padding as this is not accounted for.
         *   If a padding is required apply it to the Parent's parent or apply a margin to the Parent.
         *   If you need to add a border, margin or any other CSS around your game container, then use a parent element and
         *   apply the CSS to this instead, otherwise you'll be constantly resizing the shape of the game container.
         *
         * - The Display canvas layout CSS styles (i.e. margins, size) should not be altered / specified as
         *   they may be updated by the Scale Manager.
         *
         * #### Scale Modes
         *
         * The way the scaling is handled is determined by the `scaleMode` property. The default is `NO_SCALE`,
         * which prevents Phaser from scaling or touching the canvas, or its parent, at all. In this mode, you are
         * responsible for all scaling. The other scaling modes afford you automatic scaling.
         *
         * If you wish to scale your game so that it always fits into the available space within the parent, you
         * should use the scale mode `FIT`. Look at the documentation for other scale modes to see what options are
         * available. Here is a basic config showing how to set this scale mode:
         *
         * ```javascript
         * scale: {
         *     parent: 'yourgamediv',
         *     mode: Phaser.Scale.FIT,
         *     width: 800,
         *     height: 600
         * }
         * ```
         *
         * Place the `scale` config object within your game config.
         *
         * If you wish for the canvas to be resized directly, so that the canvas itself fills the available space
         * (i.e. it isn't scaled, it's resized) then use the `RESIZE` scale mode. This will give you a 1:1 mapping
         * of canvas pixels to game size. In this mode CSS isn't used to scale the canvas, it's literally adjusted
         * to fill all available space within the parent. You should be extremely careful about the size of the
         * canvas you're creating when doing this, as the larger the area, the more work the GPU has to do and it's
         * very easy to hit fill-rate limits quickly.
         *
         * For complex, custom-scaling requirements, you should probably consider using the `RESIZE` scale mode,
         * with your own limitations in place re: canvas dimensions and managing the scaling with the game scenes
         * yourself. For the vast majority of games, however, the `FIT` mode is likely to be the most used.
         *
         * Please appreciate that the Scale Manager cannot perform miracles. All it does is scale your game canvas
         * as best it can, based on what it can infer from its surrounding area. There are all kinds of environments
         * where it's up to you to guide and help the canvas position itself, especially when built into rendering
         * frameworks like React and Vue. If your page requires meta tags to prevent user scaling gestures, or such
         * like, then it's up to you to ensure they are present in the html.
         *
         * #### Centering
         *
         * You can also have the game canvas automatically centered. Again, this relies heavily on the parent being
         * properly configured and styled, as the centering offsets are based entirely on the available space
         * within the parent element. Centering is disabled by default, or can be applied horizontally, vertically,
         * or both. Here's an example:
         *
         * ```javascript
         * scale: {
         *     parent: 'yourgamediv',
         *     autoCenter: Phaser.Scale.CENTER_BOTH,
         *     width: 800,
         *     height: 600
         * }
         * ```
         *
         * #### Fullscreen API
         *
         * If the browser supports it, you can send your game into fullscreen mode. In this mode, the game will fill
         * the entire display, removing all browser UI and anything else present on the screen. It will remain in this
         * mode until your game either disables it, or until the user tabs out or presses ESCape if on desktop. It's a
         * great way to achieve a desktop-game like experience from the browser, but it does require a modern browser
         * to handle it. Some mobile browsers also support this.
         */
        class ScaleManager extends Phaser.Events.EventEmitter {
            /**
             *
             * @param game A reference to the Phaser.Game instance.
             */
            constructor(game: Game);

            /**
             * A reference to the Phaser.Game instance.
             */
            readonly game: Game;

            /**
             * A reference to the HTML Canvas Element that Phaser uses to render the game.
             */
            canvas: HTMLCanvasElement;

            /**
             * The DOM bounds of the canvas element.
             */
            canvasBounds: Geom.Rectangle;

            /**
             * The parent object of the Canvas. Often a div, or the browser window, or nothing in non-browser environments.
             *
             * This is set in the Game Config as the `parent` property. If undefined (or just not present), it will default
             * to use the document body. If specifically set to `null` Phaser will ignore all parent operations.
             */
            parent: any;

            /**
             * Is the parent element the browser window?
             */
            parentIsWindow: boolean;

            /**
             * The Parent Size component.
             */
            parentSize: Structs.Size;

            /**
             * The Game Size component.
             *
             * The un-modified game size, as requested in the game config (the raw width / height),
             * as used for world bounds, cameras, etc
             */
            gameSize: Structs.Size;

            /**
             * The Base Size component.
             *
             * The modified game size, which is the gameSize * resolution, used to set the canvas width and height
             * (but not the CSS style)
             */
            baseSize: Structs.Size;

            /**
             * The Display Size component.
             *
             * The size used for the canvas style, factoring in the scale mode, parent and other values.
             */
            displaySize: Structs.Size;

            /**
             * The game scale mode.
             */
            scaleMode: ScaleModeinterface;

            /**
             * The canvas resolution.
             *
             * This is hard-coded to a value of 1 in the 3.16 release of Phaser and will be enabled at a later date.
             */
            resolution: number;

            /**
             * The game zoom factor.
             *
             * This value allows you to multiply your games base size by the given zoom factor.
             * This is then used when calculating the display size, even in `NO_SCALE` situations.
             * If you don't want Phaser to touch the canvas style at all, this value should be 1.
             *
             * Can also be set to `MAX_ZOOM` in which case the zoom value will be derived based
             * on the game size and available space within the parent.
             */
            zoom: number;

            /**
             * The scale factor between the baseSize and the canvasBounds.
             */
            displayScale: Math.Vector2;

            /**
             * If set, the canvas sizes will be automatically passed through Math.floor.
             * This results in rounded pixel display values, which is important for performance on legacy
             * and low powered devices, but at the cost of not achieving a 'perfect' fit in some browser windows.
             */
            autoRound: boolean;

            /**
             * Automatically center the canvas within the parent? The different centering modes are:
             *
             * 1. No centering.
             * 2. Center both horizontally and vertically.
             * 3. Center horizontally.
             * 4. Center vertically.
             *
             * Please be aware that in order to center the game canvas, you must have specified a parent
             * that has a size set, or the canvas parent is the document.body.
             */
            autoCenter: Centerinterface;

            /**
             * The current device orientation.
             *
             * Orientation events are dispatched via the Device Orientation API, typically only on mobile browsers.
             */
            orientation: Orientationinterface;

            /**
             * A reference to the Device.Fullscreen object.
             */
            fullscreen: Device.Fullscreen;

            /**
             * The DOM Element which is sent into fullscreen mode.
             */
            fullscreenTarget: any;

            /**
             * The dirty state of the Scale Manager.
             * Set if there is a change between the parent size and the current size.
             */
            dirty: boolean;

            /**
             * How many milliseconds should elapse before checking if the browser size has changed?
             *
             * Most modern browsers dispatch a 'resize' event, which the Scale Manager will listen for.
             * However, older browsers fail to do this, or do it consistently, so we fall back to a
             * more traditional 'size check' based on a time interval. You can control how often it is
             * checked here.
             */
            resizeInterval: integer;

            /**
             * Called _before_ the canvas object is created and added to the DOM.
             */
            protected preBoot(): void;

            /**
             * The Boot handler is called by Phaser.Game when it first starts up.
             * The renderer is available by now and the canvas has been added to the DOM.
             */
            protected boot(): void;

            /**
             * Parses the game configuration to set-up the scale defaults.
             * @param config The Game configuration object.
             */
            protected parseConfig(config: GameConfig): void;

            /**
             * Determines the parent element of the game canvas, if any, based on the game configuration.
             * @param config The Game configuration object.
             */
            getParent(config: GameConfig): void;

            /**
             * Calculates the size of the parent bounds and updates the `parentSize` component, if the canvas has a dom parent.
             */
            getParentBounds(): boolean;

            /**
             * Attempts to lock the orientation of the web browser using the Screen Orientation API.
             *
             * This API is only available on modern mobile browsers.
             * See https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation for details.
             * @param orientation The orientation you'd like to lock the browser in. Should be an API string such as 'landscape', 'landscape-primary', 'portrait', etc.
             */
            lockOrientation(orientation: string): boolean;

            /**
             * This method will set the size of the Parent Size component, which is used in scaling
             * and centering calculations. You only need to call this method if you have explicitly
             * disabled the use of a parent in your game config, but still wish to take advantage of
             * other Scale Manager features.
             * @param width The new width of the parent.
             * @param height The new height of the parent.
             */
            setParentSize(width: number, height: number): this;

            /**
             * This method will set a new size for your game.
             * @param width The new width of the game.
             * @param height The new height of the game.
             */
            setGameSize(width: number, height: number): this;

            /**
             * Call this to modify the size of the Phaser canvas element directly.
             * You should only use this if you are using the `NO_SCALE` scale mode,
             * it will update all internal components completely.
             *
             * If all you want to do is change the size of the parent, see the `setParentSize` method.
             *
             * If all you want is to change the base size of the game, but still have the Scale Manager
             * manage all the scaling, then see the `setGameSize` method.
             *
             * This method will set the `gameSize`, `baseSize` and `displaySize` components to the given
             * dimensions. It will then resize the canvas width and height to the values given, by
             * directly setting the properties. Finally, if you have set the Scale Manager zoom value
             * to anything other than 1 (the default), it will set the canvas CSS width and height to
             * be the given size multiplied by the zoom factor (the canvas pixel size remains untouched).
             *
             * If you have enabled `autoCenter`, it is then passed to the `updateCenter` method and
             * the margins are set, allowing the canvas to be centered based on its parent element
             * alone. Finally, the `displayScale` is adjusted and the RESIZE event dispatched.
             * @param width The new width of the game.
             * @param height The new height of the game.
             */
            resize(width: number, height: number): this;

            /**
             * Sets the zoom value of the Scale Manager.
             * @param value The new zoom value of the game.
             */
            setZoom(value: integer): this;

            /**
             * Sets the zoom to be the maximum possible based on the _current_ parent size.
             */
            setMaxZoom(): this;

            /**
             * Refreshes the internal scale values, bounds sizes and orientation checks.
             *
             * Once finished, dispatches the resize event.
             *
             * This is called automatically by the Scale Manager when the browser window size changes,
             * as long as it is using a Scale Mode other than 'NONE'.
             */
            refresh(): this;

            /**
             * Internal method that checks the current screen orientation, only if the internal check flag is set.
             *
             * If the orientation has changed it updates the orientation property and then dispatches the orientation change event.
             */
            updateOrientation(): void;

            /**
             * Internal method that manages updating the size components based on the scale mode.
             */
            updateScale(): void;

            /**
             * Calculates and returns the largest possible zoom factor, based on the current
             * parent and game sizes. If the parent has no dimensions (i.e. an unstyled div),
             * or is smaller than the un-zoomed game, then this will return a value of 1 (no zoom)
             */
            getMaxZoom(): integer;

            /**
             * Calculates and updates the canvas CSS style in order to center it within the
             * bounds of its parent. If you have explicitly set parent to be `null` in your
             * game config then this method will likely give incorrect results unless you have called the
             * `setParentSize` method first.
             *
             * It works by modifying the canvas CSS `marginLeft` and `marginTop` properties.
             *
             * If they have already been set by your own style sheet, or code, this will overwrite them.
             *
             * To prevent the Scale Manager from centering the canvas, either do not set the
             * `autoCenter` property in your game config, or make sure it is set to `NO_CENTER`.
             */
            updateCenter(): void;

            /**
             * Updates the `canvasBounds` rectangle to match the bounding client rectangle of the
             * canvas element being used to track input events.
             */
            updateBounds(): void;

            /**
             * Transforms the pageX value into the scaled coordinate space of the Scale Manager.
             * @param pageX The DOM pageX value.
             */
            transformX(pageX: number): number;

            /**
             * Transforms the pageY value into the scaled coordinate space of the Scale Manager.
             * @param pageY The DOM pageY value.
             */
            transformY(pageY: number): number;

            /**
             * Sends a request to the browser to ask it to go in to full screen mode, using the {@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API Fullscreen API}.
             *
             * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.
             *
             * This method _must_ be called from a user-input gesture, such as `pointerdown`. You cannot launch
             * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked
             * from fullscreen unless the iframe has the `allowfullscreen` attribute.
             *
             * Performing an action that navigates to another page, or opens another tab, will automatically cancel
             * fullscreen mode, as will the user pressing the ESC key. To cancel fullscreen mode from your game, i.e.
             * from clicking an icon, call the `stopFullscreen` method.
             *
             * A browser can only send one DOM element into fullscreen. You can control which element this is by
             * setting the `fullscreenTarget` property in your game config, or changing the property in the Scale Manager.
             * Note that the game canvas _must_ be a child of the target. If you do not give a target, Phaser will
             * automatically create a blank `<div>` element and move the canvas into it, before going fullscreen.
             * When it leaves fullscreen, the div will be removed.
             * @param fullscreenOptions The FullscreenOptions dictionary is used to provide configuration options when entering full screen.
             */
            startFullscreen(fullscreenOptions?: object): void;

            /**
             * An internal method that gets the target element that is used when entering fullscreen mode.
             */
            getFullscreenTarget(): object;

            /**
             * Calling this method will cancel fullscreen mode, if the browser has entered it.
             */
            stopFullscreen(): void;

            /**
             * Toggles the fullscreen mode. If already in fullscreen, calling this will cancel it.
             * If not in fullscreen, this will request the browser to enter fullscreen mode.
             *
             * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.
             *
             * This method _must_ be called from a user-input gesture, such as `pointerdown`. You cannot launch
             * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked
             * from fullscreen unless the iframe has the `allowfullscreen` attribute.
             * @param fullscreenOptions The FullscreenOptions dictionary is used to provide configuration options when entering full screen.
             */
            toggleFullscreen(fullscreenOptions?: object): void;

            /**
             * An internal method that starts the different DOM event listeners running.
             */
            startListeners(): void;

            /**
             * Triggered when a fullscreenchange event is dispatched by the DOM.
             */
            onFullScreenChange(): void;

            /**
             * Triggered when a fullscreenerror event is dispatched by the DOM.
             */
            onFullScreenError(): void;

            /**
             * Internal method, called automatically by the game step.
             * Monitors the elapsed time and resize interval to see if a parent bounds check needs to take place.
             * @param time The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().
             * @param delta The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.
             */
            step(time: number, delta: number): void;

            /**
             * Stops all DOM event listeners.
             */
            stopListeners(): void;

            /**
             * Destroys this Scale Manager, releasing all references to external resources.
             * Once destroyed, the Scale Manager cannot be used again.
             */
            destroy(): void;

            /**
             * Is the browser currently in fullscreen mode or not?
             */
            readonly isFullscreen: boolean;

            /**
             * The game width.
             *
             * This is typically the size given in the game configuration.
             */
            readonly width: number;

            /**
             * The game height.
             *
             * This is typically the size given in the game configuration.
             */
            readonly height: number;

            /**
             * Is the device in a portrait orientation as reported by the Orientation API?
             * This value is usually only available on mobile devices.
             */
            readonly isPortrait: boolean;

            /**
             * Is the device in a landscape orientation as reported by the Orientation API?
             * This value is usually only available on mobile devices.
             */
            readonly isLandscape: boolean;

            /**
             * Are the game dimensions portrait? (i.e. taller than they are wide)
             *
             * This is different to the device itself being in a portrait orientation.
             */
            readonly isGamePortrait: boolean;

            /**
             * Are the game dimensions landscape? (i.e. wider than they are tall)
             *
             * This is different to the device itself being in a landscape orientation.
             */
            readonly isGameLandscape: boolean;
        }

        /**
         * The game canvas is not centered within the parent by Phaser.
         * You can still center it yourself via CSS.
         */
        const NO_CENTER: any;

        /**
         * The game canvas is centered both horizontally and vertically within the parent.
         * To do this, the parent has to have a bounds that can be calculated and not be empty.
         *
         * Centering is achieved by setting the margin left and top properties of the
         * game canvas, and does not factor in any other CSS styles you may have applied.
         */
        const CENTER_BOTH: any;

        /**
         * The game canvas is centered horizontally within the parent.
         * To do this, the parent has to have a bounds that can be calculated and not be empty.
         *
         * Centering is achieved by setting the margin left and top properties of the
         * game canvas, and does not factor in any other CSS styles you may have applied.
         */
        const CENTER_HORIZONTALLY: any;

        /**
         * The game canvas is centered both vertically within the parent.
         * To do this, the parent has to have a bounds that can be calculated and not be empty.
         *
         * Centering is achieved by setting the margin left and top properties of the
         * game canvas, and does not factor in any other CSS styles you may have applied.
         */
        const CENTER_VERTICALLY: any;

        /**
         * A landscape orientation.
         */
        const LANDSCAPE: any;

        /**
         * A portrait orientation.
         */
        const PORTRAIT: any;

        /**
         * No scaling happens at all. The canvas is set to the size given in the game config and Phaser doesn't change it
         * again from that point on. If you change the canvas size, either via CSS, or directly via code, then you need
         * to call the Scale Managers `resize` method to give the new dimensions, or input events will stop working.
         */
        const NONE: any;

        /**
         * The height is automatically adjusted based on the width.
         */
        const WIDTH_CONTROLS_HEIGHT: any;

        /**
         * The width is automatically adjusted based on the height.
         */
        const HEIGHT_CONTROLS_WIDTH: any;

        /**
         * The width and height are automatically adjusted to fit inside the given target area,
         * while keeping the aspect ratio. Depending on the aspect ratio there may be some space
         * inside the area which is not covered.
         */
        const FIT: any;

        /**
         * The width and height are automatically adjusted to make the size cover the entire target
         * area while keeping the aspect ratio. This may extend further out than the target size.
         */
        const ENVELOP: any;

        /**
         * The Canvas is resized to fit all available _parent_ space, regardless of aspect ratio.
         */
        const RESIZE: any;

        /**
         * The game canvas will not be zoomed by Phaser.
         */
        const NO_ZOOM: any;

        /**
         * The game canvas will be 2x zoomed by Phaser.
         */
        const ZOOM_2X: any;

        /**
         * The game canvas will be 4x zoomed by Phaser.
         */
        const ZOOM_4X: any;

        /**
         * Calculate the zoom value based on the maximum multiplied game size that will
         * fit into the parent, or browser window if no parent is set.
         */
        const MAX_ZOOM: any;
    }

    namespace Scenes {
        /**
         * Scene state.
         */
        const PENDING: integer;

        /**
         * Scene state.
         */
        const INIT: integer;

        /**
         * Scene state.
         */
        const START: integer;

        /**
         * Scene state.
         */
        const LOADING: integer;

        /**
         * Scene state.
         */
        const CREATING: integer;

        /**
         * Scene state.
         */
        const RUNNING: integer;

        /**
         * Scene state.
         */
        const PAUSED: integer;

        /**
         * Scene state.
         */
        const SLEEPING: integer;

        /**
         * Scene state.
         */
        const SHUTDOWN: integer;

        /**
         * Scene state.
         */
        const DESTROYED: integer;

        namespace Events {
            /**
             * The Scene Systems Boot Event.
             *
             * This event is dispatched by a Scene during the Scene Systems boot process. Primarily used by Scene Plugins.
             *
             * Listen to it from a Scene using `this.scene.events.on('boot', listener)`.
             */
            const BOOT: any;

            /**
             * The Scene Systems Destroy Event.
             *
             * This event is dispatched by a Scene during the Scene Systems destroy process.
             *
             * Listen to it from a Scene using `this.scene.events.on('destroy', listener)`.
             *
             * You should destroy any resources that may be in use by your Scene in this event handler.
             */
            const DESTROY: any;

            /**
             * The Scene Systems Pause Event.
             *
             * This event is dispatched by a Scene when it is paused, either directly via the `pause` method, or as an
             * action from another Scene.
             *
             * Listen to it from a Scene using `this.scene.events.on('pause', listener)`.
             */
            const PAUSE: any;

            /**
             * The Scene Systems Post Update Event.
             *
             * This event is dispatched by a Scene during the main game loop step.
             *
             * The event flow for a single step of a Scene is as follows:
             *
             * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}
             * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}
             * 3. The `Scene.update` method is called, if it exists
             * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}
             * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}
             *
             * Listen to it from a Scene using `this.scene.events.on('postupdate', listener)`.
             *
             * A Scene will only run its step if it is active.
             */
            const POST_UPDATE: any;

            /**
             * The Scene Systems Pre Update Event.
             *
             * This event is dispatched by a Scene during the main game loop step.
             *
             * The event flow for a single step of a Scene is as follows:
             *
             * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}
             * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}
             * 3. The `Scene.update` method is called, if it exists
             * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}
             * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}
             *
             * Listen to it from a Scene using `this.scene.events.on('preupdate', listener)`.
             *
             * A Scene will only run its step if it is active.
             */
            const PRE_UPDATE: any;

            /**
             * The Scene Systems Ready Event.
             *
             * This event is dispatched by a Scene during the Scene Systems start process.
             * By this point in the process the Scene is now fully active and rendering.
             * This event is meant for your game code to use, as all plugins have responded to the earlier 'start' event.
             *
             * Listen to it from a Scene using `this.scene.events.on('ready', listener)`.
             */
            const READY: any;

            /**
             * The Scene Systems Render Event.
             *
             * This event is dispatched by a Scene during the main game loop step.
             *
             * The event flow for a single step of a Scene is as follows:
             *
             * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}
             * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}
             * 3. The `Scene.update` method is called, if it exists
             * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}
             * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}
             *
             * Listen to it from a Scene using `this.scene.events.on('render', listener)`.
             *
             * A Scene will only render if it is visible and active.
             * By the time this event is dispatched, the Scene will have already been rendered.
             */
            const RENDER: any;

            /**
             * The Scene Systems Resume Event.
             *
             * This event is dispatched by a Scene when it is resumed from a paused state, either directly via the `resume` method,
             * or as an action from another Scene.
             *
             * Listen to it from a Scene using `this.scene.events.on('resume', listener)`.
             */
            const RESUME: any;

            /**
             * The Scene Systems Shutdown Event.
             *
             * This event is dispatched by a Scene during the Scene Systems shutdown process.
             *
             * Listen to it from a Scene using `this.scene.events.on('shutdown', listener)`.
             *
             * You should free-up any resources that may be in use by your Scene in this event handler, on the understanding
             * that the Scene may, at any time, become active again. A shutdown Scene is not 'destroyed', it's simply not
             * currently active. Use the [DESTROY]{@linkcode Phaser.Scenes.Events#event:DESTROY} event to completely clear resources.
             */
            const SHUTDOWN: any;

            /**
             * The Scene Systems Sleep Event.
             *
             * This event is dispatched by a Scene when it is sent to sleep, either directly via the `sleep` method,
             * or as an action from another Scene.
             *
             * Listen to it from a Scene using `this.scene.events.on('sleep', listener)`.
             */
            const SLEEP: any;

            /**
             * The Scene Systems Start Event.
             *
             * This event is dispatched by a Scene during the Scene Systems start process. Primarily used by Scene Plugins.
             *
             * Listen to it from a Scene using `this.scene.events.on('start', listener)`.
             */
            const START: any;

            /**
             * The Scene Transition Complete Event.
             *
             * This event is dispatched by the Target Scene of a transition.
             *
             * It happens when the transition process has completed. This occurs when the duration timer equals or exceeds the duration
             * of the transition.
             *
             * Listen to it from a Scene using `this.scene.events.on('transitioncomplete', listener)`.
             *
             * The Scene Transition event flow is as follows:
             *
             * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.
             * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.
             * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...
             * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.
             * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.
             */
            const TRANSITION_COMPLETE: any;

            /**
             * The Scene Transition Init Event.
             *
             * This event is dispatched by the Target Scene of a transition.
             *
             * It happens immediately after the `Scene.init` method is called. If the Scene does not have an `init` method,
             * this event is not dispatched.
             *
             * Listen to it from a Scene using `this.scene.events.on('transitioninit', listener)`.
             *
             * The Scene Transition event flow is as follows:
             *
             * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.
             * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.
             * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...
             * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.
             * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.
             */
            const TRANSITION_INIT: any;

            /**
             * The Scene Transition Out Event.
             *
             * This event is dispatched by a Scene when it initiates a transition to another Scene.
             *
             * Listen to it from a Scene using `this.scene.events.on('transitionout', listener)`.
             *
             * The Scene Transition event flow is as follows:
             *
             * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.
             * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.
             * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...
             * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.
             * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.
             */
            const TRANSITION_OUT: any;

            /**
             * The Scene Transition Start Event.
             *
             * This event is dispatched by the Target Scene of a transition, only if that Scene was not asleep.
             *
             * It happens immediately after the `Scene.create` method is called. If the Scene does not have a `create` method,
             * this event is dispatched anyway.
             *
             * If the Target Scene was sleeping then the [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} event is
             * dispatched instead of this event.
             *
             * Listen to it from a Scene using `this.scene.events.on('transitionstart', listener)`.
             *
             * The Scene Transition event flow is as follows:
             *
             * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.
             * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.
             * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...
             * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.
             * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.
             */
            const TRANSITION_START: any;

            /**
             * The Scene Transition Wake Event.
             *
             * This event is dispatched by the Target Scene of a transition, only if that Scene was asleep before
             * the transition began. If the Scene was not asleep the [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} event is dispatched instead.
             *
             * Listen to it from a Scene using `this.scene.events.on('transitionwake', listener)`.
             *
             * The Scene Transition event flow is as follows:
             *
             * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.
             * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.
             * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...
             * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.
             * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.
             */
            const TRANSITION_WAKE: any;

            /**
             * The Scene Systems Update Event.
             *
             * This event is dispatched by a Scene during the main game loop step.
             *
             * The event flow for a single step of a Scene is as follows:
             *
             * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}
             * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}
             * 3. The `Scene.update` method is called, if it exists
             * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}
             * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}
             *
             * Listen to it from a Scene using `this.scene.events.on('update', listener)`.
             *
             * A Scene will only run its step if it is active.
             */
            const UPDATE: any;

            /**
             * The Scene Systems Wake Event.
             *
             * This event is dispatched by a Scene when it is woken from sleep, either directly via the `wake` method,
             * or as an action from another Scene.
             *
             * Listen to it from a Scene using `this.scene.events.on('wake', listener)`.
             */
            const WAKE: any;
        }

        /**
         * Builds an array of which physics plugins should be activated for the given Scene.
         * @param sys The scene system to get the physics systems of.
         */
        function GetPhysicsPlugins(sys: Systems): any[];

        /**
         * Builds an array of which plugins (not including physics plugins) should be activated for the given Scene.
         * @param sys The Scene Systems object to check for plugins.
         */
        function GetScenePlugins(sys: Systems): any[];

        /**
         * The Scene Manager.
         *
         * The Scene Manager is a Game level system, responsible for creating, processing and updating all of the
         * Scenes in a Game instance.
         */
        class SceneManager {
            /**
             *
             * @param game The Phaser.Game instance this Scene Manager belongs to.
             * @param sceneConfig Scene specific configuration settings.
             */
            constructor(game: Game, sceneConfig: object);

            /**
             * The Game that this SceneManager belongs to.
             */
            game: Game;

            /**
             * An object that maps the keys to the scene so we can quickly get a scene from a key without iteration.
             */
            keys: object;

            /**
             * The array in which all of the scenes are kept.
             */
            scenes: any[];

            /**
             * Is the Scene Manager actively processing the Scenes list?
             */
            readonly isProcessing: boolean;

            /**
             * Has the Scene Manager properly started?
             */
            readonly isBooted: boolean;

            /**
             * Do any of the Cameras in any of the Scenes require a custom viewport?
             * If not we can skip scissor tests.
             */
            customViewports: number;

            /**
             * Process the Scene operations queue.
             */
            processQueue(): void;

            /**
             * Adds a new Scene into the SceneManager.
             * You must give each Scene a unique key by which you'll identify it.
             *
             * The `sceneConfig` can be:
             *
             * * A `Phaser.Scene` object, or an object that extends it.
             * * A plain JavaScript object
             * * A JavaScript ES6 Class that extends `Phaser.Scene`
             * * A JavaScript ES5 protointerface based Class
             * * A JavaScript function
             *
             * If a function is given then a new Scene will be created by calling it.
             * @param key A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.
             * @param sceneConfig The config for the Scene
             * @param autoStart If `true` the Scene will be started immediately after being added. Default false.
             * @param data Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.
             */
            add(key: string, sceneConfig: Scene | Settings.Config | CallbackFn, autoStart?: boolean, data?: object): Scene;

            /**
             * Removes a Scene from the SceneManager.
             *
             * The Scene is removed from the local scenes array, it's key is cleared from the keys
             * cache and Scene.Systems.destroy is then called on it.
             *
             * If the SceneManager is processing the Scenes when this method is called it will
             * queue the operation for the next update sequence.
             * @param scene The Scene to be removed.
             */
            remove(scene: string | Scene): SceneManager;

            /**
             * Updates the Scenes.
             * @param time Time elapsed.
             * @param delta Delta time from the last update.
             */
            update(time: number, delta: number): void;

            /**
             * Renders the Scenes.
             * @param renderer The renderer to use.
             */
            render(renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer): void;

            /**
             * Returns an array of all the current Scenes being managed by this Scene Manager.
             *
             * You can filter the output by the active state of the Scene and choose to have
             * the array returned in normal or reversed order.
             * @param isActive Only include Scene's that are currently active? Default true.
             * @param inReverse Return the array of Scenes in reverse? Default false.
             */
            getScenes(isActive?: boolean, inReverse?: boolean): Scene[];

            /**
             * Retrieves a Scene.
             * @param key The Scene to retrieve.
             */
            getScene(key: string | Scene): Scene;

            /**
             * Determines whether a Scene is active.
             * @param key The Scene to check.
             */
            isActive(key: string): boolean;

            /**
             * Determines whether a Scene is visible.
             * @param key The Scene to check.
             */
            isVisible(key: string): boolean;

            /**
             * Determines whether a Scene is sleeping.
             * @param key The Scene to check.
             */
            isSleeping(key: string): boolean;

            /**
             * Pauses the given Scene.
             * @param key The Scene to pause.
             * @param data An optional data object that will be passed to the Scene and emitted by its pause event.
             */
            pause(key: string, data?: object): SceneManager;

            /**
             * Resumes the given Scene.
             * @param key The Scene to resume.
             * @param data An optional data object that will be passed to the Scene and emitted by its resume event.
             */
            resume(key: string, data?: object): SceneManager;

            /**
             * Puts the given Scene to sleep.
             * @param key The Scene to put to sleep.
             * @param data An optional data object that will be passed to the Scene and emitted by its sleep event.
             */
            sleep(key: string, data?: object): SceneManager;

            /**
             * Awakens the given Scene.
             * @param key The Scene to wake up.
             * @param data An optional data object that will be passed to the Scene and emitted by its wake event.
             */
            wake(key: string, data?: object): SceneManager;

            /**
             * Runs the given Scene, but does not change the state of this Scene.
             *
             * If the given Scene is paused, it will resume it. If sleeping, it will wake it.
             * If not running at all, it will be started.
             *
             * Use this if you wish to open a modal Scene by calling `pause` on the current
             * Scene, then `run` on the modal Scene.
             * @param key The Scene to run.
             * @param data A data object that will be passed to the Scene on start, wake, or resume.
             */
            run(key: string, data?: object): SceneManager;

            /**
             * Starts the given Scene.
             * @param key The Scene to start.
             * @param data Optional data object to pass to Scene.Settings and Scene.init.
             */
            start(key: string, data?: object): SceneManager;

            /**
             * Stops the given Scene.
             * @param key The Scene to stop.
             */
            stop(key: string): SceneManager;

            /**
             * Sleeps one one Scene and starts the other.
             * @param from The Scene to sleep.
             * @param to The Scene to start.
             */
            switch(from: string, to: string): SceneManager;

            /**
             * Retrieves a Scene by numeric index.
             * @param index The index of the Scene to retrieve.
             */
            getAt(index: integer): Scene | undefined;

            /**
             * Retrieves the numeric index of a Scene.
             * @param key The key of the Scene.
             */
            getIndex(key: string | Scene): integer;

            /**
             * Brings a Scene to the top of the Scenes list.
             *
             * This means it will render above all other Scenes.
             * @param key The Scene to move.
             */
            bringToTop(key: string | Scene): SceneManager;

            /**
             * Sends a Scene to the back of the Scenes list.
             *
             * This means it will render below all other Scenes.
             * @param key The Scene to move.
             */
            sendToBack(key: string | Scene): SceneManager;

            /**
             * Moves a Scene down one position in the Scenes list.
             * @param key The Scene to move.
             */
            moveDown(key: string | Scene): SceneManager;

            /**
             * Moves a Scene up one position in the Scenes list.
             * @param key The Scene to move.
             */
            moveUp(key: string | Scene): SceneManager;

            /**
             * Moves a Scene so it is immediately above another Scene in the Scenes list.
             *
             * This means it will render over the top of the other Scene.
             * @param keyA The Scene that Scene B will be moved above.
             * @param keyB The Scene to be moved.
             */
            moveAbove(keyA: string | Scene, keyB: string | Scene): SceneManager;

            /**
             * Moves a Scene so it is immediately below another Scene in the Scenes list.
             *
             * This means it will render behind the other Scene.
             * @param keyA The Scene that Scene B will be moved above.
             * @param keyB The Scene to be moved.
             */
            moveBelow(keyA: string | Scene, keyB: string | Scene): SceneManager;

            /**
             * Swaps the positions of two Scenes in the Scenes list.
             * @param keyA The first Scene to swap.
             * @param keyB The second Scene to swap.
             */
            swapPosition(keyA: string | Scene, keyB: string | Scene): SceneManager;

            /**
             * Dumps debug information about each Scene to the developer console.
             */
            dump(): void;

            /**
             * Destroy the SceneManager and all of its Scene's systems.
             */
            destroy(): void;
        }

        /**
         * A proxy class to the Global Scene Manager.
         */
        class ScenePlugin {
            /**
             *
             * @param scene The Scene that this ScenePlugin belongs to.
             */
            constructor(scene: Scene);

            /**
             * The Scene that this ScenePlugin belongs to.
             */
            scene: Scene;

            /**
             * The Scene Systems instance of the Scene that this ScenePlugin belongs to.
             */
            systems: Systems;

            /**
             * The settings of the Scene this ScenePlugin belongs to.
             */
            settings: Settings.Object;

            /**
             * The key of the Scene this ScenePlugin belongs to.
             */
            key: string;

            /**
             * The Game's SceneManager.
             */
            manager: SceneManager;

            /**
             * If this Scene is currently transitioning to another, this holds
             * the current percentage of the transition progress, between 0 and 1.
             */
            transitionProgress: number;

            /**
             * Shutdown this Scene and run the given one.
             * @param key The Scene to start.
             * @param data The Scene data.
             */
            start(key?: string, data?: object): ScenePlugin;

            /**
             * Restarts this Scene.
             * @param data The Scene data.
             */
            restart(data?: object): ScenePlugin;

            /**
             * This will start a transition from the current Scene to the target Scene given.
             *
             * The transition will last for the duration specified in milliseconds.
             *
             * You can have the target Scene moved above or below this one in the display list.
             *
             * You can specify an update callback. This callback will be invoked _every frame_ for the duration
             * of the transition.
             *
             * This Scene can either be sent to sleep at the end of the transition, or stopped. The default is to stop.
             *
             * There are also 5 transition related events: This scene will emit the event `transitionout` when
             * the transition begins, which is typically the frame after calling this method.
             *
             * The target Scene will emit the event `transitioninit` when that Scene's `init` method is called.
             * It will then emit the event `transitionstart` when its `create` method is called.
             * If the Scene was sleeping and has been woken up, it will emit the event `transitionwake` instead of these two,
             * as the Scenes `init` and `create` methods are not invoked when a Scene wakes up.
             *
             * When the duration of the transition has elapsed it will emit the event `transitioncomplete`.
             * These events are cleared of all listeners when the Scene shuts down, but not if it is sent to sleep.
             *
             * It's important to understand that the duration of the transition begins the moment you call this method.
             * If the Scene you are transitioning to includes delayed processes, such as waiting for files to load, the
             * time still counts down even while that is happening. If the game itself pauses, or something else causes
             * this Scenes update loop to stop, then the transition will also pause for that duration. There are
             * checks in place to prevent you accidentally stopping a transitioning Scene but if you've got code to
             * override this understand that until the target Scene completes it might never be unlocked for input events.
             * @param config The transition configuration object.
             */
            transition(config: SceneTransitionConfig): boolean;

            /**
             * Add the Scene into the Scene Manager and start it if 'autoStart' is true or the Scene config 'active' property is set.
             * @param key The Scene key.
             * @param sceneConfig The config for the Scene.
             * @param autoStart Whether to start the Scene after it's added.
             * @param data Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.
             */
            add(key: string, sceneConfig: Scene | Settings.Config | CallbackFn, autoStart: boolean, data?: object): ScenePlugin;

            /**
             * Launch the given Scene and run it in parallel with this one.
             * @param key The Scene to launch.
             * @param data The Scene data.
             */
            launch(key: string, data?: object): ScenePlugin;

            /**
             * Runs the given Scene, but does not change the state of this Scene.
             *
             * If the given Scene is paused, it will resume it. If sleeping, it will wake it.
             * If not running at all, it will be started.
             *
             * Use this if you wish to open a modal Scene by calling `pause` on the current
             * Scene, then `run` on the modal Scene.
             * @param key The Scene to run.
             * @param data A data object that will be passed to the Scene and emitted in its ready, wake, or resume events.
             */
            run(key: string, data?: object): ScenePlugin;

            /**
             * Pause the Scene - this stops the update step from happening but it still renders.
             * @param key The Scene to pause.
             * @param data An optional data object that will be passed to the Scene and emitted in its pause event.
             */
            pause(key?: string, data?: object): ScenePlugin;

            /**
             * Resume the Scene - starts the update loop again.
             * @param key The Scene to resume.
             * @param data An optional data object that will be passed to the Scene and emitted in its resume event.
             */
            resume(key?: string, data?: object): ScenePlugin;

            /**
             * Makes the Scene sleep (no update, no render) but doesn't shutdown.
             * @param key The Scene to put to sleep.
             * @param data An optional data object that will be passed to the Scene and emitted in its sleep event.
             */
            sleep(key?: string, data?: object): ScenePlugin;

            /**
             * Makes the Scene wake-up (starts update and render)
             * @param key The Scene to wake up.
             * @param data An optional data object that will be passed to the Scene and emitted in its wake event.
             */
            wake(key?: string, data?: object): ScenePlugin;

            /**
             * Makes this Scene sleep then starts the Scene given.
             * @param key The Scene to start.
             */
            switch(key: string): ScenePlugin;

            /**
             * Shutdown the Scene, clearing display list, timers, etc.
             * @param key The Scene to stop.
             */
            stop(key?: string): ScenePlugin;

            /**
             * Sets the active state of the given Scene.
             * @param value If `true` the Scene will be resumed. If `false` it will be paused.
             * @param key The Scene to set the active state of.
             * @param data An optional data object that will be passed to the Scene and emitted with its events.
             */
            setActive(value: boolean, key?: string, data?: object): ScenePlugin;

            /**
             * Sets the visible state of the given Scene.
             * @param value The visible value.
             * @param key The Scene to set the visible state for.
             */
            setVisible(value: boolean, key?: string): ScenePlugin;

            /**
             * Checks if the given Scene is sleeping or not?
             * @param key The Scene to check.
             */
            isSleeping(key?: string): boolean;

            /**
             * Checks if the given Scene is active or not?
             * @param key The Scene to check.
             */
            isActive(key?: string): boolean;

            /**
             * Checks if the given Scene is visible or not?
             * @param key The Scene to check.
             */
            isVisible(key?: string): boolean;

            /**
             * Swaps the position of two scenes in the Scenes list.
             *
             * This controls the order in which they are rendered and updated.
             * @param keyA The first Scene to swap.
             * @param keyB The second Scene to swap. If none is given it defaults to this Scene.
             */
            swapPosition(keyA: string, keyB?: string): ScenePlugin;

            /**
             * Swaps the position of two scenes in the Scenes list, so that Scene B is directly above Scene A.
             *
             * This controls the order in which they are rendered and updated.
             * @param keyA The Scene that Scene B will be moved to be above.
             * @param keyB The Scene to be moved. If none is given it defaults to this Scene.
             */
            moveAbove(keyA: string, keyB?: string): ScenePlugin;

            /**
             * Swaps the position of two scenes in the Scenes list, so that Scene B is directly below Scene A.
             *
             * This controls the order in which they are rendered and updated.
             * @param keyA The Scene that Scene B will be moved to be below.
             * @param keyB The Scene to be moved. If none is given it defaults to this Scene.
             */
            moveBelow(keyA: string, keyB?: string): ScenePlugin;

            /**
             * Removes a Scene from the SceneManager.
             *
             * The Scene is removed from the local scenes array, it's key is cleared from the keys
             * cache and Scene.Systems.destroy is then called on it.
             *
             * If the SceneManager is processing the Scenes when this method is called it wil
             * queue the operation for the next update sequence.
             * @param key The Scene to be removed.
             */
            remove(key?: string | Scene): SceneManager;

            /**
             * Moves a Scene up one position in the Scenes list.
             * @param key The Scene to move.
             */
            moveUp(key?: string): ScenePlugin;

            /**
             * Moves a Scene down one position in the Scenes list.
             * @param key The Scene to move.
             */
            moveDown(key?: string): ScenePlugin;

            /**
             * Brings a Scene to the top of the Scenes list.
             *
             * This means it will render above all other Scenes.
             * @param key The Scene to move.
             */
            bringToTop(key?: string): ScenePlugin;

            /**
             * Sends a Scene to the back of the Scenes list.
             *
             * This means it will render below all other Scenes.
             * @param key The Scene to move.
             */
            sendToBack(key?: string): ScenePlugin;

            /**
             * Retrieve a Scene.
             * @param key The Scene to retrieve.
             */
            get(key: string): Scene;

            /**
             * Retrieves the numeric index of a Scene in the Scenes list.
             * @param key The Scene to get the index of.
             */
            getIndex(key?: string | Scene): integer;
        }

        namespace Settings {
            interface Config {
                /**
                 * The unique key of this Scene. Must be unique within the entire Game instance.
                 */
                key?: string;
                /**
                 * Does the Scene start as active or not? An active Scene updates each step.
                 */
                active?: boolean;
                /**
                 * Does the Scene start as visible or not? A visible Scene renders each step.
                 */
                visible?: boolean;
                /**
                 * An optional Loader Packfile to be loaded before the Scene begins.
                 */
                pack?: false | Loader.FileTypes.PackFileConfig;
                /**
                 * An optional Camera configuration object.
                 */
                cameras?: InputJSONCameraObject | InputJSONCameraObject[];
                /**
                 * Overwrites the default injection map for a scene.
                 */
                map?: {[key: string]: string};
                /**
                 * Extends the injection map for a scene.
                 */
                mapAdd?: {[key: string]: string};
                /**
                 * The physics configuration object for the Scene.
                 */
                physics?: object;
                /**
                 * The loader configuration object for the Scene.
                 */
                loader?: object;
                /**
                 * The plugin configuration object for the Scene.
                 */
                plugins?: false | object;
            }

            interface Object {
                /**
                 * The current status of the Scene. Maps to the Scene constants.
                 */
                status: number;
                /**
                 * The unique key of this Scene. Unique within the entire Game instance.
                 */
                key: string;
                /**
                 * The active state of this Scene. An active Scene updates each step.
                 */
                active: boolean;
                /**
                 * The visible state of this Scene. A visible Scene renders each step.
                 */
                visible: boolean;
                /**
                 * Has the Scene finished booting?
                 */
                isBooted: boolean;
                /**
                 * Is the Scene in a state of transition?
                 */
                isTransition: boolean;
                /**
                 * The Scene this Scene is transitioning from, if set.
                 */
                transitionFrom: Scene;
                /**
                 * The duration of the transition, if set.
                 */
                transitionDuration: integer;
                /**
                 * Is this Scene allowed to receive input during transitions?
                 */
                transitionAllowInput: boolean;
                /**
                 * a data bundle passed to this Scene from the Scene Manager.
                 */
                data: object;
                /**
                 * The Loader Packfile to be loaded before the Scene begins.
                 */
                pack: false | Loader.FileTypes.PackFileConfig;
                /**
                 * The Camera configuration object.
                 */
                cameras: InputJSONCameraObject | InputJSONCameraObject[];
                /**
                 * The Scene's Injection Map.
                 */
                map: {[key: string]: string};
                /**
                 * The physics configuration object for the Scene.
                 */
                physics: object;
                /**
                 * The loader configuration object for the Scene.
                 */
                loader: object;
                /**
                 * The plugin configuration object for the Scene.
                 */
                plugins: false | object;
            }

            /**
             * Takes a Scene configuration object and returns a fully formed System Settings object.
             * @param config The Scene configuration object used to create this Scene Settings.
             */
            function create(config: string | Config): object;
        }

        /**
         * The Scene Systems class.
         *
         * This class is available from within a Scene under the property `sys`.
         * It is responsible for managing all of the plugins a Scene has running, including the display list, and
         * handling the update step and renderer. It also contains references to global systems belonging to Game.
         */
        class Systems {
            /**
             *
             * @param scene The Scene that owns this Systems instance.
             * @param config Scene specific configuration settings.
             */
            constructor(scene: Scene, config: string | Settings.Config);

            /**
             * A reference to the Scene that these Systems belong to.
             */
            scene: Scene;

            /**
             * A reference to the Phaser Game instance.
             */
            game: Game;

            /**
             * The Facebook Instant Games Plugin.
             */
            facebook: FacebookInstantGamesPlugin;

            /**
             * The Scene Configuration object, as passed in when creating the Scene.
             */
            config: string | Settings.Config;

            /**
             * The Scene Settings. This is the parsed output based on the Scene configuration.
             */
            settings: Settings.Object;

            /**
             * A handy reference to the Scene canvas / context.
             */
            canvas: HTMLCanvasElement;

            /**
             * A reference to the Canvas Rendering Context being used by the renderer.
             */
            context: CanvasRenderingContext2D;

            /**
             * A reference to the global Animations Manager.
             *
             * In the default set-up you can access this from within a Scene via the `this.anims` property.
             */
            anims: Animations.AnimationManager;

            /**
             * A reference to the global Cache. The Cache stores all files bought in to Phaser via
             * the Loader, with the exception of images. Images are stored in the Texture Manager.
             *
             * In the default set-up you can access this from within a Scene via the `this.cache` property.
             */
            cache: Cache.CacheManager;

            /**
             * A reference to the global Plugins Manager.
             *
             * In the default set-up you can access this from within a Scene via the `this.plugins` property.
             */
            plugins: Plugins.PluginManager;

            /**
             * A reference to the global registry. This is a game-wide instance of the Data Manager, allowing
             * you to exchange data between Scenes via a universal and shared point.
             *
             * In the default set-up you can access this from within a Scene via the `this.registry` property.
             */
            registry: Data.DataManager;

            /**
             * A reference to the global Scale Manager.
             *
             * In the default set-up you can access this from within a Scene via the `this.scale` property.
             */
            scale: Scale.ScaleManager;

            /**
             * A reference to the global Sound Manager.
             *
             * In the default set-up you can access this from within a Scene via the `this.sound` property.
             */
            sound: Sound.BaseSoundManager;

            /**
             * A reference to the global Texture Manager.
             *
             * In the default set-up you can access this from within a Scene via the `this.textures` property.
             */
            textures: Textures.TextureManager;

            /**
             * A reference to the Scene's Game Object Factory.
             *
             * Use this to quickly and easily create new Game Object's.
             *
             * In the default set-up you can access this from within a Scene via the `this.add` property.
             */
            add: GameObjects.GameObjectFactory;

            /**
             * A reference to the Scene's Camera Manager.
             *
             * Use this to manipulate and create Cameras for this specific Scene.
             *
             * In the default set-up you can access this from within a Scene via the `this.cameras` property.
             */
            cameras: Cameras.Scene2D.CameraManager;

            /**
             * A reference to the Scene's Display List.
             *
             * Use this to organize the children contained in the display list.
             *
             * In the default set-up you can access this from within a Scene via the `this.children` property.
             */
            displayList: GameObjects.DisplayList;

            /**
             * A reference to the Scene's Event Manager.
             *
             * Use this to listen for Scene specific events, such as `pause` and `shutdown`.
             *
             * In the default set-up you can access this from within a Scene via the `this.events` property.
             */
            events: Phaser.Events.EventEmitter;

            /**
             * A reference to the Scene's Game Object Creator.
             *
             * Use this to quickly and easily create new Game Object's. The difference between this and the
             * Game Object Factory, is that the Creator just creates and returns Game Object instances, it
             * doesn't then add them to the Display List or Update List.
             *
             * In the default set-up you can access this from within a Scene via the `this.make` property.
             */
            make: GameObjects.GameObjectCreator;

            /**
             * A reference to the Scene Manager Plugin.
             *
             * Use this to manipulate both this and other Scene's in your game, for example to launch a parallel Scene,
             * or pause or resume a Scene, or switch from this Scene to another.
             *
             * In the default set-up you can access this from within a Scene via the `this.scene` property.
             */
            scenePlugin: ScenePlugin;

            /**
             * A reference to the Scene's Update List.
             *
             * Use this to organize the children contained in the update list.
             *
             * The Update List is responsible for managing children that need their `preUpdate` methods called,
             * in order to process so internal components, such as Sprites with Animations.
             *
             * In the default set-up there is no reference to this from within the Scene itself.
             */
            updateList: GameObjects.UpdateList;

            /**
             * This method is called only once by the Scene Manager when the Scene is instantiated.
             * It is responsible for setting up all of the Scene plugins and references.
             * It should never be called directly.
             * @param game A reference to the Phaser Game instance.
             */
            protected init(game: Game): void;

            /**
             * A single game step. Called automatically by the Scene Manager as a result of a Request Animation
             * Frame or Set Timeout call to the main Game instance.
             * @param time The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().
             * @param delta The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.
             */
            step(time: number, delta: number): void;

            /**
             * Called automatically by the Scene Manager.
             * Instructs the Scene to render itself via its Camera Manager to the renderer given.
             * @param renderer The renderer that invoked the render call.
             */
            render(renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer): void;

            /**
             * Force a sort of the display list on the next render.
             */
            queueDepthSort(): void;

            /**
             * Immediately sorts the display list if the flag is set.
             */
            depthSort(): void;

            /**
             * Pause this Scene.
             * A paused Scene still renders, it just doesn't run ANY of its update handlers or systems.
             * @param data A data object that will be passed in the 'pause' event.
             */
            pause(data?: object): Systems;

            /**
             * Resume this Scene from a paused state.
             * @param data A data object that will be passed in the 'resume' event.
             */
            resume(data?: object): Systems;

            /**
             * Send this Scene to sleep.
             *
             * A sleeping Scene doesn't run it's update step or render anything, but it also isn't shut down
             * or have any of its systems or children removed, meaning it can be re-activated at any point and
             * will carry on from where it left off. It also keeps everything in memory and events and callbacks
             * from other Scenes may still invoke changes within it, so be careful what is left active.
             * @param data A data object that will be passed in the 'sleep' event.
             */
            sleep(data?: object): Systems;

            /**
             * Wake-up this Scene if it was previously asleep.
             * @param data A data object that will be passed in the 'wake' event.
             */
            wake(data?: object): Systems;

            /**
             * Is this Scene sleeping?
             */
            isSleeping(): boolean;

            /**
             * Is this Scene active?
             */
            isActive(): boolean;

            /**
             * Is this Scene paused?
             */
            isPaused(): boolean;

            /**
             * Is this Scene currently transitioning out to, or in from another Scene?
             */
            isTransitioning(): boolean;

            /**
             * Is this Scene currently transitioning out from itself to another Scene?
             */
            isTransitionOut(): boolean;

            /**
             * Is this Scene currently transitioning in from another Scene?
             */
            isTransitionIn(): boolean;

            /**
             * Is this Scene visible and rendering?
             */
            isVisible(): boolean;

            /**
             * Sets the visible state of this Scene.
             * An invisible Scene will not render, but will still process updates.
             * @param value `true` to render this Scene, otherwise `false`.
             */
            setVisible(value: boolean): Systems;

            /**
             * Set the active state of this Scene.
             *
             * An active Scene will run its core update loop.
             * @param value If `true` the Scene will be resumed, if previously paused. If `false` it will be paused.
             * @param data A data object that will be passed in the 'resume' or 'pause' events.
             */
            setActive(value: boolean, data?: object): Systems;

            /**
             * Start this Scene running and rendering.
             * Called automatically by the SceneManager.
             * @param data Optional data object that may have been passed to this Scene from another.
             */
            start(data: object): void;

            /**
             * Shutdown this Scene and send a shutdown event to all of its systems.
             * A Scene that has been shutdown will not run its update loop or render, but it does
             * not destroy any of its plugins or references. It is put into hibernation for later use.
             * If you don't ever plan to use this Scene again, then it should be destroyed instead
             * to free-up resources.
             * @param data A data object that will be passed in the 'shutdown' event.
             */
            shutdown(data?: object): void;
        }
    }

    /**
     * A base Phaser.Scene class which you could extend for your own use.
     */
    class Scene {
        /**
         *
         * @param config Scene specific configuration settings.
         */
        constructor(config: string | Scenes.Settings.Config);

        /**
         * The Scene Systems. You must never overwrite this property, or all hell will break lose.
         */
        sys: Scenes.Systems;

        /**
         * A reference to the Phaser.Game instance.
         * This property will only be available if defined in the Scene Injection Map.
         */
        game: Game;

        /**
         * A reference to the global Animation Manager.
         * This property will only be available if defined in the Scene Injection Map.
         */
        anims: Animations.AnimationManager;

        /**
         * A reference to the global Cache.
         * This property will only be available if defined in the Scene Injection Map.
         */
        cache: Cache.CacheManager;

        /**
         * A reference to the game level Data Manager.
         * This property will only be available if defined in the Scene Injection Map.
         */
        registry: Data.DataManager;

        /**
         * A reference to the Sound Manager.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        sound: Sound.BaseSoundManager;

        /**
         * A reference to the Texture Manager.
         * This property will only be available if defined in the Scene Injection Map.
         */
        textures: Textures.TextureManager;

        /**
         * A scene level Event Emitter.
         * This property will only be available if defined in the Scene Injection Map.
         */
        events: Events.EventEmitter;

        /**
         * A scene level Camera System.
         * This property will only be available if defined in the Scene Injection Map.
         */
        cameras: Cameras.Scene2D.CameraManager;

        /**
         * A scene level Game Object Factory.
         * This property will only be available if defined in the Scene Injection Map.
         */
        add: GameObjects.GameObjectFactory;

        /**
         * A scene level Game Object Creator.
         * This property will only be available if defined in the Scene Injection Map.
         */
        make: GameObjects.GameObjectCreator;

        /**
         * A reference to the Scene Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map.
         */
        scene: Scenes.ScenePlugin;

        /**
         * A scene level Game Object Display List.
         * This property will only be available if defined in the Scene Injection Map.
         */
        children: GameObjects.DisplayList;

        /**
         * A scene level Lights Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        lights: GameObjects.LightsManager;

        /**
         * A scene level Data Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        data: Data.DataManager;

        /**
         * A scene level Input Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        input: Input.InputPlugin;

        /**
         * A scene level Loader Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        load: Loader.LoaderPlugin;

        /**
         * A scene level Time and Clock Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        time: Time.Clock;

        /**
         * A scene level Tween Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        tweens: Tweens.TweenManager;

        /**
         * A scene level Arcade Physics Plugin.
         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.
         */
        physics: Physics.Arcade.ArcadePhysics;

        /**
         * A scene level Impact Physics Plugin.
         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.
         */
        impact: Physics.Impact.ImpactPhysics;

        /**
         * A scene level Matter Physics Plugin.
         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.
         */
        matter: Physics.Matter.MatterPhysics;

        /**
         * A scene level Facebook Instant Games Plugin.
         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.
         */
        facebook: FacebookInstantGamesPlugin;

        /**
         * Should be overridden by your own Scenes.
         * @param time The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
         * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
         */
        update(time: number, delta: number): void;
    }

    namespace Sound {
        /**
         * Class containing all the shared state and behavior of a sound object, independent of the implementation.
         */
        class BaseSound extends Phaser.Events.EventEmitter {
            /**
             *
             * @param manager Reference to the current sound manager instance.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings.
             */
            constructor(manager: BaseSoundManager, key: string, config?: SoundConfig);

            /**
             * Asset key for the sound.
             */
            readonly key: string;

            /**
             * Flag indicating if sound is currently playing.
             */
            readonly isPlaying: boolean;

            /**
             * Flag indicating if sound is currently paused.
             */
            readonly isPaused: boolean;

            /**
             * A property that holds the value of sound's actual playback rate,
             * after its rate and detune values has been combined with global
             * rate and detune values.
             */
            readonly totalRate: number;

            /**
             * A value representing the duration, in seconds.
             * It could be total sound duration or a marker duration.
             */
            readonly duration: number;

            /**
             * The total duration of the sound in seconds.
             */
            readonly totalDuration: number;

            /**
             * Object containing markers definitions.
             */
            readonly markers: {[key: string]: SoundMarker};

            /**
             * Currently playing marker.
             * 'null' if whole sound is playing.
             */
            readonly currentMarker: SoundMarker;

            /**
             * Adds a marker into the current sound. A marker is represented by name, start time, duration, and optionally config object.
             * This allows you to bundle multiple sounds together into a single audio file and use markers to jump between them for playback.
             * @param marker Marker object.
             */
            addMarker(marker: SoundMarker): boolean;

            /**
             * Updates previously added marker.
             * @param marker Marker object with updated values.
             */
            updateMarker(marker: SoundMarker): boolean;

            /**
             * Removes a marker from the sound.
             * @param markerName The name of the marker to remove.
             */
            removeMarker(markerName: string): SoundMarker;

            /**
             * Play this sound, or a marked section of it.
             * It always plays the sound from the start. If you want to start playback from a specific time
             * you can set 'seek' setting of the config object, provided to this call, to that value.
             * @param markerName If you want to play a marker then provide the marker name here, otherwise omit it to play the full sound. Default ''.
             * @param config Optional sound config object to be applied to this marker or entire sound if no marker name is provided.
             * It gets memorized for future plays of current section of the sound.
             */
            play(markerName?: string, config?: SoundConfig): boolean;

            /**
             * Pauses the sound.
             */
            pause(): boolean;

            /**
             * Resumes the sound.
             */
            resume(): boolean;

            /**
             * Stop playing this sound.
             */
            stop(): boolean;

            /**
             * Method used internally for applying config values to some of the sound properties.
             */
            protected applyConfig(): void;

            /**
             * Method used internally for resetting values of some of the config properties.
             */
            protected resetConfig(): void;

            /**
             * Update method called automatically by sound manager on every game step.
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             * @param delta The delta time elapsed since the last frame.
             */
            protected update(time: number, delta: number): void;

            /**
             * Method used internally to calculate total playback rate of the sound.
             */
            protected calculateRate(): void;

            /**
             * Destroys this sound and all associated events and marks it for removal from the sound manager.
             */
            destroy(): void;
        }

        /**
         * The sound manager is responsible for playing back audio via Web Audio API or HTML Audio tag as fallback.
         * The audio file interface and the encoding of those files are extremely important.
         *
         * Not all browsers can play all audio formats.
         *
         * There is a good guide to what's supported [here](https://developer.mozilla.org/en-US/Apps/Fundamentals/Audio_and_video_delivery/Cross-browser_audio_basics#Audio_Codec_Support).
         */
        class BaseSoundManager extends Phaser.Events.EventEmitter {
            /**
             *
             * @param game Reference to the current game instance.
             */
            constructor(game: Game);

            /**
             * Local reference to game.
             */
            readonly game: Game;

            /**
             * Local reference to the JSON Cache, as used by Audio Sprites.
             */
            readonly jsonCache: Cache.BaseCache;

            /**
             * Global mute setting.
             */
            mute: boolean;

            /**
             * Global volume setting.
             */
            volume: number;

            /**
             * Flag indicating if sounds should be paused when game looses focus,
             * for instance when user switches to another tab/program/app.
             */
            pauseOnBlur: boolean;

            /**
             * Mobile devices require sounds to be triggered from an explicit user action,
             * such as a tap, before any sound can be loaded/played on a web page.
             * Set to true if the audio system is currently locked awaiting user interaction.
             */
            readonly locked: boolean;

            /**
             * Adds a new sound into the sound manager.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings.
             */
            add(key: string, config?: SoundConfig): BaseSound;

            /**
             * Adds a new audio sprite sound into the sound manager.
             * Audio Sprites are a combination of audio files and a JSON configuration.
             * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings.
             */
            addAudioSprite(key: string, config?: SoundConfig): AudioSpriteSound;

            /**
             * Enables playing sound on the fly without the need to keep a reference to it.
             * Sound will auto destroy once its playback ends.
             * @param key Asset key for the sound.
             * @param extra An optional additional object containing settings to be applied to the sound. It could be either config or marker object.
             */
            play(key: string, extra?: SoundConfig | SoundMarker): boolean;

            /**
             * Enables playing audio sprite sound on the fly without the need to keep a reference to it.
             * Sound will auto destroy once its playback ends.
             * @param key Asset key for the sound.
             * @param spriteName The name of the sound sprite to play.
             * @param config An optional config object containing default sound settings.
             */
            playAudioSprite(key: string, spriteName: string, config?: SoundConfig): boolean;

            /**
             * Removes a sound from the sound manager.
             * The removed sound is destroyed before removal.
             * @param sound The sound object to remove.
             */
            remove(sound: BaseSound): boolean;

            /**
             * Removes all sounds from the sound manager that have an asset key matching the given value.
             * The removed sounds are destroyed before removal.
             * @param key The key to match when removing sound objects.
             */
            removeByKey(key: string): number;

            /**
             * Pauses all the sounds in the game.
             */
            pauseAll(): void;

            /**
             * Resumes all the sounds in the game.
             */
            resumeAll(): void;

            /**
             * Stops all the sounds in the game.
             */
            stopAll(): void;

            /**
             * Method used internally for unlocking audio playback on devices that
             * require user interaction before any sound can be played on a web page.
             *
             * Read more about how this issue is handled here in [this article](https://medium.com/@pgoloskokovic/unlocking-web-audio-the-smarter-way-8858218c0e09).
             */
            protected unlock(): void;

            /**
             * Method used internally for pausing sound manager if
             * Phaser.Sound.BaseSoundManager#pauseOnBlur is set to true.
             */
            protected onBlur(): void;

            /**
             * Method used internally for resuming sound manager if
             * Phaser.Sound.BaseSoundManager#pauseOnBlur is set to true.
             */
            protected onFocus(): void;

            /**
             * Update method called on every game step.
             * Removes destroyed sounds and updates every active sound in the game.
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             * @param delta The delta time elapsed since the last frame.
             */
            protected update(time: number, delta: number): void;

            /**
             * Destroys all the sounds in the game and all associated events.
             */
            destroy(): void;

            /**
             * Sets the global playback rate at which all the sounds will be played.
             *
             * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audios playback speed.
             * @param value Global playback rate at which all the sounds will be played.
             */
            setRate(value: number): BaseSoundManager;

            /**
             * Global playback rate at which all the sounds will be played.
             * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audio's playback speed.
             */
            rate: number;

            /**
             * Sets the global detuning of all sounds in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             * @param value The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            setDetune(value: number): BaseSoundManager;

            /**
             * Global detuning of all sounds in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            detune: number;
        }

        namespace Events {
            /**
             * The Sound Complete Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they complete playback.
             *
             * Listen to it from a Sound instance using `Sound.on('complete', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('complete', listener);
             * music.play();
             * ```
             */
            const COMPLETE: any;

            /**
             * The Sound Destroy Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are destroyed, either
             * directly or via a Sound Manager.
             *
             * Listen to it from a Sound instance using `Sound.on('destroy', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('destroy', listener);
             * music.destroy();
             * ```
             */
            const DESTROY: any;

            /**
             * The Sound Detune Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when their detune value changes.
             *
             * Listen to it from a Sound instance using `Sound.on('detune', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('detune', listener);
             * music.play();
             * music.setDetune(200);
             * ```
             */
            const DETUNE: any;

            /**
             * The Sound Manager Global Detune Event.
             *
             * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
             * or the HTML5 Audio Manager. It is dispatched when the `detune` property of the Sound Manager is changed, which globally
             * adjusts the detuning of all active sounds.
             *
             * Listen to it from a Scene using: `this.sound.on('rate', listener)`.
             */
            const GLOBAL_DETUNE: any;

            /**
             * The Sound Manager Global Mute Event.
             *
             * This event is dispatched by the Sound Manager when its `mute` property is changed, either directly
             * or via the `setMute` method. This changes the mute state of all active sounds.
             *
             * Listen to it from a Scene using: `this.sound.on('mute', listener)`.
             */
            const GLOBAL_MUTE: any;

            /**
             * The Sound Manager Global Rate Event.
             *
             * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
             * or the HTML5 Audio Manager. It is dispatched when the `rate` property of the Sound Manager is changed, which globally
             * adjusts the playback rate of all active sounds.
             *
             * Listen to it from a Scene using: `this.sound.on('rate', listener)`.
             */
            const GLOBAL_RATE: any;

            /**
             * The Sound Manager Global Volume Event.
             *
             * This event is dispatched by the Sound Manager when its `volume` property is changed, either directly
             * or via the `setVolume` method. This changes the volume of all active sounds.
             *
             * Listen to it from a Scene using: `this.sound.on('volume', listener)`.
             */
            const GLOBAL_VOLUME: any;

            /**
             * The Sound Looped Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they loop during playback.
             *
             * Listen to it from a Sound instance using `Sound.on('looped', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('looped', listener);
             * music.setLoop(true);
             * music.play();
             * ```
             *
             * This is not to be confused with the [LOOP]{@linkcode Phaser.Sound.Events#event:LOOP} event, which only emits when the loop state of a Sound is changed.
             */
            const LOOPED: any;

            /**
             * The Sound Loop Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when their loop state is changed.
             *
             * Listen to it from a Sound instance using `Sound.on('loop', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('loop', listener);
             * music.setLoop(true);
             * ```
             *
             * This is not to be confused with the [LOOPED]{@linkcode Phaser.Sound.Events#event:LOOPED} event, which emits each time a Sound loops during playback.
             */
            const LOOP: any;

            /**
             * The Sound Mute Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when their mute state changes.
             *
             * Listen to it from a Sound instance using `Sound.on('mute', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('mute', listener);
             * music.play();
             * music.setMute(true);
             * ```
             */
            const MUTE: any;

            /**
             * The Pause All Sounds Event.
             *
             * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
             * or the HTML5 Audio Manager. It is dispatched when the `pauseAll` method is invoked and after all current Sounds
             * have been paused.
             *
             * Listen to it from a Scene using: `this.sound.on('pauseall', listener)`.
             */
            const PAUSE_ALL: any;

            /**
             * The Sound Pause Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are paused.
             *
             * Listen to it from a Sound instance using `Sound.on('pause', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('pause', listener);
             * music.play();
             * music.pause();
             * ```
             */
            const PAUSE: any;

            /**
             * The Sound Play Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are played.
             *
             * Listen to it from a Sound instance using `Sound.on('play', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('play', listener);
             * music.play();
             * ```
             */
            const PLAY: any;

            /**
             * The Sound Rate Change Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when their rate changes.
             *
             * Listen to it from a Sound instance using `Sound.on('rate', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('rate', listener);
             * music.play();
             * music.setRate(0.5);
             * ```
             */
            const RATE: any;

            /**
             * The Resume All Sounds Event.
             *
             * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
             * or the HTML5 Audio Manager. It is dispatched when the `resumeAll` method is invoked and after all current Sounds
             * have been resumed.
             *
             * Listen to it from a Scene using: `this.sound.on('resumeall', listener)`.
             */
            const RESUME_ALL: any;

            /**
             * The Sound Resume Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are resumed from a paused state.
             *
             * Listen to it from a Sound instance using `Sound.on('resume', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('resume', listener);
             * music.play();
             * music.pause();
             * music.resume();
             * ```
             */
            const RESUME: any;

            /**
             * The Sound Seek Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are seeked to a new position.
             *
             * Listen to it from a Sound instance using `Sound.on('seek', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('seek', listener);
             * music.play();
             * music.setSeek(5000);
             * ```
             */
            const SEEK: any;

            /**
             * The Stop All Sounds Event.
             *
             * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
             * or the HTML5 Audio Manager. It is dispatched when the `stopAll` method is invoked and after all current Sounds
             * have been stopped.
             *
             * Listen to it from a Scene using: `this.sound.on('stopall', listener)`.
             */
            const STOP_ALL: any;

            /**
             * The Sound Stop Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are stopped.
             *
             * Listen to it from a Sound instance using `Sound.on('stop', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('stop', listener);
             * music.play();
             * music.stop();
             * ```
             */
            const STOP: any;

            /**
             * The Sound Manager Unlocked Event.
             *
             * This event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,
             * or the HTML5 Audio Manager. It is dispatched during the update loop when the Sound Manager becomes unlocked. For
             * Web Audio this is on the first user gesture on the page.
             *
             * Listen to it from a Scene using: `this.sound.on('unlocked', listener)`.
             */
            const UNLOCKED: any;

            /**
             * The Sound Volume Event.
             *
             * This event is dispatched by both Web Audio and HTML5 Audio Sound objects when their volume changes.
             *
             * Listen to it from a Sound instance using `Sound.on('volume', listener)`, i.e.:
             *
             * ```javascript
             * var music = this.sound.add('key');
             * music.on('volume', listener);
             * music.play();
             * music.setVolume(0.5);
             * ```
             */
            const VOLUME: any;
        }

        /**
         * HTML5 Audio implementation of the sound.
         */
        class HTML5AudioSound extends BaseSound {
            /**
             *
             * @param manager Reference to the current sound manager instance.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings. Default {}.
             */
            constructor(manager: HTML5AudioSoundManager, key: string, config?: SoundConfig);

            /**
             * Play this sound, or a marked section of it.
             * It always plays the sound from the start. If you want to start playback from a specific time
             * you can set 'seek' setting of the config object, provided to this call, to that value.
             * @param markerName If you want to play a marker then provide the marker name here, otherwise omit it to play the full sound. Default ''.
             * @param config Optional sound config object to be applied to this marker or entire sound if no marker name is provided.
             * It gets memorized for future plays of current section of the sound.
             */
            play(markerName?: string, config?: SoundConfig): boolean;

            /**
             * Pauses the sound.
             */
            pause(): boolean;

            /**
             * Resumes the sound.
             */
            resume(): boolean;

            /**
             * Stop playing this sound.
             */
            stop(): boolean;

            /**
             * Update method called automatically by sound manager on every game step.
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             * @param delta The delta time elapsed since the last frame.
             */
            protected update(time: number, delta: number): void;

            /**
             * Calls Phaser.Sound.BaseSound#destroy method
             * and cleans up all HTML5 Audio related stuff.
             */
            destroy(): void;

            /**
             * Method used internally to calculate total playback rate of the sound.
             */
            protected calculateRate(): void;

            /**
             * Boolean indicating whether the sound is muted or not.
             * Gets or sets the muted state of this sound.
             */
            mute: boolean;

            /**
             * Sets the muted state of this Sound.
             * @param value `true` to mute this sound, `false` to unmute it.
             */
            setMute(value: boolean): HTML5AudioSound;

            /**
             * Gets or sets the volume of this sound, a value between 0 (silence) and 1 (full volume).
             */
            volume: number;

            /**
             * Sets the volume of this Sound.
             * @param value The volume of the sound.
             */
            setVolume(value: number): HTML5AudioSound;

            /**
             * Rate at which this Sound will be played.
             * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audios playback speed.
             */
            rate: number;

            /**
             * Sets the playback rate of this Sound.
             *
             * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audios playback speed.
             * @param value The playback rate at of this Sound.
             */
            setRate(value: number): HTML5AudioSound;

            /**
             * The detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            detune: number;

            /**
             * Sets the detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             * @param value The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            setDetune(value: number): HTML5AudioSound;

            /**
             * Property representing the position of playback for this sound, in seconds.
             * Setting it to a specific value moves current playback to that position.
             * The value given is clamped to the range 0 to current marker duration.
             * Setting seek of a stopped sound has no effect.
             */
            seek: number;

            /**
             * Seeks to a specific point in this sound.
             * @param value The point in the sound to seek to.
             */
            setSeek(value: number): HTML5AudioSound;

            /**
             * Flag indicating whether or not the sound or current sound marker will loop.
             */
            loop: boolean;

            /**
             * Sets the loop state of this Sound.
             * @param value `true` to loop this sound, `false` to not loop it.
             */
            setLoop(value: boolean): HTML5AudioSound;
        }

        /**
         * HTML5AudioSoundManager
         */
        class HTML5AudioSoundManager extends BaseSoundManager {
            /**
             *
             * @param game Reference to the current game instance.
             */
            constructor(game: Game);

            /**
             * Flag indicating whether if there are no idle instances of HTML5 Audio tag,
             * for any particular sound, if one of the used tags should be hijacked and used
             * for succeeding playback or if succeeding Phaser.Sound.HTML5AudioSound#play
             * call should be ignored.
             */
            override: boolean;

            /**
             * Value representing time difference, in seconds, between calling
             * play method on an audio tag and when it actually starts playing.
             * It is used to achieve more accurate delayed sound playback.
             *
             * You might need to tweak this value to get the desired results
             * since audio play delay varies depending on the browser/platform.
             */
            audioPlayDelay: number;

            /**
             * A value by which we should offset the loop end marker of the
             * looping sound to compensate for lag, caused by changing audio
             * tag playback position, in order to achieve gapless looping.
             *
             * You might need to tweak this value to get the desired results
             * since loop lag varies depending on the browser/platform.
             */
            loopEndOffset: number;

            /**
             * Adds a new sound into the sound manager.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings.
             */
            add(key: string, config?: SoundConfig): HTML5AudioSound;

            /**
             * Unlocks HTML5 Audio loading and playback on mobile
             * devices on the initial explicit user interaction.
             */
            unlock(): void;

            /**
             * Method used internally for pausing sound manager if
             * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.
             */
            protected onBlur(): void;

            /**
             * Method used internally for resuming sound manager if
             * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.
             */
            protected onFocus(): void;

            /**
             * Calls Phaser.Sound.BaseSoundManager#destroy method
             * and cleans up all HTML5 Audio related stuff.
             */
            destroy(): void;

            /**
             * Method used internally by Phaser.Sound.HTML5AudioSound class methods and property setters
             * to check if sound manager is locked and then either perform action immediately or queue it
             * to be performed once the sound manager gets unlocked.
             * @param sound Sound object on which to perform queued action.
             * @param prop Name of the method to be called or property to be assigned a value to.
             * @param value An optional parameter that either holds an array of arguments to be passed to the method call or value to be set to the property.
             */
            protected isLocked(sound: HTML5AudioSound, prop: string, value?: any): boolean;

            /**
             * Sets the muted state of all this Sound Manager.
             * @param value `true` to mute all sounds, `false` to unmute them.
             */
            setMute(value: boolean): HTML5AudioSoundManager;

            mute: boolean;

            /**
             * Sets the volume of this Sound Manager.
             * @param value The global volume of this Sound Manager.
             */
            setVolume(value: number): HTML5AudioSoundManager;

            volume: number;
        }

        /**
         * No audio implementation of the sound. It is used if audio has been
         * disabled in the game config or the device doesn't support any audio.
         *
         * It represents a graceful degradation of sound logic that provides
         * minimal functionality and prevents Phaser projects that use audio from
         * breaking on devices that don't support any audio playback technologies.
         */
        class NoAudioSound extends BaseSound {
            /**
             *
             * @param manager Reference to the current sound manager instance.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings. Default {}.
             */
            constructor(manager: NoAudioSoundManager, key: string, config?: SoundConfig);
        }

        /**
         * No audio implementation of the sound manager. It is used if audio has been
         * disabled in the game config or the device doesn't support any audio.
         *
         * It represents a graceful degradation of sound manager logic that provides
         * minimal functionality and prevents Phaser projects that use audio from
         * breaking on devices that don't support any audio playback technologies.
         */
        class NoAudioSoundManager extends BaseSoundManager {
            /**
             *
             * @param game Reference to the current game instance.
             */
            constructor(game: Game);
        }

        /**
         * Creates a Web Audio, HTML5 Audio or No Audio Sound Manager based on config and device settings.
         *
         * Be aware of https://developers.google.com/web/updates/2017/09/autoplay-policy-changes
         * @param game Reference to the current game instance.
         */
        function SoundManagerCreator(game: Game): void;

        /**
         * Web Audio API implementation of the sound.
         */
        class WebAudioSound extends BaseSound {
            /**
             *
             * @param manager Reference to the current sound manager instance.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings. Default {}.
             */
            constructor(manager: WebAudioSoundManager, key: string, config?: SoundConfig);

            /**
             * Play this sound, or a marked section of it.
             *
             * It always plays the sound from the start. If you want to start playback from a specific time
             * you can set 'seek' setting of the config object, provided to this call, to that value.
             * @param markerName If you want to play a marker then provide the marker name here, otherwise omit it to play the full sound. Default ''.
             * @param config Optional sound config object to be applied to this marker or entire sound if no marker name is provided.
             * It gets memorized for future plays of current section of the sound.
             */
            play(markerName?: string, config?: SoundConfig): boolean;

            /**
             * Pauses the sound.
             */
            pause(): boolean;

            /**
             * Resumes the sound.
             */
            resume(): boolean;

            /**
             * Stop playing this sound.
             */
            stop(): boolean;

            /**
             * Method used internally for applying config values to some of the sound properties.
             */
            protected applyConfig(): void;

            /**
             * Update method called automatically by sound manager on every game step.
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             * @param delta The delta time elapsed since the last frame.
             */
            protected update(time: number, delta: number): void;

            /**
             * Calls Phaser.Sound.BaseSound#destroy method
             * and cleans up all Web Audio API related stuff.
             */
            destroy(): void;

            /**
             * Method used internally to calculate total playback rate of the sound.
             */
            protected calculateRate(): void;

            /**
             * Rate at which this Sound will be played.
             * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audios playback speed.
             */
            rate: number;

            /**
             * Sets the playback rate of this Sound.
             *
             * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audios playback speed.
             * @param value The playback rate at of this Sound.
             */
            setRate(value: number): WebAudioSound;

            /**
             * The detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            detune: number;

            /**
             * Sets the detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             * @param value The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            setDetune(value: number): WebAudioSound;

            /**
             * Boolean indicating whether the sound is muted or not.
             * Gets or sets the muted state of this sound.
             */
            mute: boolean;

            /**
             * Sets the muted state of this Sound.
             * @param value `true` to mute this sound, `false` to unmute it.
             */
            setMute(value: boolean): WebAudioSound;

            /**
             * Gets or sets the volume of this sound, a value between 0 (silence) and 1 (full volume).
             */
            volume: number;

            /**
             * Sets the volume of this Sound.
             * @param value The volume of the sound.
             */
            setVolume(value: number): WebAudioSound;

            /**
             * Property representing the position of playback for this sound, in seconds.
             * Setting it to a specific value moves current playback to that position.
             * The value given is clamped to the range 0 to current marker duration.
             * Setting seek of a stopped sound has no effect.
             */
            seek: number;

            /**
             * Seeks to a specific point in this sound.
             * @param value The point in the sound to seek to.
             */
            setSeek(value: number): WebAudioSound;

            /**
             * Flag indicating whether or not the sound or current sound marker will loop.
             */
            loop: boolean;

            /**
             * Sets the loop state of this Sound.
             * @param value `true` to loop this sound, `false` to not loop it.
             */
            setLoop(value: boolean): WebAudioSound;
        }

        /**
         * Web Audio API implementation of the sound manager.
         */
        class WebAudioSoundManager extends BaseSoundManager {
            /**
             *
             * @param game Reference to the current game instance.
             */
            constructor(game: Game);

            /**
             * Adds a new sound into the sound manager.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings.
             */
            add(key: string, config?: SoundConfig): WebAudioSound;

            /**
             * Unlocks Web Audio API on the initial input event.
             *
             * Read more about how this issue is handled here in [this article](https://medium.com/@pgoloskokovic/unlocking-web-audio-the-smarter-way-8858218c0e09).
             */
            unlock(): void;

            /**
             * Method used internally for pausing sound manager if
             * Phaser.Sound.WebAudioSoundManager#pauseOnBlur is set to true.
             */
            protected onBlur(): void;

            /**
             * Method used internally for resuming sound manager if
             * Phaser.Sound.WebAudioSoundManager#pauseOnBlur is set to true.
             */
            protected onFocus(): void;

            /**
             * Calls Phaser.Sound.BaseSoundManager#destroy method
             * and cleans up all Web Audio API related stuff.
             */
            destroy(): void;

            /**
             * Sets the muted state of all this Sound Manager.
             * @param value `true` to mute all sounds, `false` to unmute them.
             */
            setMute(value: boolean): WebAudioSoundManager;

            mute: boolean;

            /**
             * Sets the volume of this Sound Manager.
             * @param value The global volume of this Sound Manager.
             */
            setVolume(value: number): WebAudioSoundManager;

            volume: number;
        }
    }

    namespace Structs {
        /**
         * List is a generic implementation of an ordered list which contains utility methods for retrieving, manipulating, and iterating items.
         */
        class List<T> {
            /**
             *
             * @param parent The parent of this list.
             */
            constructor(parent: any);

            /**
             * The parent of this list.
             */
            parent: any;

            /**
             * The objects that belong to this collection.
             */
            list: T[];

            /**
             * The index of the current element.
             *
             * This is used internally when iterating through the list with the {@link #first}, {@link #last}, {@link #get}, and {@link #previous} properties.
             */
            position: integer;

            /**
             * A callback that is invoked every time a child is added to this list.
             */
            addCallback: CallbackFn;

            /**
             * A callback that is invoked every time a child is removed from this list.
             */
            removeCallback: CallbackFn;

            /**
             * The property key to sort by.
             */
            _sortKey: string;

            /**
             * Adds the given item to the end of the list. Each item must be unique.
             * @param child The item, or array of items, to add to the list.
             * @param skipCallback Skip calling the List.addCallback if this child is added successfully. Default false.
             */
            add(child: T, skipCallback?: boolean): T;

            /**
             * Adds an item to list, starting at a specified index. Each item must be unique within the list.
             * @param child The item, or array of items, to add to the list.
             * @param index The index in the list at which the element(s) will be inserted. Default 0.
             * @param skipCallback Skip calling the List.addCallback if this child is added successfully. Default false.
             */
            addAt(child: T, index?: integer, skipCallback?: boolean): T;

            /**
             * Retrieves the item at a given position inside the List.
             * @param index The index of the item.
             */
            getAt(index: integer): T;

            /**
             * Locates an item within the List and returns its index.
             * @param child The item to locate.
             */
            getIndex(child: T): integer;

            /**
             * Sort the contents of this List so the items are in order based on the given property.
             * For example, `sort('alpha')` would sort the List contents based on the value of their `alpha` property.
             * @param property The property to lexically sort by.
             * @param handler Provide your own custom handler function. Will receive 2 children which it should compare and return a boolean.
             */
            sort(property: string, handler?: CallbackFn): T[];

            /**
             * Searches for the first instance of a child with its `name`
             * property matching the given argument. Should more than one child have
             * the same name only the first is returned.
             * @param name The name to search for.
             */
            getByName(name: string): T | null;

            /**
             * Returns a random child from the group.
             * @param startIndex Offset from the front of the group (lowest child). Default 0.
             * @param length Restriction on the number of values you want to randomly select from. Default (to top).
             */
            getRandom(startIndex?: integer, length?: integer): T | null;

            /**
             * Returns the first element in a given part of the List which matches a specific criterion.
             * @param property The name of the property to test or a falsey value to have no criterion.
             * @param value The value to test the `property` against, or `undefined` to allow any value and only check for existence.
             * @param startIndex The position in the List to start the search at. Default 0.
             * @param endIndex The position in the List to optionally stop the search at. It won't be checked.
             */
            getFirst(property: string, value: any, startIndex?: number, endIndex?: number): T | null;

            /**
             * Returns all children in this List.
             *
             * You can optionally specify a matching criteria using the `property` and `value` arguments.
             *
             * For example: `getAll('parent')` would return only children that have a property called `parent`.
             *
             * You can also specify a value to compare the property to:
             *
             * `getAll('visible', true)` would return only children that have their visible property set to `true`.
             *
             * Optionally you can specify a start and end index. For example if this List had 100 children,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
             * the first 50 children in the List.
             * @param property An optional property to test against the value argument.
             * @param value If property is set then Child.property must strictly equal this value to be included in the results.
             * @param startIndex The first child index to start the search from.
             * @param endIndex The last child index to search up until.
             */
            getAll(property?: string, value?: T, startIndex?: integer, endIndex?: integer): T[];

            /**
             * Returns the total number of items in the List which have a property matching the given value.
             * @param property The property to test on each item.
             * @param value The value to test the property against.
             */
            count(property: string, value: T): integer;

            /**
             * Swaps the positions of two items in the list.
             * @param child1 The first item to swap.
             * @param child2 The second item to swap.
             */
            swap(child1: T, child2: T): void;

            /**
             * Moves an item in the List to a new position.
             * @param child The item to move.
             * @param index Moves an item in the List to a new position.
             */
            moveTo(child: T, index: integer): T;

            /**
             * Removes one or many items from the List.
             * @param child The item, or array of items, to remove.
             * @param skipCallback Skip calling the List.removeCallback. Default false.
             */
            remove(child: T, skipCallback?: boolean): T;

            /**
             * Removes the item at the given position in the List.
             * @param index The position to remove the item from.
             * @param skipCallback Skip calling the List.removeCallback. Default false.
             */
            removeAt(index: integer, skipCallback?: boolean): T;

            /**
             * Removes the items within the given range in the List.
             * @param startIndex The index to start removing from. Default 0.
             * @param endIndex The position to stop removing at. The item at this position won't be removed.
             * @param skipCallback Skip calling the List.removeCallback. Default false.
             */
            removeBetween(startIndex?: integer, endIndex?: integer, skipCallback?: boolean): T[];

            /**
             * Removes all the items.
             * @param skipCallback Skip calling the List.removeCallback. Default false.
             */
            removeAll(skipCallback?: boolean): List<T>;

            /**
             * Brings the given child to the top of this List.
             * @param child The item to bring to the top of the List.
             */
            bringToTop(child: T): T;

            /**
             * Sends the given child to the bottom of this List.
             * @param child The item to send to the back of the list.
             */
            sendToBack(child: T): T;

            /**
             * Moves the given child up one place in this group unless it's already at the top.
             * @param child The item to move up.
             */
            moveUp(child: T): T;

            /**
             * Moves the given child down one place in this group unless it's already at the bottom.
             * @param child The item to move down.
             */
            moveDown(child: T): T;

            /**
             * Reverses the order of all children in this List.
             */
            reverse(): List<T>;

            /**
             * Shuffles the items in the list.
             */
            shuffle(): List<T>;

            /**
             * Replaces a child of this List with the given newChild. The newChild cannot be a member of this List.
             * @param oldChild The child in this List that will be replaced.
             * @param newChild The child to be inserted into this List.
             */
            replace(oldChild: T, newChild: T): T;

            /**
             * Checks if an item exists within the List.
             * @param child The item to check for the existence of.
             */
            exists(child: T): boolean;

            /**
             * Sets the property `key` to the given value on all members of this List.
             * @param property The name of the property to set.
             * @param value The value to set the property to.
             * @param startIndex The first child index to start the search from.
             * @param endIndex The last child index to search up until.
             */
            setAll(property: string, value: T, startIndex?: integer, endIndex?: integer): void;

            /**
             * Passes all children to the given callback.
             * @param callback The function to call.
             * @param context Value to use as `this` when executing callback.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            each(callback: EachListCallback<T>, context?: any, ...args: any[]): void;

            /**
             * Clears the List and recreates its internal array.
             */
            shutdown(): void;

            /**
             * Destroys this List.
             */
            destroy(): void;

            /**
             * The number of items inside the List.
             */
            readonly length: integer;

            /**
             * The first item in the List or `null` for an empty List.
             */
            readonly first: T;

            /**
             * The last item in the List, or `null` for an empty List.
             */
            readonly last: T;

            /**
             * The next item in the List, or `null` if the entire List has been traversed.
             *
             * This property can be read successively after reading {@link #first} or manually setting the {@link #position} to iterate the List.
             */
            readonly next: T;

            /**
             * The previous item in the List, or `null` if the entire List has been traversed.
             *
             * This property can be read successively after reading {@link #last} or manually setting the {@link #position} to iterate the List backwards.
             */
            readonly previous: T;
        }

        /**
         * The keys of a Map can be arbitrary values.
         *
         * ```javascript
         * var map = new Map([
         *    [ 1, 'one' ],
         *    [ 2, 'two' ],
         *    [ 3, 'three' ]
         * ]);
         * ```
         */
        class Map<K, V> {
            /**
             *
             * @param elements An optional array of key-value pairs to populate this Map with.
             */
            constructor(elements: V[]);

            /**
             * The entries in this Map.
             */
            entries: {[key: string]: V};

            /**
             * The number of key / value pairs in this Map.
             */
            size: number;

            /**
             * Adds an element with a specified `key` and `value` to this Map.
             * If the `key` already exists, the value will be replaced.
             * @param key The key of the element to be added to this Map.
             * @param value The value of the element to be added to this Map.
             */
            set(key: K, value: V): Map<K, V>;

            /**
             * Returns the value associated to the `key`, or `undefined` if there is none.
             * @param key The key of the element to return from the `Map` object.
             */
            get(key: K): V;

            /**
             * Returns an `Array` of all the values stored in this Map.
             */
            getArray(): V[];

            /**
             * Returns a boolean indicating whether an element with the specified key exists or not.
             * @param key The key of the element to test for presence of in this Map.
             */
            has(key: K): boolean;

            /**
             * Delete the specified element from this Map.
             * @param key The key of the element to delete from this Map.
             */
            delete(key: K): Map<K, V>;

            /**
             * Delete all entries from this Map.
             */
            clear(): Map<K, V>;

            /**
             * Returns all entries keys in this Map.
             */
            keys(): K[];

            /**
             * Returns an `Array` of all entries.
             */
            values(): V[];

            /**
             * Dumps the contents of this Map to the console via `console.group`.
             */
            dump(): void;

            /**
             * Passes all entries in this Map to the given callback.
             * @param callback The callback which will receive the keys and entries held in this Map.
             */
            each(callback: EachMapCallback<V>): Map<K, V>;

            /**
             * Returns `true` if the value exists within this Map. Otherwise, returns `false`.
             * @param value The value to search for.
             */
            contains(value: V): boolean;

            /**
             * Merges all new keys from the given Map into this one.
             * If it encounters a key that already exists it will be skipped unless override is set to `true`.
             * @param map The Map to merge in to this Map.
             * @param override Set to `true` to replace values in this Map with those from the source map, or `false` to skip them. Default false.
             */
            merge(map: Map<K, V>, override?: boolean): Map<K, V>;
        }

        /**
         * A Process Queue maintains three internal lists.
         *
         * The `pending` list is a selection of items which are due to be made 'active' in the next update.
         * The `active` list is a selection of items which are considered active and should be updated.
         * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.
         *
         * When new items are added to a Process Queue they are put in a pending data, rather than being added
         * immediately the active list. Equally, items that are removed are put into the destroy list, rather than
         * being destroyed immediately. This allows the Process Queue to carefully process each item at a specific, fixed
         * time, rather than at the time of the request from the API.
         */
        class ProcessQueue<T> {
            /**
             * Adds a new item to the Process Queue.
             * The item is added to the pending list and made active in the next update.
             * @param item The item to add to the queue.
             */
            add(item: T): ProcessQueue<T>;

            /**
             * Removes an item from the Process Queue.
             * The item is added to the pending destroy and fully removed in the next update.
             * @param item The item to be removed from the queue.
             */
            remove(item: T): ProcessQueue<T>;

            /**
             * Update this queue. First it will process any items awaiting destruction, and remove them.
             *
             * Then it will check to see if there are any items pending insertion, and move them to an
             * active state. Finally, it will return a list of active items for further processing.
             */
            update(): T[];

            /**
             * Returns the current list of active items.
             */
            getActive(): T[];

            /**
             * Immediately destroys this process queue, clearing all of its internal arrays and resetting the process totals.
             */
            destroy(): void;
        }

        /**
         * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.
         * It's based on an optimized R-tree data structure with bulk insertion support.
         *
         * Spatial index is a special data structure for points and rectangles that allows you to perform queries like
         * "all items within this bounding box" very efficiently (e.g. hundreds of times faster than looping over all items).
         *
         * This version of RBush uses a fixed min/max accessor structure of `[ '.left', '.top', '.right', '.bottom' ]`.
         * This is to avoid the eval like function creation that the original library used, which caused CSP policy violations.
         */
        class RTree {
            [key: string]: any;
        }

        /**
         * A Set is a collection of unique elements.
         */
        class Set<T> {
            /**
             *
             * @param elements An optional array of elements to insert into this Set.
             */
            constructor(elements?: T[]);

            /**
             * The entries of this Set. Stored internally as an array.
             */
            entries: T[];

            /**
             * Inserts the provided value into this Set. If the value is already contained in this Set this method will have no effect.
             * @param value The value to insert into this Set.
             */
            set(value: T): Set<T>;

            /**
             * Get an element of this Set which has a property of the specified name, if that property is equal to the specified value.
             * If no elements of this Set satisfy the condition then this method will return `null`.
             * @param property The property name to check on the elements of this Set.
             * @param value The value to check for.
             */
            get(property: string, value: T): T;

            /**
             * Returns an array containing all the values in this Set.
             */
            getArray(): T[];

            /**
             * Removes the given value from this Set if this Set contains that value.
             * @param value The value to remove from the Set.
             */
            delete(value: T): Set<T>;

            /**
             * Dumps the contents of this Set to the console via `console.group`.
             */
            dump(): void;

            /**
             * Passes each value in this Set to the given callback.
             * Use this function when you know this Set will be modified during the iteration, otherwise use `iterate`.
             * @param callback The callback to be invoked and passed each value this Set contains.
             * @param callbackScope The scope of the callback.
             */
            each(callback: EachSetCallback<T>, callbackScope?: any): Set<T>;

            /**
             * Passes each value in this Set to the given callback.
             * For when you absolutely know this Set won't be modified during the iteration.
             * @param callback The callback to be invoked and passed each value this Set contains.
             * @param callbackScope The scope of the callback.
             */
            iterate(callback: EachSetCallback<T>, callbackScope?: any): Set<T>;

            /**
             * Goes through each entry in this Set and invokes the given function on them, passing in the arguments.
             * @param callbackKey The key of the function to be invoked on each Set entry.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            iterateLocal(callbackKey: string, ...args: any[]): Set<T>;

            /**
             * Clears this Set so that it no longer contains any values.
             */
            clear(): Set<T>;

            /**
             * Returns `true` if this Set contains the given value, otherwise returns `false`.
             * @param value The value to check for in this Set.
             */
            contains(value: T): boolean;

            /**
             * Returns a new Set containing all values that are either in this Set or in the Set provided as an argument.
             * @param set The Set to perform the union with.
             */
            union(set: Set<T>): Set<T>;

            /**
             * Returns a new Set that contains only the values which are in this Set and that are also in the given Set.
             * @param set The Set to intersect this set with.
             */
            intersect(set: Set<T>): Set<T>;

            /**
             * Returns a new Set containing all the values in this Set which are *not* also in the given Set.
             * @param set The Set to perform the difference with.
             */
            difference(set: Set<T>): Set<T>;

            /**
             * The size of this Set. This is the number of entries within it.
             * Changing the size will truncate the Set if the given value is smaller than the current size.
             * Increasing the size larger than the current size has no effect.
             */
            size: integer;
        }

        /**
         * The Size component allows you to set `width` and `height` properties and define the relationship between them.
         *
         * The component can automatically maintain the aspect ratios between the two values, and clamp them
         * to a defined min-max range. You can also control the dominant axis. When dimensions are given to the Size component
         * that would cause it to exceed its min-max range, the dimensions are adjusted based on the dominant axis.
         */
        class Size {
            /**
             *
             * @param width The width of the Size component. Default 0.
             * @param height The height of the Size component. If not given, it will use the `width`. Default width.
             * @param aspectMode The aspect mode of the Size component. Defaults to 0, no mode. Default 0.
             * @param parent The parent of this Size component. Can be any object with public `width` and `height` properties.
             * Dimensions are clamped to keep them within the parent bounds where possible. Default null.
             */
            constructor(width?: number, height?: number, aspectMode?: integer, parent?: any);

            /**
             * The aspect mode this Size component will use when calculating its dimensions.
             * This property is read-only. To change it use the `setAspectMode` method.
             */
            readonly aspectMode: integer;

            /**
             * The proportional relationship between the width and height.
             *
             * This property is read-only and is updated automatically when either the `width` or `height` properties are changed,
             * depending on the aspect mode.
             */
            readonly aspectRatio: number;

            /**
             * The minimum allowed width.
             * Cannot be less than zero.
             * This value is read-only. To change it see the `setMin` method.
             */
            readonly minWidth: number;

            /**
             * The minimum allowed height.
             * Cannot be less than zero.
             * This value is read-only. To change it see the `setMin` method.
             */
            readonly minHeight: number;

            /**
             * The maximum allowed width.
             * This value is read-only. To change it see the `setMax` method.
             */
            readonly maxWidth: number;

            /**
             * The maximum allowed height.
             * This value is read-only. To change it see the `setMax` method.
             */
            readonly maxHeight: number;

            /**
             * A Vector2 containing the horizontal and vertical snap values, which the width and height are snapped to during resizing.
             *
             * By default this is disabled.
             *
             * This property is read-only. To change it see the `setSnap` method.
             */
            readonly snapTo: Math.Vector2;

            /**
             * Sets the aspect mode of this Size component.
             *
             * The aspect mode controls what happens when you modify the `width` or `height` properties, or call `setSize`.
             *
             * It can be a number from 0 to 4, or a Size constant:
             *
             * 0. NONE = Do not make the size fit the aspect ratio. Change the ratio when the size changes.
             * 1. WIDTH_CONTROLS_HEIGHT = The height is automatically adjusted based on the width.
             * 2. HEIGHT_CONTROLS_WIDTH = The width is automatically adjusted based on the height.
             * 3. FIT = The width and height are automatically adjusted to fit inside the given target area, while keeping the aspect ratio.
             * Depending on the aspect ratio there may be some space inside the area which is not covered.
             * 4. ENVELOP = The width and height are automatically adjusted to make the size cover the entire target area while keeping the aspect ratio.
             * This may extend further out than the target size.
             *
             * Calling this method automatically recalculates the `width` and the `height`, if required.
             * @param value The aspect mode value. Default 0.
             */
            setAspectMode(value?: integer): this;

            /**
             * By setting a Snap To value when this Size component is modified its dimensions will automatically
             * by snapped to the nearest grid slice, using floor. For example, if you have snap value of 16,
             * and the width changes to 68, then it will snap down to 64 (the closest multiple of 16 when floored)
             *
             * Note that snapping takes place before adjustments by the parent, or the min / max settings. If these
             * values are not multiples of the given snap values, then this can result in un-snapped dimensions.
             *
             * Call this method with no arguments to reset the snap values.
             *
             * Calling this method automatically recalculates the `width` and the `height`, if required.
             * @param snapWidth The amount to snap the width to. If you don't want to snap the width, pass a value of zero. Default 0.
             * @param snapHeight The amount to snap the height to. If not provided it will use the `snapWidth` value. If you don't want to snap the height, pass a value of zero. Default snapWidth.
             */
            setSnap(snapWidth?: number, snapHeight?: number): this;

            /**
             * Sets, or clears, the parent of this Size component.
             *
             * To clear the parent call this method with no arguments.
             *
             * The parent influences the maximum extents to which this Size compoent can expand,
             * based on the aspect mode:
             *
             * NONE - The parent clamps both the width and height.
             * WIDTH_CONTROLS_HEIGHT - The parent clamps just the width.
             * HEIGHT_CONTROLS_WIDTH - The parent clamps just the height.
             * FIT - The parent clamps whichever axis is required to ensure the size fits within it.
             * ENVELOP - The parent is used to ensure the size fully envelops the parent.
             *
             * Calling this method automatically calls `setSize`.
             * @param parent Sets the parent of this Size component. Don't provide a value to clear an existing parent.
             */
            setParent(parent?: any): this;

            /**
             * Set the minimum width and height values this Size component will allow.
             *
             * The minimum values can never be below zero, or greater than the maximum values.
             *
             * Setting this will automatically adjust both the `width` and `height` properties to ensure they are within range.
             *
             * Note that based on the aspect mode, and if this Size component has a parent set or not, the minimums set here
             * _can_ be exceed in some situations.
             * @param width The minimum allowed width of the Size component. Default 0.
             * @param height The minimum allowed height of the Size component. If not given, it will use the `width`. Default width.
             */
            setMin(width?: number, height?: number): this;

            /**
             * Set the maximum width and height values this Size component will allow.
             *
             * Setting this will automatically adjust both the `width` and `height` properties to ensure they are within range.
             *
             * Note that based on the aspect mode, and if this Size component has a parent set or not, the maximums set here
             * _can_ be exceed in some situations.
             * @param width The maximum allowed width of the Size component. Default Number.MAX_VALUE.
             * @param height The maximum allowed height of the Size component. If not given, it will use the `width`. Default width.
             */
            setMax(width?: number, height?: number): this;

            /**
             * Sets the width and height of this Size component based on the aspect mode.
             *
             * If the aspect mode is 'none' then calling this method will change the aspect ratio, otherwise the current
             * aspect ratio is honored across all other modes.
             *
             * If snapTo values have been set then the given width and height are snapped first, prior to any further
             * adjustment via min/max values, or a parent.
             *
             * If minimum and/or maximum dimensions have been specified, the values given to this method will be clamped into
             * that range prior to adjustment, but may still exceed them depending on the aspect mode.
             *
             * If this Size component has a parent set, and the aspect mode is `fit` or `envelop`, then the given sizes will
             * be clamped to the range specified by the parent.
             * @param width The new width of the Size component. Default 0.
             * @param height The new height of the Size component. If not given, it will use the `width`. Default width.
             */
            setSize(width?: number, height?: number): this;

            /**
             * Sets a new aspect ratio, overriding what was there previously.
             *
             * It then calls `setSize` immediately using the current dimensions.
             * @param ratio The new aspect ratio.
             */
            setAspectRatio(ratio: number): this;

            /**
             * Sets a new width and height for this Size component and updates the aspect ratio based on them.
             *
             * It _doesn't_ change the `aspectMode` and still factors in size limits such as the min max and parent bounds.
             * @param width The new width of the Size component.
             * @param height The new height of the Size component. If not given, it will use the `width`. Default width.
             */
            resize(width: number, height?: number): this;

            /**
             * Takes a new width and passes it through the min/max clamp and then checks it doesn't exceed the parent width.
             * @param value The value to clamp and check.
             * @param checkParent Check the given value against the parent, if set. Default true.
             */
            getNewWidth(value: number, checkParent?: boolean): number;

            /**
             * Takes a new height and passes it through the min/max clamp and then checks it doesn't exceed the parent height.
             * @param value The value to clamp and check.
             * @param checkParent Check the given value against the parent, if set. Default true.
             */
            getNewHeight(value: number, checkParent?: boolean): number;

            /**
             * The current `width` and `height` are adjusted to fit inside the given dimensions, while keeping the aspect ratio.
             *
             * If `fit` is true there may be some space inside the target area which is not covered if its aspect ratio differs.
             * If `fit` is false the size may extend further out than the target area if the aspect ratios differ.
             *
             * If this Size component has a parent set, then the width and height passed to this method will be clamped so
             * it cannot exceed that of the parent.
             * @param width The new width of the Size component. Default 0.
             * @param height The new height of the Size component. If not given, it will use the width value.
             * @param fit Perform a `fit` (true) constraint, or an `envelop` (false) constraint. Default true.
             */
            constrain(width?: number, height?: number, fit?: boolean): this;

            /**
             * The current `width` and `height` are adjusted to fit inside the given dimensions, while keeping the aspect ratio.
             *
             * There may be some space inside the target area which is not covered if its aspect ratio differs.
             *
             * If this Size component has a parent set, then the width and height passed to this method will be clamped so
             * it cannot exceed that of the parent.
             * @param width The new width of the Size component. Default 0.
             * @param height The new height of the Size component. If not given, it will use the width value.
             */
            fitTo(width?: number, height?: number): this;

            /**
             * The current `width` and `height` are adjusted so that they fully envlop the given dimensions, while keeping the aspect ratio.
             *
             * The size may extend further out than the target area if the aspect ratios differ.
             *
             * If this Size component has a parent set, then the values are clamped so that it never exceeds the parent
             * on the longest axis.
             * @param width The new width of the Size component. Default 0.
             * @param height The new height of the Size component. If not given, it will use the width value.
             */
            envelop(width?: number, height?: number): this;

            /**
             * Sets the width of this Size component.
             *
             * Depending on the aspect mode, changing the width may also update the height and aspect ratio.
             * @param width The new width of the Size component.
             */
            setWidth(width: number): this;

            /**
             * Sets the height of this Size component.
             *
             * Depending on the aspect mode, changing the height may also update the width and aspect ratio.
             * @param height The new height of the Size component.
             */
            setHeight(height: number): this;

            /**
             * Returns a string representation of this Size component.
             */
            toString(): string;

            /**
             * Copies the aspect mode, aspect ratio, width and height from this Size component
             * to the given Size component. Note that the parent, if set, is not copied across.
             * @param destination The Size component to copy the values to.
             */
            copy(destination: Size): Size;

            /**
             * Destroys this Size component.
             *
             * This clears the local properties and any parent object, if set.
             *
             * A destroyed Size component cannot be re-used.
             */
            destroy(): void;

            /**
             * The width of this Size component.
             *
             * This value is clamped to the range specified by `minWidth` and `maxWidth`, if enabled.
             *
             * A width can never be less than zero.
             *
             * Changing this value will automatically update the `height` if the aspect ratio lock is enabled.
             * You can also use the `setWidth` and `getWidth` methods.
             */
            width: number;

            /**
             * The height of this Size component.
             *
             * This value is clamped to the range specified by `minHeight` and `maxHeight`, if enabled.
             *
             * A height can never be less than zero.
             *
             * Changing this value will automatically update the `width` if the aspect ratio lock is enabled.
             * You can also use the `setHeight` and `getHeight` methods.
             */
            height: number;

            /**
             * Do not make the size fit the aspect ratio. Change the ratio when the size changes.
             */
            static readonly NONE: integer;

            /**
             * The height is automatically adjusted based on the width.
             */
            static readonly WIDTH_CONTROLS_HEIGHT: integer;

            /**
             * The width is automatically adjusted based on the height.
             */
            static readonly HEIGHT_CONTROLS_WIDTH: integer;

            /**
             * The width and height are automatically adjusted to fit inside the given target area, while keeping the aspect ratio.
             * Depending on the aspect ratio there may be some space inside the area which is not covered.
             */
            static readonly FIT: integer;

            /**
             * The width and height are automatically adjusted to make the size cover the entire target area while keeping the aspect ratio. This may extend further out than the target size.
             */
            static readonly ENVELOP: integer;
        }
    }

    namespace Textures {
        /**
         * A Canvas Texture is a special kind of Texture that is backed by an HTML Canvas Element as its source.
         *
         * You can use the properties of this texture to draw to the canvas element directly, using all of the standard
         * canvas operations available in the browser. Any Game Object can be given this texture and will render with it.
         *
         * Note: When running under WebGL the Canvas Texture needs to re-generate its base WebGLTexture and reupload it to
         * the GPU every time you modify it, otherwise the changes you make to this texture will not be visible. To do this
         * you should call `CanvasTexture.refresh()` once you are finished with your changes to the canvas. Try and keep
         * this to a minimum, especially on large canvas sizes, or you may inadvertently thrash the GPU by constantly uploading
         * texture data to it. This restriction does not apply if using the Canvas Renderer.
         *
         * It starts with only one frame that covers the whole of the canvas. You can add further frames, that specify
         * sections of the canvas using the `add` method.
         *
         * Should you need to resize the canvas use the `setSize` method so that it accurately updates all of the underlying
         * texture data as well. Forgetting to do this (i.e. by changing the canvas size directly from your code) could cause
         * graphical errors.
         */
        class CanvasTexture extends Texture {
            /**
             *
             * @param manager A reference to the Texture Manager this Texture belongs to.
             * @param key The unique string-based key of this Texture.
             * @param source The canvas element that is used as the base of this texture.
             * @param width The width of the canvas.
             * @param height The height of the canvas.
             */
            constructor(manager: CanvasTexture, key: string, source: HTMLCanvasElement, width: integer, height: integer);

            /**
             * The source Canvas Element.
             */
            readonly canvas: HTMLCanvasElement;

            /**
             * The 2D Canvas Rendering Context.
             */
            readonly context: CanvasRenderingContext2D;

            /**
             * The width of the Canvas.
             * This property is read-only, if you wish to change it use the `setSize` method.
             */
            readonly width: integer;

            /**
             * The height of the Canvas.
             * This property is read-only, if you wish to change it use the `setSize` method.
             */
            readonly height: integer;

            /**
             * The context image data.
             * Use the `update` method to populate this when the canvas changes.
             */
            imageData: ImageData;

            /**
             * A Uint8ClampedArray view into the `buffer`.
             * Use the `update` method to populate this when the canvas changes.
             * Note that this is unavailable in some browsers, such as Epic Browser, due to their security restrictions.
             */
            data: Uint8ClampedArray;

            /**
             * An Uint32Array view into the `buffer`.
             */
            pixels: Uint32Array;

            /**
             * An ArrayBuffer the same size as the context ImageData.
             */
            buffer: ArrayBuffer;

            /**
             * This re-creates the `imageData` from the current context.
             * It then re-builds the ArrayBuffer, the `data` Uint8ClampedArray reference and the `pixels` Int32Array.
             *
             * Warning: This is a very expensive operation, so use it sparingly.
             */
            update(): CanvasTexture;

            /**
             * Draws the given Image or Canvas element to this CanvasTexture, then updates the internal
             * ImageData buffer and arrays.
             * @param x The x coordinate to draw the source at.
             * @param y The y coordinate to draw the source at.
             * @param source The element to draw to this canvas.
             */
            draw(x: integer, y: integer, source: HTMLImageElement | HTMLCanvasElement): CanvasTexture;

            /**
             * Draws the given texture frame to this CanvasTexture, then updates the internal
             * ImageData buffer and arrays.
             * @param key The unique string-based key of the Texture.
             * @param frame The string-based name, or integer based index, of the Frame to get from the Texture.
             * @param x The x coordinate to draw the source at. Default 0.
             * @param y The y coordinate to draw the source at. Default 0.
             */
            drawFrame(key: string, frame?: string | integer, x?: integer, y?: integer): CanvasTexture;

            /**
             * Sets a pixel in the CanvasTexture to the given color and alpha values.
             *
             * This is an expensive operation to run in large quantities, so use sparingly.
             * @param x The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
             * @param y The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
             * @param red The red color value. A number between 0 and 255.
             * @param green The green color value. A number between 0 and 255.
             * @param blue The blue color value. A number between 0 and 255.
             * @param alpha The alpha value. A number between 0 and 255. Default 255.
             */
            setPixel(x: integer, y: integer, red: integer, green: integer, blue: integer, alpha?: integer): this;

            /**
             * Puts the ImageData into the context of this CanvasTexture at the given coordinates.
             * @param imageData The ImageData to put at the given location.
             * @param x The x coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.
             * @param y The y coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.
             */
            putData(imageData: ImageData, x: integer, y: integer): this;

            /**
             * Gets an ImageData region from this CanvasTexture from the position and size specified.
             * You can write this back using `CanvasTexture.putData`, or manipulate it.
             * @param x The x coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.
             * @param y The y coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.
             * @param width The width of the region to get. Must be an integer.
             * @param height The height of the region to get. Must be an integer.
             */
            getData(x: integer, y: integer, width: integer, height: integer): ImageData;

            /**
             * Get the color of a specific pixel from this texture and store it in a Color object.
             *
             * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,
             * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.
             * @param x The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
             * @param y The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
             * @param out A Color object to store the pixel values in. If not provided a new Color object will be created.
             */
            getPixel(x: integer, y: integer, out?: Display.Color): Display.Color;

            /**
             * Returns an array containing all of the pixels in the given region.
             *
             * If the requested region extends outside the bounds of this CanvasTexture,
             * the region is truncated to fit.
             *
             * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,
             * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.
             * @param x The x coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.
             * @param y The y coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.
             * @param width The width of the region to get. Must be an integer.
             * @param height The height of the region to get. Must be an integer. If not given will be set to the `width`.
             */
            getPixels(x: integer, y: integer, width: integer, height?: integer): PixelConfig[];

            /**
             * Returns the Image Data index for the given pixel in this CanvasTexture.
             *
             * The index can be used to read directly from the `this.data` array.
             *
             * The index points to the red value in the array. The subsequent 3 indexes
             * point to green, blue and alpha respectively.
             * @param x The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
             * @param y The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.
             */
            getIndex(x: integer, y: integer): integer;

            /**
             * This should be called manually if you are running under WebGL.
             * It will refresh the WebGLTexture from the Canvas source. Only call this if you know that the
             * canvas has changed, as there is a significant GPU texture allocation cost involved in doing so.
             */
            refresh(): CanvasTexture;

            /**
             * Gets the Canvas Element.
             */
            getCanvas(): HTMLCanvasElement;

            /**
             * Gets the 2D Canvas Rendering Context.
             */
            getContext(): CanvasRenderingContext2D;

            /**
             * Clears the given region of this Canvas Texture, resetting it back to transparent.
             * If no region is given, the whole Canvas Texture is cleared.
             * @param x The x coordinate of the top-left of the region to clear. Default 0.
             * @param y The y coordinate of the top-left of the region to clear. Default 0.
             * @param width The width of the region.
             * @param height The height of the region.
             */
            clear(x?: integer, y?: integer, width?: integer, height?: integer): CanvasTexture;

            /**
             * Changes the size of this Canvas Texture.
             * @param width The new width of the Canvas.
             * @param height The new height of the Canvas. If not given it will use the width as the height.
             */
            setSize(width: integer, height?: integer): CanvasTexture;

            /**
             * Destroys this Texture and releases references to its sources and frames.
             */
            destroy(): void;
        }

        /**
         * Filter types.
         */
        enum FilterMode {
            /**
             * Linear filter interface.
             */
            LINEAR,
            /**
             * Nearest neighbor filter interface.
             */
            NEAREST
        }

        namespace Events {
            /**
             * The Texture Add Event.
             *
             * This event is dispatched by the Texture Manager when a texture is added to it.
             *
             * Listen to this event from within a Scene using: `this.textures.on('addtexture', listener)`.
             */
            const ADD: any;

            /**
             * The Texture Load Error Event.
             *
             * This event is dispatched by the Texture Manager when a texture it requested to load failed.
             * This only happens when base64 encoded textures fail. All other texture types are loaded via the Loader Plugin.
             *
             * Listen to this event from within a Scene using: `this.textures.on('onerror', listener)`.
             */
            const ERROR: any;

            /**
             * The Texture Load Event.
             *
             * This event is dispatched by the Texture Manager when a texture has finished loading on it.
             * This only happens for base64 encoded textures. All other texture types are loaded via the Loader Plugin.
             *
             * Listen to this event from within a Scene using: `this.textures.on('onload', listener)`.
             *
             * This event is dispatched after the [ADD]{@linkcode Phaser.Textures.Events#event:ADD} event.
             */
            const LOAD: any;

            /**
             * This internal event signifies that the Texture Manager is now ready and the Game can continue booting.
             *
             * When a Phaser Game instance is booting for the first time, the Texture Manager has to wait on a couple of non-blocking
             * async events before it's fully ready to carry on. When those complete the Texture Manager emits this event via the Game
             * instance, which tells the Game to carry on booting.
             */
            const READY: any;

            /**
             * The Texture Remove Event.
             *
             * This event is dispatched by the Texture Manager when a texture is removed from it.
             *
             * Listen to this event from within a Scene using: `this.textures.on('removetexture', listener)`.
             *
             * If you have any Game Objects still using the removed texture, they will start throwing
             * errors the next time they try to render. Be sure to clear all use of the texture in this event handler.
             */
            const REMOVE: any;
        }

        /**
         * A Frame is a section of a Texture.
         */
        class Frame {
            /**
             *
             * @param texture The Texture this Frame is a part of.
             * @param name The name of this Frame. The name is unique within the Texture.
             * @param sourceIndex The index of the TextureSource that this Frame is a part of.
             * @param x The x coordinate of the top-left of this Frame.
             * @param y The y coordinate of the top-left of this Frame.
             * @param width The width of this Frame.
             * @param height The height of this Frame.
             */
            constructor(texture: Texture, name: integer | string, sourceIndex: integer, x: number, y: number, width: number, height: number);

            /**
             * The Texture this Frame is a part of.
             */
            texture: Texture;

            /**
             * The name of this Frame.
             * The name is unique within the Texture.
             */
            name: string;

            /**
             * The TextureSource this Frame is part of.
             */
            source: TextureSource;

            /**
             * The index of the TextureSource in the Texture sources array.
             */
            sourceIndex: integer;

            /**
             * A reference to the Texture Source WebGL Texture that this Frame is using.
             */
            glTexture: WebGLTexture;

            /**
             * X position within the source image to cut from.
             */
            cutX: integer;

            /**
             * Y position within the source image to cut from.
             */
            cutY: integer;

            /**
             * The width of the area in the source image to cut.
             */
            cutWidth: integer;

            /**
             * The height of the area in the source image to cut.
             */
            cutHeight: integer;

            /**
             * The X rendering offset of this Frame, taking trim into account.
             */
            x: integer;

            /**
             * The Y rendering offset of this Frame, taking trim into account.
             */
            y: integer;

            /**
             * The rendering width of this Frame, taking trim into account.
             */
            width: integer;

            /**
             * The rendering height of this Frame, taking trim into account.
             */
            height: integer;

            /**
             * Half the width, floored.
             * Precalculated for the renderer.
             */
            halfWidth: integer;

            /**
             * Half the height, floored.
             * Precalculated for the renderer.
             */
            halfHeight: integer;

            /**
             * The x center of this frame, floored.
             */
            centerX: integer;

            /**
             * The y center of this frame, floored.
             */
            centerY: integer;

            /**
             * The horizontal pivot point of this Frame.
             */
            pivotX: number;

            /**
             * The vertical pivot point of this Frame.
             */
            pivotY: number;

            /**
             * Does this Frame have a custom pivot point?
             */
            customPivot: boolean;

            /**
             * **CURRENTLY UNSUPPORTED**
             *
             * Is this frame is rotated or not in the Texture?
             * Rotation allows you to use rotated frames in texture atlas packing.
             * It has nothing to do with Sprite rotation.
             */
            rotated: boolean;

            /**
             * Over-rides the Renderer setting.
             * -1 = use Renderer Setting
             * 0 = No rounding
             * 1 = Round
             */
            autoRound: integer;

            /**
             * Any Frame specific custom data can be stored here.
             */
            customData: object;

            /**
             * WebGL UV u0 value.
             */
            u0: number;

            /**
             * WebGL UV v0 value.
             */
            v0: number;

            /**
             * WebGL UV u1 value.
             */
            u1: number;

            /**
             * WebGL UV v1 value.
             */
            v1: number;

            /**
             * Sets the width, height, x and y of this Frame.
             *
             * This is called automatically by the constructor
             * and should rarely be changed on-the-fly.
             * @param width The width of the frame before being trimmed.
             * @param height The height of the frame before being trimmed.
             * @param x The x coordinate of the top-left of this Frame. Default 0.
             * @param y The y coordinate of the top-left of this Frame. Default 0.
             */
            setSize(width: integer, height: integer, x?: integer, y?: integer): Frame;

            /**
             * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.
             * @param actualWidth The width of the frame before being trimmed.
             * @param actualHeight The height of the frame before being trimmed.
             * @param destX The destination X position of the trimmed frame for display.
             * @param destY The destination Y position of the trimmed frame for display.
             * @param destWidth The destination width of the trimmed frame for display.
             * @param destHeight The destination height of the trimmed frame for display.
             */
            setTrim(actualWidth: number, actualHeight: number, destX: number, destY: number, destWidth: number, destHeight: number): Frame;

            /**
             * Takes a crop data object and, based on the rectangular region given, calculates the
             * required UV coordinates in order to crop this Frame for WebGL and Canvas rendering.
             *
             * This is called directly by the Game Object Texture Components `setCrop` method.
             * Please use that method to crop a Game Object.
             * @param crop The crop data object. This is the `GameObject._crop` property.
             * @param x The x coordinate to start the crop from. Cannot be negative or exceed the Frame width.
             * @param y The y coordinate to start the crop from. Cannot be negative or exceed the Frame height.
             * @param width The width of the crop rectangle. Cannot exceed the Frame width.
             * @param height The height of the crop rectangle. Cannot exceed the Frame height.
             * @param flipX Does the parent Game Object have flipX set?
             * @param flipY Does the parent Game Object have flipY set?
             */
            setCropUVs(crop: object, x: number, y: number, width: number, height: number, flipX: boolean, flipY: boolean): object;

            /**
             * Takes a crop data object and recalculates the UVs based on the dimensions inside the crop object.
             * Called automatically by `setFrame`.
             * @param crop The crop data object. This is the `GameObject._crop` property.
             * @param flipX Does the parent Game Object have flipX set?
             * @param flipY Does the parent Game Object have flipY set?
             */
            updateCropUVs(crop: object, flipX: boolean, flipY: boolean): object;

            /**
             * Updates the internal WebGL UV cache and the drawImage cache.
             */
            updateUVs(): Frame;

            /**
             * Updates the internal WebGL UV cache.
             */
            updateUVsInverted(): Frame;

            /**
             * Clones this Frame into a new Frame object.
             */
            clone(): Frame;

            /**
             * Destroys this Frames references.
             */
            destroy(): void;

            /**
             * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
             * before being packed.
             */
            readonly realWidth: number;

            /**
             * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
             * before being packed.
             */
            readonly realHeight: number;

            /**
             * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)
             */
            readonly radius: number;

            /**
             * Is the Frame trimmed or not?
             */
            readonly trimmed: boolean;

            /**
             * The Canvas drawImage data object.
             */
            readonly canvasData: object;
        }

        /**
         * Linear filter interface.
         */
        const LINEAR: any;

        /**
         * Nearest Neighbor filter interface.
         */
        const NEAREST: any;

        namespace Parsers {}

        /**
         * A Texture consists of a source, usually an Image from the Cache, and a collection of Frames.
         * The Frames represent the different areas of the Texture. For example a texture atlas
         * may have many Frames, one for each element within the atlas. Where-as a single image would have
         * just one frame, that encompasses the whole image.
         *
         * Textures are managed by the global TextureManager. This is a singleton class that is
         * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
         *
         * Sprites and other Game Objects get the texture data they need from the TextureManager.
         */
        class Texture {
            /**
             *
             * @param manager A reference to the Texture Manager this Texture belongs to.
             * @param key The unique string-based key of this Texture.
             * @param source An array of sources that are used to create the texture. Usually Images, but can also be a Canvas.
             * @param width The width of the Texture. This is optional and automatically derived from the source images.
             * @param height The height of the Texture. This is optional and automatically derived from the source images.
             */
            constructor(manager: TextureManager, key: string, source: HTMLImageElement | HTMLCanvasElement | HTMLImageElement[] | HTMLCanvasElement[], width?: number, height?: number);

            /**
             * A reference to the Texture Manager this Texture belongs to.
             */
            manager: TextureManager;

            /**
             * The unique string-based key of this Texture.
             */
            key: string;

            /**
             * An array of TextureSource instances.
             * These are unique to this Texture and contain the actual Image (or Canvas) data.
             */
            source: TextureSource[];

            /**
             * An array of TextureSource data instances.
             * Used to store additional data images, such as normal maps or specular maps.
             */
            dataSource: any[];

            /**
             * A key-value object pair associating the unique Frame keys with the Frames objects.
             */
            frames: object;

            /**
             * Any additional data that was set in the source JSON (if any),
             * or any extra data you'd like to store relating to this texture
             */
            customData: object;

            /**
             * The name of the first frame of the Texture.
             */
            firstFrame: string;

            /**
             * The total number of Frames in this Texture.
             */
            frameTotal: integer;

            /**
             * Adds a new Frame to this Texture.
             *
             * A Frame is a rectangular region of a TextureSource with a unique index or string-based key.
             * @param name The name of this Frame. The name is unique within the Texture.
             * @param sourceIndex The index of the TextureSource that this Frame is a part of.
             * @param x The x coordinate of the top-left of this Frame.
             * @param y The y coordinate of the top-left of this Frame.
             * @param width The width of this Frame.
             * @param height The height of this Frame.
             */
            add(name: integer | string, sourceIndex: integer, x: number, y: number, width: number, height: number): Frame;

            /**
             * Checks to see if a Frame matching the given key exists within this Texture.
             * @param name The key of the Frame to check for.
             */
            has(name: string): boolean;

            /**
             * Gets a Frame from this Texture based on either the key or the index of the Frame.
             *
             * In a Texture Atlas Frames are typically referenced by a key.
             * In a Sprite Sheet Frames are referenced by an index.
             * Passing no value for the name returns the base texture.
             * @param name The string-based name, or integer based index, of the Frame to get from this Texture.
             */
            get(name?: string | integer): Frame;

            /**
             * Takes the given TextureSource and returns the index of it within this Texture.
             * If it's not in this Texture, it returns -1.
             * Unless this Texture has multiple TextureSources, such as with a multi-atlas, this
             * method will always return zero or -1.
             * @param source The TextureSource to check.
             */
            getTextureSourceIndex(source: TextureSource): integer;

            /**
             * Returns an array of all the Frames in the given TextureSource.
             * @param sourceIndex The index of the TextureSource to get the Frames from.
             * @param includeBase Include the `__BASE` Frame in the output array? Default false.
             */
            getFramesFromTextureSource(sourceIndex: integer, includeBase?: boolean): Frame[];

            /**
             * Returns an array with all of the names of the Frames in this Texture.
             *
             * Useful if you want to randomly assign a Frame to a Game Object, as you can
             * pick a random element from the returned array.
             * @param includeBase Include the `__BASE` Frame in the output array? Default false.
             */
            getFrameNames(includeBase?: boolean): string[];

            /**
             * Given a Frame name, return the source image it uses to render with.
             *
             * This will return the actual DOM Image or Canvas element.
             * @param name The string-based name, or integer based index, of the Frame to get from this Texture.
             */
            getSourceImage(name?: string | integer): HTMLImageElement | HTMLCanvasElement | GameObjects.RenderTexture;

            /**
             * Given a Frame name, return the data source image it uses to render with.
             * You can use this to get the normal map for an image for example.
             *
             * This will return the actual DOM Image.
             * @param name The string-based name, or integer based index, of the Frame to get from this Texture.
             */
            getDataSourceImage(name?: string | integer): HTMLImageElement | HTMLCanvasElement;

            /**
             * Adds a data source image to this Texture.
             *
             * An example of a data source image would be a normal map, where all of the Frames for this Texture
             * equally apply to the normal map.
             * @param data The source image.
             */
            setDataSource(data: HTMLImageElement | HTMLCanvasElement | HTMLImageElement[] | HTMLCanvasElement[]): void;

            /**
             * Sets the Filter Mode for this Texture.
             *
             * The mode can be either Linear, the default, or Nearest.
             *
             * For pixel-art you should use Nearest.
             *
             * The mode applies to the entire Texture, not just a specific Frame of it.
             * @param filterMode The Filter Mode.
             */
            setFilter(filterMode: FilterMode): void;

            /**
             * Destroys this Texture and releases references to its sources and frames.
             */
            destroy(): void;
        }

        /**
         * Textures are managed by the global TextureManager. This is a singleton class that is
         * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
         *
         * Sprites and other Game Objects get the texture data they need from the TextureManager.
         *
         * Access it via `scene.textures`.
         */
        class TextureManager extends Phaser.Events.EventEmitter {
            /**
             *
             * @param game The Phaser.Game instance this Texture Manager belongs to.
             */
            constructor(game: Game);

            /**
             * The Game that this TextureManager belongs to.
             */
            game: Game;

            /**
             * The name of this manager.
             */
            name: string;

            /**
             * An object that has all of textures that Texture Manager creates.
             * Textures are assigned to keys so we can access to any texture that this object has directly by key value without iteration.
             */
            list: object;

            /**
             * Checks the given texture key and throws a console.warn if the key is already in use, then returns false.
             * If you wish to avoid the console.warn then use `TextureManager.exists` instead.
             * @param key The texture key to check.
             */
            checkKey(key: string): boolean;

            /**
             * Removes a Texture from the Texture Manager and destroys it. This will immediately
             * clear all references to it from the Texture Manager, and if it has one, destroy its
             * WebGLTexture. This will emit a `removetexture` event.
             *
             * Note: If you have any Game Objects still using this texture they will start throwing
             * errors the next time they try to render. Make sure that removing the texture is the final
             * step when clearing down to avoid this.
             * @param key The key of the Texture to remove, or a reference to it.
             */
            remove(key: string | Texture): TextureManager;

            /**
             * Adds a new Texture to the Texture Manager created from the given Base64 encoded data.
             * @param key The unique string-based key of the Texture.
             * @param data The Base64 encoded data.
             */
            addBase64(key: string, data: any): this;

            /**
             * Gets an existing texture frame and converts it into a base64 encoded image and returns the base64 data.
             *
             * You can also provide the image interface and encoder options.
             * @param key The unique string-based key of the Texture.
             * @param frame The string-based name, or integer based index, of the Frame to get from the Texture.
             * @param interface [description] Default 'image/png'.
             * @param encoderOptions [description] Default 0.92.
             */
            getBase64(key: string, frame?: string | integer, interface?: string, encoderOptions?: number): string;

            /**
             * Adds a new Texture to the Texture Manager created from the given Image element.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param dataSource An optional data Image element.
             */
            addImage(key: string, source: HTMLImageElement, dataSource?: HTMLImageElement | HTMLCanvasElement): Texture;

            /**
             * Adds a Render Texture to the Texture Manager using the given key.
             * This allows you to then use the Render Texture as a normal texture for texture based Game Objects like Sprites.
             * @param key The unique string-based key of the Texture.
             * @param renderTexture The source Render Texture.
             */
            addRenderTexture(key: string, renderTexture: GameObjects.RenderTexture): Texture;

            /**
             * Creates a new Texture using the given config values.
             * Generated textures consist of a Canvas element to which the texture data is drawn.
             * See the Phaser.Create function for the more direct way to create textures.
             * @param key The unique string-based key of the Texture.
             * @param config The configuration object needed to generate the texture.
             */
            generate(key: string, config: object): Texture;

            /**
             * Creates a new Texture using a blank Canvas element of the size given.
             *
             * Canvas elements are automatically pooled and calling this method will
             * extract a free canvas from the CanvasPool, or create one if none are available.
             * @param key The unique string-based key of the Texture.
             * @param width The width of the Canvas element. Default 256.
             * @param height The height of the Canvas element. Default 256.
             */
            createCanvas(key: string, width?: integer, height?: integer): CanvasTexture;

            /**
             * Creates a new Canvas Texture object from an existing Canvas element
             * and adds it to this Texture Manager, unless `skipCache` is true.
             * @param key The unique string-based key of the Texture.
             * @param source The Canvas element to form the base of the new Texture.
             * @param skipCache Skip adding this Texture into the Cache? Default false.
             */
            addCanvas(key: string, source: HTMLCanvasElement, skipCache?: boolean): CanvasTexture;

            /**
             * Adds a new Texture Atlas to this Texture Manager.
             * It can accept either JSON Array or JSON Hash formats, as exported by Texture Packer and similar software.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param data The Texture Atlas data.
             * @param dataSource An optional data Image element.
             */
            addAtlas(key: string, source: HTMLImageElement, data: object, dataSource?: HTMLImageElement | HTMLCanvasElement | HTMLImageElement[] | HTMLCanvasElement[]): Texture;

            /**
             * Adds a Texture Atlas to this Texture Manager.
             * The frame data of the atlas must be stored in an Array within the JSON.
             * This is known as a JSON Array in software such as Texture Packer.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element/s.
             * @param data The Texture Atlas data/s.
             * @param dataSource An optional data Image element.
             */
            addAtlasJSONArray(
                key: string,
                source: HTMLImageElement | HTMLImageElement[],
                data: object | object[],
                dataSource?: HTMLImageElement | HTMLCanvasElement | HTMLImageElement[] | HTMLCanvasElement[]
            ): Texture;

            /**
             * Adds a Texture Atlas to this Texture Manager.
             * The frame data of the atlas must be stored in an Object within the JSON.
             * This is known as a JSON Hash in software such as Texture Packer.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param data The Texture Atlas data.
             * @param dataSource An optional data Image element.
             */
            addAtlasJSONHash(key: string, source: HTMLImageElement, data: object, dataSource?: HTMLImageElement | HTMLCanvasElement | HTMLImageElement[] | HTMLCanvasElement[]): Texture;

            /**
             * Adds a Texture Atlas to this Texture Manager, where the atlas data is given
             * in the XML format.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param data The Texture Atlas XML data.
             * @param dataSource An optional data Image element.
             */
            addAtlasXML(key: string, source: HTMLImageElement, data: object, dataSource?: HTMLImageElement | HTMLCanvasElement | HTMLImageElement[] | HTMLCanvasElement[]): Texture;

            /**
             * Adds a Unity Texture Atlas to this Texture Manager.
             * The data must be in the form of a Unity YAML file.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param data The Texture Atlas data.
             * @param dataSource An optional data Image element.
             */
            addUnityAtlas(key: string, source: HTMLImageElement, data: object, dataSource?: HTMLImageElement | HTMLCanvasElement | HTMLImageElement[] | HTMLCanvasElement[]): Texture;

            /**
             * Adds a Sprite Sheet to this Texture Manager.
             *
             * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact
             * same size and cannot be trimmed or rotated.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param config The configuration object for this Sprite Sheet.
             */
            addSpriteSheet(key: string, source: HTMLImageElement, config: SpriteSheetConfig): Texture;

            /**
             * Adds a Sprite Sheet to this Texture Manager, where the Sprite Sheet exists as a Frame within a Texture Atlas.
             *
             * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact
             * same size and cannot be trimmed or rotated.
             * @param key The unique string-based key of the Texture.
             * @param config The configuration object for this Sprite Sheet.
             */
            addSpriteSheetFromAtlas(key: string, config: SpriteSheetFromAtlasConfig): Texture;

            /**
             * Creates a new Texture using the given source and dimensions.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param width The width of the Texture.
             * @param height The height of the Texture.
             */
            create(key: string, source: HTMLImageElement, width: integer, height: integer): Texture;

            /**
             * Checks the given key to see if a Texture using it exists within this Texture Manager.
             * @param key The unique string-based key of the Texture.
             */
            exists(key: string): boolean;

            /**
             * Returns a Texture from the Texture Manager that matches the given key.
             * If the key is undefined it will return the `__DEFAULT` Texture.
             * If the key is given, but not found, it will return the `__MISSING` Texture.
             * @param key The unique string-based key of the Texture.
             */
            get(key: string): Texture;

            /**
             * Takes a Texture key and Frame name and returns a clone of that Frame if found.
             * @param key The unique string-based key of the Texture.
             * @param frame The string or index of the Frame to be cloned.
             */
            cloneFrame(key: string, frame: string | integer): Frame;

            /**
             * Takes a Texture key and Frame name and returns a reference to that Frame, if found.
             * @param key The unique string-based key of the Texture.
             * @param frame The string-based name, or integer based index, of the Frame to get from the Texture.
             */
            getFrame(key: string, frame?: string | integer): Frame;

            /**
             * Returns an array with all of the keys of all Textures in this Texture Manager.
             * The output array will exclude the `__DEFAULT` and `__MISSING` keys.
             */
            getTextureKeys(): string[];

            /**
             * Given a Texture and an `x` and `y` coordinate this method will return a new
             * Color object that has been populated with the color and alpha values of the pixel
             * at that location in the Texture.
             * @param x The x coordinate of the pixel within the Texture.
             * @param y The y coordinate of the pixel within the Texture.
             * @param key The unique string-based key of the Texture.
             * @param frame The string or index of the Frame.
             */
            getPixel(x: integer, y: integer, key: string, frame?: string | integer): Display.Color;

            /**
             * Given a Texture and an `x` and `y` coordinate this method will return a value between 0 and 255
             * corresponding to the alpha value of the pixel at that location in the Texture. If the coordinate
             * is out of bounds it will return null.
             * @param x The x coordinate of the pixel within the Texture.
             * @param y The y coordinate of the pixel within the Texture.
             * @param key The unique string-based key of the Texture.
             * @param frame The string or index of the Frame.
             */
            getPixelAlpha(x: integer, y: integer, key: string, frame?: string | integer): integer;

            /**
             * Sets the given Game Objects `texture` and `frame` properties so that it uses
             * the Texture and Frame specified in the `key` and `frame` arguments to this method.
             * @param gameObject The Game Object the texture would be set on.
             * @param key The unique string-based key of the Texture.
             * @param frame The string or index of the Frame.
             */
            setTexture(gameObject: GameObjects.GameObject, key: string, frame?: string | integer): GameObjects.GameObject;

            /**
             * Changes the key being used by a Texture to the new key provided.
             *
             * The old key is removed, allowing it to be re-used.
             *
             * Game Objects are linked to Textures by a reference to the Texture object, so
             * all existing references will be retained.
             * @param currentKey The current string-based key of the Texture you wish to rename.
             * @param newKey The new unique string-based key to use for the Texture.
             */
            renameTexture(currentKey: string, newKey: string): boolean;

            /**
             * Passes all Textures to the given callback.
             * @param callback The callback function to be sent the Textures.
             * @param scope The value to use as `this` when executing the callback.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            each(callback: EachTextureCallback, scope: object, ...args: any[]): void;

            /**
             * Destroys the Texture Manager and all Textures stored within it.
             */
            destroy(): void;
        }

        /**
         * A Texture Source is the encapsulation of the actual source data for a Texture.
         * This is typically an Image Element, loaded from the file system or network, or a Canvas Element.
         *
         * A Texture can contain multiple Texture Sources, which only happens when a multi-atlas is loaded.
         */
        class TextureSource {
            /**
             *
             * @param texture The Texture this TextureSource belongs to.
             * @param source The source image data.
             * @param width Optional width of the source image. If not given it's derived from the source itself.
             * @param height Optional height of the source image. If not given it's derived from the source itself.
             */
            constructor(texture: Texture, source: HTMLImageElement | HTMLCanvasElement, width?: integer, height?: integer);

            /**
             * The Texture this TextureSource belongs to.
             */
            renderer: Renderer.Canvas.CanvasRenderer | Renderer.WebGL.WebGLRenderer;

            /**
             * The Texture this TextureSource belongs to.
             */
            texture: Texture;

            /**
             * The source of the image data.
             * This is either an Image Element, a Canvas Element or a RenderTexture.
             */
            source: HTMLImageElement | HTMLCanvasElement | GameObjects.RenderTexture;

            /**
             * The image data.
             * This is either an Image element or a Canvas element.
             */
            image: HTMLImageElement | HTMLCanvasElement;

            /**
             * Currently un-used.
             */
            compressionAlgorithm: integer;

            /**
             * The resolution of the source image.
             */
            resolution: number;

            /**
             * The width of the source image. If not specified in the constructor it will check
             * the `naturalWidth` and then `width` properties of the source image.
             */
            width: integer;

            /**
             * The height of the source image. If not specified in the constructor it will check
             * the `naturalHeight` and then `height` properties of the source image.
             */
            height: integer;

            /**
             * The Scale Mode the image will use when rendering.
             * Either Linear or Nearest.
             */
            scaleMode: number;

            /**
             * Is the source image a Canvas Element?
             */
            isCanvas: boolean;

            /**
             * Is the source image a Render Texture?
             */
            isRenderTexture: boolean;

            /**
             * Are the source image dimensions a power of two?
             */
            isPowerOf2: boolean;

            /**
             * The WebGL Texture of the source image.
             */
            glTexture: WebGLTexture;

            /**
             * Creates a WebGL Texture, if required, and sets the Texture filter mode.
             * @param game A reference to the Phaser Game instance.
             */
            init(game: Game): void;

            /**
             * Sets the Filter Mode for this Texture.
             *
             * The mode can be either Linear, the default, or Nearest.
             *
             * For pixel-art you should use Nearest.
             * @param filterMode The Filter Mode.
             */
            setFilter(filterMode: FilterMode): void;

            /**
             * If this TextureSource is backed by a Canvas and is running under WebGL,
             * it updates the WebGLTexture using the canvas data.
             */
            update(): void;

            /**
             * Destroys this Texture Source and nulls the references.
             */
            destroy(): void;
        }
    }

    namespace Tilemaps {
        namespace Components {}

        /**
         * A Dynamic Tilemap Layer is a Game Object that renders LayerData from a Tilemap when used in combination
         * with one, or more, Tilesets.
         *
         * A Dynamic Tilemap Layer trades some speed for being able to apply powerful effects. Unlike a
         * Static Tilemap Layer, you can apply per-tile effects like tint or alpha, and you can change the
         * tiles in a DynamicTilemapLayer.
         *
         * Use this over a Static Tilemap Layer when you need those features.
         */
        class DynamicTilemapLayer extends GameObjects.GameObject
            implements
                GameObjects.Components.Alpha,
                GameObjects.Components.BlendMode,
                GameObjects.Components.ComputedSize,
                GameObjects.Components.Depth,
                GameObjects.Components.Flip,
                GameObjects.Components.GetBounds,
                GameObjects.Components.Origin,
                GameObjects.Components.Pipeline,
                GameObjects.Components.ScaleMode,
                GameObjects.Components.ScrollFactor,
                GameObjects.Components.Transform,
                GameObjects.Components.Visible {
            /**
             *
             * @param scene The Scene to which this Game Object belongs.
             * @param tilemap The Tilemap this layer is a part of.
             * @param layerIndex The index of the LayerData associated with this layer.
             * @param tileset The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.
             * @param x The world x position where the top left of this layer will be placed. Default 0.
             * @param y The world y position where the top left of this layer will be placed. Default 0.
             */
            constructor(scene: Scene, tilemap: Tilemap, layerIndex: integer, tileset: string | string[] | Tileset | Tileset[], x?: number, y?: number);

            /**
             * Used internally by physics system to perform fast interface checks.
             */
            readonly isTilemap: boolean;

            /**
             * The Tilemap that this layer is a part of.
             */
            tilemap: Tilemap;

            /**
             * The index of the LayerData associated with this layer.
             */
            layerIndex: integer;

            /**
             * The LayerData associated with this layer. LayerData can only be associated with one
             * tilemap layer.
             */
            layer: LayerData;

            /**
             * The Tileset/s associated with this layer.
             *
             * As of Phaser 3.14 this property is now an array of Tileset objects, previously it was a single reference.
             */
            tileset: Tileset[];

            /**
             * Used internally with the canvas render. This holds the tiles that are visible within the
             * camera.
             */
            culledTiles: any[];

            /**
             * You can control if the Cameras should cull tiles before rendering them or not.
             * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.
             *
             * However, there are some instances when you may wish to disable this, and toggling this flag allows
             * you to do so. Also see `setSkipCull` for a chainable method that does the same thing.
             */
            skipCull: boolean;

            /**
             * The total number of tiles drawn by the renderer in the last frame.
             */
            readonly tilesDrawn: integer;

            /**
             * The total number of tiles in this layer. Updated every frame.
             */
            readonly tilesTotal: integer;

            /**
             * The amount of extra tiles to add into the cull rectangle when calculating its horizontal size.
             *
             * See the method `setCullPadding` for more details.
             */
            cullPaddingX: integer;

            /**
             * The amount of extra tiles to add into the cull rectangle when calculating its vertical size.
             *
             * See the method `setCullPadding` for more details.
             */
            cullPaddingY: integer;

            /**
             * The callback that is invoked when the tiles are culled.
             *
             * By default it will call `TilemapComponents.CullTiles` but you can override this to call any function you like.
             *
             * It will be sent 3 arguments:
             *
             * 1. The Phaser.Tilemaps.LayerData object for this Layer
             * 2. The Camera that is culling the layer. You can check its `dirty` property to see if it has changed since the last cull.
             * 3. A reference to the `culledTiles` array, which should be used to store the tiles you want rendered.
             *
             * See the `TilemapComponents.CullTiles` source code for details on implementing your own culling system.
             */
            cullCallback: CallbackFn;

            /**
             * An array holding the mapping between the tile indexes and the tileset they belong to.
             */
            gidMap: Tileset[];

            /**
             * Sets the rendering (draw) order of the tiles in this layer.
             *
             * The default is 'right-down', meaning it will order the tiles starting from the top-left,
             * drawing to the right and then moving down to the next row.
             *
             * The draw orders are:
             *
             * 0 = right-down
             * 1 = left-down
             * 2 = right-up
             * 3 = left-up
             *
             * Setting the render order does not change the tiles or how they are stored in the layer,
             * it purely impacts the order in which they are rendered.
             *
             * You can provide either an integer (0 to 3), or the string version of the order.
             * @param renderOrder The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.
             */
            setRenderOrder(renderOrder: integer | string): this;

            /**
             * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting
             * faces are used internally for optimizing collisions against tiles. This method is mostly used
             * internally to optimize recalculating faces when only one tile has been changed.
             * @param tileX The x coordinate.
             * @param tileY The y coordinate.
             */
            calculateFacesAt(tileX: integer, tileY: integer): DynamicTilemapLayer;

            /**
             * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the
             * layer. Interesting faces are used internally for optimizing collisions against tiles. This method
             * is mostly used internally.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             */
            calculateFacesWithin(tileX?: integer, tileY?: integer, width?: integer, height?: integer): DynamicTilemapLayer;

            /**
             * Creates a Sprite for every object matching the given tile indexes in the layer. You can
             * optionally specify if each tile will be replaced with a new tile after the Sprite has been
             * created. This is useful if you want to lay down special tiles in a level that are converted to
             * Sprites, but want to replace the tile itself with a floor tile or similar once converted.
             * @param indexes The tile index, or array of indexes, to create Sprites from.
             * @param replacements The tile index, or array of indexes, to change a converted
             * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a
             * one-to-one mapping with the indexes array.
             * @param spriteConfig The config object to pass into the Sprite creator (i.e.
             * scene.make.sprite).
             * @param scene The Scene to create the Sprites within. Default scene the map is within.
             * @param camera The Camera to use when determining the world XY Default main camera.
             */
            createFromTiles(indexes: integer | integer[], replacements: integer | integer[], spriteConfig: SpriteConfig, scene?: Scene, camera?: Cameras.Scene2D.Camera): GameObjects.Sprite[];

            /**
             * Returns the tiles in the given layer that are within the cameras viewport.
             * This is used internally.
             * @param camera The Camera to run the cull check against.
             */
            cull(camera?: Cameras.Scene2D.Camera): Tile[];

            /**
             * Copies the tiles in the source rectangular area to a new destination (all specified in tile
             * coordinates) within the layer. This copies all tile properties & recalculates collision
             * information in the destination region.
             * @param srcTileX The x coordinate of the area to copy from, in tiles, not pixels.
             * @param srcTileY The y coordinate of the area to copy from, in tiles, not pixels.
             * @param width The width of the area to copy, in tiles, not pixels.
             * @param height The height of the area to copy, in tiles, not pixels.
             * @param destTileX The x coordinate of the area to copy to, in tiles, not pixels.
             * @param destTileY The y coordinate of the area to copy to, in tiles, not pixels.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             */
            copy(srcTileX: integer, srcTileY: integer, width: integer, height: integer, destTileX: integer, destTileY: integer, recalculateFaces?: boolean): DynamicTilemapLayer;

            /**
             * Destroys this DynamicTilemapLayer and removes its link to the associated LayerData.
             */
            destroy(): void;

            /**
             * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the
             * specified index. Tiles will be set to collide if the given index is a colliding index.
             * Collision information in the region will be recalculated.
             * @param index The tile index to fill the area with.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             */
            fill(index: integer, tileX?: integer, tileY?: integer, width?: integer, height?: integer, recalculateFaces?: boolean): DynamicTilemapLayer;

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns
             * true) will returned as a new array. Similar to Array.protointerface.Filter in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter. The callback should return true for tiles that pass the
             * filter.
             * @param context The context under which the callback should be run.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area to filter. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area to filter. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param FilteringOptions Optional filters to apply when getting the tiles.
             */
            filterTiles(callback: CallbackFn, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, FilteringOptions?: object): Tile[];

            /**
             * Searches the entire map layer for the first tile matching the given index, then returns that Tile
             * object. If no match is found, it returns null. The search starts from the top-left tile and
             * continues horizontally until it hits the end of the row, then it drops down to the next column.
             * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to
             * the top-left.
             * @param index The tile index value to search for.
             * @param skip The number of times to skip a matching tile before returning. Default 0.
             * @param reverse If true it will scan the layer in reverse, starting at the
             * bottom-right. Otherwise it scans from the top-left. Default false.
             */
            findByIndex(index: integer, skip?: integer, reverse?: boolean): Tile;

            /**
             * Find the first tile in the given rectangular area (in tile coordinates) of the layer that
             * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns
             * true. Similar to Array.protointerface.find in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area to search. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area to search. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param FilteringOptions Optional filters to apply when getting the tiles.
             */
            findTile(callback: FindTileCallback, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, FilteringOptions?: object): Tile;

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * callback. Similar to Array.protointerface.forEach in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area to search. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area to search. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param FilteringOptions Optional filters to apply when getting the tiles.
             */
            forEachTile(callback: EachTileCallback, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, FilteringOptions?: object): DynamicTilemapLayer;

            /**
             * Gets a tile at the given tile coordinates from the given layer.
             * @param tileX X position to get the tile from (given in tile units, not pixels).
             * @param tileY Y position to get the tile from (given in tile units, not pixels).
             * @param nonNull If true getTile won't return null for empty tiles, but a Tile object with an index of -1. Default false.
             */
            getTileAt(tileX: integer, tileY: integer, nonNull?: boolean): Tile;

            /**
             * Gets a tile at the given world coordinates from the given layer.
             * @param worldX X position to get the tile from (given in pixels)
             * @param worldY Y position to get the tile from (given in pixels)
             * @param nonNull If true, function won't return null for empty tiles, but a Tile object with an index of -1. Default false.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            getTileAtWorldXY(worldX: number, worldY: number, nonNull?: boolean, camera?: Cameras.Scene2D.Camera): Tile;

            /**
             * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param FilteringOptions Optional filters to apply when getting the tiles.
             */
            getTilesWithin(tileX?: integer, tileY?: integer, width?: integer, height?: integer, FilteringOptions?: object): Tile[];

            /**
             * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,
             * Line, Rectangle or Triangle. The shape should be in world coordinates.
             * @param shape A shape in world (pixel) coordinates
             * @param FilteringOptions Optional filters to apply when getting the tiles.
             * @param camera The Camera to use when factoring in which tiles to return. Default main camera.
             */
            getTilesWithinShape(
                shape: Geom.Circle | Geom.Line | Geom.Rectangle | Geom.Triangle,
                FilteringOptions?: object,
                camera?: Cameras.Scene2D.Camera
            ): Tile[];

            /**
             * Gets the tiles in the given rectangular area (in world coordinates) of the layer.
             * @param worldX The world x coordinate for the top-left of the area.
             * @param worldY The world y coordinate for the top-left of the area.
             * @param width The width of the area.
             * @param height The height of the area.
             * @param FilteringOptions Optional filters to apply when getting the tiles.
             * @param camera The Camera to use when factoring in which tiles to return. Default main camera.
             */
            getTilesWithinWorldXY(worldX: number, worldY: number, width: number, height: number, FilteringOptions?: object, camera?: Cameras.Scene2D.Camera): Tile[];

            /**
             * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             */
            hasTileAt(tileX: integer, tileY: integer): boolean;

            /**
             * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             * @param worldX The x coordinate, in pixels.
             * @param worldY The y coordinate, in pixels.
             * @param camera The Camera to use when factoring in which tiles to return. Default main camera.
             */
            hasTileAtWorldXY(worldX: number, worldY: number, camera?: Cameras.Scene2D.Camera): boolean;

            /**
             * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index
             * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified
             * location. If you pass in an index, only the index at the specified location will be changed.
             * Collision information will be recalculated at the specified location.
             * @param tile The index of this tile to set or a Tile object.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             */
            putTileAt(tile: integer | Tile, tileX: integer, tileY: integer, recalculateFaces?: boolean): Tile;

            /**
             * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either
             * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the
             * specified location. If you pass in an index, only the index at the specified location will be
             * changed. Collision information will be recalculated at the specified location.
             * @param tile The index of this tile to set or a Tile object.
             * @param worldX The x coordinate, in pixels.
             * @param worldY The y coordinate, in pixels.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            putTileAtWorldXY(tile: integer | Tile, worldX: number, worldY: number, recalculateFaces?: boolean, camera?: Cameras.Scene2D.Camera): Tile;

            /**
             * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified
             * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,
             * all attributes will be copied over to the specified location. If you pass in an index, only the
             * index at the specified location will be changed. Collision information will be recalculated
             * within the region tiles were changed.
             * @param tile A row (array) or grid (2D array) of Tiles or tile indexes to place.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             */
            putTilesAt(
                tile: integer[] | integer[][] | Tile[] | Tile[][],
                tileX: integer,
                tileY: integer,
                recalculateFaces?: boolean
            ): DynamicTilemapLayer;

            /**
             * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
             * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then
             * those will be used for randomly assigning new tile indexes. If an array is not provided, the
             * indexes found within the region (excluding -1) will be used for randomly assigning new tile
             * indexes. This method only modifies tile indexes and does not change collision information.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param indexes An array of indexes to randomly draw from during randomization.
             */
            randomize(tileX?: integer, tileY?: integer, width?: integer, height?: integer, indexes?: integer[]): DynamicTilemapLayer;

            /**
             * Removes the tile at the given tile coordinates in the specified layer and updates the layer's
             * collision information.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param replaceWithNull If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1. Default true.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             */
            removeTileAt(tileX: integer, tileY: integer, replaceWithNull?: boolean, recalculateFaces?: boolean): Tile;

            /**
             * Removes the tile at the given world coordinates in the specified layer and updates the layer's
             * collision information.
             * @param worldX The x coordinate, in pixels.
             * @param worldY The y coordinate, in pixels.
             * @param replaceWithNull If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1. Default true.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            removeTileAtWorldXY(worldX: number, worldY: number, replaceWithNull?: boolean, recalculateFaces?: boolean, camera?: Cameras.Scene2D.Camera): Tile;

            /**
             * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to
             * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles
             * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation
             * wherever you want on the screen.
             * @param graphics The target Graphics object to draw upon.
             * @param styleConfig An object specifying the colors to use for the debug drawing.
             */
            renderDebug(graphics: GameObjects.Graphics, styleConfig: StyleConfig): DynamicTilemapLayer;

            /**
             * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
             * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does
             * not change collision information.
             * @param findIndex The index of the tile to search for.
             * @param newIndex The index of the tile to replace it with.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             */
            replaceByIndex(findIndex: integer, newIndex: integer, tileX?: integer, tileY?: integer, width?: integer, height?: integer): DynamicTilemapLayer;

            /**
             * You can control if the Cameras should cull tiles before rendering them or not.
             * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.
             *
             * However, there are some instances when you may wish to disable this.
             * @param value Set to `true` to stop culling tiles. Set to `false` to enable culling again. Default true.
             */
            setSkipCull(value?: boolean): this;

            /**
             * When a Camera culls the tiles in this layer it does so using its view into the world, building up a
             * rectangle inside which the tiles must exist or they will be culled. Sometimes you may need to expand the size
             * of this 'cull rectangle', especially if you plan on rotating the Camera viewing the layer. Do so
             * by providing the padding values. The values given are in tiles, not pixels. So if the tile width was 32px
             * and you set `paddingX` to be 4, it would add 32px x 4 to the cull rectangle (adjusted for scale)
             * @param paddingX The amount of extra horizontal tiles to add to the cull check padding. Default 1.
             * @param paddingY The amount of extra vertical tiles to add to the cull check padding. Default 1.
             */
            setCullPadding(paddingX?: integer, paddingY?: integer): this;

            /**
             * Sets collision on the given tile or tiles within a layer by index. You can pass in either a
             * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if
             * collision will be enabled (true) or disabled (false).
             * @param indexes Either a single tile index, or an array of tile indexes.
             * @param collides If true it will enable collision. If false it will clear collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the update. Default true.
             */
            setCollision(indexes: integer | integer[], collides?: boolean, recalculateFaces?: boolean): DynamicTilemapLayer;

            /**
             * Sets collision on a range of tiles in a layer whose index is between the specified `start` and
             * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set
             * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be
             * enabled (true) or disabled (false).
             * @param start The first index of the tile to be set for collision.
             * @param stop The last index of the tile to be set for collision.
             * @param collides If true it will enable collision. If false it will clear collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the update. Default true.
             */
            setCollisionBetween(start: integer, stop: integer, collides?: boolean, recalculateFaces?: boolean): DynamicTilemapLayer;

            /**
             * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property
             * that matches the given properties object, its collision flag will be set. The `collides`
             * parameter controls if collision will be enabled (true) or disabled (false). Passing in
             * `{ collides: true }` would update the collision flag on any tiles with a "collides" property that
             * has a value of true. Any tile that doesn't have "collides" set to true will be ignored. You can
             * also use an array of values, e.g. `{ types: ["stone", "lava", "sand" ] }`. If a tile has a
             * "types" property that matches any of those values, its collision flag will be updated.
             * @param properties An object with tile properties and corresponding values that should be checked.
             * @param collides If true it will enable collision. If false it will clear collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the update. Default true.
             */
            setCollisionByProperty(properties: object, collides?: boolean, recalculateFaces?: boolean): DynamicTilemapLayer;

            /**
             * Sets collision on all tiles in the given layer, except for tiles that have an index specified in
             * the given array. The `collides` parameter controls if collision will be enabled (true) or
             * disabled (false).
             * @param indexes An array of the tile indexes to not be counted for collision.
             * @param collides If true it will enable collision. If false it will clear collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the update. Default true.
             */
            setCollisionByExclusion(indexes: integer[], collides?: boolean, recalculateFaces?: boolean): DynamicTilemapLayer;

            /**
             * Sets collision on the tiles within a layer by checking each tiles collision group data
             * (typically defined in Tiled within the tileset collision editor). If any objects are found within
             * a tiles collision group, the tile's colliding information will be set. The `collides` parameter
             * controls if collision will be enabled (true) or disabled (false).
             * @param collides If true it will enable collision. If false it will clear collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the update. Default true.
             */
            setCollisionFromCollisionGroup(collides?: boolean, recalculateFaces?: boolean): DynamicTilemapLayer;

            /**
             * Sets a global collision callback for the given tile index within the layer. This will affect all
             * tiles on this layer that have the same index. If a callback is already set for the tile index it
             * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile
             * at a specific location on the map then see setTileLocationCallback.
             * @param indexes Either a single tile index, or an array of tile indexes to have a collision callback set for.
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             */
            setTileIndexCallback(indexes: integer | integer[], callback: CallbackFn, callbackContext: object): DynamicTilemapLayer;

            /**
             * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.
             * If a callback is already set for the tile index it will be replaced. Set the callback to null to
             * remove it.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             */
            setTileLocationCallback(tileX?: integer, tileY?: integer, width?: integer, height?: integer, callback?: CallbackFn, callbackContext?: object): DynamicTilemapLayer;

            /**
             * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given
             * layer. It will only randomize the tiles in that area, so if they're all the same nothing will
             * appear to have changed! This method only modifies tile indexes and does not change collision
             * information.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             */
            shuffle(tileX?: integer, tileY?: integer, width?: integer, height?: integer): DynamicTilemapLayer;

            /**
             * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
             * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision
             * information.
             * @param tileA First tile index.
             * @param tileB Second tile index.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             */
            swapByIndex(tileA: integer, tileB: integer, tileX?: integer, tileY?: integer, width?: integer, height?: integer): DynamicTilemapLayer;

            /**
             * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            tileToWorldX(tileX: integer, camera?: Cameras.Scene2D.Camera): number;

            /**
             * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            tileToWorldY(tileY: integer, camera?: Cameras.Scene2D.Camera): number;

            /**
             * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param point A Vector2 to store the coordinates in. If not given a new Vector2 is created.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            tileToWorldXY(tileX: integer, tileY: integer, point?: Math.Vector2, camera?: Cameras.Scene2D.Camera): Math.Vector2;

            /**
             * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
             * specified layer. Each tile will recieve a new index. New indexes are drawn from the given
             * weightedIndexes array. An example weighted array:
             *
             * [
             *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8
             *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8
             *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8
             *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8
             * ]
             *
             * The probability of any index being choose is (the index's weight) / (sum of all weights). This
             * method only modifies tile indexes and does not change collision information.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param weightedIndexes An array of objects to randomly draw from during
             * randomization. They should be in the form: { index: 0, weight: 4 } or
             * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.
             */
            weightedRandomize(tileX?: integer, tileY?: integer, width?: integer, height?: integer, weightedIndexes?: object[]): DynamicTilemapLayer;

            /**
             * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             * @param worldX The x coordinate to be converted, in pixels, not tiles.
             * @param snapToFloor Whether or not to round the tile coordinate down to the nearest integer. Default true.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            worldToTileX(worldX: number, snapToFloor?: boolean, camera?: Cameras.Scene2D.Camera): number;

            /**
             * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             * @param worldY The y coordinate to be converted, in pixels, not tiles.
             * @param snapToFloor Whether or not to round the tile coordinate down to the nearest integer. Default true.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            worldToTileY(worldY: number, snapToFloor?: boolean, camera?: Cameras.Scene2D.Camera): number;

            /**
             * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             * @param worldX The x coordinate to be converted, in pixels, not tiles.
             * @param worldY The y coordinate to be converted, in pixels, not tiles.
             * @param snapToFloor Whether or not to round the tile coordinate down to the nearest integer. Default true.
             * @param point A Vector2 to store the coordinates in. If not given a new Vector2 is created.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            worldToTileXY(worldX: number, worldY: number, snapToFloor?: boolean, point?: Math.Vector2, camera?: Cameras.Scene2D.Camera): Math.Vector2;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): this;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): this;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): this;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): this;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): this;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: GameObjects.Components.TransformMatrix): GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(tempMatrix?: GameObjects.Components.TransformMatrix, parentMatrix?: GameObjects.Components.TransformMatrix): GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        namespace Formats {
            /**
             * CSV Map interface
             */
            const CSV: number;

            /**
             * Tiled JSON Map interface
             */
            const TILED_JSON: number;

            /**
             * 2D Array Map interface
             */
            const ARRAY_2D: number;

            /**
             * Weltmeister (Impact.js) Map interface
             */
            const WELTMEISTER: number;
        }

        /**
         * An Image Collection is a special Tile Set containing multiple images, with no slicing into each image.
         *
         * Image Collections are normally created automatically when Tiled data is loaded.
         */
        class ImageCollection {
            /**
             *
             * @param name The name of the image collection in the map data.
             * @param firstgid The first image index this image collection contains.
             * @param width Width of widest image (in pixels). Default 32.
             * @param height Height of tallest image (in pixels). Default 32.
             * @param margin The margin around all images in the collection (in pixels). Default 0.
             * @param spacing The spacing between each image in the collection (in pixels). Default 0.
             * @param properties Custom Image Collection properties. Default {}.
             */
            constructor(name: string, firstgid: integer, width?: integer, height?: integer, margin?: integer, spacing?: integer, properties?: object);

            /**
             * The name of the Image Collection.
             */
            name: string;

            /**
             * The Tiled firstgid value.
             * This is the starting index of the first image index this Image Collection contains.
             */
            firstgid: integer;

            /**
             * The width of the widest image (in pixels).
             */
            readonly imageWidth: integer;

            /**
             * The height of the tallest image (in pixels).
             */
            readonly imageHeight: integer;

            /**
             * The margin around the images in the collection (in pixels).
             * Use `setSpacing` to change.
             */
            readonly imageMarge: integer;

            /**
             * The spacing between each image in the collection (in pixels).
             * Use `setSpacing` to change.
             */
            readonly imageSpacing: integer;

            /**
             * Image Collection-specific properties that are typically defined in the Tiled editor.
             */
            properties: object;

            /**
             * The cached images that are a part of this collection.
             */
            readonly images: any[];

            /**
             * The total number of images in the image collection.
             */
            readonly total: integer;

            /**
             * Returns true if and only if this image collection contains the given image index.
             * @param imageIndex The image index to search for.
             */
            containsImageIndex(imageIndex: integer): boolean;

            /**
             * Add an image to this Image Collection.
             * @param gid The gid of the image in the Image Collection.
             * @param image The the key of the image in the Image Collection and in the cache.
             */
            addImage(gid: integer, image: string): ImageCollection;
        }

        /**
         * A class for representing data about about a layer in a map. Maps are parsed from CSV, Tiled,
         * etc. into this format. Tilemap, StaticTilemapLayer and DynamicTilemapLayer have a reference
         * to this data and use it to look up and perform operations on tiles.
         */
        class LayerData {
            /**
             *
             * @param config [description]
             */
            constructor(config?: object);

            /**
             * The name of the layer, if specified in Tiled.
             */
            name: string;

            /**
             * The x offset of where to draw from the top left
             */
            x: number;

            /**
             * The y offset of where to draw from the top left
             */
            y: number;

            /**
             * The width in tile of the layer.
             */
            width: number;

            /**
             * The height in tiles of the layer.
             */
            height: number;

            /**
             * The pixel width of the tiles.
             */
            tileWidth: number;

            /**
             * The pixel height of the tiles.
             */
            tileHeight: number;

            /**
             * [description]
             */
            baseTileWidth: number;

            /**
             * [description]
             */
            baseTileHeight: number;

            /**
             * The width in pixels of the entire layer.
             */
            widthInPixels: number;

            /**
             * The height in pixels of the entire layer.
             */
            heightInPixels: number;

            /**
             * [description]
             */
            alpha: number;

            /**
             * [description]
             */
            visible: boolean;

            /**
             * Layer specific properties (can be specified in Tiled)
             */
            properties: object;

            /**
             * [description]
             */
            indexes: any[];

            /**
             * [description]
             */
            collideIndexes: any[];

            /**
             * [description]
             */
            callbacks: any[];

            /**
             * [description]
             */
            bodies: any[];

            /**
             * An array of the tile indexes
             */
            data: number[];

            /**
             * [description]
             */
            tilemapLayer: DynamicTilemapLayer | StaticTilemapLayer;
        }

        /**
         * A class for representing data about a map. Maps are parsed from CSV, Tiled, etc. into this
         * format. A Tilemap object get a copy of this data and then unpacks the needed properties into
         * itself.
         */
        class MapData {
            /**
             *
             * @param config [description]
             */
            constructor(config?: MapDataConfig);

            /**
             * The key in the Phaser cache that corresponds to the loaded tilemap data.
             */
            name: string;

            /**
             * The width of the entire tilemap.
             */
            width: number;

            /**
             * The height of the entire tilemap.
             */
            height: number;

            /**
             * The width of the tiles.
             */
            tileWidth: number;

            /**
             * The height of the tiles.
             */
            tileHeight: number;

            /**
             * The width in pixels of the entire tilemap.
             */
            widthInPixels: number;

            /**
             * The height in pixels of the entire tilemap.
             */
            heightInPixels: number;

            /**
             * [description]
             */
            format: integer;

            /**
             * The orientation of the map data (i.e. orthogonal, isometric, hexagonal), default 'orthogonal'.
             */
            orientation: string;

            /**
             * Determines the draw order of tilemap. Default is right-down
             *
             * 0, or 'right-down'
             * 1, or 'left-down'
             * 2, or 'right-up'
             * 3, or 'left-up'
             */
            renderOrder: string;

            /**
             * The version of the map data (as specified in Tiled).
             */
            version: string;

            /**
             * Map specific properties (can be specified in Tiled)
             */
            properties: object;

            /**
             * An array with all the layers configured to the MapData.
             */
            layers: LayerData[] | ObjectLayer;

            /**
             * An array of Tiled Image Layers.
             */
            images: any[];

            /**
             * An object of Tiled Object Layers.
             */
            objects: object;

            /**
             * An object of collision data. Must be created as physics object or will return undefined.
             */
            collision: object;

            /**
             * An array of Tilesets.
             */
            tilesets: Tileset[];

            /**
             * The collection of images the map uses(specified in Tiled)
             */
            imageCollections: any[];

            /**
             * [description]
             */
            tiles: any[];
        }

        /**
         * A class for representing a Tiled object layer in a map. This mirrors the structure of a Tiled
         * object layer, except:
         *  - "x" & "y" properties are ignored since these cannot be changed in Tiled.
         *  - "offsetx" & "offsety" are applied to the individual object coordinates directly, so they
         *    are ignored as well.
         *  - "draworder" is ignored.
         */
        class ObjectLayer {
            /**
             *
             * @param config The data for the layer from the Tiled JSON object.
             */
            constructor(config?: object);

            /**
             * The name of the Object Layer.
             */
            name: string;

            /**
             * The opacity of the layer, between 0 and 1.
             */
            opacity: number;

            /**
             * The custom properties defined on the Object Layer, keyed by their name.
             */
            properties: object;

            /**
             * The interface of each custom property defined on the Object Layer, keyed by its name.
             */
            propertytypes: object;

            /**
             * The interface of the layer, which should be `objectgroup`.
             */
            interface: string;

            /**
             * Whether the layer is shown (`true`) or hidden (`false`).
             */
            visible: boolean;

            /**
             * An array of all objects on this Object Layer.
             *
             * Each Tiled object corresponds to a JavaScript object in this array.
             * It has an `id` (unique), `name` (as assigned in Tiled), `interface` (as assigned in Tiled), `rotation` (in clockwise degrees), `properties` (if any),
             * `visible` state (`true` if visible, `false` otherwise), `x` and `y` coordinates (in pixels, relative to the tilemap), and a `width` and `height` (in pixels).
             * An object tile has a `gid` property (GID of the represented tile), a `flippedHorizontal` property, a `flippedVertical` property, and `flippedAntiDiagonal` property.
             * The {@link http://docs.mapeditor.org/en/latest/reference/tmx-map-format/|Tiled documentation} contains information on flipping and rotation.
             *
             * Polylines have a `polyline` property, which is an array of objects corresponding to points, where each point has an `x` property and a `y` property.
             * Polygons have an identically structured array in their `polygon` property. Text objects have a `text` property with the text's properties.
             *
             * Rectangles and ellipses have a `rectangle` or `ellipse` property set to `true`.
             */
            objects: GameObjects.GameObject[];
        }

        namespace Parsers {
            namespace Impact {
                /**
                 * [description]
                 * @param json [description]
                 * @param insertNull [description]
                 */
                function ParseTileLayers(json: object, insertNull: boolean): any[];

                /**
                 * [description]
                 * @param json [description]
                 */
                function ParseTilesets(json: object): any[];

                /**
                 * Parses a Weltmeister JSON object into a new MapData object.
                 * @param name The name of the tilemap, used to set the name on the MapData.
                 * @param json The Weltmeister JSON object.
                 * @param insertNull Controls how empty tiles, tiles with an index of -1, in the map
                 * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
                 * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
                 * the tile data doesn't need to change then setting this value to `true` will help with memory
                 * consumption. However if your map is small or you need to update the tiles dynamically, then leave
                 * the default value set.
                 */
                function ParseWeltmeister(name: string, json: object, insertNull: boolean): object;
            }

            /**
             * Parses raw data of a given Tilemap format into a new MapData object. If no recognized data format
             * is found, returns `null`. When loading from CSV or a 2D array, you should specify the tileWidth &
             * tileHeight. When parsing from a map from Tiled, the tileWidth & tileHeight will be pulled from
             * the map data.
             * @param name The name of the tilemap, used to set the name on the MapData.
             * @param mapFormat See ../Formats.js.
             * @param data 2D array, CSV string or Tiled JSON object.
             * @param tileWidth The width of a tile in pixels. Required for 2D array and CSV, but
             * ignored for Tiled JSON.
             * @param tileHeight The height of a tile in pixels. Required for 2D array and CSV, but
             * ignored for Tiled JSON.
             * @param insertNull Controls how empty tiles, tiles with an index of -1, in the map
             * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
             * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
             * the tile data doesn't need to change then setting this value to `true` will help with memory
             * consumption. However if your map is small or you need to update the tiles dynamically, then leave
             * the default value set.
             */
            function Parse(name: string, mapFormat: integer, data: integer[][] | string | object, tileWidth: integer, tileHeight: integer, insertNull: boolean): MapData;

            /**
             * Parses a 2D array of tile indexes into a new MapData object with a single layer.
             * @param name The name of the tilemap, used to set the name on the MapData.
             * @param data 2D array, CSV string or Tiled JSON object.
             * @param tileWidth The width of a tile in pixels.
             * @param tileHeight The height of a tile in pixels.
             * @param insertNull Controls how empty tiles, tiles with an index of -1, in the map
             * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
             * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
             * the tile data doesn't need to change then setting this value to `true` will help with memory
             * consumption. However if your map is small or you need to update the tiles dynamically, then leave
             * the default value set.
             */
            function Parse2DArray(name: string, data: integer[][], tileWidth: integer, tileHeight: integer, insertNull: boolean): MapData;

            /**
             * Parses a CSV string of tile indexes into a new MapData object with a single layer.
             * @param name The name of the tilemap, used to set the name on the MapData.
             * @param data CSV string of tile indexes.
             * @param tileWidth The width of a tile in pixels.
             * @param tileHeight The height of a tile in pixels.
             * @param insertNull Controls how empty tiles, tiles with an index of -1, in the map
             * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
             * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
             * the tile data doesn't need to change then setting this value to `true` will help with memory
             * consumption. However if your map is small or you need to update the tiles dynamically, then leave
             * the default value set.
             */
            function ParseCSV(name: string, data: string, tileWidth: integer, tileHeight: integer, insertNull: boolean): MapData;

            namespace Tiled {
                /**
                 * Copy properties from tileset to tiles.
                 * @param mapData [description]
                 */
                function AssignTileProperties(mapData: MapData): void;

                /**
                 * Decode base-64 encoded data, for example as exported by Tiled.
                 * @param data Base-64 encoded data to decode.
                 */
                function Base64Decode(data: object): any[];

                /**
                 * Master list of tiles -> x, y, index in tileset.
                 * @param mapData [description]
                 */
                function BuildTilesetIndex(mapData: MapData): any[];

                /**
                 * See Tiled documentation on tile flipping:
                 * http://docs.mapeditor.org/en/latest/reference/tmx-map-format/
                 * @param gid [description]
                 */
                function ParseGID(gid: number): object;

                /**
                 * [description]
                 * @param json [description]
                 */
                function ParseImageLayers(json: object): any[];

                /**
                 * Parses a Tiled JSON object into a new MapData object.
                 * @param name The name of the tilemap, used to set the name on the MapData.
                 * @param json The Tiled JSON object.
                 * @param insertNull Controls how empty tiles, tiles with an index of -1, in the map
                 * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
                 * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
                 * the tile data doesn't need to change then setting this value to `true` will help with memory
                 * consumption. However if your map is small or you need to update the tiles dynamically, then leave
                 * the default value set.
                 */
                function ParseJSONTiled(name: string, json: object, insertNull: boolean): MapData;

                /**
                 * Convert a Tiled object to an internal parsed object normalising and copying properties over, while applying optional x and y offsets.
                 * The parsed object will always have the properties `id`, `name`, `interface`, `rotation`, `properties`, `visible`, `x`, `y`, `width` and `height`.
                 * Other properties will be added according to the object interface (such as text, polyline, gid etc.)
                 * @param tiledObject Tiled object to convert to an internal parsed object normalising and copying properties over.
                 * @param offsetX Optional additional offset to apply to the object's x property. Defaults to 0. Default 0.
                 * @param offsetY Optional additional offset to apply to the object's y property. Defaults to 0. Default 0.
                 */
                function ParseObject(tiledObject: object, offsetX?: number, offsetY?: number): object;

                /**
                 * Parses a Tiled JSON object into an array of ObjectLayer objects.
                 * @param json The Tiled JSON object.
                 */
                function ParseObjectLayers(json: object): any[];

                /**
                 * [description]
                 * @param json [description]
                 * @param insertNull [description]
                 */
                function ParseTileLayers(json: object, insertNull: boolean): any[];

                /**
                 * Tilesets & Image Collections
                 * @param json [description]
                 */
                function ParseTilesets(json: object): object;

                /**
                 * Returns a new object that only contains the `keys` that were found on the object provided. If no `keys` are found, an empty object is returned.
                 * @param object The object to pick the provided keys from.
                 * @param keys An array of properties to retrieve from the provided object.
                 */
                function Pick(object: object, keys: any[]): object;
            }
        }

        /**
         * Create a Tilemap from the given key or data. If neither is given, make a blank Tilemap. When
         * loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing from
         * a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map data. For
         * an empty map, you should specify tileWidth, tileHeight, width & height.
         * @param scene The Scene to which this Tilemap belongs.
         * @param key The key in the Phaser cache that corresponds to the loaded tilemap data.
         * @param tileWidth The width of a tile in pixels. Default 32.
         * @param tileHeight The height of a tile in pixels. Default 32.
         * @param width The width of the map in tiles. Default 10.
         * @param height The height of the map in tiles. Default 10.
         * @param data Instead of loading from the cache, you can also load directly from
         * a 2D array of tile indexes.
         * @param insertNull Controls how empty tiles, tiles with an index of -1, in the
         * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
         * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
         * the tile data doesn't need to change then setting this value to `true` will help with memory
         * consumption. However if your map is small or you need to update the tiles dynamically, then leave
         * the default value set. Default false.
         */
        function ParseToTilemap(
            scene: Scene,
            key?: string,
            tileWidth?: integer,
            tileHeight?: integer,
            width?: integer,
            height?: integer,
            data?: integer[][],
            insertNull?: boolean
        ): Tilemap;

        /**
         * A Static Tilemap Layer is a Game Object that renders LayerData from a Tilemap when used in combination
         * with one, or more, Tilesets.
         *
         * A Static Tilemap Layer is optimized for rendering speed over flexibility. You cannot apply per-tile
         * effects like tint or alpha, or change the tiles or tilesets the layer uses.
         *
         * Use a Static Tilemap Layer instead of a Dynamic Tilemap Layer when you don't need tile manipulation features.
         */
        class StaticTilemapLayer extends GameObjects.GameObject
            implements
                GameObjects.Components.Alpha,
                GameObjects.Components.BlendMode,
                GameObjects.Components.ComputedSize,
                GameObjects.Components.Depth,
                GameObjects.Components.Flip,
                GameObjects.Components.GetBounds,
                GameObjects.Components.Origin,
                GameObjects.Components.Pipeline,
                GameObjects.Components.ScaleMode,
                GameObjects.Components.Transform,
                GameObjects.Components.Visible,
                GameObjects.Components.ScrollFactor {
            /**
             *
             * @param scene The Scene to which this Game Object belongs.
             * @param tilemap The Tilemap this layer is a part of.
             * @param layerIndex The index of the LayerData associated with this layer.
             * @param tileset The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.
             * @param x The world x position where the top left of this layer will be placed. Default 0.
             * @param y The world y position where the top left of this layer will be placed. Default 0.
             */
            constructor(
                scene: Scene,
                tilemap: Tilemap,
                layerIndex: integer,
                tileset: string | string[] | Tileset | Tileset[],
                x?: number,
                y?: number
            );

            /**
             * Used internally by physics system to perform fast interface checks.
             */
            readonly isTilemap: boolean;

            /**
             * The Tilemap that this layer is a part of.
             */
            tilemap: Tilemap;

            /**
             * The index of the LayerData associated with this layer.
             */
            layerIndex: integer;

            /**
             * The LayerData associated with this layer. LayerData can only be associated with one
             * tilemap layer.
             */
            layer: LayerData;

            /**
             * The Tileset/s associated with this layer.
             *
             * As of Phaser 3.14 this property is now an array of Tileset objects, previously it was a single reference.
             */
            tileset: Tileset[];

            /**
             * Used internally by the Canvas renderer.
             * This holds the tiles that are visible within the camera in the last frame.
             */
            culledTiles: any[];

            /**
             * Canvas only.
             *
             * You can control if the Cameras should cull tiles before rendering them or not.
             * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.
             *
             * However, there are some instances when you may wish to disable this, and toggling this flag allows
             * you to do so. Also see `setSkipCull` for a chainable method that does the same thing.
             */
            skipCull: boolean;

            /**
             * Canvas only.
             *
             * The total number of tiles drawn by the renderer in the last frame.
             *
             * This only works when rending with Canvas.
             */
            readonly tilesDrawn: integer;

            /**
             * Canvas only.
             *
             * The total number of tiles in this layer. Updated every frame.
             */
            readonly tilesTotal: integer;

            /**
             * Canvas only.
             *
             * The amount of extra tiles to add into the cull rectangle when calculating its horizontal size.
             *
             * See the method `setCullPadding` for more details.
             */
            cullPaddingX: integer;

            /**
             * Canvas only.
             *
             * The amount of extra tiles to add into the cull rectangle when calculating its vertical size.
             *
             * See the method `setCullPadding` for more details.
             */
            cullPaddingY: integer;

            /**
             * Canvas only.
             *
             * The callback that is invoked when the tiles are culled.
             *
             * By default it will call `TilemapComponents.CullTiles` but you can override this to call any function you like.
             *
             * It will be sent 3 arguments:
             *
             * 1. The Phaser.Tilemaps.LayerData object for this Layer
             * 2. The Camera that is culling the layer. You can check its `dirty` property to see if it has changed since the last cull.
             * 3. A reference to the `culledTiles` array, which should be used to store the tiles you want rendered.
             *
             * See the `TilemapComponents.CullTiles` source code for details on implementing your own culling system.
             */
            cullCallback: CallbackFn;

            /**
             * An array holding the mapping between the tile indexes and the tileset they belong to.
             */
            gidMap: Tileset[];

            /**
             * Upload the tile data to a VBO.
             * @param camera The camera to render to.
             * @param tilesetIndex The tileset index.
             */
            upload(camera: Cameras.Scene2D.Camera, tilesetIndex: integer): StaticTilemapLayer;

            /**
             * Sets the rendering (draw) order of the tiles in this layer.
             *
             * The default is 'right-down', meaning it will order the tiles starting from the top-left,
             * drawing to the right and then moving down to the next row.
             *
             * The draw orders are:
             *
             * 0 = right-down
             * 1 = left-down
             * 2 = right-up
             * 3 = left-up
             *
             * Setting the render order does not change the tiles or how they are stored in the layer,
             * it purely impacts the order in which they are rendered.
             *
             * You can provide either an integer (0 to 3), or the string version of the order.
             * @param renderOrder The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.
             */
            setRenderOrder(renderOrder: integer | string): this;

            /**
             * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting
             * faces are used internally for optimizing collisions against tiles. This method is mostly used
             * internally to optimize recalculating faces when only one tile has been changed.
             * @param tileX The x coordinate.
             * @param tileY The y coordinate.
             */
            calculateFacesAt(tileX: integer, tileY: integer): StaticTilemapLayer;

            /**
             * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the
             * layer. Interesting faces are used internally for optimizing collisions against tiles. This method
             * is mostly used internally.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             */
            calculateFacesWithin(tileX?: integer, tileY?: integer, width?: integer, height?: integer): StaticTilemapLayer;

            /**
             * Creates a Sprite for every object matching the given tile indexes in the layer. You can
             * optionally specify if each tile will be replaced with a new tile after the Sprite has been
             * created. This is useful if you want to lay down special tiles in a level that are converted to
             * Sprites, but want to replace the tile itself with a floor tile or similar once converted.
             * @param indexes The tile index, or array of indexes, to create Sprites from.
             * @param replacements The tile index, or array of indexes, to change a converted
             * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a
             * one-to-one mapping with the indexes array.
             * @param spriteConfig The config object to pass into the Sprite creator (i.e.
             * scene.make.sprite).
             * @param scene The Scene to create the Sprites within. Default scene the map is within.
             * @param camera The Camera to use when determining the world XY Default main camera.
             */
            createFromTiles(
                indexes: integer | integer[],
                replacements: integer | integer[],
                spriteConfig: SpriteConfig,
                scene?: Scene,
                camera?: Cameras.Scene2D.Camera
            ): GameObjects.Sprite[];

            /**
             * Returns the tiles in the given layer that are within the cameras viewport.
             * This is used internally.
             * @param camera The Camera to run the cull check against.
             */
            cull(camera?: Cameras.Scene2D.Camera): Tile[];

            /**
             * Canvas only.
             *
             * You can control if the Cameras should cull tiles before rendering them or not.
             * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.
             *
             * However, there are some instances when you may wish to disable this.
             * @param value Set to `true` to stop culling tiles. Set to `false` to enable culling again. Default true.
             */
            setSkipCull(value?: boolean): this;

            /**
             * Canvas only.
             *
             * When a Camera culls the tiles in this layer it does so using its view into the world, building up a
             * rectangle inside which the tiles must exist or they will be culled. Sometimes you may need to expand the size
             * of this 'cull rectangle', especially if you plan on rotating the Camera viewing the layer. Do so
             * by providing the padding values. The values given are in tiles, not pixels. So if the tile width was 32px
             * and you set `paddingX` to be 4, it would add 32px x 4 to the cull rectangle (adjusted for scale)
             * @param paddingX The amount of extra horizontal tiles to add to the cull check padding. Default 1.
             * @param paddingY The amount of extra vertical tiles to add to the cull check padding. Default 1.
             */
            setCullPadding(paddingX?: integer, paddingY?: integer): this;

            /**
             * Searches the entire map layer for the first tile matching the given index, then returns that Tile
             * object. If no match is found, it returns null. The search starts from the top-left tile and
             * continues horizontally until it hits the end of the row, then it drops down to the next column.
             * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to
             * the top-left.
             * @param index The tile index value to search for.
             * @param skip The number of times to skip a matching tile before returning. Default 0.
             * @param reverse If true it will scan the layer in reverse, starting at the
             * bottom-right. Otherwise it scans from the top-left. Default false.
             */
            findByIndex(index: integer, skip?: integer, reverse?: boolean): Tile;

            /**
             * Find the first tile in the given rectangular area (in tile coordinates) of the layer that
             * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns
             * true. Similar to Array.protointerface.find in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area to filter. Default 0.
             * @param tileY The topmost tile index (in tile coordinates) to use as the origin of the area to filter. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             */
            findTile(callback: CallbackFn, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: FilteringOptions): Tile;

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns
             * true) will returned as a new array. Similar to Array.protointerface.Filter in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter. The callback should return true for tiles that pass the
             * filter.
             * @param context The context under which the callback should be run.
             * @param tileX The leftmost tile index (in tile coordinates) to use as the origin of the area to filter. Default 0.
             * @param tileY The topmost tile index (in tile coordinates) to use as the origin of the area to filter. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             */
            filterTiles(callback: CallbackFn, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: FilteringOptions): Tile[];

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * callback. Similar to Array.protointerface.forEach in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX The leftmost tile index (in tile coordinates) to use as the origin of the area to filter. Default 0.
             * @param tileY The topmost tile index (in tile coordinates) to use as the origin of the area to filter. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             */
            forEachTile(
                callback: CallbackFn,
                context?: object,
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                filteringOptions?: FilteringOptions
            ): StaticTilemapLayer;

            /**
             * Gets a tile at the given tile coordinates from the given layer.
             * @param tileX X position to get the tile from (given in tile units, not pixels).
             * @param tileY Y position to get the tile from (given in tile units, not pixels).
             * @param nonNull If true getTile won't return null for empty tiles, but a Tile
             * object with an index of -1. Default false.
             */
            getTileAt(tileX: integer, tileY: integer, nonNull?: boolean): Tile;

            /**
             * Gets a tile at the given world coordinates from the given layer.
             * @param worldX X position to get the tile from (given in pixels)
             * @param worldY Y position to get the tile from (given in pixels)
             * @param nonNull If true, function won't return null for empty tiles, but a Tile
             * object with an index of -1. Default false.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            getTileAtWorldXY(worldX: number, worldY: number, nonNull?: boolean, camera?: Cameras.Scene2D.Camera): Tile;

            /**
             * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.
             * @param tileX The leftmost tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The topmost tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             */
            getTilesWithin(tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: FilteringOptions): Tile[];

            /**
             * Gets the tiles in the given rectangular area (in world coordinates) of the layer.
             * @param worldX The leftmost tile index (in tile coordinates) to use as the origin of the area to filter.
             * @param worldY The topmost tile index (in tile coordinates) to use as the origin of the area to filter.
             * @param width How many tiles wide from the `tileX` index the area will be.
             * @param height How many tiles high from the `tileY` index the area will be.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param camera The Camera to use when factoring in which tiles to return. Default main camera.
             */
            getTilesWithinWorldXY(worldX: number, worldY: number, width: number, height: number, filteringOptions?: FilteringOptions, camera?: Cameras.Scene2D.Camera): Tile[];

            /**
             * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,
             * Line, Rectangle or Triangle. The shape should be in world coordinates.
             * @param shape A shape in world (pixel) coordinates
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            getTilesWithinShape(
                shape: Geom.Circle | Geom.Line | Geom.Rectangle | Geom.Triangle,
                filteringOptions?: FilteringOptions,
                camera?: Cameras.Scene2D.Camera
            ): Tile[];

            /**
             * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             * @param tileX X position to get the tile from in tile coordinates.
             * @param tileY Y position to get the tile from in tile coordinates.
             */
            hasTileAt(tileX: integer, tileY: integer): boolean;

            /**
             * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             * @param worldX The X coordinate of the world position.
             * @param worldY The Y coordinate of the world position.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            hasTileAtWorldXY(worldX: number, worldY: number, camera?: Cameras.Scene2D.Camera): boolean;

            /**
             * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to
             * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles
             * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation
             * wherever you want on the screen.
             * @param graphics The target Graphics object to draw upon.
             * @param styleConfig An object specifying the colors to use for the debug drawing.
             */
            renderDebug(graphics: GameObjects.Graphics, styleConfig: StyleConfig): StaticTilemapLayer;

            /**
             * Sets collision on the given tile or tiles within a layer by index. You can pass in either a
             * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if
             * collision will be enabled (true) or disabled (false).
             * @param indexes Either a single tile index, or an array of tile indexes.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollision(indexes: integer | integer[], collides?: boolean, recalculateFaces?: boolean): StaticTilemapLayer;

            /**
             * Sets collision on a range of tiles in a layer whose index is between the specified `start` and
             * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set
             * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be
             * enabled (true) or disabled (false).
             * @param start The first index of the tile to be set for collision.
             * @param stop The last index of the tile to be set for collision.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionBetween(start: integer, stop: integer, collides?: boolean, recalculateFaces?: boolean): StaticTilemapLayer;

            /**
             * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property
             * that matches the given properties object, its collision flag will be set. The `collides`
             * parameter controls if collision will be enabled (true) or disabled (false). Passing in
             * `{ collides: true }` would update the collision flag on any tiles with a "collides" property that
             * has a value of true. Any tile that doesn't have "collides" set to true will be ignored. You can
             * also use an array of values, e.g. `{ types: ["stone", "lava", "sand" ] }`. If a tile has a
             * "types" property that matches any of those values, its collision flag will be updated.
             * @param properties An object with tile properties and corresponding values that should
             * be checked.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionByProperty(properties: object, collides?: boolean, recalculateFaces?: boolean): StaticTilemapLayer;

            /**
             * Sets collision on all tiles in the given layer, except for tiles that have an index specified in
             * the given array. The `collides` parameter controls if collision will be enabled (true) or
             * disabled (false).
             * @param indexes An array of the tile indexes to not be counted for collision.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionByExclusion(indexes: integer[], collides?: boolean, recalculateFaces?: boolean): StaticTilemapLayer;

            /**
             * Sets a global collision callback for the given tile index within the layer. This will affect all
             * tiles on this layer that have the same index. If a callback is already set for the tile index it
             * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile
             * at a specific location on the map then see setTileLocationCallback.
             * @param indexes Either a single tile index, or an array of tile indexes to have a
             * collision callback set for.
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             */
            setTileIndexCallback(indexes: integer | integer[], callback: CallbackFn, callbackContext: object): StaticTilemapLayer;

            /**
             * Sets collision on the tiles within a layer by checking each tiles collision group data
             * (typically defined in Tiled within the tileset collision editor). If any objects are found within
             * a tiles collision group, the tile's colliding information will be set. The `collides` parameter
             * controls if collision will be enabled (true) or disabled (false).
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionFromCollisionGroup(collides?: boolean, recalculateFaces?: boolean): StaticTilemapLayer;

            /**
             * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.
             * If a callback is already set for the tile index it will be replaced. Set the callback to null to
             * remove it.
             * @param tileX The leftmost tile index (in tile coordinates) to use as the origin of the area.
             * @param tileY The topmost tile index (in tile coordinates) to use as the origin of the area.
             * @param width How many tiles wide from the `tileX` index the area will be.
             * @param height How many tiles tall from the `tileY` index the area will be.
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             */
            setTileLocationCallback(tileX: integer, tileY: integer, width: integer, height: integer, callback: CallbackFn, callbackContext?: object): StaticTilemapLayer;

            /**
             * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             * @param tileX The X coordinate, in tile coordinates.
             * @param camera The Camera to use when calculating the world values from the tile index. Default main camera.
             */
            tileToWorldX(tileX: integer, camera?: Cameras.Scene2D.Camera): number;

            /**
             * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             * @param tileY The Y coordinate, in tile coordinates.
             * @param camera The Camera to use when calculating the world values from the tile index. Default main camera.
             */
            tileToWorldY(tileY: integer, camera?: Cameras.Scene2D.Camera): number;

            /**
             * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             * @param tileX The X coordinate, in tile coordinates.
             * @param tileY The Y coordinate, in tile coordinates.
             * @param point A Vector2 to store the coordinates in. If not given, a new Vector2 is created.
             * @param camera The Camera to use when calculating the world values from the tile index. Default main camera.
             */
            tileToWorldXY(tileX: integer, tileY: integer, point?: Math.Vector2, camera?: Cameras.Scene2D.Camera): Math.Vector2;

            /**
             * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             * @param worldX The X coordinate, in world pixels.
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param camera The Camera to use when calculating the tile index from the world values.] Default main camera.
             */
            worldToTileX(worldX: number, snapToFloor?: boolean, camera?: Cameras.Scene2D.Camera): number;

            /**
             * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             * @param worldY The Y coordinate, in world pixels.
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            worldToTileY(worldY: number, snapToFloor?: boolean, camera?: Cameras.Scene2D.Camera): number;

            /**
             * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             * @param worldX The X coordinate, in world pixels.
             * @param worldY The Y coordinate, in world pixels.
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param point A Vector2 to store the coordinates in. If not given, a new Vector2 is created.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             */
            worldToTileXY(worldX: number, worldY: number, snapToFloor?: boolean, point?: Math.Vector2, camera?: Cameras.Scene2D.Camera): Math.Vector2;

            /**
             * Destroys this StaticTilemapLayer and removes its link to the associated LayerData.
             */
            destroy(): void;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             *
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             *
             * Under WebGL only the following Blend Modes are available:
             *
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * * ERASE (only works when rendering to a framebuffer, like a Render Texture)
             *
             * Canvas has more available depending on browser support.
             *
             * You can also create your own custom Blend Modes in WebGL.
             *
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency in which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | BlendModes): this;

            /**
             * The native (un-scaled) width of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayWidth` property.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             *
             * Changing this value will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or use
             * the `displayHeight` property.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             *
             * This value takes into account the scale factor.
             *
             * Setting this value will adjust the Game Object's scale property.
             */
            displayHeight: number;

            /**
             * Sets the internal size of this Game Object, as used for frame or physics body creation.
             *
             * This will not change the size that the Game Object is rendered in-game.
             * For that you need to either set the scale of the Game Object (`setScale`) or call the
             * `setDisplaySize` method, which is the same thing as changing the scale but allows you
             * to do so by giving pixel values.
             *
             * If you have enabled this Game Object for input, changing the size will _not_ change the
             * size of the hit area. To do this you should adjust the `input.hitArea` object directly.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): this;

            /**
             * Sets the display size of this Game Object.
             *
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): this;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             *
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             *
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             *
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): this;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): this;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): this;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): this;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): this;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): this;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): this;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Geom.Rectangle>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             *
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): this;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): this;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): this;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): this;

            /**
             * The initial WebGL pipeline of this Game Object.
             */
            defaultPipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * The current WebGL pipeline of this Game Object.
             */
            pipeline: Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object. Defaults to the Texture Tint Pipeline. Default TextureTintPipeline.
             */
            initPipeline(pipelineName?: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): this;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: ScaleModes): this;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             *
             * Where 0 is to the right, 90 is down, 180 is left.
             *
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             *
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): this;

            /**
             * Sets the position of this Game Object to be a random position within the confines of
             * the given area.
             *
             * If no area is specified a random position between 0 x 0 and the game width x height is used instead.
             *
             * The position does not factor in the size of this Game Object, meaning that only the origin is
             * guaranteed to be within the area.
             * @param x The x position of the top-left of the random area. Default 0.
             * @param y The y position of the top-left of the random area. Default 0.
             * @param width The width of the random area.
             * @param height The height of the random area.
             */
            setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): this;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): this;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): this;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): this;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): this;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): this;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): this;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: GameObjects.Components.TransformMatrix): GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             * @param parentMatrix A temporary matrix to hold parent values during the calculations.
             */
            getWorldTransformMatrix(
                tempMatrix?: GameObjects.Components.TransformMatrix,
                parentMatrix?: GameObjects.Components.TransformMatrix
            ): GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;

            /**
             * The horizontal scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             *
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             *
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             *
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             *
             * Please be aware that scroll factor values other than 1 are not taken in to consideration when
             * calculating physics collisions. Bodies always collide based on their world position, but changing
             * the scroll factor is a visual adjustment to where the textures are rendered, which can offset
             * them from physics bodies if not accounted for in your code.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): this;
        }

        /**
         * A Tile is a representation of a single tile within the Tilemap. This is a lightweight data
         * representation, so its position information is stored without factoring in scroll, layer
         * scale or layer position.
         */
        class Tile implements GameObjects.Components.Alpha, GameObjects.Components.Flip, GameObjects.Components.Visible {
            /**
             *
             * @param layer The LayerData object in the Tilemap that this tile belongs to.
             * @param index The unique index of this tile within the map.
             * @param x The x coordinate of this tile in tile coordinates.
             * @param y The y coordinate of this tile in tile coordinates.
             * @param width Width of the tile in pixels.
             * @param height Height of the tile in pixels.
             * @param baseWidth The base width a tile in the map (in pixels). Tiled maps support
             * multiple tileset sizes within one map, but they are still placed at intervals of the base
             * tile width.
             * @param baseHeight The base height of the tile in pixels (in pixels). Tiled maps
             * support multiple tileset sizes within one map, but they are still placed at intervals of the
             * base tile height.
             */
            constructor(layer: LayerData, index: integer, x: integer, y: integer, width: integer, height: integer, baseWidth: integer, baseHeight: integer);

            /**
             * The LayerData in the Tilemap data that this tile belongs to.
             */
            layer: LayerData;

            /**
             * The index of this tile within the map data corresponding to the tileset, or -1 if this
             * represents a blank tile.
             */
            index: integer;

            /**
             * The x map coordinate of this tile in tile units.
             */
            x: integer;

            /**
             * The y map coordinate of this tile in tile units.
             */
            y: integer;

            /**
             * The width of the tile in pixels.
             */
            width: integer;

            /**
             * The height of the tile in pixels.
             */
            height: integer;

            /**
             * The map's base width of a tile in pixels. Tiled maps support multiple tileset sizes
             * within one map, but they are still placed at intervals of the base tile size.
             */
            baseWidth: integer;

            /**
             * The map's base height of a tile in pixels. Tiled maps support multiple tileset sizes
             * within one map, but they are still placed at intervals of the base tile size.
             */
            baseHeight: integer;

            /**
             * The x coordinate of the top left of this tile in pixels. This is relative to the top left
             * of the layer this tile is being rendered within. This property does NOT factor in camera
             * scroll, layer scale or layer position.
             */
            pixelX: number;

            /**
             * The y coordinate of the top left of this tile in pixels. This is relative to the top left
             * of the layer this tile is being rendered within. This property does NOT factor in camera
             * scroll, layer scale or layer position.
             */
            pixelY: number;

            /**
             * Tile specific properties. These usually come from Tiled.
             */
            properties: object;

            /**
             * The rotation angle of this tile.
             */
            rotation: number;

            /**
             * Whether the tile should collide with any object on the left side.
             */
            collideLeft: boolean;

            /**
             * Whether the tile should collide with any object on the right side.
             */
            collideRight: boolean;

            /**
             * Whether the tile should collide with any object on the top side.
             */
            collideUp: boolean;

            /**
             * Whether the tile should collide with any object on the bottom side.
             */
            collideDown: boolean;

            /**
             * Whether the tile's left edge is interesting for collisions.
             */
            faceLeft: boolean;

            /**
             * Whether the tile's right edge is interesting for collisions.
             */
            faceRight: boolean;

            /**
             * Whether the tile's top edge is interesting for collisions.
             */
            faceTop: boolean;

            /**
             * Whether the tile's bottom edge is interesting for collisions.
             */
            faceBottom: boolean;

            /**
             * Tile collision callback.
             */
            collisionCallback: CallbackFn;

            /**
             * The context in which the collision callback will be called.
             */
            collisionCallbackContext: object;

            /**
             * The tint to apply to this tile. Note: tint is currently a single color value instead of
             * the 4 corner tint component on other GameObjects.
             */
            tint: number;

            /**
             * An empty object where physics-engine specific information (e.g. bodies) may be stored.
             */
            physics: object;

            /**
             * Check if the given x and y world coordinates are within this Tile. This does not factor in
             * camera scroll, layer scale or layer position.
             * @param x The x coordinate to test.
             * @param y The y coordinate to test.
             */
            containsPoint(x: number, y: number): boolean;

            /**
             * Copies the tile data & properties from the given tile to this tile. This copies everything
             * except for position and interesting faces.
             * @param tile The tile to copy from.
             */
            copy(tile: Tile): Tile;

            /**
             * The collision group for this Tile, defined within the Tileset. This returns a reference to
             * the collision group stored within the Tileset, so any modification of the returned object
             * will impact all tiles that have the same index as this tile.
             */
            getCollisionGroup(): object;

            /**
             * The tile data for this Tile, defined within the Tileset. This typically contains Tiled
             * collision data, tile animations and terrain information. This returns a reference to the tile
             * data stored within the Tileset, so any modification of the returned object will impact all
             * tiles that have the same index as this tile.
             */
            getTileData(): object;

            /**
             * Gets the world X position of the left side of the tile, factoring in the layers position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getLeft(camera?: Cameras.Scene2D.Camera): number;

            /**
             * Gets the world X position of the right side of the tile, factoring in the layer's position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getRight(camera?: Cameras.Scene2D.Camera): number;

            /**
             * Gets the world Y position of the top side of the tile, factoring in the layer's position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getTop(camera?: Cameras.Scene2D.Camera): number;

            /**
             * Gets the world Y position of the bottom side of the tile, factoring in the layer's position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getBottom(camera?: Cameras.Scene2D.Camera): number;

            /**
             * Gets the world rectangle bounding box for the tile, factoring in the layers position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             * @param output [description]
             */
            getBounds(camera?: Cameras.Scene2D.Camera, output?: object): Geom.Rectangle | object;

            /**
             * Gets the world X position of the center of the tile, factoring in the layer's position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getCenterX(camera?: Cameras.Scene2D.Camera): number;

            /**
             * Gets the world Y position of the center of the tile, factoring in the layer's position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getCenterY(camera?: Cameras.Scene2D.Camera): number;

            /**
             * Clean up memory.
             */
            destroy(): void;

            /**
             * Check for intersection with this tile. This does not factor in camera scroll, layer scale or
             * layer position.
             * @param x The x axis in pixels.
             * @param y The y axis in pixels.
             * @param right The right point.
             * @param bottom The bottom point.
             */
            intersects(x: number, y: number, right: number, bottom: number): boolean;

            /**
             * Checks if the tile is interesting.
             * @param collides If true, will consider the tile interesting if it collides on any side.
             * @param faces If true, will consider the tile interesting if it has an interesting face.
             */
            isInteresting(collides: boolean, faces: boolean): boolean;

            /**
             * Reset collision status flags.
             * @param recalculateFaces Whether or not to recalculate interesting faces for this tile and its neighbors. Default true.
             */
            resetCollision(recalculateFaces?: boolean): Tile;

            /**
             * Reset faces.
             */
            resetFaces(): Tile;

            /**
             * Sets the collision flags for each side of this tile and updates the interesting faces list.
             * @param left Indicating collide with any object on the left.
             * @param right Indicating collide with any object on the right.
             * @param up Indicating collide with any object on the top.
             * @param down Indicating collide with any object on the bottom.
             * @param recalculateFaces Whether or not to recalculate interesting faces
             * for this tile and its neighbors. Default true.
             */
            setCollision(left: boolean, right?: boolean, up?: boolean, down?: boolean, recalculateFaces?: boolean): Tile;

            /**
             * Set a callback to be called when this tile is hit by an object. The callback must true for
             * collision processing to take place.
             * @param callback Callback function.
             * @param context Callback will be called within this context.
             */
            setCollisionCallback(callback: CallbackFn, context: object): Tile;

            /**
             * Sets the size of the tile and updates its pixelX and pixelY.
             * @param tileWidth The width of the tile in pixels.
             * @param tileHeight The height of the tile in pixels.
             * @param baseWidth The base width a tile in the map (in pixels).
             * @param baseHeight The base height of the tile in pixels (in pixels).
             */
            setSize(tileWidth: integer, tileHeight: integer, baseWidth: integer, baseHeight: integer): Tile;

            /**
             * Used internally. Updates the tile's world XY position based on the current tile size.
             */
            updatePixelXY(): Tile;

            /**
             * True if this tile can collide on any of its faces or has a collision callback set.
             */
            readonly canCollide: boolean;

            /**
             * True if this tile can collide on any of its faces.
             */
            readonly collides: boolean;

            /**
             * True if this tile has any interesting faces.
             */
            readonly hasInterestingFace: boolean;

            /**
             * The tileset that contains this Tile. This is null if accessed from a LayerData instance
             * before the tile is placed in a StaticTilemapLayer or DynamicTilemapLayer, or if the tile has
             * an index that doesn't correspond to any of the map's tilesets.
             */
            readonly tileset: Tileset;

            /**
             * The tilemap layer that contains this Tile. This will only return null if accessed from a
             * LayerData instance before the tile is placed within a StaticTilemapLayer or
             * DynamicTilemapLayer.
             */
            readonly tilemapLayer: StaticTilemapLayer | DynamicTilemapLayer;

            /**
             * The tilemap that contains this Tile. This will only return null if accessed from a LayerData
             * instance before the tile is placed within a StaticTilemapLayer or DynamicTilemapLayer.
             */
            readonly tilemap: Tilemap;

            /**
             * Clears all alpha values associated with this Game Object.
             *
             * Immediately sets the alpha levels back to 1 (fully opaque).
             */
            clearAlpha(): this;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             *
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): this;

            /**
             * The alpha value of the Game Object.
             *
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): this;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): this;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): this;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): this;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): this;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): this;

            /**
             * The visible state of the Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             *
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): this;
        }

        /**
         * A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data
         * about the map and allows you to add tilesets and tilemap layers to it. A map can have one or
         * more tilemap layers (StaticTilemapLayer or DynamicTilemapLayer), which are the display
         * objects that actually render tiles.
         *
         * The Tilemap data be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free
         * software package specifically for creating tile maps, and is available from:
         * http://www.mapeditor.org
         *
         * A Tilemap has handy methods for getting & manipulating the tiles within a layer. You can only
         * use the methods that change tiles (e.g. removeTileAt) on a DynamicTilemapLayer.
         *
         * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a
         * StaticTilemapLayer or DynamicTilemapLayer may have its own unique tile size that overrides
         * it.
         */
        class Tilemap {
            /**
             *
             * @param scene The Scene to which this Tilemap belongs.
             * @param mapData A MapData instance containing Tilemap data.
             */
            constructor(scene: Scene, mapData: MapData);

            scene: Scene;

            /**
             * The base width of a tile in pixels. Note that individual layers may have a different tile
             * width.
             */
            tileWidth: integer;

            /**
             * The base height of a tile in pixels. Note that individual layers may have a different
             * tile height.
             */
            tileHeight: integer;

            /**
             * The width of the map (in tiles).
             */
            width: number;

            /**
             * The height of the map (in tiles).
             */
            height: number;

            /**
             * The orientation of the map data (as specified in Tiled), usually 'orthogonal'.
             */
            orientation: string;

            /**
             * The render (draw) order of the map data (as specified in Tiled), usually 'right-down'.
             *
             * The draw orders are:
             *
             * right-down
             * left-down
             * right-up
             * left-up
             *
             * This can be changed via the `setRenderOrder` method.
             */
            renderOrder: string;

            /**
             * The format of the map data.
             */
            format: number;

            /**
             * The version of the map data (as specified in Tiled, usually 1).
             */
            version: number;

            /**
             * Map specific properties as specified in Tiled.
             */
            properties: object;

            /**
             * The width of the map in pixels based on width * tileWidth.
             */
            widthInPixels: number;

            /**
             * The height of the map in pixels based on height * tileHeight.
             */
            heightInPixels: number;

            imageCollections: ImageCollection[];

            /**
             * An array of Tiled Image Layers.
             */
            images: any[];

            /**
             * An array of Tilemap layer data.
             */
            layers: LayerData[];

            /**
             * An array of Tilesets used in the map.
             */
            tilesets: Tileset[];

            /**
             * An array of ObjectLayer instances parsed from Tiled object layers.
             */
            objects: ObjectLayer[];

            /**
             * The index of the currently selected LayerData object.
             */
            currentLayerIndex: integer;

            /**
             * Sets the rendering (draw) order of the tiles in this map.
             *
             * The default is 'right-down', meaning it will order the tiles starting from the top-left,
             * drawing to the right and then moving down to the next row.
             *
             * The draw orders are:
             *
             * 0 = right-down
             * 1 = left-down
             * 2 = right-up
             * 3 = left-up
             *
             * Setting the render order does not change the tiles or how they are stored in the layer,
             * it purely impacts the order in which they are rendered.
             *
             * You can provide either an integer (0 to 3), or the string version of the order.
             *
             * Calling this method _after_ creating Static or Dynamic Tilemap Layers will **not** automatically
             * update them to use the new render order. If you call this method after creating layers, use their
             * own `setRenderOrder` methods to change them as needed.
             * @param renderOrder The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.
             */
            setRenderOrder(renderOrder: integer | string): this;

            /**
             * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.
             * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled
             * editor.
             * @param tilesetName The name of the tileset as specified in the map data.
             * @param key The key of the Phaser.Cache image used for this tileset. If
             * `undefined` or `null` it will look for an image with a key matching the tilesetName parameter.
             * @param tileWidth The width of the tile (in pixels) in the Tileset Image. If not
             * given it will default to the map's tileWidth value, or the tileWidth specified in the Tiled
             * JSON file.
             * @param tileHeight The height of the tiles (in pixels) in the Tileset Image. If
             * not given it will default to the map's tileHeight value, or the tileHeight specified in the
             * Tiled JSON file.
             * @param tileMargin The margin around the tiles in the sheet (in pixels). If not
             * specified, it will default to 0 or the value specified in the Tiled JSON file.
             * @param tileSpacing The spacing between each the tile in the sheet (in pixels).
             * If not specified, it will default to 0 or the value specified in the Tiled JSON file.
             * @param gid If adding multiple tilesets to a blank map, specify the starting
             * GID this set will use here. Default 0.
             */
            addTilesetImage(tilesetName: string, key?: string, tileWidth?: integer, tileHeight?: integer, tileMargin?: integer, tileSpacing?: integer, gid?: integer): Tileset;

            /**
             * Turns the StaticTilemapLayer associated with the given layer into a DynamicTilemapLayer. If
             * no layer specified, the map's current layer is used. This is useful if you want to manipulate
             * a map at the start of a scene, but then make it non-manipulable and optimize it for speed.
             * Note: the DynamicTilemapLayer passed in is destroyed, so make sure to store the value
             * returned from this method if you want to manipulate the new StaticTilemapLayer.
             * @param layer The name of the layer from Tiled, the
             * index of the layer in the map, or a DynamicTilemapLayer.
             */
            convertLayerToStatic(layer?: string | integer | DynamicTilemapLayer): StaticTilemapLayer;

            /**
             * Copies the tiles in the source rectangular area to a new destination (all specified in tile
             * coordinates) within the layer. This copies all tile properties & recalculates collision
             * information in the destination region.
             *
             * If no layer specified, the map's current layer is used. This cannot be applied to StaticTilemapLayers.
             * @param srcTileX The x coordinate of the area to copy from, in tiles, not pixels.
             * @param srcTileY The y coordinate of the area to copy from, in tiles, not pixels.
             * @param width The width of the area to copy, in tiles, not pixels.
             * @param height The height of the area to copy, in tiles, not pixels.
             * @param destTileX The x coordinate of the area to copy to, in tiles, not pixels.
             * @param destTileY The y coordinate of the area to copy to, in tiles, not pixels.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            copy(
                srcTileX: integer,
                srcTileY: integer,
                width: integer,
                height: integer,
                destTileX: integer,
                destTileY: integer,
                recalculateFaces?: boolean,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Creates a new and empty DynamicTilemapLayer. The currently selected layer in the map is set to this new layer.
             * @param name The name of this layer. Must be unique within the map.
             * @param tileset The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.
             * @param x The world x position where the top left of this layer will be placed. Default 0.
             * @param y The world y position where the top left of this layer will be placed. Default 0.
             * @param width The width of the layer in tiles. If not specified, it will default to the map's width.
             * @param height The height of the layer in tiles. If not specified, it will default to the map's height.
             * @param tileWidth The width of the tiles the layer uses for calculations. If not specified, it will default to the map's tileWidth.
             * @param tileHeight The height of the tiles the layer uses for calculations. If not specified, it will default to the map's tileHeight.
             */
            createBlankDynamicLayer(
                name: string,
                tileset: string | string[] | Tileset | Tileset[],
                x?: number,
                y?: number,
                width?: integer,
                height?: integer,
                tileWidth?: integer,
                tileHeight?: integer
            ): DynamicTilemapLayer;

            /**
             * Creates a new DynamicTilemapLayer that renders the LayerData associated with the given
             * `layerID`. The currently selected layer in the map is set to this new layer.
             *
             * The `layerID` is important. If you've created your map in Tiled then you can get this by
             * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and
             * look at the layers[].name value. Either way it must match.
             *
             * Unlike a static layer, a dynamic layer can be modified. See DynamicTilemapLayer for more
             * information.
             * @param layerID The layer array index value, or if a string is given, the layer name from Tiled.
             * @param tileset The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.
             * @param x The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.
             * @param y The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.
             */
            createDynamicLayer(layerID: integer | string, tileset: string | string[] | Tileset | Tileset[], x: number, y: number): DynamicTilemapLayer;

            /**
             * Creates a Sprite for every object matching the given gid in the map data. All properties from
             * the map data objectgroup are copied into the `spriteConfig`, so you can use this as an easy
             * way to configure Sprite properties from within the map editor. For example giving an object a
             * property of alpha: 0.5 in the map editor will duplicate that when the Sprite is created.
             *
             * Custom object properties not sharing names with the Sprite's own properties are copied to the
             * Sprite's {@link Phaser.GameObjects.Sprite#data data store}.
             * @param name The name of the object layer (from Tiled) to create Sprites from.
             * @param id Either the id (object), gid (tile object) or name (object or
             * tile object) from Tiled. Ids are unique in Tiled, but a gid is shared by all tile objects
             * with the same graphic. The same name can be used on multiple objects.
             * @param spriteConfig The config object to pass into the Sprite creator (i.e.
             * scene.make.sprite).
             * @param scene The Scene to create the Sprites within. Default the scene the map is within.
             */
            createFromObjects(name: string, id: integer | string, spriteConfig: SpriteConfig, scene?: Scene): GameObjects.Sprite[];

            /**
             * Creates a Sprite for every object matching the given tile indexes in the layer. You can
             * optionally specify if each tile will be replaced with a new tile after the Sprite has been
             * created. This is useful if you want to lay down special tiles in a level that are converted to
             * Sprites, but want to replace the tile itself with a floor tile or similar once converted.
             * @param indexes The tile index, or array of indexes, to create Sprites from.
             * @param replacements The tile index, or array of indexes, to change a converted
             * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a
             * one-to-one mapping with the indexes array.
             * @param spriteConfig The config object to pass into the Sprite creator (i.e. scene.make.sprite).
             * @param scene The Scene to create the Sprites within. Default scene the map is within.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            createFromTiles(
                indexes: integer | integer[],
                replacements: integer | integer[],
                spriteConfig: SpriteConfig,
                scene?: Scene,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): GameObjects.Sprite[];

            /**
             * Creates a new StaticTilemapLayer that renders the LayerData associated with the given
             * `layerID`. The currently selected layer in the map is set to this new layer.
             *
             * The `layerID` is important. If you've created your map in Tiled then you can get this by
             * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and
             * look at the layers[].name value. Either way it must match.
             *
             * It's important to remember that a static layer cannot be modified. See StaticTilemapLayer for
             * more information.
             * @param layerID The layer array index value, or if a string is given, the layer name from Tiled.
             * @param tileset The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.
             * @param x The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0. Default 0.
             * @param y The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0. Default 0.
             */
            createStaticLayer(layerID: integer | string, tileset: string | string[] | Tileset | Tileset[], x?: number, y?: number): StaticTilemapLayer;

            /**
             * Removes all layer data from this Tilemap and nulls the scene reference. This will destroy any
             * StaticTilemapLayers or DynamicTilemapLayers that have been linked to LayerData.
             */
            destroy(): void;

            /**
             * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the
             * specified index. Tiles will be set to collide if the given index is a colliding index.
             * Collision information in the region will be recalculated.
             *
             * If no layer specified, the map's current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param index The tile index to fill the area with.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            fill(
                index: integer,
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                recalculateFaces?: boolean,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * For each object in the given object layer, run the given filter callback function. Any
             * objects that pass the filter test (i.e. where the callback returns true) will returned as a
             * new array. Similar to Array.protointerface.Filter in vanilla JS.
             * @param objectLayer The name of an object layer (from Tiled) or an ObjectLayer instance.
             * @param callback The callback. Each object in the given area will be passed to this callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             */
            filterObjects(objectLayer: ObjectLayer | string, callback: TilemapFilterCallback, context?: object): GameObjects.GameObject[];

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns
             * true) will returned as a new array. Similar to Array.protointerface.Filter in vanilla JS.
             * If no layer specified, the map's current layer is used.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter. The callback should return true for tiles that pass the
             * filter.
             * @param context The context under which the callback should be run.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area to filter. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area to filter. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            filterTiles(
                callback: CallbackFn,
                context?: object,
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                filteringOptions?: FilteringOptions,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tile[];

            /**
             * Searches the entire map layer for the first tile matching the given index, then returns that Tile
             * object. If no match is found, it returns null. The search starts from the top-left tile and
             * continues horizontally until it hits the end of the row, then it drops down to the next column.
             * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to
             * the top-left.
             * If no layer specified, the map's current layer is used.
             * @param index The tile index value to search for.
             * @param skip The number of times to skip a matching tile before returning. Default 0.
             * @param reverse If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left. Default false.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            findByIndex(index: integer, skip?: integer, reverse?: boolean, layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer): Tile;

            /**
             * Find the first object in the given object layer that satisfies the provided testing function.
             * I.e. finds the first object for which `callback` returns true. Similar to
             * Array.protointerface.find in vanilla JS.
             * @param objectLayer The name of an object layer (from Tiled) or an ObjectLayer instance.
             * @param callback The callback. Each object in the given area will be passed to this callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             */
            findObject(objectLayer: ObjectLayer | string, callback: TilemapFindCallback, context?: object): GameObjects.GameObject;

            /**
             * Find the first tile in the given rectangular area (in tile coordinates) of the layer that
             * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns
             * true. Similar to Array.protointerface.find in vanilla JS.
             * If no layer specified, the maps current layer is used.
             * @param callback The callback. Each tile in the given area will be passed to this callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area to search. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area to search. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param layer The Tile layer to run the search on. If not provided will use the current layer.
             */
            findTile(
                callback: FindTileCallback,
                context?: object,
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                filteringOptions?: FilteringOptions,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tile;

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * callback. Similar to Array.protointerface.forEach in vanilla JS.
             *
             * If no layer specified, the map's current layer is used.
             * @param callback The callback. Each tile in the given area will be passed to this callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area to search. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area to search. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param layer The Tile layer to run the search on. If not provided will use the current layer.
             */
            forEachTile(
                callback: EachTileCallback,
                context?: object,
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                filteringOptions?: FilteringOptions,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Gets the image layer index based on its name.
             * @param name The name of the image to get.
             */
            getImageIndex(name: string): integer;

            /**
             * Internally used. Returns the index of the object in one of the Tilemaps arrays whose name
             * property matches the given `name`.
             * @param location The Tilemap array to search.
             * @param name The name of the array element to get.
             */
            getIndex(location: any[], name: string): number;

            /**
             * Gets the LayerData from this.layers that is associated with `layer`, or null if an invalid
             * `layer` is given.
             * @param layer The name of the
             * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
             * StaticTilemapLayer. If not given will default to the maps current layer index.
             */
            getLayer(layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer): LayerData;

            /**
             * Gets the ObjectLayer from this.objects that has the given `name`, or null if no ObjectLayer
             * is found with that name.
             * @param name The name of the object layer from Tiled.
             */
            getObjectLayer(name?: string): ObjectLayer;

            /**
             * Gets the LayerData index of the given `layer` within this.layers, or null if an invalid
             * `layer` is given.
             * @param layer The name of the
             * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
             * StaticTilemapLayer. If not given will default to the map's current layer index.
             */
            getLayerIndex(layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer): integer;

            /**
             * Gets the index of the LayerData within this.layers that has the given `name`, or null if an
             * invalid `name` is given.
             * @param name The name of the layer to get.
             */
            getLayerIndexByName(name: string): integer;

            /**
             * Gets a tile at the given tile coordinates from the given layer.
             * If no layer specified, the map's current layer is used.
             * @param tileX X position to get the tile from (given in tile units, not pixels).
             * @param tileY Y position to get the tile from (given in tile units, not pixels).
             * @param nonNull If true getTile won't return null for empty tiles, but a Tile object with an index of -1. Default false.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            getTileAt(tileX: integer, tileY: integer, nonNull?: boolean, layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer): Tile;

            /**
             * Gets a tile at the given world coordinates from the given layer.
             * If no layer specified, the map's current layer is used.
             * @param worldX X position to get the tile from (given in pixels)
             * @param worldY Y position to get the tile from (given in pixels)
             * @param nonNull If true, function won't return null for empty tiles, but a Tile object with an index of -1. Default false.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            getTileAtWorldXY(
                worldX: number,
                worldY: number,
                nonNull?: boolean,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tile;

            /**
             * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.
             * If no layer specified, the maps current layer is used.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            getTilesWithin(
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                filteringOptions?: FilteringOptions,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tile[];

            /**
             * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,
             * Line, Rectangle or Triangle. The shape should be in world coordinates.
             * If no layer specified, the maps current layer is used.
             * @param shape A shape in world (pixel) coordinates
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param camera The Camera to use when factoring in which tiles to return. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            getTilesWithinShape(
                shape: Geom.Circle | Geom.Line | Geom.Rectangle | Geom.Triangle,
                filteringOptions?: FilteringOptions,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tile[];

            /**
             * Gets the tiles in the given rectangular area (in world coordinates) of the layer.
             * If no layer specified, the maps current layer is used.
             * @param worldX The world x coordinate for the top-left of the area.
             * @param worldY The world y coordinate for the top-left of the area.
             * @param width The width of the area.
             * @param height The height of the area.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param camera The Camera to use when factoring in which tiles to return. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            getTilesWithinWorldXY(
                worldX: number,
                worldY: number,
                width: number,
                height: number,
                filteringOptions?: FilteringOptions,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tile[];

            /**
             * Gets the Tileset that has the given `name`, or null if an invalid `name` is given.
             * @param name The name of the Tileset to get.
             */
            getTileset(name: string): Tileset;

            /**
             * Gets the index of the Tileset within this.tilesets that has the given `name`, or null if an
             * invalid `name` is given.
             * @param name The name of the Tileset to get.
             */
            getTilesetIndex(name: string): integer;

            /**
             * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             *
             * If no layer specified, the map's current layer is used.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            hasTileAt(tileX: integer, tileY: integer, layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer): boolean;

            /**
             * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             *
             * If no layer specified, the maps current layer is used.
             * @param worldX The x coordinate, in pixels.
             * @param worldY The y coordinate, in pixels.
             * @param camera The Camera to use when factoring in which tiles to return. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            hasTileAtWorldXY(
                worldX: number,
                worldY: number,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): boolean;

            /**
             * The LayerData object that is currently selected in the map. You can set this property using
             * any interface supported by setLayer.
             */
            layer: LayerData;

            /**
             * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index
             * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified
             * location. If you pass in an index, only the index at the specified location will be changed.
             * Collision information will be recalculated at the specified location.
             *
             * If no layer specified, the maps current layer is used.
             *
             * This cannot be applied to StaticTilemapLayers.
             * @param tile The index of this tile to set or a Tile object.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            putTileAt(
                tile: integer | Tile,
                tileX: integer,
                tileY: integer,
                recalculateFaces?: boolean,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tile;

            /**
             * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either
             * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the
             * specified location. If you pass in an index, only the index at the specified location will be
             * changed. Collision information will be recalculated at the specified location.
             *
             * If no layer specified, the maps current layer is used. This
             * cannot be applied to StaticTilemapLayers.
             * @param tile The index of this tile to set or a Tile object.
             * @param worldX The x coordinate, in pixels.
             * @param worldY The y coordinate, in pixels.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            putTileAtWorldXY(
                tile: integer | Tile,
                worldX: number,
                worldY: number,
                recalculateFaces?: boolean,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tile;

            /**
             * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified
             * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,
             * all attributes will be copied over to the specified location. If you pass in an index, only the
             * index at the specified location will be changed. Collision information will be recalculated
             * within the region tiles were changed.
             *
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tile A row (array) or grid (2D array) of Tiles or tile indexes to place.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            putTilesAt(
                tile: integer[] | integer[][] | Tile[] | Tile[][],
                tileX: integer,
                tileY: integer,
                recalculateFaces?: boolean,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
             * specified layer. Each tile will recieve a new index. If an array of indexes is passed in, then
             * those will be used for randomly assigning new tile indexes. If an array is not provided, the
             * indexes found within the region (excluding -1) will be used for randomly assigning new tile
             * indexes. This method only modifies tile indexes and does not change collision information.
             *
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param indexes An array of indexes to randomly draw from during randomization.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            randomize(
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                indexes?: integer[],
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting
             * faces are used internally for optimizing collisions against tiles. This method is mostly used
             * internally to optimize recalculating faces when only one tile has been changed.
             *
             * If no layer specified, the maps current layer is used.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            calculateFacesAt(tileX: integer, tileY: integer, layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer): Tilemap;

            /**
             * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the
             * layer. Interesting faces are used internally for optimizing collisions against tiles. This method
             * is mostly used internally.
             *
             * If no layer specified, the map's current layer is used.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            calculateFacesWithin(
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Removes all layers from this Tilemap and destroys any associated StaticTilemapLayers or
             * DynamicTilemapLayers.
             */
            removeAllLayers(): Tilemap;

            /**
             * Removes the tile at the given tile coordinates in the specified layer and updates the layer's
             * collision information.
             *
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param replaceWithNull If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1. Default true.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            removeTileAt(
                tileX: integer,
                tileY: integer,
                replaceWithNull?: boolean,
                recalculateFaces?: boolean,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tile;

            /**
             * Removes the tile at the given world coordinates in the specified layer and updates the layer's
             * collision information.
             *
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param worldX The x coordinate, in pixels.
             * @param worldY The y coordinate, in pixels.
             * @param replaceWithNull If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1. Default true.
             * @param recalculateFaces `true` if the faces data should be recalculated. Default true.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            removeTileAtWorldXY(
                worldX: number,
                worldY: number,
                replaceWithNull?: boolean,
                recalculateFaces?: boolean,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tile;

            /**
             * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to
             * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles
             * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation
             * wherever you want on the screen.
             *
             * If no layer specified, the maps current layer is used.
             * @param graphics The target Graphics object to draw upon.
             * @param styleConfig An object specifying the colors to use for the debug drawing.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            renderDebug(
                graphics: GameObjects.Graphics,
                styleConfig: StyleConfig,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
             * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does
             * not change collision information.
             *
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param findIndex The index of the tile to search for.
             * @param newIndex The index of the tile to replace it with.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            replaceByIndex(
                findIndex: integer,
                newIndex: integer,
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Sets collision on the given tile or tiles within a layer by index. You can pass in either a
             * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if
             * collision will be enabled (true) or disabled (false).
             *
             * If no layer specified, the map's current layer is used.
             * @param indexes Either a single tile index, or an array of tile indexes.
             * @param collides If true it will enable collision. If false it will clear collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the update. Default true.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            setCollision(
                indexes: integer | integer[],
                collides?: boolean,
                recalculateFaces?: boolean,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Sets collision on a range of tiles in a layer whose index is between the specified `start` and
             * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set
             * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be
             * enabled (true) or disabled (false).
             *
             * If no layer specified, the map's current layer is used.
             * @param start The first index of the tile to be set for collision.
             * @param stop The last index of the tile to be set for collision.
             * @param collides If true it will enable collision. If false it will clear collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the update. Default true.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            setCollisionBetween(
                start: integer,
                stop: integer,
                collides?: boolean,
                recalculateFaces?: boolean,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property
             * that matches the given properties object, its collision flag will be set. The `collides`
             * parameter controls if collision will be enabled (true) or disabled (false). Passing in
             * `{ collides: true }` would update the collision flag on any tiles with a "collides" property that
             * has a value of true. Any tile that doesn't have "collides" set to true will be ignored. You can
             * also use an array of values, e.g. `{ types: ["stone", "lava", "sand" ] }`. If a tile has a
             * "types" property that matches any of those values, its collision flag will be updated.
             *
             * If no layer specified, the map's current layer is used.
             * @param properties An object with tile properties and corresponding values that should be checked.
             * @param collides If true it will enable collision. If false it will clear collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the update. Default true.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            setCollisionByProperty(
                properties: object,
                collides?: boolean,
                recalculateFaces?: boolean,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Sets collision on all tiles in the given layer, except for tiles that have an index specified in
             * the given array. The `collides` parameter controls if collision will be enabled (true) or
             * disabled (false).
             *
             * If no layer specified, the map's current layer is used.
             * @param indexes An array of the tile indexes to not be counted for collision.
             * @param collides If true it will enable collision. If false it will clear collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the update. Default true.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            setCollisionByExclusion(
                indexes: integer[],
                collides?: boolean,
                recalculateFaces?: boolean,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Sets collision on the tiles within a layer by checking each tile's collision group data
             * (typically defined in Tiled within the tileset collision editor). If any objects are found within
             * a tile's collision group, the tile's colliding information will be set. The `collides` parameter
             * controls if collision will be enabled (true) or disabled (false).
             *
             * If no layer specified, the map's current layer is used.
             * @param collides If true it will enable collision. If false it will clear collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the update. Default true.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            setCollisionFromCollisionGroup(
                collides?: boolean,
                recalculateFaces?: boolean,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Sets a global collision callback for the given tile index within the layer. This will affect all
             * tiles on this layer that have the same index. If a callback is already set for the tile index it
             * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile
             * at a specific location on the map then see setTileLocationCallback.
             *
             * If no layer specified, the map's current layer is used.
             * @param indexes Either a single tile index, or an array of tile indexes to have a collision callback set for.
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            setTileIndexCallback(
                indexes: integer | integer[],
                callback: CallbackFn,
                callbackContext: object,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Sets a collision callback for the given rectangular area (in tile coordindates) within the layer.
             * If a callback is already set for the tile index it will be replaced. Set the callback to null to
             * remove it.
             *
             * If no layer specified, the map's current layer is used.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area.
             * @param width How many tiles wide from the `tileX` index the area will be.
             * @param height How many tiles tall from the `tileY` index the area will be.
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            setTileLocationCallback(
                tileX: integer,
                tileY: integer,
                width: integer,
                height: integer,
                callback: CallbackFn,
                callbackContext?: object,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Sets the current layer to the LayerData associated with `layer`.
             * @param layer The name of the
             * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
             * StaticTilemapLayer. If not given will default to the map's current layer index.
             */
            setLayer(layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer): Tilemap;

            /**
             * Sets the base tile size for the map. Note: this does not necessarily match the tileWidth and
             * tileHeight for all layers. This also updates the base size on all tiles across all layers.
             * @param tileWidth The width of the tiles the map uses for calculations.
             * @param tileHeight The height of the tiles the map uses for calculations.
             */
            setBaseTileSize(tileWidth: integer, tileHeight: integer): Tilemap;

            /**
             * Sets the tile size for a specific `layer`. Note: this does not necessarily match the map's
             * tileWidth and tileHeight for all layers. This will set the tile size for the layer and any
             * tiles the layer has.
             * @param tileWidth The width of the tiles (in pixels) in the layer.
             * @param tileHeight The height of the tiles (in pixels) in the layer.
             * @param layer The name of the
             * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
             * StaticTilemapLayer. If not given will default to the map's current layer index.
             */
            setLayerTileSize(tileWidth: integer, tileHeight: integer, layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer): Tilemap;

            /**
             * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given
             * layer. It will only randomize the tiles in that area, so if they're all the same nothing will
             * appear to have changed! This method only modifies tile indexes and does not change collision
             * information.
             *
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            shuffle(
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
             * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision
             * information.
             *
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tileA First tile index.
             * @param tileB Second tile index.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            swapByIndex(
                tileA: integer,
                tileB: integer,
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             *
             * If no layer specified, the maps current layer is used.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            tileToWorldX(tileX: integer, camera?: Cameras.Scene2D.Camera, layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer): number;

            /**
             * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             *
             * If no layer specified, the maps current layer is used.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             * @param layer The tile layer
             * to use. If not given the current layer is used.
             */
            tileToWorldY(tileY: integer, camera?: Cameras.Scene2D.Camera, layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer): number;

            /**
             * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             *
             * If no layer specified, the maps current layer is used.
             * @param tileX The x coordinate, in tiles, not pixels.
             * @param tileY The y coordinate, in tiles, not pixels.
             * @param point A Vector2 to store the coordinates in. If not given a new Vector2 is created.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            tileToWorldXY(
                tileX: integer,
                tileY: integer,
                point?: Math.Vector2,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Math.Vector2;

            /**
             * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
             * specified layer. Each tile will receive a new index. New indexes are drawn from the given
             * weightedIndexes array. An example weighted array:
             *
             * [
             *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8
             *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8
             *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8
             *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8
             * ]
             *
             * The probability of any index being choose is (the index's weight) / (sum of all weights). This
             * method only modifies tile indexes and does not change collision information.
             *
             * If no layer specified, the map's current layer is used. This
             * cannot be applied to StaticTilemapLayers.
             * @param tileX The left most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param tileY The top most tile index (in tile coordinates) to use as the origin of the area. Default 0.
             * @param width How many tiles wide from the `tileX` index the area will be. Default max width based on tileX.
             * @param height How many tiles tall from the `tileY` index the area will be. Default max height based on tileY.
             * @param weightedIndexes An array of objects to randomly draw from during
             * randomization. They should be in the form: { index: 0, weight: 4 } or
             * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            weightedRandomize(
                tileX?: integer,
                tileY?: integer,
                width?: integer,
                height?: integer,
                weightedIndexes?: object[],
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Tilemap;

            /**
             * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             *
             * If no layer specified, the maps current layer is used.
             * @param worldX The x coordinate to be converted, in pixels, not tiles.
             * @param snapToFloor Whether or not to round the tile coordinate down to the nearest integer. Default true.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             * @param layer The tile layer
             * to use. If not given the current layer is used.
             */
            worldToTileX(
                worldX: number,
                snapToFloor?: boolean,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): number;

            /**
             * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             *
             * If no layer specified, the maps current layer is used.
             * @param worldY The y coordinate to be converted, in pixels, not tiles.
             * @param snapToFloor Whether or not to round the tile coordinate down to the nearest integer. Default true.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            worldToTileY(
                worldY: number,
                snapToFloor?: boolean,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): number;

            /**
             * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             *
             * If no layer specified, the maps current layer is used.
             * @param worldX The x coordinate to be converted, in pixels, not tiles.
             * @param worldY The y coordinate to be converted, in pixels, not tiles.
             * @param snapToFloor Whether or not to round the tile coordinate down to the nearest integer. Default true.
             * @param point A Vector2 to store the coordinates in. If not given a new Vector2 is created.
             * @param camera The Camera to use when calculating the tile index from the world values. Default main camera.
             * @param layer The tile layer to use. If not given the current layer is used.
             */
            worldToTileXY(
                worldX: number,
                worldY: number,
                snapToFloor?: boolean,
                point?: Math.Vector2,
                camera?: Cameras.Scene2D.Camera,
                layer?: string | integer | DynamicTilemapLayer | StaticTilemapLayer
            ): Math.Vector2;
        }

        /**
         * A Tileset is a combination of an image containing the tiles and a container for data about
         * each tile.
         */
        class Tileset {
            /**
             *
             * @param name The name of the tileset in the map data.
             * @param firstgid The first tile index this tileset contains.
             * @param tileWidth Width of each tile (in pixels). Default 32.
             * @param tileHeight Height of each tile (in pixels). Default 32.
             * @param tileMargin The margin around all tiles in the sheet (in pixels). Default 0.
             * @param tileSpacing The spacing between each tile in the sheet (in pixels). Default 0.
             * @param tileProperties Custom properties defined per tile in the Tileset.
             * These typically are custom properties created in Tiled when editing a tileset. Default {}.
             * @param tileData Data stored per tile. These typically are created in Tiled
             * when editing a tileset, e.g. from Tiled's tile collision editor or terrain editor. Default {}.
             */
            constructor(name: string, firstgid: integer, tileWidth?: integer, tileHeight?: integer, tileMargin?: integer, tileSpacing?: integer, tileProperties?: object, tileData?: object);

            /**
             * The name of the Tileset.
             */
            name: string;

            /**
             * The starting index of the first tile index this Tileset contains.
             */
            firstgid: integer;

            /**
             * The width of each tile (in pixels). Use setTileSize to change.
             */
            readonly tileWidth: integer;

            /**
             * The height of each tile (in pixels). Use setTileSize to change.
             */
            readonly tileHeight: integer;

            /**
             * The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.
             */
            readonly tileMargin: integer;

            /**
             * The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.
             */
            readonly tileSpacing: integer;

            /**
             * Tileset-specific properties per tile that are typically defined in the Tiled editor in the
             * Tileset editor.
             */
            tileProperties: object;

            /**
             * Tileset-specific data per tile that are typically defined in the Tiled editor, e.g. within
             * the Tileset collision editor. This is where collision objects and terrain are stored.
             */
            tileData: object;

            /**
             * The cached image that contains the individual tiles. Use setImage to set.
             */
            readonly image: Textures.Texture;

            /**
             * The gl texture used by the WebGL renderer.
             */
            readonly glTexture: WebGLTexture;

            /**
             * The number of tile rows in the the tileset.
             */
            readonly rows: integer;

            /**
             * The number of tile columns in the tileset.
             */
            readonly columns: integer;

            /**
             * The total number of tiles in the tileset.
             */
            readonly total: integer;

            /**
             * The look-up table to specific tile image texture coordinates (UV in pixels). Each element
             * contains the coordinates for a tile in an object of the form {x, y}.
             */
            readonly texCoordinates: object[];

            /**
             * Get a tiles properties that are stored in the Tileset. Returns null if tile index is not
             * contained in this Tileset. This is typically defined in Tiled under the Tileset editor.
             * @param tileIndex The unique id of the tile across all tilesets in the map.
             */
            getTileProperties(tileIndex: integer): object | undefined;

            /**
             * Get a tile's data that is stored in the Tileset. Returns null if tile index is not contained
             * in this Tileset. This is typically defined in Tiled and will contain both Tileset collision
             * info and terrain mapping.
             * @param tileIndex The unique id of the tile across all tilesets in the map.
             */
            getTileData(tileIndex: integer): object | undefined;

            /**
             * Get a tile's collision group that is stored in the Tileset. Returns null if tile index is not
             * contained in this Tileset. This is typically defined within Tiled's tileset collision editor.
             * @param tileIndex The unique id of the tile across all tilesets in the map.
             */
            getTileCollisionGroup(tileIndex: integer): object;

            /**
             * Returns true if and only if this Tileset contains the given tile index.
             * @param tileIndex The unique id of the tile across all tilesets in the map.
             */
            containsTileIndex(tileIndex: integer): boolean;

            /**
             * Returns the texture coordinates (UV in pixels) in the Tileset image for the given tile index.
             * Returns null if tile index is not contained in this Tileset.
             * @param tileIndex The unique id of the tile across all tilesets in the map.
             */
            getTileTextureCoordinates(tileIndex: integer): object;

            /**
             * Sets the image associated with this Tileset and updates the tile data (rows, columns, etc.).
             * @param texture The image that contains the tiles.
             */
            setImage(texture: Textures.Texture): Tileset;

            /**
             * Sets the tile width & height and updates the tile data (rows, columns, etc.).
             * @param tileWidth The width of a tile in pixels.
             * @param tileHeight The height of a tile in pixels.
             */
            setTileSize(tileWidth?: integer, tileHeight?: integer): Tileset;

            /**
             * Sets the tile margin & spacing and updates the tile data (rows, columns, etc.).
             * @param margin The margin around the tiles in the sheet (in pixels).
             * @param spacing The spacing between the tiles in the sheet (in pixels).
             */
            setSpacing(margin?: integer, spacing?: integer): Tileset;

            /**
             * Updates tile texture coordinates and tileset data.
             * @param imageWidth The (expected) width of the image to slice.
             * @param imageHeight The (expected) height of the image to slice.
             */
            updateTileData(imageWidth: integer, imageHeight: integer): Tileset;
        }
    }

    namespace Time {
        /**
         * The Clock is a Scene plugin which creates and updates Timer Events for its Scene.
         */
        class Clock {
            /**
             *
             * @param scene The Scene which owns this Clock.
             */
            constructor(scene: Scene);

            /**
             * The Scene which owns this Clock.
             */
            scene: Scene;

            /**
             * The Scene Systems object of the Scene which owns this Clock.
             */
            systems: Scenes.Systems;

            /**
             * The current time of the Clock, in milliseconds.
             *
             * If accessed externally, this is equivalent to the `time` parameter normally passed to a Scene's `update` method.
             */
            now: number;

            /**
             * The scale of the Clock's time delta.
             *
             * The time delta is the time elapsed between two consecutive frames and influences the speed of time for this Clock and anything which uses it, such as its Timer Events.
             * Values higher than 1 increase the speed of time, while values smaller than 1 decrease it. A value of 0 freezes time and is effectively equivalent to pausing the Clock.
             */
            timeScale: number;

            /**
             * Whether the Clock is paused (`true`) or active (`false`).
             *
             * When paused, the Clock will not update any of its Timer Events, thus freezing time.
             */
            paused: boolean;

            /**
             * Creates a Timer Event and adds it to the Clock at the start of the frame.
             * @param config The configuration for the Timer Event.
             */
            addEvent(config: TimerEventConfig): TimerEvent;

            /**
             * Creates a Timer Event and adds it to the Clock at the start of the frame.
             *
             * This is a shortcut for {@link #addEvent} which can be shorter and is compatible with the syntax of the GreenSock Animation Platform (GSAP).
             * @param delay The delay of the function call, in milliseconds.
             * @param callback The function to call after the delay expires.
             * @param args The arguments to call the function with.
             * @param callbackScope The scope (`this` object) to call the function with.
             */
            delayedCall(delay: number, callback: CallbackFn, args: any[], callbackScope: any): TimerEvent;

            /**
             * Clears and recreates the array of pending Timer Events.
             */
            clearPendingEvents(): Clock;

            /**
             * Schedules all active Timer Events for removal at the start of the frame.
             */
            removeAllEvents(): Clock;

            /**
             * Updates the arrays of active and pending Timer Events. Called at the start of the frame.
             * @param time The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
             * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
             */
            preUpdate(time: number, delta: number): void;

            /**
             * Updates the Clock's internal time and all of its Timer Events.
             * @param time The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
             * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
             */
            update(time: number, delta: number): void;
        }

        /**
         * A Timer Event represents a delayed function call. It's managed by a Scene's {@link Clock} and will call its function after a set amount of time has passed.
         * The Timer Event can optionally repeat - i.e. call its function multiple times before finishing, or loop indefinitely.
         *
         * Because it's managed by a Clock, a Timer Event is based on game time, will be affected by its Clock's time scale, and will pause if its Clock pauses.
         */
        class TimerEvent {
            /**
             *
             * @param config The configuration for the Timer Event, including its delay and callback.
             */
            constructor(config: TimerEventConfig);

            /**
             * The delay in ms at which this TimerEvent fires.
             */
            readonly delay: number;

            /**
             * The total number of times this TimerEvent will repeat before finishing.
             */
            readonly repeat: number;

            /**
             * If repeating this contains the current repeat count.
             */
            repeatCount: number;

            /**
             * True if this TimerEvent loops, otherwise false.
             */
            readonly loop: boolean;

            /**
             * The callback that will be called when the TimerEvent occurs.
             */
            callback: CallbackFn;

            /**
             * The scope in which the callback will be called.
             */
            callbackScope: object;

            /**
             * Additional arguments to be passed to the callback.
             */
            args: any[];

            /**
             * Scale the time causing this TimerEvent to update.
             */
            timeScale: number;

            /**
             * Start this many MS into the elapsed (useful if you want a long duration with repeat, but for the first loop to fire quickly)
             */
            startAt: number;

            /**
             * The time in milliseconds which has elapsed since the Timer Event's creation.
             *
             * This value is local for the Timer Event and is relative to its Clock. As such, it's influenced by the Clock's time scale and paused state,
             * the Timer Event's initial {@link #startAt} property, and the Timer Event's {@link #timeScale} and {@link #paused} state.
             */
            elapsed: number;

            /**
             * Whether or not this timer is paused.
             */
            paused: boolean;

            /**
             * Whether the Timer Event's function has been called.
             *
             * When the Timer Event fires, this property will be set to `true`
             * before the callback function is invoked and will be reset immediately afterward if the Timer Event should repeat.
             * The value of this property does not directly influence whether the Timer Event will be removed from its Clock, but can prevent it from firing.
             */
            hasDispatched: boolean;

            /**
             * Completely reinitializes the Timer Event, regardless of its current state, according to a configuration object.
             * @param config The new state for the Timer Event.
             */
            reset(config: TimerEventConfig): TimerEvent;

            /**
             * Gets the progress of the current iteration, not factoring in repeats.
             */
            getProgress(): number;

            /**
             * Gets the progress of the timer overall, factoring in repeats.
             */
            getOverallProgress(): number;

            /**
             * Returns the number of times this Timer Event will repeat before finishing.
             *
             * This should not be confused with the number of times the Timer Event will fire before finishing.
             * A return value of 0 doesn't indicate that the Timer Event has finished running - it indicates that it will not repeat after the next time it fires.
             */
            getRepeatCount(): number;

            /**
             * Returns the local elapsed time for the current iteration of the Timer Event.
             */
            getElapsed(): number;

            /**
             * Returns the local elapsed time for the current iteration of the Timer Event in seconds.
             */
            getElapsedSeconds(): number;

            /**
             * Forces the Timer Event to immediately expire, thus scheduling its removal in the next frame.
             * @param dispatchCallback If `true` (by default `false`), the function of the Timer Event will be called before its removal from its Clock.
             */
            remove(dispatchCallback?: boolean): void;

            /**
             * Destroys all object references in the Timer Event, i.e. its callback, scope, and arguments.
             *
             * Normally, this method is only called by the Clock when it shuts down. As such, it doesn't stop the Timer Event. If called manually,
             * the Timer Event will still be updated by the Clock, but it won't do anything when it fires.
             */
            destroy(): void;
        }
    }

    namespace Tweens {
        namespace Builders {
            /**
             * Retrieves the value of the given key from an object.
             * @param source The object to retrieve the value from.
             * @param key The key to look for in the `source` object.
             * @param defaultValue The default value to return if the `key` doesn't exist or if no `source` object is provided.
             */
            function GetBoolean(source: object, key: string, defaultValue: any): any;

            /**
             * [description]
             * @param ease [description]
             * @param easeParams [description]
             */
            function GetEaseFunction(ease: string | CallbackFn, easeParams: any[]): CallbackFn;

            /**
             * [description]
             * @param source [description]
             * @param key [description]
             * @param defaultValue [description]
             */
            function GetNewValue(source: object, key: string, defaultValue: any): CallbackFn;

            /**
             * [description]
             * @param config The configuration object of the tween to get the target(s) from.
             */
            function GetProps(config: object): any[];

            /**
             * Extracts an array of targets from a Tween configuration object.
             *
             * The targets will be looked for in a `targets` property. If it's a function, its return value will be used as the result.
             * @param config The configuration object to use.
             */
            function GetTargets(config: object): any[];

            /**
             * Returns an array of all tweens in the given config
             * @param config [description]
             */
            function GetTweens(config: object): any[];

            /**
             * Returns `getStart` and `getEnd` functions for a Tween's Data based on a target property and end value.
             *
             * If the end value is a number, it will be treated as an absolute value and the property will be tweened to it.
             * A string can be provided to specify a relative end value which consists of an operation
             * (`+=` to add to the current value, `-=` to subtract from the current value, `*=` to multiply the current value, or `/=` to divide the current value) followed by its operand.
             * A function can be provided to allow greater control over the end value; it will receive the target object being tweened, the name of the property being tweened, and the current
             * value of the property as its arguments. If both the starting and the ending values need to be controlled, an object with `getStart` and `getEnd` callbacks, which will receive the
             * same arguments, can be provided instead. If an object with a `value` property is provided, the property will be used as the effective value under the same rules described here.
             * @param key The name of the property to modify.
             * @param propertyValue The ending value of the property, as described above.
             */
            function GetValueOp(key: string, propertyValue: any): CallbackFn;

            /**
             * [description]
             * @param parent [description]
             * @param config [description]
             * @param defaults [description]
             */
            function NumberTweenBuilder(parent: TweenManager | Timeline, config: object, defaults: TweenConfigDefaults): Tween;

            /**
             * Builds a Timeline of Tweens based on a configuration object.
             *
             * The configuration object (`config`) can have the following properties:
             *
             * `tweens` - an array of tween configuration objects to create and add into the new Timeline, as described by `TweenBuilder`.
             * If this doesn't exist or is empty, the Timeline will start off paused and none of the other configuration settings will be read.
             * If it's a function, it will be called and its return value will be used as the array.
             * `targets` - an array (or function which returns one) of default targets to which to apply the Timeline. Each individual Tween configuration can override this value.
             * `totalDuration` - if specified, each Tween in the Timeline will get an equal portion of this duration, usually in milliseconds, by default.
             * Each individual Tween configuration can override the Tween's duration.
             * `duration` - if `totalDuration` is not specified, the default duration, usually in milliseconds,
             * of each Tween which will be created. Each individual Tween configuration can override the Tween's duration.
             * `delay`, `easeParams`, `ease`, `hold`, `repeat`, `repeatDelay`, `yoyo`, `flipX`, `flipY` - the default settings for each Tween which will be created, as specified by `TweenBuilder`.
             * Each individual Tween configuration can override any of these values.
             * `completeDelay` - if specified, the time to wait, usually in milliseconds, before the Timeline completes.
             * `loop` - how many times the Timeline should loop, or -1 to loop indefinitely.
             * `loopDelay` - the time, usually in milliseconds, between each loop
             * `paused` - if `true`, the Timeline will start paused
             * `useFrames` - if `true`, all duration in the Timeline will be in frames instead of milliseconds
             * `callbackScope` - the default scope (`this` value) to use for each callback registered by the Timeline Builder. If not specified, the Timeline itself will be used.
             * `onStart` - if specified, the `onStart` callback for the Timeline, called every time it starts playing
             * `onStartScope` - the scope (`this` value) to use for the `onStart` callback. If not specified, the `callbackScope` will be used.
             * `onStartParams` - additional arguments to pass to the `onStart` callback. The Timeline will always be the first argument.
             * `onUpdate` - if specified, the `onUpdate` callback for the Timeline, called every frame it's active, regardless of its Tweens
             * `onUpdateScope` - the scope (`this` value) to use for the `onUpdate` callback. If not specified, the `callbackScope` will be used.
             * `onUpdateParams` - additional arguments to pass to the `onUpdate` callback. The Timeline will always be the first argument.
             * `onLoop` - if specified, the `onLoop` callback for the Timeline, called every time it loops
             * `onLoopScope` - the scope (`this` value) to use for the `onLoop` callback. If not specified, the `callbackScope` will be used.
             * `onLoopParams` - additional arguments to pass to the `onLoop` callback. The Timeline will always be the first argument.
             * `onYoyo` - if specified, the `onYoyo` callback for the Timeline, called every time it yoyos
             * `onYoyoScope` - the scope (`this` value) to use for the `onYoyo` callback. If not specified, the `callbackScope` will be used.
             * `onYoyoParams` - additional arguments to pass to the `onYoyo` callback. The first argument will always be `null`, while the Timeline will always be the second argument.
             * `onComplete` - if specified, the `onComplete` callback for the Timeline, called after it completes
             * `onCompleteScope` - the scope (`this` value) to use for the `onComplete` callback. If not specified, the `callbackScope` will be used.
             * `onCompleteParams` - additional arguments to pass to the `onComplete` callback. The Timeline will always be the first argument.
             * @param manager The Tween Manager to which the Timeline will belong.
             * @param config The configuration object for the Timeline, as described above.
             */
            function TimelineBuilder(manager: TweenManager, config: object): Timeline;

            /**
             * [description]
             * @param parent [description]
             * @param config [description]
             * @param defaults Tween configuration defaults.
             * `
             */
            function TweenBuilder(parent: TweenManager | Timeline, config: object, defaults: TweenConfigDefaults): Tween;
        }

        namespace Events {
            /**
             * The Timeline Complete Event.
             *
             * This event is dispatched by a Tween Timeline when it completes playback.
             *
             * Listen to it from a Timeline instance using `Timeline.on('complete', listener)`, i.e.:
             *
             * ```javascript
             * var timeline = this.tweens.timeline({
             *     targets: image,
             *     ease: 'Power1',
             *     duration: 3000,
             *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
             * });
             * timeline.on('complete', listener);
             * timeline.play();
             * ```
             */
            const TIMELINE_COMPLETE: any;

            /**
             * The Timeline Loop Event.
             *
             * This event is dispatched by a Tween Timeline every time it loops.
             *
             * Listen to it from a Timeline instance using `Timeline.on('loop', listener)`, i.e.:
             *
             * ```javascript
             * var timeline = this.tweens.timeline({
             *     targets: image,
             *     ease: 'Power1',
             *     duration: 3000,
             *     loop: 4,
             *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
             * });
             * timeline.on('loop', listener);
             * timeline.play();
             * ```
             */
            const TIMELINE_LOOP: any;

            /**
             * The Timeline Pause Event.
             *
             * This event is dispatched by a Tween Timeline when it is paused.
             *
             * Listen to it from a Timeline instance using `Timeline.on('pause', listener)`, i.e.:
             *
             * ```javascript
             * var timeline = this.tweens.timeline({
             *     targets: image,
             *     ease: 'Power1',
             *     duration: 3000,
             *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
             * });
             * timeline.on('pause', listener);
             * // At some point later ...
             * timeline.pause();
             * ```
             */
            const TIMELINE_PAUSE: any;

            /**
             * The Timeline Resume Event.
             *
             * This event is dispatched by a Tween Timeline when it is resumed from a paused state.
             *
             * Listen to it from a Timeline instance using `Timeline.on('resume', listener)`, i.e.:
             *
             * ```javascript
             * var timeline = this.tweens.timeline({
             *     targets: image,
             *     ease: 'Power1',
             *     duration: 3000,
             *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
             * });
             * timeline.on('resume', listener);
             * // At some point later ...
             * timeline.resume();
             * ```
             */
            const TIMELINE_RESUME: any;

            /**
             * The Timeline Start Event.
             *
             * This event is dispatched by a Tween Timeline when it starts.
             *
             * Listen to it from a Timeline instance using `Timeline.on('start', listener)`, i.e.:
             *
             * ```javascript
             * var timeline = this.tweens.timeline({
             *     targets: image,
             *     ease: 'Power1',
             *     duration: 3000,
             *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
             * });
             * timeline.on('start', listener);
             * timeline.play();
             * ```
             */
            const TIMELINE_START: any;

            /**
             * The Timeline Update Event.
             *
             * This event is dispatched by a Tween Timeline every time it updates, which can happen a lot of times per second,
             * so be careful about listening to this event unless you absolutely require it.
             *
             * Listen to it from a Timeline instance using `Timeline.on('update', listener)`, i.e.:
             *
             * ```javascript
             * var timeline = this.tweens.timeline({
             *     targets: image,
             *     ease: 'Power1',
             *     duration: 3000,
             *     tweens: [ { x: 600 }, { y: 500 }, { x: 100 }, { y: 100 } ]
             * });
             * timeline.on('update', listener);
             * timeline.play();
             * ```
             */
            const TIMELINE_UPDATE: any;
        }

        /**
         * A Timeline combines multiple Tweens into one. Its overall behavior is otherwise similar to a single Tween.
         *
         * The Timeline updates all of its Tweens simultaneously.
         * Its methods allow you to easily build a sequence of Tweens (each one starting after the previous one) or run multiple Tweens at once during given parts of the Timeline.
         */
        class Timeline extends Phaser.Events.EventEmitter {
            /**
             *
             * @param manager The Tween Manager which owns this Timeline.
             */
            constructor(manager: TweenManager);

            /**
             * The Tween Manager which owns this Timeline.
             */
            manager: TweenManager;

            /**
             * A constant value which allows this Timeline to be easily identified as one.
             */
            isTimeline: boolean;

            /**
             * An array of Tween objects, each containing a unique property and target being tweened.
             */
            data: any[];

            /**
             * data array doesn't usually change, so we can cache the length
             */
            totalData: number;

            /**
             * If true then duration, delay, etc values are all frame totals.
             */
            useFrames: boolean;

            /**
             * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
             * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.
             */
            timeScale: number;

            /**
             * Loop this tween? Can be -1 for an infinite loop, or an integer.
             * When enabled it will play through ALL TweenDatas again (use TweenData.repeat to loop a single TD)
             */
            loop: number;

            /**
             * Time in ms/frames before the tween loops.
             */
            loopDelay: number;

            /**
             * How many loops are left to run?
             */
            loopCounter: number;

            /**
             * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = true (as it never completes)
             */
            completeDelay: number;

            /**
             * Countdown timer (used by loopDelay and completeDelay)
             */
            countdown: number;

            /**
             * The current state of the tween
             */
            state: integer;

            /**
             * Does the Tween start off paused? (if so it needs to be started with Tween.play)
             */
            paused: boolean;

            /**
             * Elapsed time in ms/frames of this run through the Tween.
             */
            elapsed: number;

            /**
             * Total elapsed time in ms/frames of the entire Tween, including looping.
             */
            totalElapsed: number;

            /**
             * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.
             */
            duration: number;

            /**
             * Value between 0 and 1. The amount through the Tween, excluding loops.
             */
            progress: number;

            /**
             * Time in ms/frames for all Tweens to complete (including looping)
             */
            totalDuration: number;

            /**
             * Value between 0 and 1. The amount through the entire Tween, including looping.
             */
            totalProgress: number;

            /**
             * Sets the value of the time scale applied to this Timeline. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
             * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.
             * @param value The time scale value to set.
             */
            setTimeScale(value: number): Timeline;

            /**
             * Gets the value of the time scale applied to this Timeline. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
             */
            getTimeScale(): number;

            /**
             * Check whether or not the Timeline is playing.
             */
            isPlaying(): boolean;

            /**
             * [description]
             * @param config [description]
             */
            add(config: object): Timeline;

            /**
             * [description]
             * @param tween [description]
             */
            queue(tween: Tween): Timeline;

            /**
             * [description]
             * @param tween [description]
             */
            hasOffset(tween: Tween): boolean;

            /**
             * Checks whether the offset value is a number or a directive that is relative to previous tweens.
             * @param value The offset value to be evaluated
             */
            isOffsetAbsolute(value: number): boolean;

            /**
             * Checks if the offset is a relative value rather than an absolute one. If the value is just a number, this returns false.
             * @param value The offset value to be evaluated
             */
            isOffsetRelative(value: string): boolean;

            /**
             * Parses the relative offset value, returning a positive or negative number.
             * @param value The relative offset, in the format of '-=500', for example. The first character determines whether it will be a positive or negative number. Spacing matters here.
             * @param base The value to use as the offset.
             */
            getRelativeOffset(value: string, base: number): number;

            /**
             * Calculates the total duration of the timeline.  Computes all tween's durations and returns the full duration of the timeline.
             * The resulting number is stored in the timeline, not as a return value.
             */
            calcDuration(): void;

            /**
             * Initializes the timeline, which means all Tweens get their init() called, and the total duration will be computed.
             * Returns a boolean indicating whether the timeline is auto-started or not.
             */
            init(): boolean;

            /**
             * Resets all of the timeline's tweens back to their initial states.  The boolean parameter indicates whether tweens that are looping should reset as well, or not.
             * @param resetFromLoop If true, resets all looping tweens to their initial values.
             */
            resetTweens(resetFromLoop: boolean): void;

            /**
             * Sets a callback for the Timeline.
             * @param interface The internal interface of callback to set.
             * @param callback Timeline allows multiple tweens to be linked together to create a streaming sequence.
             * @param params The parameters to pass to the callback.
             * @param scope The context scope of the callback.
             */
            setCallback(interface: string, callback: CallbackFn, params?: any[], scope?: object): Timeline;

            /**
             * Delegates #makeActive to the Tween manager.
             * @param tween The tween object to make active.
             */
            makeActive(tween: Tween): TweenManager;

            /**
             * Starts playing the timeline.
             */
            play(): void;

            /**
             * [description]
             */
            nextState(): void;

            /**
             * Returns 'true' if this Timeline has finished and should be removed from the Tween Manager.
             * Otherwise, returns false.
             * @param timestamp [description]
             * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
             */
            update(timestamp: number, delta: number): boolean;

            /**
             * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.
             */
            stop(): void;

            /**
             * Pauses the timeline, retaining its internal state.
             */
            pause(): Timeline;

            /**
             * Resumes the timeline from where it was when it was paused.
             */
            resume(): Timeline;

            /**
             * Checks if any of the tweens has the target as the object they are operating on. Retuns false if no tweens operate on the target object.
             * @param target The target to check all tweens against.
             */
            hasTarget(target: object): boolean;

            /**
             * Stops all the Tweens in the Timeline immediately, whatever stage of progress they are at and flags them for removal by the TweenManager.
             */
            destroy(): void;
        }

        /**
         * TweenData state.
         */
        const CREATED: integer;

        /**
         * TweenData state.
         */
        const INIT: integer;

        /**
         * TweenData state.
         */
        const DELAY: integer;

        /**
         * TweenData state.
         */
        const OFFSET_DELAY: integer;

        /**
         * TweenData state.
         */
        const PENDING_RENDER: integer;

        /**
         * TweenData state.
         */
        const PLAYING_FORWARD: integer;

        /**
         * TweenData state.
         */
        const PLAYING_BACKWARD: integer;

        /**
         * TweenData state.
         */
        const HOLD_DELAY: integer;

        /**
         * TweenData state.
         */
        const REPEAT_DELAY: integer;

        /**
         * TweenData state.
         */
        const COMPLETE: integer;

        /**
         * Tween state.
         */
        const PENDING_ADD: integer;

        /**
         * Tween state.
         */
        const PAUSED: integer;

        /**
         * Tween state.
         */
        const LOOP_DELAY: integer;

        /**
         * Tween state.
         */
        const ACTIVE: integer;

        /**
         * Tween state.
         */
        const COMPLETE_DELAY: integer;

        /**
         * Tween state.
         */
        const PENDING_REMOVE: integer;

        /**
         * Tween state.
         */
        const REMOVED: integer;

        interface TweenConfigDefaults {
            /**
             * The object, or an array of objects, to run the tween on.
             */
            targets: object | object[];
            /**
             * The number of milliseconds to delay before the tween will start.
             */
            delay?: number;
            /**
             * The duration of the tween in milliseconds.
             */
            duration?: number;
            /**
             * The easing equation to use for the tween.
             */
            ease?: string;
            /**
             * Optional easing parameters.
             */
            easeParams?: any[];
            /**
             * The number of milliseconds to hold the tween for before yoyo'ing.
             */
            hold?: number;
            /**
             * The number of times to repeat the tween.
             */
            repeat?: number;
            /**
             * The number of milliseconds to pause before a tween will repeat.
             */
            repeatDelay?: number;
            /**
             * Should the tween complete, then reverse the values incrementally to get back to the starting tween values? The reverse tweening will also take `duration` milliseconds to complete.
             */
            yoyo?: boolean;
            /**
             * Horizontally flip the target of the Tween when it completes (before it yoyos, if set to do so). Only works for targets that support the `flipX` property.
             */
            flipX?: boolean;
            /**
             * Vertically flip the target of the Tween when it completes (before it yoyos, if set to do so). Only works for targets that support the `flipY` property.
             */
            flipY?: boolean;
        }

        /**
         * A Tween is able to manipulate the properties of one or more objects to any given value, based
         * on a duration and interface of ease. They are rarely instantiated directly and instead should be
         * created via the TweenManager.
         */
        class Tween {
            /**
             *
             * @param parent A reference to the parent of this Tween. Either the Tween Manager or a Tween Timeline instance.
             * @param data An array of TweenData objects, each containing a unique property to be tweened.
             * @param targets An array of targets to be tweened.
             */
            constructor(parent: TweenManager | Timeline, data: TweenDataConfig[], targets: any[]);

            /**
             * A reference to the parent of this Tween.
             * Either the Tween Manager or a Tween Timeline instance.
             */
            parent: TweenManager | Timeline;

            /**
             * Is the parent of this Tween a Timeline?
             */
            parentIsTimeline: boolean;

            /**
             * An array of TweenData objects, each containing a unique property and target being tweened.
             */
            data: TweenDataConfig[];

            /**
             * The cached length of the data array.
             */
            totalData: integer;

            /**
             * An array of references to the target/s this Tween is operating on.
             */
            targets: object[];

            /**
             * Cached target total (not necessarily the same as the data total)
             */
            totalTargets: integer;

            /**
             * If `true` then duration, delay, etc values are all frame totals.
             */
            useFrames: boolean;

            /**
             * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
             * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.
             */
            timeScale: number;

            /**
             * Loop this tween? Can be -1 for an infinite loop, or an integer.
             * When enabled it will play through ALL TweenDatas again. Use TweenData.repeat to loop a single element.
             */
            loop: number;

            /**
             * Time in ms/frames before the tween loops.
             */
            loopDelay: number;

            /**
             * How many loops are left to run?
             */
            loopCounter: number;

            /**
             * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = -1 (as it never completes)
             */
            completeDelay: number;

            /**
             * Countdown timer (used by timeline offset, loopDelay and completeDelay)
             */
            countdown: number;

            /**
             * Set only if this Tween is part of a Timeline.
             */
            offset: number;

            /**
             * Set only if this Tween is part of a Timeline. The calculated offset amount.
             */
            calculatedOffset: number;

            /**
             * The current state of the tween
             */
            state: integer;

            /**
             * Does the Tween start off paused? (if so it needs to be started with Tween.play)
             */
            paused: boolean;

            /**
             * Elapsed time in ms/frames of this run through the Tween.
             */
            elapsed: number;

            /**
             * Total elapsed time in ms/frames of the entire Tween, including looping.
             */
            totalElapsed: number;

            /**
             * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.
             */
            duration: number;

            /**
             * Value between 0 and 1. The amount through the Tween, excluding loops.
             */
            progress: number;

            /**
             * Time in ms/frames for the Tween to complete (including looping)
             */
            totalDuration: number;

            /**
             * Value between 0 and 1. The amount through the entire Tween, including looping.
             */
            totalProgress: number;

            /**
             * An object containing the various Tween callback references.
             */
            callbacks: object;

            /**
             * Returns the current value of the Tween.
             */
            getValue(): number;

            /**
             * Set the scale the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
             * @param value The scale factor for timescale.
             */
            setTimeScale(value: number): this;

            /**
             * Returns the scale of the time applied to this Tween.
             */
            getTimeScale(): number;

            /**
             * Checks if the Tween is currently active.
             */
            isPlaying(): boolean;

            /**
             * Checks if the Tween is currently paused.
             */
            isPaused(): boolean;

            /**
             * See if this Tween is currently acting upon the given target.
             * @param target The target to check against this Tween.
             */
            hasTarget(target: object): boolean;

            /**
             * Updates the value of a property of this Tween to a new value, without adjusting the
             * Tween duration or current progress.
             *
             * You can optionally tell it to set the 'start' value to be the current value (before the change).
             * @param key The property to set the new value for.
             * @param value The new value of the property.
             * @param startToCurrent Should this change set the start value to be the current value? Default false.
             */
            updateTo(key: string, value: any, startToCurrent?: boolean): this;

            /**
             * Restarts the tween from the beginning.
             */
            restart(): this;

            /**
             * Internal method that calculates the overall duration of the Tween.
             */
            calcDuration(): void;

            /**
             * Called by TweenManager.preUpdate as part of its loop to check pending and active tweens.
             * Should not be called directly.
             */
            init(): boolean;

            /**
             * Internal method that advances to the next state of the Tween during playback.
             */
            nextState(): void;

            /**
             * Pauses the Tween immediately. Use `resume` to continue playback.
             */
            pause(): this;

            /**
             * Starts a Tween playing.
             *
             * You only need to call this method if you have configured the tween to be paused on creation.
             * @param resetFromTimeline Is this Tween being played as part of a Timeline?
             */
            play(resetFromTimeline: boolean): this;

            /**
             * Internal method that resets all of the Tween Data, including the progress and elapsed values.
             * @param resetFromLoop Has this method been called as part of a loop?
             */
            resetTweenData(resetFromLoop: boolean): void;

            /**
             * Resumes the playback of a previously paused Tween.
             */
            resume(): this;

            /**
             * Attempts to seek to a specific position in a Tween.
             * @param toPosition A value between 0 and 1 which represents the progress point to seek to.
             */
            seek(toPosition: number): this;

            /**
             * Sets an event based callback to be invoked during playback.
             * @param interface interface of the callback.
             * @param callback Callback function.
             * @param params An array of parameters for specified callbacks types.
             * @param scope The context the callback will be invoked in.
             */
            setCallback(interface: string, callback: CallbackFn, params?: any[], scope?: object): this;

            /**
             * Flags the Tween as being complete, whatever stage of progress it is at.
             *
             * If an onComplete callback has been defined it will automatically invoke it, unless a `delay`
             * argument is provided, in which case the Tween will delay for that period of time before calling the callback.
             *
             * If you don't need a delay, or have an onComplete callback, then call `Tween.stop` instead.
             * @param delay The time to wait before invoking the complete callback. If zero it will fire immediately. Default 0.
             */
            complete(delay?: number): this;

            /**
             * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.
             * @param resetTo A value between 0 and 1.
             */
            stop(resetTo?: number): this;

            /**
             * Internal method that advances the Tween based on the time values.
             * @param timestamp The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
             * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
             */
            update(timestamp: number, delta: number): boolean;

            /**
             * Internal method used as part of the playback process that sets a tween to play in reverse.
             * @param tween The Tween to update.
             * @param tweenData The TweenData property to update.
             * @param diff Any extra time that needs to be accounted for in the elapsed and progress values.
             */
            setStateFromEnd(tween: Tween, tweenData: TweenDataConfig, diff: number): integer;

            /**
             * Internal method used as part of the playback process that sets a tween to play from the start.
             * @param tween The Tween to update.
             * @param tweenData The TweenData property to update.
             * @param diff Any extra time that needs to be accounted for in the elapsed and progress values.
             */
            setStateFromStart(tween: Tween, tweenData: TweenDataConfig, diff: number): integer;

            /**
             * Internal method that advances the TweenData based on the time value given.
             * @param tween The Tween to update.
             * @param tweenData The TweenData property to update.
             * @param delta Either a value in ms, or 1 if Tween.useFrames is true
             */
            updateTweenData(tween: Tween, tweenData: TweenDataConfig, delta: number): boolean;
        }

        interface TweenDataConfig {
            /**
             * The target to tween.
             */
            target: object;
            /**
             * The property of the target being tweened.
             */
            key: string;
            /**
             * The returned value sets what the property will be at the END of the Tween.
             */
            getEndValue: CallbackFn;
            /**
             * The returned value sets what the property will be at the START of the Tween.
             */
            getStartValue: CallbackFn;
            /**
             * The ease function this tween uses.
             */
            ease: CallbackFn;
            /**
             * Duration of the tween in ms/frames, excludes time for yoyo or repeats.
             */
            duration?: number;
            /**
             * The total calculated duration of this TweenData (based on duration, repeat, delay and yoyo)
             */
            totalDuration?: number;
            /**
             * Time in ms/frames before tween will start.
             */
            delay?: number;
            /**
             * Cause the tween to return back to its start value after hold has expired.
             */
            yoyo?: boolean;
            /**
             * Time in ms/frames the tween will pause before running the yoyo or starting a repeat.
             */
            hold?: number;
            /**
             * Number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.
             */
            repeat?: integer;
            /**
             * Time in ms/frames before the repeat will start.
             */
            repeatDelay?: number;
            /**
             * Automatically call toggleFlipX when the TweenData yoyos or repeats
             */
            flipX?: boolean;
            /**
             * Automatically call toggleFlipY when the TweenData yoyos or repeats
             */
            flipY?: boolean;
            /**
             * Between 0 and 1 showing completion of this TweenData.
             */
            progress?: number;
            /**
             * Delta counter
             */
            elapsed?: number;
            /**
             * How many repeats are left to run?
             */
            repeatCounter?: integer;
            /**
             * Ease value data.
             */
            start?: number;
            /**
             * Ease value data.
             */
            current?: number;
            /**
             * Ease value data.
             */
            end?: number;
            /**
             * Time duration 1.
             */
            t1?: number;
            /**
             * Time duration 2.
             */
            t2?: number;
            /**
             * LoadValue generation functions.
             */
            gen?: TweenDataGenConfig;
            /**
             * TWEEN_CONST.CREATED
             */
            state?: integer;
        }

        /**
         * Returns a TweenDataConfig object that describes the tween data for a unique property of a unique target. A single Tween consists of multiple TweenDatas,
         * depending on how many properties are being changed by the Tween.
         *
         * This is an internal function used by the TweenBuilder and should not be accessed directly, instead, Tweens should be created using the GameObjectFactory or GameObjectCreator.
         * @param target The target to tween.
         * @param key The property of the target to tween.
         * @param getEnd What the property will be at the END of the Tween.
         * @param getStart What the property will be at the START of the Tween.
         * @param ease The ease function this tween uses.
         * @param delay Time in ms/frames before tween will start.
         * @param duration Duration of the tween in ms/frames.
         * @param yoyo Determines whether the tween should return back to its start value after hold has expired.
         * @param hold Time in ms/frames the tween will pause before repeating or returning to its starting value if yoyo is set to true.
         * @param repeat Number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.
         * @param repeatDelay Time in ms/frames before the repeat will start.
         * @param flipX Should toggleFlipX be called when yoyo or repeat happens?
         * @param flipY Should toggleFlipY be called when yoyo or repeat happens?
         */
        function TweenData(
            target: object,
            key: string,
            getEnd: CallbackFn,
            getStart: CallbackFn,
            ease: CallbackFn,
            delay: number,
            duration: number,
            yoyo: boolean,
            hold: number,
            repeat: number,
            repeatDelay: number,
            flipX: boolean,
            flipY: boolean
        ): TweenDataConfig;

        /**
         * The Tween Manager is a default Scene Plugin which controls and updates Tweens and Timelines.
         */
        class TweenManager {
            /**
             *
             * @param scene The Scene which owns this Tween Manager.
             */
            constructor(scene: Scene);

            /**
             * The Scene which owns this Tween Manager.
             */
            scene: Scene;

            /**
             * The Systems object of the Scene which owns this Tween Manager.
             */
            systems: Scenes.Systems;

            /**
             * The time scale of the Tween Manager.
             *
             * This value scales the time delta between two frames, thus influencing the speed of time for all Tweens owned by this Tween Manager.
             */
            timeScale: number;

            /**
             * Create a Tween Timeline and return it, but do NOT add it to the active or pending Tween lists.
             * @param config The configuration object for the Timeline and its Tweens.
             */
            createTimeline(config: object): Timeline;

            /**
             * Create a Tween Timeline and add it to the active Tween list/
             * @param config The configuration object for the Timeline and its Tweens.
             */
            timeline(config: object): Timeline;

            /**
             * Create a Tween and return it, but do NOT add it to the active or pending Tween lists.
             * @param config The configuration object for the Tween as per {@link Phaser.Tweens.Builders.TweenBuilder}.
             */
            create(config: object): Tween;

            /**
             * Create a Tween and add it to the active Tween list.
             * @param config The configuration object for the Tween as per the {@link Phaser.Tweens.Builders.TweenBuilder}.
             */
            add(config: object): Tween;

            /**
             * Add an existing tween into the active Tween list.
             * @param tween The Tween to add.
             */
            existing(tween: Tween): TweenManager;

            /**
             * Create a Tween and add it to the active Tween list.
             * @param config The configuration object for the Number Tween as per the {@link Phaser.Tweens.Builders.NumberTweenBuilder}.
             */
            addCounter(config: object): Tween;

            /**
             * Updates the Tween Manager's internal lists at the start of the frame.
             *
             * This method will return immediately if no changes have been indicated.
             */
            preUpdate(): void;

            /**
             * Updates all Tweens and Timelines of the Tween Manager.
             * @param timestamp The current time in milliseconds.
             * @param delta The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
             */
            update(timestamp: number, delta: number): void;

            /**
             * Checks if a Tween or Timeline is active and adds it to the Tween Manager at the start of the frame if it isn't.
             * @param tween The Tween to check.
             */
            makeActive(tween: Tween): TweenManager;

            /**
             * Passes all Tweens to the given callback.
             * @param callback The function to call.
             * @param scope The scope (`this` object) to call the function with.
             * @param args The arguments to pass into the function. Its first argument will always be the Tween currently being iterated.
             */
            each(callback: CallbackFn, scope?: object, ...args: any[]): void;

            /**
             * Returns an array of all active Tweens and Timelines in the Tween Manager.
             */
            getAllTweens(): Tween[];

            /**
             * Returns the scale of the time delta for all Tweens and Timelines owned by this Tween Manager.
             */
            getGlobalTimeScale(): number;

            /**
             * Returns an array of all Tweens or Timelines in the Tween Manager which affect the given target or array of targets.
             * @param target The target to look for. Provide an array to look for multiple targets.
             */
            getTweensOf(target: object | object[]): Tween[];

            /**
             * Checks if the given object is being affected by a playing Tween.
             * @param target target Phaser.Tweens.Tween object
             */
            isTweening(target: object): boolean;

            /**
             * Stops all Tweens in this Tween Manager. They will be removed at the start of the frame.
             */
            killAll(): TweenManager;

            /**
             * Stops all Tweens which affect the given target or array of targets. The Tweens will be removed from the Tween Manager at the start of the frame.
             * @param target The target to look for. Provide an array to look for multiple targets.
             */
            killTweensOf(target: object | object[]): TweenManager;

            /**
             * Pauses all Tweens in this Tween Manager.
             */
            pauseAll(): TweenManager;

            /**
             * Resumes all Tweens in this Tween Manager.
             */
            resumeAll(): TweenManager;

            /**
             * Sets a new scale of the time delta for this Tween Manager.
             *
             * The time delta is the time elapsed between two consecutive frames and influences the speed of time for this Tween Manager and all Tweens it owns.
             * Values higher than 1 increase the speed of time, while values smaller than 1 decrease it. A value of 0 freezes time and is effectively equivalent to pausing all Tweens.
             * @param value The new scale of the time delta, where 1 is the normal speed.
             */
            setGlobalTimeScale(value: number): TweenManager;

            /**
             * The Scene that owns this plugin is shutting down.
             * We need to kill and reset all internal properties as well as stop listening to Scene events.
             */
            shutdown(): void;

            /**
             * The Scene that owns this plugin is being destroyed.
             * We need to shutdown and then kill off all external references.
             */
            destroy(): void;
        }
    }

    namespace Utils {
        namespace Array {
            /**
             * Adds the given item, or array of items, to the array.
             *
             * Each item must be unique within the array.
             *
             * The array is modified in-place and returned.
             *
             * You can optionally specify a limit to the maximum size of the array. If the quantity of items being
             * added will take the array length over this limit, it will stop adding once the limit is reached.
             *
             * You can optionally specify a callback to be invoked for each item successfully added to the array.
             * @param array The array to be added to.
             * @param item The item, or array of items, to add to the array. Each item must be unique within the array.
             * @param limit Optional limit which caps the size of the array.
             * @param callback A callback to be invoked for each item successfully added to the array.
             * @param context The context in which the callback is invoked.
             */
            function Add<T>(array: any[], item: T | any[], limit?: integer, callback?: CallbackFn, context?: object): T[] | any[];

            /**
             * Adds the given item, or array of items, to the array starting at the index specified.
             *
             * Each item must be unique within the array.
             *
             * Existing elements in the array are shifted up.
             *
             * The array is modified in-place and returned.
             *
             * You can optionally specify a limit to the maximum size of the array. If the quantity of items being
             * added will take the array length over this limit, it will stop adding once the limit is reached.
             *
             * You can optionally specify a callback to be invoked for each item successfully added to the array.
             * @param array The array to be added to.
             * @param item The item, or array of items, to add to the array.
             * @param index The index in the array where the item will be inserted. Default 0.
             * @param limit Optional limit which caps the size of the array.
             * @param callback A callback to be invoked for each item successfully added to the array.
             * @param context The context in which the callback is invoked.
             */
            function AddAt(array: any[], item: any, index?: integer, limit?: integer, callback?: CallbackFn, context?: object): any[];

            /**
             * Moves the given element to the top of the array.
             * The array is modified in-place.
             * @param array The array.
             * @param item The element to move.
             */
            function BringToTop(array: any[], item: any): any;

            /**
             * Returns the total number of elements in the array which have a property matching the given value.
             * @param array The array to search.
             * @param property The property to test on each array element.
             * @param value The value to test the property against. Must pass a strict (`===`) comparison check.
             * @param startIndex An optional start index to search from.
             * @param endIndex An optional end index to search to.
             */
            function CountAllMatching(array: any[], property: string, value: any, startIndex?: integer, endIndex?: integer): integer;

            /**
             * Passes each element in the array to the given callback.
             * @param array The array to search.
             * @param callback A callback to be invoked for each item in the array.
             * @param context The context in which the callback is invoked.
             * @param args Additional arguments that will be passed to the callback, after the current array item.
             */
            function Each(array: any[], callback: CallbackFn, context: object, ...args: any[]): any[];

            /**
             * Passes each element in the array, between the start and end indexes, to the given callback.
             * @param array The array to search.
             * @param callback A callback to be invoked for each item in the array.
             * @param context The context in which the callback is invoked.
             * @param startIndex The start index to search from.
             * @param endIndex The end index to search to.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            function EachInRange(array: any[], callback: CallbackFn, context: object, startIndex: integer, endIndex: integer, ...args: any[]): any[];

            /**
             * Searches a pre-sorted array for the closet value to the given number.
             *
             * If the `key` argument is given it will assume the array contains objects that all have the required `key` property name,
             * and will check for the closest value of those to the given number.
             * @param value The value to search for in the array.
             * @param array The array to search, which must be sorted.
             * @param key An optional property key. If specified the array elements property will be checked against value.
             */
            function FindClosestInSorted<T>(value: number, array: T[], key?: string): number | T;

            /**
             * Returns all elements in the array.
             *
             * You can optionally specify a matching criteria using the `property` and `value` arguments.
             *
             * For example: `getAll('visible', true)` would return only elements that have their visible property set.
             *
             * Optionally you can specify a start and end index. For example if the array had 100 elements,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
             * the first 50 elements.
             * @param array The array to search.
             * @param property The property to test on each array element.
             * @param value The value to test the property against. Must pass a strict (`===`) comparison check.
             * @param startIndex An optional start index to search from.
             * @param endIndex An optional end index to search to.
             */
            function GetAll(array: any[], property?: string, value?: any, startIndex?: integer, endIndex?: integer): any[];

            /**
             * Returns the first element in the array.
             *
             * You can optionally specify a matching criteria using the `property` and `value` arguments.
             *
             * For example: `getAll('visible', true)` would return the first element that had its `visible` property set.
             *
             * Optionally you can specify a start and end index. For example if the array had 100 elements,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would search only the first 50 elements.
             * @param array The array to search.
             * @param property The property to test on each array element.
             * @param value The value to test the property against. Must pass a strict (`===`) comparison check.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default array.length.
             */
            function GetFirst(array: any[], property?: string, value?: any, startIndex?: integer, endIndex?: integer): object;

            /**
             * Returns a Random element from the array.
             * @param array The array to select the random entry from.
             * @param startIndex An optional start index. Default 0.
             * @param length An optional length, the total number of elements (from the startIndex) to choose from. Default array.length.
             */
            function GetRandom(array: any[], startIndex?: integer, length?: integer): any;

            namespace Matrix {
                /**
                 * Checks if an array can be used as a matrix.
                 *
                 * A matrix is a two-dimensional array (array of arrays), where all sub-arrays (rows) have the same length. There must be at least two rows:
                 *
                 * ```
                 *    [
                 *        [ 1, 1, 1, 1, 1, 1 ],
                 *        [ 2, 0, 0, 0, 0, 4 ],
                 *        [ 2, 0, 1, 2, 0, 4 ],
                 *        [ 2, 0, 3, 4, 0, 4 ],
                 *        [ 2, 0, 0, 0, 0, 4 ],
                 *        [ 3, 3, 3, 3, 3, 3 ]
                 *    ]
                 * ```
                 * @param matrix The array to check.
                 */
                function CheckMatrix(matrix: any[]): boolean;

                /**
                 * Generates a string (which you can pass to console.log) from the given Array Matrix.
                 * @param matrix A 2-dimensional array.
                 */
                function MatrixToString(matrix: any[]): string;

                /**
                 * Reverses the columns in the given Array Matrix.
                 * @param matrix The array matrix to reverse the columns for.
                 */
                function ReverseColumns(matrix: any[]): any[];

                /**
                 * Reverses the rows in the given Array Matrix.
                 * @param matrix The array matrix to reverse the rows for.
                 */
                function ReverseRows(matrix: any[]): any[];

                /**
                 * Rotates the array matrix 180 degrees.
                 * @param matrix The array to rotate.
                 */
                function Rotate180(matrix: any[]): any[];

                /**
                 * Rotates the array matrix to the left (or 90 degrees)
                 * @param matrix The array to rotate.
                 */
                function RotateLeft(matrix: any[]): any[];

                /**
                 * Rotates the array matrix based on the given rotation value.
                 *
                 * The value can be given in degrees: 90, -90, 270, -270 or 180,
                 * or a string command: `rotateLeft`, `rotateRight` or `rotate180`.
                 *
                 * Based on the routine from {@link http://jsfiddle.net/MrPolywhirl/NH42z/}.
                 * @param matrix The array to rotate.
                 * @param direction The amount to rotate the matrix by. Default 90.
                 */
                function RotateMatrix(matrix: any[], direction?: number | string): any[];

                /**
                 * Rotates the array matrix to the left (or -90 degrees)
                 * @param matrix The array to rotate.
                 */
                function RotateRight(matrix: any[]): any[];

                /**
                 * Transposes the elements of the given matrix (array of arrays).
                 *
                 * The transpose of a matrix is a new matrix whose rows are the columns of the original.
                 * @param array The array matrix to transpose.
                 */
                function TransposeMatrix(array: any[]): any[];
            }

            /**
             * Moves the given array element down one place in the array.
             * The array is modified in-place.
             * @param array The input array.
             * @param item The element to move down the array.
             */
            function MoveDown(array: any[], item: any): any[];

            /**
             * Moves an element in an array to a new position within the same array.
             * The array is modified in-place.
             * @param array The array.
             * @param item The element to move.
             * @param index The new index that the element will be moved to.
             */
            function MoveTo(array: any[], item: any, index: integer): any;

            /**
             * Moves the given array element up one place in the array.
             * The array is modified in-place.
             * @param array The input array.
             * @param item The element to move up the array.
             */
            function MoveUp(array: any[], item: any): any[];

            /**
             * Create an array representing the range of numbers (usually integers), between, and inclusive of,
             * the given `start` and `end` arguments. For example:
             *
             * `var array = numberArray(2, 4); // array = [2, 3, 4]`
             * `var array = numberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
             *
             * This is equivalent to `numberArrayStep(start, end, 1)`.
             *
             * You can optionally provide a prefix and / or suffix string. If given the array will contain
             * strings, not integers. For example:
             *
             * `var array = numberArray(1, 4, 'Level '); // array = ["Level 1", "Level 2", "Level 3", "Level 4"]`
             * `var array = numberArray(5, 7, 'HD-', '.png'); // array = ["HD-5.png", "HD-6.png", "HD-7.png"]`
             * @param start The minimum value the array starts with.
             * @param end The maximum value the array contains.
             * @param prefix Optional prefix to place before the number. If provided the array will contain strings, not integers.
             * @param suffix Optional suffix to place after the number. If provided the array will contain strings, not integers.
             */
            function NumberArray(start: number, end: number, prefix?: string, suffix?: string): number[] | string[];

            /**
             * Create an array of numbers (positive and/or negative) progressing from `start`
             * up to but not including `end` by advancing by `step`.
             *
             * If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.
             *
             * Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;
             * for forward compatibility make sure to pass in actual numbers.
             * @param start The start of the range. Default 0.
             * @param end The end of the range. Default null.
             * @param step The value to increment or decrement by. Default 1.
             */
            function NumberArrayStep(start?: number, end?: number, step?: number): number[];

            /**
             * A [Floyd-Rivest](https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm) quick selection algorithm.
             *
             * Rearranges the array items so that all items in the [left, k] range are smaller than all items in [k, right];
             * The k-th element will have the (k - left + 1)th smallest value in [left, right].
             *
             * The array is modified in-place.
             *
             * Based on code by [Vladimir Agafonkin](https://www.npmjs.com/~mourner)
             * @param arr The array to sort.
             * @param k The k-th element index.
             * @param left The index of the left part of the range. Default 0.
             * @param right The index of the right part of the range.
             * @param compare An optional comparison function. Is passed two elements and should return 0, 1 or -1.
             */
            function QuickSelect(arr: any[], k: integer, left?: integer, right?: integer, compare?: CallbackFn): void;

            /**
             * Creates an array populated with a range of values, based on the given arguments and configuration object.
             *
             * Range ([a,b,c], [1,2,3]) =
             * a1, a2, a3, b1, b2, b3, c1, c2, c3
             *
             * Range ([a,b], [1,2,3], qty = 3) =
             * a1, a1, a1, a2, a2, a2, a3, a3, a3, b1, b1, b1, b2, b2, b2, b3, b3, b3
             *
             * Range ([a,b,c], [1,2,3], repeat x1) =
             * a1, a2, a3, b1, b2, b3, c1, c2, c3, a1, a2, a3, b1, b2, b3, c1, c2, c3
             *
             * Range ([a,b], [1,2], repeat -1 = endless, max = 14) =
             * Maybe if max is set then repeat goes to -1 automatically?
             * a1, a2, b1, b2, a1, a2, b1, b2, a1, a2, b1, b2, a1, a2 (capped at 14 elements)
             *
             * Range ([a], [1,2,3,4,5], random = true) =
             * a4, a1, a5, a2, a3
             *
             * Range ([a, b], [1,2,3], random = true) =
             * b3, a2, a1, b1, a3, b2
             *
             * Range ([a, b, c], [1,2,3], randomB = true) =
             * a3, a1, a2, b2, b3, b1, c1, c3, c2
             *
             * Range ([a], [1,2,3,4,5], yoyo = true) =
             * a1, a2, a3, a4, a5, a5, a4, a3, a2, a1
             *
             * Range ([a, b], [1,2,3], yoyo = true) =
             * a1, a2, a3, b1, b2, b3, b3, b2, b1, a3, a2, a1
             * @param a The first array of range elements.
             * @param b The second array of range elements.
             * @param options A range configuration object. Can contain: repeat, random, randomB, yoyo, max, qty.
             */
            function Range(a: any[], b: any[], options?: object): any[];

            /**
             * Removes the given item, or array of items, from the array.
             *
             * The array is modified in-place.
             *
             * You can optionally specify a callback to be invoked for each item successfully removed from the array.
             * @param array The array to be modified.
             * @param item The item, or array of items, to be removed from the array.
             * @param callback A callback to be invoked for each item successfully removed from the array.
             * @param context The context in which the callback is invoked.
             */
            function Remove<T>(array: any[], item: T | any[], callback?: CallbackFn, context?: object): T | any[];

            /**
             * Removes the item from the given position in the array.
             *
             * The array is modified in-place.
             *
             * You can optionally specify a callback to be invoked for the item if it is successfully removed from the array.
             * @param array The array to be modified.
             * @param index The array index to remove the item from. The index must be in bounds or it will throw an error.
             * @param callback A callback to be invoked for the item removed from the array.
             * @param context The context in which the callback is invoked.
             */
            function RemoveAt(array: any[], index: integer, callback?: CallbackFn, context?: object): any;

            /**
             * Removes the item within the given range in the array.
             *
             * The array is modified in-place.
             *
             * You can optionally specify a callback to be invoked for the item/s successfully removed from the array.
             * @param array The array to be modified.
             * @param startIndex The start index to remove from.
             * @param endIndex The end index to remove to.
             * @param callback A callback to be invoked for the item removed from the array.
             * @param context The context in which the callback is invoked.
             */
            function RemoveBetween(array: any[], startIndex: integer, endIndex: integer, callback?: CallbackFn, context?: object): any[];

            /**
             * Removes a random object from the given array and returns it.
             * Will return null if there are no array items that fall within the specified range or if there is no item for the randomly chosen index.
             * @param array The array to removed a random element from.
             * @param start The array index to start the search from. Default 0.
             * @param length Optional restriction on the number of elements to randomly select from. Default array.length.
             */
            function RemoveRandomElement(array: any[], start?: integer, length?: integer): object;

            /**
             * Replaces an element of the array with the new element.
             * The new element cannot already be a member of the array.
             * The array is modified in-place.
             * @param oldChild The element in the array that will be replaced.
             * @param newChild The element to be inserted into the array at the position of `oldChild`.
             */
            function Replace(oldChild: any, newChild: any): boolean;

            /**
             * Moves the element at the start of the array to the end, shifting all items in the process.
             * The "rotation" happens to the left.
             * @param array The array to shift to the left. This array is modified in place.
             * @param total The number of times to shift the array. Default 1.
             */
            function RotateLeft(array: any[], total?: integer): any;

            /**
             * Moves the element at the end of the array to the start, shifting all items in the process.
             * The "rotation" happens to the right.
             * @param array The array to shift to the right. This array is modified in place.
             * @param total The number of times to shift the array. Default 1.
             */
            function RotateRight(array: any[], total?: integer): any;

            /**
             * Tests if the start and end indexes are a safe range for the given array.
             * @param array The array to check.
             * @param startIndex The start index.
             * @param endIndex The end index.
             * @param throwError Throw an error if the range is out of bounds. Default true.
             */
            function SafeRange(array: any[], startIndex: integer, endIndex: integer, throwError?: boolean): boolean;

            /**
             * Moves the given element to the bottom of the array.
             * The array is modified in-place.
             * @param array The array.
             * @param item The element to move.
             */
            function SendToBack(array: any[], item: any): any;

            /**
             * Scans the array for elements with the given property. If found, the property is set to the `value`.
             *
             * For example: `SetAll('visible', true)` would set all elements that have a `visible` property to `false`.
             *
             * Optionally you can specify a start and end index. For example if the array had 100 elements,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would update only the first 50 elements.
             * @param array The array to search.
             * @param property The property to test for on each array element.
             * @param value The value to set the property to.
             * @param startIndex An optional start index to search from.
             * @param endIndex An optional end index to search to.
             */
            function SetAll(array: any[], property: string, value: any, startIndex?: integer, endIndex?: integer): any[];

            /**
             * Shuffles the contents of the given array using the Fisher-Yates implementation.
             *
             * The original array is modified directly and returned.
             * @param array The array to shuffle. This array is modified in place.
             */
            function Shuffle(array: any[]): any[];

            /**
             * Removes a single item from an array and returns it without creating gc, like the native splice does.
             * Based on code by Mike Reinstein.
             * @param array The array to splice from.
             * @param index The index of the item which should be spliced.
             */
            function SpliceOne(array: any[], index: integer): any;

            namespace StableSortFunctions {
                /**
                 * Sort the input array and simply copy it back if the result isn't in the original array, which happens on an odd number of passes.
                 * @param arr The input array.
                 * @param comp The comparison handler.
                 */
                function inplace(arr: any[], comp: CallbackFn): any[];
            }

            /**
             * A stable array sort, because `Array#sort()` is not guaranteed stable.
             * This is an implementation of merge sort, without recursion.
             * @param arr The input array to be sorted.
             * @param comp The comparison handler.
             */
            function StableSort(arr: any[], comp: CallbackFn): any[];

            /**
             * Swaps the position of two elements in the given array.
             * The elements must exist in the same array.
             * The array is modified in-place.
             * @param array The input array.
             * @param item1 The first element to swap.
             * @param item2 The second element to swap.
             */
            function Swap(array: any[], item1: any, item2: any): any[];
        }

        /**
         * A NOOP (No Operation) callback function.
         *
         * Used internally by Phaser when it's more expensive to determine if a callback exists
         * than it is to just invoke an empty function.
         */
        function NOOP(): void;

        namespace Objects {
            /**
             * Shallow Object Clone. Will not clone nested objects.
             * @param obj the object from which to clone
             */
            function Clone(obj: object): object;

            /**
             * This is a slightly modified version of http://api.jquery.com/jQuery.extend/
             */
            function Extend(): object;

            /**
             * Retrieves a value from an object. Allows for more advanced selection options, including:
             *
             * Allowed types:
             *
             * Implicit
             * {
             *     x: 4
             * }
             *
             * From function
             * {
             *     x: CallbackFn ()
             * }
             *
             * Randomly pick one element from the array
             * {
             *     x: [a, b, c, d, e, f]
             * }
             *
             * Random integer between min and max:
             * {
             *     x: { randInt: [min, max] }
             * }
             *
             * Random float between min and max:
             * {
             *     x: { randFloat: [min, max] }
             * }
             * @param source The object to retrieve the value from.
             * @param key The name of the property to retrieve from the object.
             * If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner`
             * property from the object stored in the `banner` property of the `source` object.
             * @param defaultValue The value to return if the `key` isn't found in the `source` object.
             */
            function GetAdvancedValue(source: object, key: string, defaultValue: any): any;

            /**
             * Finds the key within the top level of the {@link source} object, or returns {@link defaultValue}
             * @param source The object to search
             * @param key The key for the property on source. Must exist at the top level of the source object (no periods)
             * @param defaultValue The default value to use if the key does not exist.
             */
            function GetFastValue(source: object, key: string, defaultValue?: any): any;

            /**
             * Retrieves and clamps a numerical value from an object.
             * @param source The object to retrieve the value from.
             * @param key The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`).
             * @param min The minimum value which can be returned.
             * @param max The maximum value which can be returned.
             * @param defaultValue The value to return if the property doesn't exist. It's also constrained to the given bounds.
             */
            function GetMinMaxValue(source: object, key: string, min: number, max: number, defaultValue: number): number;

            /**
             * Retrieves a value from an object.
             * @param source The object to retrieve the value from.
             * @param key The name of the property to retrieve from the object.
             * If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the
             * object stored in the `banner` property of the `source` object.
             * @param defaultValue The value to return if the `key` isn't found in the `source` object.
             */
            function GetValue(source: object, key: string, defaultValue: any): any;

            /**
             * Verifies that an object contains all requested keys
             * @param source an object on which to check for key existence
             * @param keys an array of keys to ensure the source object contains
             */
            function HasAll(source: object, keys: string[]): boolean;

            /**
             * Verifies that an object contains at least one of the requested keys
             * @param source an object on which to check for key existence
             * @param keys an array of keys to search the object for
             */
            function HasAny(source: object, keys: string[]): boolean;

            /**
             * Determine whether the source object has a property with the specified key.
             * @param source The source object to be checked.
             * @param key The property to check for within the object
             */
            function HasValue(source: object, key: string): boolean;

            /**
             * This is a slightly modified version of jQuery.isPlainObject.
             * A plain object is an object whose internal class property is [object Object].
             * @param obj The object to inspect.
             */
            function IsPlainObject(obj: object): boolean;

            /**
             * Creates a new Object using all values from obj1 and obj2.
             * If a value exists in both obj1 and obj2, the value in obj1 is used.
             * @param obj1 The first object.
             * @param obj2 The second object.
             */
            function Merge(obj1: object, obj2: object): object;

            /**
             * Creates a new Object using all values from obj1.
             *
             * Then scans obj2. If a property is found in obj2 that *also* exists in obj1, the value from obj2 is used, otherwise the property is skipped.
             * @param obj1 The first object to merge.
             * @param obj2 The second object to merge. Keys from this object which also exist in `obj1` will be copied to `obj1`.
             */
            function MergeRight(obj1: object, obj2: object): object;
        }

        namespace String {
            /**
             * Takes a string and replaces instances of markers with values in the given array.
             * The markers take the form of `%1`, `%2`, etc. I.e.:
             *
             * `Format("The %1 is worth %2 gold", [ 'Sword', 500 ])`
             * @param string The string containing the replacement markers.
             * @param values An array containing values that will replace the markers. If no value exists an empty string is inserted instead.
             */
            function Format(string: string, values: any[]): string;

            /**
             * Takes the given string and pads it out, to the length required, using the character
             * specified. For example if you need a string to be 6 characters long, you can call:
             *
             * `pad('bob', 6, '-', 2)`
             *
             * This would return: `bob---` as it has padded it out to 6 characters, using the `-` on the right.
             *
             * You can also use it to pad numbers (they are always returned as strings):
             *
             * `pad(512, 6, '0', 1)`
             *
             * Would return: `000512` with the string padded to the left.
             *
             * If you don't specify a direction it'll pad to both sides:
             *
             * `pad('c64', 7, '*')`
             *
             * Would return: `**c64**`
             * @param str The target string. `toString()` will be called on the string, which means you can also pass in common data types like numbers.
             * @param len The number of characters to be added. Default 0.
             * @param pad The string to pad it out with (defaults to a space). Default " ".
             * @param dir The direction dir = 1 (left), 2 (right), 3 (both). Default 3.
             */
            function Pad(str: string, len?: integer, pad?: string, dir?: integer): string;

            /**
             * Takes the given string and reverses it, returning the reversed string.
             * For example if given the string `Atari 520ST` it would return `TS025 iratA`.
             * @param string The string to be reversed.
             */
            function Reverse(string: string): string;

            /**
             * Capitalizes the first letter of a string if there is one.
             * @param str The string to capitalize.
             */
            function UppercaseFirst(str: string): string;

            /**
             * Creates and returns an RFC4122 version 4 compliant UUID.
             *
             * The string is in the form: `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx` where each `x` is replaced with a random
             * hexadecimal digit from 0 to f, and `y` is replaced with a random hexadecimal digit from 8 to b.
             */
            function UUID(): string;
        }
    }

    /**
     * The Facebook Instant Games Plugin for Phaser 3 provides a seamless bridge between Phaser
     * and the Facebook Instant Games API version 6.2.
     *
     * You can access this plugin via the `facebook` property in a Scene, i.e:
     *
     * ```javascript
     * this.facebook.getPlatform();
     * ```
     *
     * If this is unavailable please check to make sure you're using a build of Phaser that has
     * this plugin within it. You can quickly check this by looking at the dev tools console
     * header - the Phaser version number will have `-FB` after it if this plugin is loaded.
     *
     * If you are building your own version of Phaser then use this Webpack DefinePlugin flag:
     *
     * `"interfaceof PLUGIN_FBINSTANT": JSON.stringify(true)`
     *
     * You will find that every Instant Games API method has a mapping in this plugin.
     * For a full list please consult either the plugin documentation, or the 6.2 SDK documentation
     * at https://developers.facebook.com/docs/games/instant-games/sdk/fbinstant6.2
     *
     * Internally this plugin uses its own Data Manager to handle seamless user data updates and provides
     * handy functions for advertisement displaying, opening share dialogs, logging, leaderboards, purchase API requests,
     * loader integration and more.
     *
     * To get started with Facebook Instant Games you will need to register on Facebook and create a new Instant
     * Game app that has its own unique app ID. Facebook have also provided a dashboard interface for setting up
     * various features for your game, including leaderboards, ad requests and the payments API. There are lots
     * of guides on the Facebook Developers portal to assist with setting these
     * various systems up: https://developers.facebook.com/docs/games/instant-games/guides
     *
     * For more details follow the Quick Start guide here: https://developers.facebook.com/docs/games/instant-games
     */
    class FacebookInstantGamesPlugin extends Events.EventEmitter {
        /**
         *
         * @param game A reference to the Phaser.Game instance.
         */
        constructor(game: Game);

        /**
         * A reference to the Phaser.Game instance.
         */
        readonly game: Game;

        /**
         * A Data Manager instance.
         * It allows you to store, query and retrieve any key/value data you may need to store.
         * It's also used internally by the plugin to store FBIG API data.
         */
        data: Data.DataManager;

        /**
         * Has the Facebook Instant Games API loaded yet?
         * This is set automatically during the boot process.
         */
        hasLoaded: boolean;

        /**
         * Is the Data Manager currently locked?
         */
        dataLocked: boolean;

        /**
         * A list of the Facebook Instant Games APIs that are available,
         * based on the given platform, context and user privacy settings.
         * This value is populated automatically during boot.
         */
        supportedAPIs: string[];

        /**
         * Holds the entry point that the game was launched from.
         * This value is populated automatically during boot.
         */
        entryPoint: string;

        /**
         * An object that contains any data associated with the entry point that the game was launched from.
         * The contents of the object are developer-defined, and can occur from entry points on different platforms.
         * This will return null for older mobile clients, as well as when there is no data associated with the particular entry point.
         * This value is populated automatically during boot.
         */
        entryPointData: any;

        /**
         * A unique identifier for the current game context. This represents a specific context
         * that the game is being played in (for example, a particular messenger conversation or facebook post).
         * The identifier will be null if game is being played in a solo context.
         * This value is populated automatically during boot.
         */
        contextID: string;

        /**
         * The current context in which your game is running. This can be either `null` or
         * one of:
         *
         * `POST` - The game is running inside of a Facebook post.
         * `THREAD` - The game is running inside a Facebook Messenger thread.
         * `GROUP` - The game is running inside a Facebook Group.
         * `SOLO` - This is the default context, the player is the only participant.
         *
         * This value is populated automatically during boot.
         */
        contextinterface: string;

        /**
         * The current locale.
         * See https://origincache.facebook.com/developers/resources/?id=FacebookLocales.xml for a complete list of supported locale values.
         * Use this to determine what languages the current game should be localized with.
         * This value is populated automatically during boot.
         */
        locale: string;

        /**
         * The platform on which the game is currently running, i.e. `IOS`.
         * This value is populated automatically during boot.
         */
        platform: string;

        /**
         * The string representation of the Facebook Instant Games SDK version being used.
         * This value is populated automatically during boot.
         */
        version: string;

        /**
         * Holds the id of the player. This is a string based ID, the same as `FBInstant.player.getID()`.
         * This value is populated automatically during boot if the API is supported.
         */
        playerID: string;

        /**
         * The player's localized display name.
         * This value is populated automatically during boot if the API is supported.
         */
        playerName: string;

        /**
         * A url to the player's public profile photo. The photo will always be a square, and with dimensions
         * of at least 200x200. When rendering it in the game, the exact dimensions should never be assumed to be constant.
         * It's recommended to always scale the image to a desired size before rendering.
         * This value is populated automatically during boot if the API is supported.
         */
        playerPhotoURL: string;

        /**
         * Whether a player can subscribe to the game bot or not.
         */
        playerCanSubscribeBot: boolean;

        /**
         * Does the current platform and context allow for use of the payments API?
         * Currently this is only available on Facebook.com and Android 6+.
         */
        paymentsReady: boolean;

        /**
         * The set of products that are registered to the game.
         */
        catalog: Product[];

        /**
         * Contains all of the player's unconsumed purchases.
         * The game must fetch the current player's purchases as soon as the client indicates that it is ready to perform payments-related operations,
         * i.e. at game start. The game can then process and consume any purchases that are waiting to be consumed.
         */
        purchases: Purchase[];

        /**
         * Contains all of the leaderboard data, as populated by the `getLeaderboard()` method.
         */
        leaderboards: FacebookInstantGamesPlugin.Leaderboard[];

        /**
         * Contains AdInstance objects, as created by the `preloadAds()` method.
         */
        ads: AdInstance[];

        /**
         * Call this method from your `Scene.preload` in order to sync the load progress
         * of the Phaser Loader with the Facebook Instant Games loader display, i.e.:
         *
         * ```javascript
         * this.facebook.showLoadProgress(this);
         * this.facebook.once('startgame', this.startGame, this);
         * ```
         * @param scene The Scene for which you want to show loader progress for.
         */
        showLoadProgress(scene: Scene): this;

        /**
         * This method is called automatically when the game has finished loading,
         * if you used the `showLoadProgress` method. If your game doesn't need to
         * load any assets, or you're managing the load yourself, then call this
         * method directly to start the API running.
         *
         * When the API has finished starting this plugin will emit a `startgame` event
         * which you should listen for.
         */
        gameStarted(): void;

        /**
         * Checks to see if a given Facebook Instant Games API is available or not.
         * @param api The API to check for, i.e. `player.getID`.
         */
        checkAPI(api: string): boolean;

        /**
         * Returns the unique identifier for the current game context. This represents a specific context
         * that the game is being played in (for example, a particular messenger conversation or facebook post).
         * The identifier will be null if game is being played in a solo context.
         *
         * It is only populated if `contextGetID` is in the list of supported APIs.
         */
        getID(): string;

        /**
         * Returns the current context in which your game is running. This can be either `null` or one of:
         *
         * `POST` - The game is running inside of a Facebook post.
         * `THREAD` - The game is running inside a Facebook Messenger thread.
         * `GROUP` - The game is running inside a Facebook Group.
         * `SOLO` - This is the default context, the player is the only participant.
         *
         * It is only populated if `contextGetinterface` is in the list of supported APIs.
         */
        getinterface(): string;

        /**
         * Returns the current locale.
         * See https://origincache.facebook.com/developers/resources/?id=FacebookLocales.xml for a complete list of supported locale values.
         * Use this to determine what languages the current game should be localized with.
         * It is only populated if `getLocale` is in the list of supported APIs.
         */
        getLocale(): string;

        /**
         * Returns the platform on which the game is currently running, i.e. `IOS`.
         * It is only populated if `getPlatform` is in the list of supported APIs.
         */
        getPlatform(): string;

        /**
         * Returns the string representation of the Facebook Instant Games SDK version being used.
         * It is only populated if `getSDKVersion` is in the list of supported APIs.
         */
        getSDKVersion(): string;

        /**
         * Returns the id of the player. This is a string based ID, the same as `FBInstant.player.getID()`.
         * It is only populated if `playerGetID` is in the list of supported APIs.
         */
        getPlayerID(): string;

        /**
         * Returns the player's localized display name.
         * It is only populated if `playerGetName` is in the list of supported APIs.
         */
        getPlayerName(): string;

        /**
         * Returns the url to the player's public profile photo. The photo will always be a square, and with dimensions
         * of at least 200x200. When rendering it in the game, the exact dimensions should never be assumed to be constant.
         * It's recommended to always scale the image to a desired size before rendering.
         * It is only populated if `playerGetPhoto` is in the list of supported APIs.
         */
        getPlayerPhotoURL(): string;

        /**
         * Load the player's photo and store it in the Texture Manager, ready for use in-game.
         *
         * This method works by using a Scene Loader instance and then asking the Loader to
         * retrieve the image.
         *
         * When complete the plugin will emit a `photocomplete` event, along with the key of the photo.
         *
         * ```javascript
         * this.facebook.loadPlayerPhoto(this, 'player').once('photocomplete', function (key) {
         *   this.add.image(x, y, 'player);
         * }, this);
         * ```
         * @param scene The Scene that will be responsible for loading this photo.
         * @param key The key to use when storing the photo in the Texture Manager.
         */
        loadPlayerPhoto(scene: Scene, key: string): this;

        /**
         * Checks if the current player can subscribe to the game bot.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * If they can subscribe, the `playerCanSubscribeBot` property is set to `true`
         * and this plugin will emit the `cansubscribebot` event.
         *
         * If they cannot, i.e. it's not in the list of supported APIs, or the request
         * was rejected, it will emit a `cansubscribebotfail` event instead.
         */
        canSubscribeBot(): this;

        /**
         * Subscribes the current player to the game bot.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * If they are successfully subscribed this plugin will emit the `subscribebot` event.
         *
         * If they cannot, i.e. it's not in the list of supported APIs, or the request
         * was rejected, it will emit a `subscribebotfail` event instead.
         */
        subscribeBot(): this;

        /**
         * Gets the associated data from the player based on the given key, or array of keys.
         *
         * The data is requested in an async call, so the result isn't available immediately.
         *
         * When the call completes the data is set into this plugins Data Manager and the
         * `getdata` event will be emitted.
         * @param keys The key/s of the data to retrieve.
         */
        getData(keys: string | string[]): this;

        /**
         * Set data to be saved to the designated cloud storage of the current player. The game can store up to 1MB of data for each unique player.
         *
         * The data save is requested in an async call, so the result isn't available immediately.
         *
         * Data managed via this plugins Data Manager instance is automatically synced with Facebook. However, you can call this
         * method directly if you need to replace the data object directly.
         *
         * When the APIs `setDataAsync` call resolves it will emit the `savedata` event from this plugin. If the call fails for some
         * reason it will emit `savedatafail` instead.
         *
         * The call resolving does not necessarily mean that the input has already been persisted. Rather, it means that the data was valid and
         * has been scheduled to be saved. It also guarantees that all values that were set are now available in `getData`.
         * @param data An object containing a set of key-value pairs that should be persisted to cloud storage.
         * The object must contain only serializable values - any non-serializable values will cause the entire modification to be rejected.
         */
        saveData(data: object): this;

        /**
         * Immediately flushes any changes to the player data to the designated cloud storage.
         * This function is expensive, and should primarily be used for critical changes where persistence needs to be immediate
         * and known by the game. Non-critical changes should rely on the platform to persist them in the background.
         * NOTE: Calls to player.setDataAsync will be rejected while this function's result is pending.
         *
         * Data managed via this plugins Data Manager instance is automatically synced with Facebook. However, you can call this
         * method directly if you need to flush the data directly.
         *
         * When the APIs `flushDataAsync` call resolves it will emit the `flushdata` event from this plugin. If the call fails for some
         * reason it will emit `flushdatafail` instead.
         */
        flushData(): this;

        /**
         * Retrieve stats from the designated cloud storage of the current player.
         *
         * The data is requested in an async call, so the result isn't available immediately.
         *
         * When the call completes the `getstats` event will be emitted along with the data object returned.
         *
         * If the call fails, i.e. it's not in the list of supported APIs, or the request was rejected,
         * it will emit a `getstatsfail` event instead.
         * @param keys An optional array of unique keys to retrieve stats for. If the function is called without it, it will fetch all stats.
         */
        getStats(keys?: string[]): this;

        /**
         * Save the stats of the current player to the designated cloud storage.
         *
         * Stats in the Facebook Instant Games API are purely numerical values paired with a string-based key. Only numbers can be saved as stats,
         * all other data types will be ignored.
         *
         * The data is requested in an async call, so the result isn't available immediately.
         *
         * When the call completes the `savestats` event will be emitted along with the data object returned.
         *
         * If the call fails, i.e. it's not in the list of supported APIs, or the request was rejected,
         * it will emit a `savestatsfail` event instead.
         * @param data An object containing a set of key-value pairs that should be persisted to cloud storage as stats. Note that only numerical values are stored.
         */
        saveStats(data: object): this;

        /**
         * Increment the stats of the current player and save them to the designated cloud storage.
         *
         * Stats in the Facebook Instant Games API are purely numerical values paired with a string-based key. Only numbers can be saved as stats,
         * all other data types will be ignored.
         *
         * The data object provided for this call should contain offsets for how much to modify the stats by:
         *
         * ```javascript
         * this.facebook.incStats({
         *     level: 1,
         *     zombiesSlain: 17,
         *     rank: -1
         * });
         * ```
         *
         * The data is requested in an async call, so the result isn't available immediately.
         *
         * When the call completes the `incstats` event will be emitted along with the data object returned.
         *
         * If the call fails, i.e. it's not in the list of supported APIs, or the request was rejected,
         * it will emit a `incstatsfail` event instead.
         * @param data An object containing a set of key-value pairs indicating how much to increment each stat in cloud storage. Note that only numerical values are processed.
         */
        incStats(data: object): this;

        /**
         * Sets the data associated with the individual gameplay session for the current context.
         *
         * This function should be called whenever the game would like to update the current session data.
         *
         * This session data may be used to populate a variety of payloads, such as game play webhooks.
         * @param data An arbitrary data object, which must be less than or equal to 1000 characters when stringified.
         */
        saveSession(data: object): this;

        /**
         * This invokes a dialog to let the user share specified content, either as a message in Messenger or as a post on the user's timeline.
         *
         * A blob of data can be attached to the share which every game session launched from the share will be able to access via the `this.entryPointData` property.
         *
         * This data must be less than or equal to 1000 characters when stringified.
         *
         * When this method is called you should consider your game paused. Listen out for the `resume` event from this plugin to know when the dialog has been closed.
         *
         * The user may choose to cancel the share action and close the dialog. The resulting `resume` event will be dispatched regardless if the user actually shared the content or not.
         * @param text A text message to be shared.
         * @param key The key of the texture to use as the share image.
         * @param frame The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
         * @param sessionData A blob of data to attach to the share.
         */
        openShare(text: string, key: string, frame?: string, sessionData?: object): this;

        /**
         * This invokes a dialog to let the user invite a friend to play this game, either as a message in Messenger or as a post on the user's timeline.
         *
         * A blob of data can be attached to the share which every game session launched from the share will be able to access via the `this.entryPointData` property.
         *
         * This data must be less than or equal to 1000 characters when stringified.
         *
         * When this method is called you should consider your game paused. Listen out for the `resume` event from this plugin to know when the dialog has been closed.
         *
         * The user may choose to cancel the share action and close the dialog. The resulting `resume` event will be dispatched regardless if the user actually shared the content or not.
         * @param text A text message to be shared.
         * @param key The key of the texture to use as the share image.
         * @param frame The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
         * @param sessionData A blob of data to attach to the share.
         */
        openInvite(text: string, key: string, frame?: string, sessionData?: object): this;

        /**
         * This invokes a dialog to let the user share specified content, either as a message in Messenger or as a post on the user's timeline.
         *
         * A blob of data can be attached to the share which every game session launched from the share will be able to access via the `this.entryPointData` property.
         *
         * This data must be less than or equal to 1000 characters when stringified.
         *
         * When this method is called you should consider your game paused. Listen out for the `resume` event from this plugin to know when the dialog has been closed.
         *
         * The user may choose to cancel the share action and close the dialog. The resulting `resume` event will be dispatched regardless if the user actually shared the content or not.
         * @param text A text message to be shared.
         * @param key The key of the texture to use as the share image.
         * @param frame The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
         * @param sessionData A blob of data to attach to the share.
         */
        openRequest(text: string, key: string, frame?: string, sessionData?: object): this;

        /**
         * This invokes a dialog to let the user share specified content, either as a message in Messenger or as a post on the user's timeline.
         *
         * A blob of data can be attached to the share which every game session launched from the share will be able to access via the `this.entryPointData` property.
         *
         * This data must be less than or equal to 1000 characters when stringified.
         *
         * When this method is called you should consider your game paused. Listen out for the `resume` event from this plugin to know when the dialog has been closed.
         *
         * The user may choose to cancel the share action and close the dialog. The resulting `resume` event will be dispatched regardless if the user actually shared the content or not.
         * @param text A text message to be shared.
         * @param key The key of the texture to use as the share image.
         * @param frame The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
         * @param sessionData A blob of data to attach to the share.
         */
        openChallenge(text: string, key: string, frame?: string, sessionData?: object): this;

        /**
         * This function determines whether the number of participants in the current game context is between a given minimum and maximum, inclusive.
         * If one of the bounds is null only the other bound will be checked against.
         * It will always return the original result for the first call made in a context in a given game play session.
         * Subsequent calls, regardless of arguments, will return the answer to the original query until a context change occurs and the query result is reset.
         * @param min The minimum bound of the context size query.
         * @param max The maximum bound of the context size query.
         */
        isSizeBetween(min?: integer, max?: integer): object;

        /**
         * Request a switch into a specific context. If the player does not have permission to enter that context,
         * or if the player does not provide permission for the game to enter that context, this will emit a `switchfail` event.
         *
         * Otherwise, the plugin will emit the `switch` event when the game has switched into the specified context.
         * @param contextID The ID of the desired context.
         */
        switchContext(contextID: string): this;

        /**
         * Opens a context selection dialog for the player. If the player selects an available context,
         * the client will attempt to switch into that context, and emit the `choose` event if successful.
         * Otherwise, if the player exits the menu or the client fails to switch into the new context, the `choosefail` event will be emitted.
         * @param contextID The ID of the desired context.
         */
        chooseContext(contextID: string): this;

        /**
         * Attempts to create or switch into a context between a specified player and the current player.
         * This plugin will emit the `create` event once the context switch is completed.
         * If the API call fails, such as if the player listed is not a Connected Player of the current player or if the
         * player does not provide permission to enter the new context, then the plugin will emit a 'createfail' event.
         * @param playerID ID of the player.
         */
        createContext(playerID: string): this;

        /**
         * Fetches an array of ConnectedPlayer objects containing information about active players
         * (people who played the game in the last 90 days) that are connected to the current player.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * If they are successfully subscribed this plugin will emit the `players` event along
         * with the player data.
         *
         * If they cannot, i.e. it's not in the list of supported APIs, or the request
         * was rejected, it will emit a `playersfail` event instead.
         */
        getPlayers(): this;

        /**
         * Fetches the game's product catalog.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * If they are successfully subscribed this plugin will emit the `getcatalog` event along
         * with the catalog data.
         *
         * If they cannot, i.e. it's not in the list of supported APIs, or the request
         * was rejected, it will emit a `getcatalogfail` event instead.
         */
        getCatalog(): this;

        /**
         * Begins the purchase flow for a specific product.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * If they are successfully subscribed this plugin will emit the `purchase` event along
         * with the purchase data.
         *
         * If they cannot, i.e. it's not in the list of supported APIs, or the request
         * was rejected, it will emit a `purchasefail` event instead.
         * @param productID The identifier of the product to purchase.
         * @param developerPayload An optional developer-specified payload, to be included in the returned purchase's signed request.
         */
        purchase(productID: string, developerPayload?: string): this;

        /**
         * Fetches all of the player's unconsumed purchases. The game must fetch the current player's purchases
         * as soon as the client indicates that it is ready to perform payments-related operations,
         * i.e. at game start. The game can then process and consume any purchases that are waiting to be consumed.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * If they are successfully subscribed this plugin will emit the `getpurchases` event along
         * with the purchase data.
         *
         * If they cannot, i.e. it's not in the list of supported APIs, or the request
         * was rejected, it will emit a `getpurchasesfail` event instead.
         */
        getPurchases(): this;

        /**
         * Consumes a specific purchase belonging to the current player. Before provisioning a product's effects to the player,
         * the game should request the consumption of the purchased product. Once the purchase is successfully consumed,
         * the game should immediately provide the player with the effects of their purchase.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * If they are successfully subscribed this plugin will emit the `consumepurchase` event along
         * with the purchase data.
         *
         * If they cannot, i.e. it's not in the list of supported APIs, or the request
         * was rejected, it will emit a `consumepurchasefail` event instead.
         * @param purchaseToken The purchase token of the purchase that should be consumed.
         */
        consumePurchases(purchaseToken: string): this;

        /**
         * Informs Facebook of a custom update that occurred in the game.
         * This will temporarily yield control to Facebook and Facebook will decide what to do based on what the update is.
         * Once Facebook returns control to the game the plugin will emit an `update` or `upatefail` event.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * The `text` parameter is an update payload with the following structure:
         *
         * ```
         * text: {
         *     default: 'X just invaded Y\'s village!',
         *     localizations: {
         *         ar_AR: 'X \u0641\u0642\u0637 \u063A\u0632\u062A ' +
         *         '\u0642\u0631\u064A\u0629 Y!',
         *         en_US: 'X just invaded Y\'s village!',
         *         es_LA: '\u00A1X acaba de invadir el pueblo de Y!',
         *     }
         * }
         * ```
         * @param cta The call to action text.
         * @param text The text object.
         * @param key The key of the texture to use as the share image.
         * @param frame The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
         * @param template The update template key.
         * @param updateData The update data object payload.
         */
        update(cta: string, text: object, key: string, frame: string | integer, template: string, updateData: object): this;

        /**
         * Informs Facebook of a leaderboard update that occurred in the game.
         * This will temporarily yield control to Facebook and Facebook will decide what to do based on what the update is.
         * Once Facebook returns control to the game the plugin will emit an `update` or `upatefail` event.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * The `text` parameter is an update payload with the following structure:
         *
         * ```
         * text: {
         *     default: 'X just invaded Y\'s village!',
         *     localizations: {
         *         ar_AR: 'X \u0641\u0642\u0637 \u063A\u0632\u062A ' +
         *         '\u0642\u0631\u064A\u0629 Y!',
         *         en_US: 'X just invaded Y\'s village!',
         *         es_LA: '\u00A1X acaba de invadir el pueblo de Y!',
         *     }
         * }
         * ```
         * @param cta The call to action text.
         * @param text The text object.
         * @param key The key of the texture to use as the share image.
         * @param frame The frame of the texture to use as the share image. Set to `null` if you don't require a frame, but do need to set session data.
         * @param template The update template key.
         * @param updateData The update data object payload.
         */
        updateLeaderboard(cta: string, text: object, key: string, frame: string | integer, template: string, updateData: object): this;

        /**
         * Request that the client switch to a different Instant Game.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * If the game switches successfully this plugin will emit the `switchgame` event and the client will load the new game.
         *
         * If they cannot, i.e. it's not in the list of supported APIs, or the request
         * was rejected, it will emit a `switchgamefail` event instead.
         * @param appID The Application ID of the Instant Game to switch to. The application must be an Instant Game, and must belong to the same business as the current game.
         * @param data An optional data payload. This will be set as the entrypoint data for the game being switched to. Must be less than or equal to 1000 characters when stringified.
         */
        switchGame(appID: string, data?: object): this;

        /**
         * Prompts the user to create a shortcut to the game if they are eligible to.
         * Can only be called once per session.
         *
         * It makes an async call to the API, so the result isn't available immediately.
         *
         * If the user choose to create a shortcut this plugin will emit the `shortcutcreated` event.
         *
         * If they cannot, i.e. it's not in the list of supported APIs, or the request
         * was rejected, it will emit a `shortcutcreatedfail` event instead.
         */
        createShortcut(): this;

        /**
         * Quits the game.
         */
        quit(): void;

        /**
         * Log an app event with FB Analytics.
         *
         * See https://developers.facebook.com/docs/javascript/reference/v2.8#app_events for more details about FB Analytics.
         * @param name Name of the event. Must be 2 to 40 characters, and can only contain '_', '-', ' ', and alphanumeric characters.
         * @param value An optional numeric value that FB Analytics can calculate a sum with.
         * @param params An optional object that can contain up to 25 key-value pairs to be logged with the event.
         * Keys must be 2 to 40 characters, and can only contain '_', '-', ' ', and alphanumeric characters. Values must be less than 100 characters in length.
         */
        log(name: string, value?: number, params?: object): this;

        /**
         * Attempt to create an instance of an interstitial ad.
         *
         * If the instance is created successfully then the ad is preloaded ready for display in-game via the method `showAd()`.
         *
         * If the ad loads it will emit the `adloaded` event, passing the AdInstance as the only parameter.
         *
         * If the ad cannot be displayed because there was no inventory to fill it, it will emit the `adsnofill` event.
         * @param placementID The ad placement ID, or an array of IDs, as created in your Audience Network settings within Facebook.
         */
        preloadAds(placementID: string | string[]): this;

        /**
         * Attempt to create an instance of an rewarded video ad.
         *
         * If the instance is created successfully then the ad is preloaded ready for display in-game via the method `showVideo()`.
         *
         * If the ad loads it will emit the `adloaded` event, passing the AdInstance as the only parameter.
         *
         * If the ad cannot be displayed because there was no inventory to fill it, it will emit the `adsnofill` event.
         * @param placementID The ad placement ID, or an array of IDs, as created in your Audience Network settings within Facebook.
         */
        preloadVideoAds(placementID: string | string[]): this;

        /**
         * Displays a previously loaded interstitial ad.
         *
         * If the ad is successfully displayed this plugin will emit the `adfinished` event, with the AdInstance object as its parameter.
         *
         * If the ad cannot be displayed, it will emit the `adsnotloaded` event.
         * @param placementID The ad placement ID to display.
         */
        showAd(placementID: string): this;

        /**
         * Displays a previously loaded interstitial video ad.
         *
         * If the ad is successfully displayed this plugin will emit the `adfinished` event, with the AdInstance object as its parameter.
         *
         * If the ad cannot be displayed, it will emit the `adsnotloaded` event.
         * @param placementID The ad placement ID to display.
         */
        showVideo(placementID: string): this;

        /**
         * Attempts to match the current player with other users looking for people to play with.
         * If successful, a new Messenger group thread will be created containing the matched players and the player will
         * be context switched to that thread. This plugin will also dispatch the `matchplayer` event, containing the new context ID and interface.
         *
         * The default minimum and maximum number of players in one matched thread are 2 and 20 respectively,
         * depending on how many players are trying to get matched around the same time.
         *
         * The values can be changed in `fbapp-config.json`. See the Bundle Config documentation for documentation about `fbapp-config.json`.
         * @param matchTag Optional extra information about the player used to group them with similar players. Players will only be grouped with other players with exactly the same tag.
         * The tag must only include letters, numbers, and underscores and be 100 characters or less in length.
         * @param switchImmediately Optional extra parameter that specifies whether the player should be immediately switched to the new context when a match is found.
         * By default this will be false which will mean the player needs explicitly press play after being matched to switch to the new context. Default false.
         */
        matchPlayer(matchTag?: string, switchImmediately?: boolean): this;

        /**
         * Fetch a specific leaderboard belonging to this Instant Game.
         *
         * The data is requested in an async call, so the result isn't available immediately.
         *
         * When the call completes the `getleaderboard` event will be emitted along with a Leaderboard object instance.
         * @param name The name of the leaderboard. Each leaderboard for an Instant Game must have its own distinct name.
         */
        getLeaderboard(name: string): this;

        /**
         * Quits the Facebook API and then destroys this plugin.
         */
        destroy(): void;
    }
}

interface ArcadeBodyBounds {
    /**
     * The left edge.
     */
    x: number;
    /**
     * The upper edge.
     */
    y: number;
    /**
     * The right edge.
     */
    right: number;
    /**
     * The lower edge.
     */
    bottom: number;
}

interface ArcadeBodyCollision {
    /**
     * True if the Body is not colliding.
     */
    none: boolean;
    /**
     * True if the Body is colliding on its upper edge.
     */
    up: boolean;
    /**
     * True if the Body is colliding on its lower edge.
     */
    down: boolean;
    /**
     * True if the Body is colliding on its left edge.
     */
    left: boolean;
    /**
     * True if the Body is colliding on its right edge.
     */
    right: boolean;
}

type ArcadePhysicsCallback = (object1: Phaser.GameObjects.GameObject, object2: Phaser.GameObjects.GameObject) => void;

interface PhysicsGroupConfig extends GroupConfig {
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#collideWorldBounds}.
     */
    collideWorldBounds?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#acceleration acceleration.x}.
     */
    accelerationX?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#acceleration acceleration.y}.
     */
    accelerationY?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#allowDrag}.
     */
    allowDrag?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#allowGravity}.
     */
    allowGravity?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#allowRotation}.
     */
    allowRotation?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#bounce bounce.x}.
     */
    bounceX?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#bounce bounce.y}.
     */
    bounceY?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#drag drag.x}.
     */
    dragX?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#drag drag.y}.
     */
    dragY?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#enable enable}.
     */
    enable?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#gravity gravity.x}.
     */
    gravityX?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#gravity gravity.y}.
     */
    gravityY?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#friction friction.x}.
     */
    frictionX?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#friction friction.y}.
     */
    frictionY?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#velocity velocity.x}.
     */
    velocityX?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#velocity velocity.y}.
     */
    velocityY?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#angularVelocity}.
     */
    angularVelocity?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#angularAcceleration}.
     */
    angularAcceleration?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#angularDrag}.
     */
    angularDrag?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#mass}.
     */
    mass?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.Body#immovable}.
     */
    immovable?: boolean;
}

interface PhysicsGroupDefaults {
    /**
     * As {@link Phaser.Physics.Arcade.Body#setCollideWorldBounds}.
     */
    setCollideWorldBounds: boolean;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setAccelerationX}.
     */
    setAccelerationX: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setAccelerationY}.
     */
    setAccelerationY: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setAllowDrag}.
     */
    setAllowDrag: boolean;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setAllowGravity}.
     */
    setAllowGravity: boolean;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setAllowRotation}.
     */
    setAllowRotation: boolean;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setBounceX}.
     */
    setBounceX: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setBounceY}.
     */
    setBounceY: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setDragX}.
     */
    setDragX: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setDragY}.
     */
    setDragY: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setEnable}.
     */
    setEnable: boolean;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setGravityX}.
     */
    setGravityX: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setGravityY}.
     */
    setGravityY: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setFrictionX}.
     */
    setFrictionX: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setFrictionY}.
     */
    setFrictionY: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setVelocityX}.
     */
    setVelocityX: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setVelocityY}.
     */
    setVelocityY: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setAngularVelocity}.
     */
    setAngularVelocity: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setAngularAcceleration}.
     */
    setAngularAcceleration: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setAngularDrag}.
     */
    setAngularDrag: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setMass}.
     */
    setMass: number;
    /**
     * As {@link Phaser.Physics.Arcade.Body#setImmovable}.
     */
    setImmovable: boolean;
}

interface ArcadeWorldConfig {
    /**
     * Sets {@link Phaser.Physics.Arcade.World#fps}.
     */
    fps?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#timeScale}.
     */
    timeScale?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#gravity}.
     */
    gravity?: object;
    /**
     * The horizontal world gravity value.
     */
    "gravity.x"?: number;
    /**
     * The vertical world gravity value.
     */
    "gravity.y"?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#bounds bounds.x}.
     */
    x?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#bounds bounds.y}.
     */
    y?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#bounds bounds.width}.
     */
    width?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#bounds bounds.height}.
     */
    height?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#checkCollision}.
     */
    checkCollision?: object;
    /**
     * Should bodies collide with the top of the world bounds?
     */
    "checkCollision.up"?: boolean;
    /**
     * Should bodies collide with the bottom of the world bounds?
     */
    "checkCollision.down"?: boolean;
    /**
     * Should bodies collide with the left of the world bounds?
     */
    "checkCollision.left"?: boolean;
    /**
     * Should bodies collide with the right of the world bounds?
     */
    "checkCollision.right"?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#OVERLAP_BIAS}.
     */
    overlapBias?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#TILE_BIAS}.
     */
    tileBias?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#forceX}.
     */
    forceX?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#isPaused}.
     */
    isPaused?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#debug}.
     */
    debug?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#defaults debugShowBody}.
     */
    debugShowBody?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#defaults debugShowStaticBody}.
     */
    debugShowStaticBody?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#defaults debugShowStaticBody}.
     */
    debugShowVelocity?: boolean;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#defaults debugBodyColor}.
     */
    debugBodyColor?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#defaults debugStaticBodyColor}.
     */
    debugStaticBodyColor?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#defaults debugVelocityColor}.
     */
    debugVelocityColor?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#maxEntries}.
     */
    maxEntries?: number;
    /**
     * Sets {@link Phaser.Physics.Arcade.World#useTree}.
     */
    useTree?: boolean;
}

interface CheckCollisionObject {
    /**
     * Will bodies collide with the top side of the world bounds?
     */
    up: boolean;
    /**
     * Will bodies collide with the bottom side of the world bounds?
     */
    down: boolean;
    /**
     * Will bodies collide with the left side of the world bounds?
     */
    left: boolean;
    /**
     * Will bodies collide with the right side of the world bounds?
     */
    right: boolean;
}

interface ArcadeWorldDefaults {
    /**
     * Set to `true` to render dynamic body outlines to the debug display.
     */
    debugShowBody: boolean;
    /**
     * Set to `true` to render static body outlines to the debug display.
     */
    debugShowStaticBody: boolean;
    /**
     * Set to `true` to render body velocity markers to the debug display.
     */
    debugShowVelocity: boolean;
    /**
     * The color of dynamic body outlines when rendered to the debug display.
     */
    bodyDebugColor: number;
    /**
     * The color of static body outlines when rendered to the debug display.
     */
    staticBodyDebugColor: number;
    /**
     * The color of the velocity markers when rendered to the debug display.
     */
    velocityDebugColor: number;
}

interface ArcadeWorldTreeMinMax {
    /**
     * The minimum x value used in RTree searches.
     */
    minX: number;
    /**
     * The minimum y value used in RTree searches.
     */
    minY: number;
    /**
     * The maximum x value used in RTree searches.
     */
    maxX: number;
    /**
     * The maximum y value used in RTree searches.
     */
    maxY: number;
}

/**
 * An Arcade Physics Collider interface.
 */
type ArcadeColliderType = Phaser.GameObjects.GameObject | Phaser.GameObjects.Group;
type CallbackFn = (...args: any[]) => void;

type BodyUpdateCallback = (body: Phaser.Physics.Impact.Body) => void;

interface JSONImpactBody {
    /**
     * [description]
     */
    name: string;
    /**
     * [description]
     */
    size: object;
    /**
     * The entity's position in the game world.
     */
    pos: object;
    /**
     * Current velocity in pixels per second.
     */
    vel: object;
    /**
     * Current acceleration to be added to the entity's velocity per second. E.g. an entity with a `vel.x` of 0 and `accel.x` of 10 will have a `vel.x` of 100 ten seconds later.
     */
    accel: object;
    /**
     * Deceleration to be subtracted from the entity's velocity per second. Only applies if `accel` is 0.
     */
    friction: object;
    /**
     * The maximum velocity a body can move.
     */
    maxVel: object;
    /**
     * [description]
     */
    gravityFactor: number;
    /**
     * [description]
     */
    bounciness: number;
    /**
     * [description]
     */
    minBounceVelocity: number;
    /**
     * [description]
     */
    interface: Phaser.Physics.Impact.interface;
    /**
     * [description]
     */
    checkAgainst: Phaser.Physics.Impact.interface;
    /**
     * [description]
     */
    collides: Phaser.Physics.Impact.COLLIDES;
}

type CollideCallback = (body: Phaser.Physics.Impact.Body, other: Phaser.Physics.Impact.Body, axis: string) => void;

interface CollisionOptions {
    /**
     * Slope IDs can be stored on tiles directly
     * using Impacts tileset editor. If a tile has a property with the given slopeTileProperty string
     * name, the value of that property for the tile will be used for its slope mapping. E.g. a 45
     * degree slope upward could be given a "slope" property with a value of 2.
     */
    slopeTileProperty?: string;
    /**
     * A tile index to slope definition map.
     */
    slopeMap?: object;
    /**
     * If specified, the default slope ID to
     * assign to a colliding tile. If not specified, the tile's index is used.
     */
    defaultCollidingSlope?: integer;
    /**
     * The default slope ID to assign to a
     * non-colliding tile.
     */
    defaultNonCollidingSlope?: integer;
}

declare namespace MatterJS {
    /**
     * The `Matter.Body` module contains methods for creating and manipulating body models.
     * A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
     * Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
     */
    class Body {
        [key: string]: any;
    }

    /**
     * The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
     * A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
     * It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
     * Note that the `Matter.World` object is also a interface of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
     */
    class Composite {
        [key: string]: any;
    }

    /**
     * The `Matter.World` module contains methods for creating and manipulating the world composite.
     * A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
     * A `Matter.World` has a few additional properties including `gravity` and `bounds`.
     * It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
     * There are also a few methods here that alias those in `Matter.Composite` for easier readability.
     */
    class World extends Composite {}

    /**
     * The `Matter.Constraint` module contains methods for creating and manipulating constraints.
     * Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
     * The stiffness of constraints can be modified to create springs or elastic.
     */
    class Constraint {
        [key: string]: any;
    }

    /**
     * The `Matter.Engine` module contains methods for creating and manipulating engines.
     * An engine is a controller that manages updating the simulation of the world.
     */
    class Engine {
        [key: string]: any;
    }

    /**
     * The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
     * A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
     * A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
     */
    class Vertices {
        [key: string]: any;
    }
}

interface MatterTileOptions {
    /**
     * An existing Matter body to be used instead of creating a new one.
     */
    body?: MatterJS.Body;
    /**
     * Whether or not the newly created body should be made static. This defaults to true since typically tiles should not be moved.
     */
    isStatic?: boolean;
    /**
     * Whether or not to add the newly created body (or existing body if options.body is used) to the Matter world.
     */
    addToWorld?: boolean;
}

interface MatterBodyTileOptions {
    /**
     * Whether or not the newly created body should be made static. This defaults to true since typically tiles should not be moved.
     */
    isStatic?: boolean;
    /**
     * Whether or not to add the newly created body (or existing body if options.body is used) to the Matter world.
     */
    addToWorld?: boolean;
}

interface CorePluginContainer {
    /**
     * The unique name of this plugin in the core plugin cache.
     */
    key: string;
    /**
     * The plugin to be stored. Should be the source object, not instantiated.
     */
    plugin: CallbackFn;
    /**
     * If this plugin is to be injected into the Scene Systems, this is the property key map used.
     */
    mapping?: string;
    /**
     * Core Scene plugin or a Custom Scene plugin?
     */
    custom?: boolean;
}

interface CustomPluginContainer {
    /**
     * The unique name of this plugin in the custom plugin cache.
     */
    key: string;
    /**
     * The plugin to be stored. Should be the source object, not instantiated.
     */
    plugin: CallbackFn;
}

interface GlobalPlugin {
    /**
     * The unique name of this plugin within the plugin cache.
     */
    key: string;
    /**
     * An instance of the plugin.
     */
    plugin: CallbackFn;
    /**
     * Is the plugin active or not?
     */
    active?: boolean;
    /**
     * If this plugin is to be injected into the Scene Systems, this is the property key map used.
     */
    mapping?: string;
}

type SnapshotCallback = (snapshot: Phaser.Display.Color | HTMLImageElement) => void;

interface SnapshotState {
    /**
     * The function to call after the snapshot is taken.
     */
    callback: SnapshotCallback;
    /**
     * The format of the image to create, usually `image/png` or `image/jpeg`.
     */
    interface?: string;
    /**
     * The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.
     */
    encoderOptions?: number;
    /**
     * The x coordinate to start the snapshot from.
     */
    x?: integer;
    /**
     * The y coordinate to start the snapshot from.
     */
    y?: integer;
    /**
     * The width of the snapshot.
     */
    width?: integer;
    /**
     * The height of the snapshot.
     */
    height?: integer;
    /**
     * Is this a snapshot to get a single pixel, or an area?
     */
    getPixel?: boolean;
}

/**
 * Implements a model view projection matrices.
 * Pipelines can implement this for doing 2D and 3D rendering.
 */
interface ModelViewProjection {
    /**
     * Dirty flag for checking if model matrix needs to be updated on GPU.
     */
    modelMatrixDirty: any;
    /**
     * Dirty flag for checking if view matrix needs to be updated on GPU.
     */
    viewMatrixDirty: any;
    /**
     * Dirty flag for checking if projection matrix needs to be updated on GPU.
     */
    projectionMatrixDirty: any;
    /**
     * Model matrix
     */
    modelMatrix: any;
    /**
     * View matrix
     */
    viewMatrix: any;
    /**
     * Projection matrix
     */
    projectionMatrix: any;
    /**
     * Initializes MVP matrices with an identity matrix
     */
    mvpInit(): void;
    /**
     * If dirty flags are set then the matrices are uploaded to the GPU.
     */
    mvpUpdate(): void;
    /**
     * Loads an identity matrix to the model matrix
     */
    modelIdentity(): void;
    /**
     * Scale model matrix
     */
    modelScale(): void;
    /**
     * Translate model matrix
     */
    modelTranslate(): void;
    /**
     * Rotates the model matrix in the X axis.
     */
    modelRotateX(): void;
    /**
     * Rotates the model matrix in the Y axis.
     */
    modelRotateY(): void;
    /**
     * Rotates the model matrix in the Z axis.
     */
    modelRotateZ(): void;
    /**
     * Loads identity matrix into the view matrix
     */
    viewIdentity(): void;
    /**
     * Scales view matrix
     */
    viewScale(): void;
    /**
     * Translates view matrix
     */
    viewTranslate(): void;
    /**
     * Rotates view matrix in the X axis.
     */
    viewRotateX(): void;
    /**
     * Rotates view matrix in the Y axis.
     */
    viewRotateY(): void;
    /**
     * Rotates view matrix in the Z axis.
     */
    viewRotateZ(): void;
    /**
     * Loads a 2D view matrix (3x2 matrix) into a 4x4 view matrix
     */
    viewLoad2D(): void;
    /**
     * Copies a 4x4 matrix into the view matrix
     */
    viewLoad(): void;
    /**
     * Loads identity matrix into the projection matrix.
     */
    projIdentity(): void;
    /**
     * Sets up an orthographics projection matrix
     */
    projOrtho(): void;
    /**
     * Sets up a perspective projection matrix
     */
    projPersp(): void;
}

type WebGLContextCallback = (renderer: Phaser.Renderer.WebGL.WebGLRenderer) => void;

interface SceneTransitionConfig {
    /**
     * The Scene key to transition to.
     */
    target: string;
    /**
     * The duration, in ms, for the transition to last.
     */
    duration?: integer;
    /**
     * Will the Scene responsible for the transition be sent to sleep on completion (`true`), or stopped? (`false`)
     */
    sleep?: boolean;
    /**
     * Will the Scenes Input system be able to process events while it is transitioning in or out?
     */
    allowInput?: boolean;
    /**
     * Move the target Scene to be above this one before the transition starts.
     */
    moveAbove?: boolean;
    /**
     * Move the target Scene to be below this one before the transition starts.
     */
    moveBelow?: boolean;
    /**
     * This callback is invoked every frame for the duration of the transition.
     */
    onUpdate?: CallbackFn;
    /**
     * The context in which the callback is invoked.
     */
    onUpdateScope?: any;
    /**
     * An object containing any data you wish to be passed to the target Scenes init / create methods.
     */
    data?: any;
}

type EachActiveSoundCallback = (manager: Phaser.Sound.BaseSoundManager, sound: Phaser.Sound.BaseSound, index: number, sounds: Phaser.Sound.BaseSound[]) => void;

/**
 * Audio sprite sound interface.
 */
interface AudioSpriteSound {
    /**
     * Local reference to 'spritemap' object form json file generated by audiosprite tool.
     */
    spritemap: object;
}

/**
 * Config object containing various sound settings.
 */
interface SoundConfig {
    /**
     * Boolean indicating whether the sound should be muted or not.
     */
    mute?: boolean;
    /**
     * A value between 0 (silence) and 1 (full volume).
     */
    volume?: number;
    /**
     * Defines the speed at which the sound should be played.
     */
    rate?: number;
    /**
     * Represents detuning of sound in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
     */
    detune?: number;
    /**
     * Position of playback for this sound, in seconds.
     */
    seek?: number;
    /**
     * Whether or not the sound or current sound marker should loop.
     */
    loop?: boolean;
    /**
     * Time, in seconds, that should elapse before the sound actually starts its playback.
     */
    delay?: number;
}

/**
 * Marked section of a sound represented by name, and optionally start time, duration, and config object.
 */
interface SoundMarker {
    /**
     * Unique identifier of a sound marker.
     */
    name: string;
    /**
     * Sound position offset at witch playback should start.
     */
    start?: number;
    /**
     * Playback duration of this marker.
     */
    duration?: number;
    /**
     * An optional config object containing default marker settings.
     */
    config?: SoundConfig;
}

type EachListCallback<I> = (item: I, ...args: any[]) => void;

type EachMapCallback<E> = (key: string, entry: E) => void;

type EachSetCallback<E> = (entry: E, index: number) => void;

/**
 * An object containing the position and color data for a single pixel in a CanvasTexture.
 */
interface PixelConfig {
    /**
     * The x-coordinate of the pixel.
     */
    x: integer;
    /**
     * The y-coordinate of the pixel.
     */
    y: integer;
    /**
     * The color of the pixel, not including the alpha channel.
     */
    color: integer;
    /**
     * The alpha of the pixel, between 0 and 1.
     */
    alpha: number;
}

type EachTextureCallback = (texture: Phaser.Textures.Texture, ...args: any[]) => void;

interface SpriteSheetConfig {
    /**
     * The fixed width of each frame.
     */
    frameWidth: integer;
    /**
     * The fixed height of each frame. If not set it will use the frameWidth as the height.
     */
    frameHeight?: integer;
    /**
     * Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
     */
    startFrame?: integer;
    /**
     * The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
     */
    endFrame?: integer;
    /**
     * If the frames have been drawn with a margin, specify the amount here.
     */
    margin?: integer;
    /**
     * If the frames have been drawn with spacing between them, specify the amount here.
     */
    spacing?: integer;
}

interface SpriteSheetFromAtlasConfig {
    /**
     * The key of the Texture Atlas in which this Sprite Sheet can be found.
     */
    atlas: string;
    /**
     * The key of the Texture Atlas Frame in which this Sprite Sheet can be found.
     */
    frame: string;
    /**
     * The fixed width of each frame.
     */
    frameWidth: integer;
    /**
     * The fixed height of each frame. If not set it will use the frameWidth as the height.
     */
    frameHeight?: integer;
    /**
     * Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
     */
    startFrame?: integer;
    /**
     * The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
     */
    endFrame?: integer;
    /**
     * If the frames have been drawn with a margin, specify the amount here.
     */
    margin?: integer;
    /**
     * If the frames have been drawn with spacing between them, specify the amount here.
     */
    spacing?: integer;
}

type FindTileCallback = (value: Phaser.Tilemaps.Tile, index: integer, array: Phaser.Tilemaps.Tile[]) => void;

type EachTileCallback = (value: Phaser.Tilemaps.Tile, index: integer, array: Phaser.Tilemaps.Tile[]) => void;

interface GetTilesWithinFilteringOptions {
    /**
     * If true, only return tiles that don't have -1 for an index.
     */
    isNotEmpty?: boolean;
    /**
     * If true, only return tiles that collide on at least one side.
     */
    isColliding?: boolean;
    /**
     * If true, only return tiles that have at least one interesting face.
     */
    hasInterestingFace?: boolean;
}

interface MapDataConfig {
    /**
     * The key in the Phaser cache that corresponds to the loaded tilemap data.
     */
    name?: string;
    /**
     * The width of the entire tilemap.
     */
    width?: number;
    /**
     * The height of the entire tilemap.
     */
    height?: number;
    /**
     * The width of the tiles.
     */
    tileWidth?: number;
    /**
     * The height of the tiles.
     */
    tileHeight?: number;
    /**
     * The width in pixels of the entire tilemap.
     */
    widthInPixels?: number;
    /**
     * The height in pixels of the entire tilemap.
     */
    heightInPixels?: number;
    /**
     * The format of the Tilemap, as defined in Tiled.
     */
    format?: integer;
    /**
     * The orientation of the map data (i.e. orthogonal, isometric, hexagonal), default 'orthogonal'.
     */
    orientation?: string;
    /**
     * Determines the draw order of tilemap. Default is right-down.
     */
    renderOrder?: string;
    /**
     * The version of Tiled the map uses.
     */
    version?: number;
    /**
     * Map specific properties (can be specified in Tiled).
     */
    properties?: number;
    /**
     * The layers of the tilemap.
     */
    layers?: Phaser.Tilemaps.LayerData[];
    /**
     * An array with all the layers configured to the MapData.
     */
    images?: any[];
    /**
     * An array of Tiled Image Layers.
     */
    objects?: object;
    /**
     * An object of Tiled Object Layers.
     */
    collision?: object;
    /**
     * The tilesets the map uses.
     */
    tilesets?: Phaser.Tilemaps.Tileset[];
    /**
     * The collection of images the map uses(specified in Tiled).
     */
    imageCollections?: any[];
    /**
     * [description]
     */
    tiles?: any[];
}

type TilemapFilterCallback = (value: Phaser.GameObjects.GameObject, index: number, array: Phaser.GameObjects.GameObject[]) => void;

type TilemapFindCallback = (value: Phaser.GameObjects.GameObject, index: number, array: Phaser.GameObjects.GameObject[]) => void;

interface FilteringOptions {
    /**
     * If true, only return tiles that don't have -1 for an index.
     */
    isNotEmpty?: boolean;
    /**
     * If true, only return tiles that collide on at least one side.
     */
    isColliding?: boolean;
    /**
     * If true, only return tiles that have at least one interesting face.
     */
    hasInterestingFace?: boolean;
}

interface StyleConfig {
    /**
     * Color to use for drawing a filled rectangle at non-colliding tile locations. If set to null, non-colliding tiles will not be drawn.
     */
    tileColor?: number;
    /**
     * Color to use for drawing a filled rectangle at colliding tile locations. If set to null, colliding tiles will not be drawn.
     */
    collidingTileColor?: number;
    /**
     * Color to use for drawing a line at interesting tile faces. If set to null, interesting tile faces will not be drawn.
     */
    faceColor?: number;
}

interface TilemapConfig {
    /**
     * The key in the Phaser cache that corresponds to the loaded tilemap data.
     */
    key?: string;
    /**
     * Instead of loading from the cache, you can also load directly from a 2D array of tile indexes.
     */
    data?: integer[][];
    /**
     * The width of a tile in pixels.
     */
    tileWidth?: integer;
    /**
     * The height of a tile in pixels.
     */
    tileHeight?: integer;
    /**
     * The width of the map in tiles.
     */
    width?: integer;
    /**
     * The height of the map in tiles.
     */
    height?: integer;
    /**
     * Controls how empty tiles, tiles with an index of -1,
     * in the map data are handled. If `true`, empty locations will get a value of `null`. If `false`,
     * empty location will get a Tile object with an index of -1. If you've a large sparsely populated
     * map and the tile data doesn't need to change then setting this value to `true` will help with
     * memory consumption. However if your map is small or you need to update the tiles dynamically,
     * then leave the default value set.
     */
    insertNull?: boolean;
}

interface TimerEventConfig {
    /**
     * The delay after which the Timer Event should fire, in milliseconds.
     */
    delay?: number;
    /**
     * The total number of times the Timer Event will repeat before finishing.
     */
    repeat?: number;
    /**
     * `true` if the Timer Event should repeat indefinitely.
     */
    loop?: boolean;
    /**
     * The callback which will be called when the Timer Event fires.
     */
    callback?: CallbackFn;
    /**
     * The scope (`this` object) with which to invoke the `callback`.
     */
    callbackScope?: any;
    /**
     * Additional arguments to be passed to the `callback`.
     */
    args?: any[];
    /**
     * The scale of the elapsed time.
     */
    timeScale?: number;
    /**
     * The initial elapsed time in milliseconds. Useful if you want a long duration with repeat, but for the first loop to fire quickly.
     */
    startAt?: number;
    /**
     * `true` if the Timer Event should be paused.
     */
    paused?: boolean;
}

interface TweenDataGenConfig {
    /**
     * Time in ms/frames before tween will start.
     */
    delay: CallbackFn;
    /**
     * Duration of the tween in ms/frames, excludes time for yoyo or repeats.
     */
    duration: CallbackFn;
    /**
     * Time in ms/frames the tween will pause before running the yoyo or starting a repeat.
     */
    hold: CallbackFn;
    /**
     * Number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.
     */
    repeat: CallbackFn;
    /**
     * Time in ms/frames before the repeat will start.
     */
    repeatDelay: CallbackFn;
}

/**
 * Class
 */
// tslint:disable-next-line no-unnecessary-class
declare class Class {
    /**
     *
     * @param definition a dictionary of functions for the class
     */
    constructor(definition: object);
}

interface AdInstance {
    /**
     * Represents an instance of an ad.
     */
    instance: any;
    /**
     * The Audience Network placement ID of this ad instance.
     */
    placementID: string;
    /**
     * Has this ad already been shown in-game?
     */
    shown: boolean;
    /**
     * Is this a video ad?
     */
    video: boolean;
}

interface LeaderboardScore {
    /**
     * An integer score value.
     */
    score: integer;
    /**
     * The score value, formatted with the score format associated with the leaderboard.
     */
    scoreFormatted: string;
    /**
     * The Unix timestamp of when the leaderboard entry was last updated.
     */
    timestamp: integer;
    /**
     * The entry's leaderboard ranking.
     */
    rank: integer;
    /**
     * The developer-specified payload associated with the score, or null if one was not set.
     */
    data: string;
    /**
     * The player's localized display name.
     */
    playerName: string;
    /**
     * A url to the player's public profile photo.
     */
    playerPhotoURL: string;
    /**
     * The game's unique identifier for the player.
     */
    playerID: string;
}

interface Product {
    /**
     * The title of the product.
     */
    title?: string;
    /**
     * The product's game-specified identifier.
     */
    productID?: string;
    /**
     * The product description.
     */
    description?: string;
    /**
     * A link to the product's associated image.
     */
    imageURI?: string;
    /**
     * The price of the product.
     */
    price?: string;
    /**
     * The currency code for the product.
     */
    priceCurrencyCode?: string;
}

interface Purchase {
    /**
     * A developer-specified string, provided during the purchase of the product.
     */
    developerPayload?: string;
    /**
     * The identifier for the purchase transaction.
     */
    paymentID?: string;
    /**
     * The product's game-specified identifier.
     */
    productID?: string;
    /**
     * Unix timestamp of when the purchase occurred.
     */
    purchaseTime?: string;
    /**
     * A token representing the purchase that may be used to consume the purchase.
     */
    purchaseToken?: string;
    /**
     * Server-signed encoding of the purchase request.
     */
    signedRequest?: string;
}

type integer = number;

declare module "phaser" {
    export = Phaser;
}
