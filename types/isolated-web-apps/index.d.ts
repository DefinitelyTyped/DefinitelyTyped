// This file contains merged type augmentations for standard global interfaces.

// It is automatically generated by the IDL-to-TS generator.

export * from "./controlled-frame";
export * from "./direct-sockets";
export * from "./screencapture";
export * from "./smart-card";
export * from "./webusb";

import {
  AudioOutputOptions,
  CaptureHandleConfig,
  DisplayMediaStreamOptions,
  MediaStreamConstraints,
  NavigatorUserMediaErrorCallback,
  NavigatorUserMediaSuccessCallback,
  UserMediaStreamConstraints,
} from "./screencapture";
import { SmartCardResourceManager } from "./smart-card";
import { USB } from "./webusb";

/** @remarks Extended attributes: [Exposed, ImplementedAs=USB, SecureContext] */
declare global {
  interface WorkerNavigator {
    /** @remarks Extended attributes: [SameObject] */
    readonly usb: USB;
  }
}

/** @remarks Extended attributes: [Exposed=Window, ImplementedAs=USB, SecureContext] */
declare global {
  interface Navigator {
    /** @remarks Extended attributes: [SameObject, RuntimeEnabled=WebUSB] */
    readonly usb: USB;
    /** @remarks Extended attributes: [SameObject] */
    readonly smartCard: SmartCardResourceManager;
    /** @remarks Extended attributes: [HighEntropy, RaisesException, SecureContext, MeasureAs=GetUserMediaLegacy] */
    getUserMedia(
      constraints: MediaStreamConstraints,
      successCallback: NavigatorUserMediaSuccessCallback,
      errorCallback: NavigatorUserMediaErrorCallback,
    ): void;
    /** @remarks Extended attributes: [HighEntropy, RaisesException, SecureContext, ImplementedAs=getUserMedia, MeasureAs=GetUserMediaPrefixed] */
    webkitGetUserMedia(
      constraints: MediaStreamConstraints,
      successCallback: NavigatorUserMediaSuccessCallback,
      errorCallback: NavigatorUserMediaErrorCallback,
    ): void;
  }
}

/** @remarks Extended attributes: [Exposed=Window, ActiveScriptWrappable, SecureContext] */
declare global {
  interface MediaDevices extends EventTarget {
    ondevicechange: ((ev: Event) => any) | null;
    /** @remarks Extended attributes: [CallWith=ScriptState, RaisesException, HighEntropy, MeasureAs=MediaDevicesEnumerateDevices] */
    enumerateDevices(): Promise<MediaDeviceInfo[]>;
    getSupportedConstraints(): MediaTrackSupportedConstraints;
    /** @remarks Extended attributes: [CallWith=ScriptState, RaisesException, HighEntropy, MeasureAs=GetUserMediaPromise] */
    getUserMedia(
      constraints?: UserMediaStreamConstraints,
    ): Promise<MediaStream>;
    /** @remarks Extended attributes: [RuntimeEnabled=GetDisplayMedia, CallWith=ScriptState, RaisesException, MeasureAs=GetDisplayMedia] */
    getDisplayMedia(
      constraints?: DisplayMediaStreamOptions,
    ): Promise<MediaStream>;
    /** @remarks Extended attributes: [RuntimeEnabled=GetAllScreensMedia, CallWith=ScriptState, RaisesException, MeasureAs=GetAllScreensMedia, IsolatedContext] */
    getAllScreensMedia(): Promise<MediaStream[]>;
    /** @remarks Extended attributes: [RuntimeEnabled=SelectAudioOutput, CallWith=ScriptState, RaisesException, MeasureAs=SelectAudioOutput] */
    selectAudioOutput(options?: AudioOutputOptions): Promise<MediaDeviceInfo>;
    /** @remarks Extended attributes: [RuntimeEnabled=CaptureHandle, CallWith=ScriptState, RaisesException] */
    setCaptureHandleConfig(config?: CaptureHandleConfig): void;
    /** @remarks Extended attributes: [RuntimeEnabled=PreferredAudioOutputDevices, CallWith=ScriptState, RaisesException, MeasureAs=PreferredAudioOutputDevices] */
    setPreferredSinkId(sinkId: string): Promise<undefined>;
  }
}
