const fs = require("fs");
const assert = require("assert");
const types = require("@babel/types");
const prettier = require("prettier");

const output = [
    "// this type definition is auto-generated by ./scripts/generate.ts",
    ""
];

const NodeNames = types.TYPES.filter(n => types.NODE_FIELDS[n]);
const AliasNames = types.TYPES.filter(n => types.FLIPPED_ALIAS_KEYS[n]);
output.push("export type NodeName =");
NodeNames.forEach((name, i) => {
    output.push(
        "    | " +
            JSON.stringify(name) +
            (i === NodeNames.length - 1 ? ";" : "")
    );
});
output.push("");
output.push("export type BabelNode =");
NodeNames.forEach((name, i) => {
    output.push("    | " + name + (i === NodeNames.length - 1 ? ";" : ""));
});
output.push("");
output.push("export type AliasName =");
AliasNames.forEach((name, i) => {
    output.push(
        "    | " +
            JSON.stringify(name) +
            (i === AliasNames.length - 1 ? ";" : "")
    );
});
output.push("");
output.push("export const TYPES: Array<NodeName | AliasName>;");
output.push("");
output.push("export const ALIAS_KEYS: Record<NodeName, AliasName[]>;");
NodeNames.forEach(name => {
    assert(
        Array.isArray(types.ALIAS_KEYS[name]),
        name + " should be in ALIAS_KEYS"
    );
    assert(
        types.ALIAS_KEYS[name].every(name => AliasNames.includes(name)),
        name + "'s ALIAS_KEYS should all be AliasNames"
    );
});
Object.keys(types.ALIAS_KEYS).forEach(name => {
    assert(NodeNames.includes(name), name + " should be in NodeNames");
});
output.push("export const FLIPPED_ALIAS_KEYS: Record<AliasName, NodeName[]>;");
AliasNames.forEach(name => {
    assert(
        Array.isArray(types.FLIPPED_ALIAS_KEYS[name]),
        name + " should be in FLIPPED_ALIAS_KEYS"
    );
    assert(
        types.FLIPPED_ALIAS_KEYS[name].every(name => NodeNames.includes(name)),
        name + "'s FLIPPED_ALIAS_KEYS should all be NodeNames"
    );
});
Object.keys(types.FLIPPED_ALIAS_KEYS).forEach(name => {
    assert(AliasNames.includes(name), name + " should be in AliasNames");
});
output.push("export const VISITOR_KEYS: Record<NodeName, string[]>;");
NodeNames.forEach(name => {
    assert(
        Array.isArray(types.VISITOR_KEYS[name]),
        name + " should be in VISITOR_KEYS"
    );
    assert(
        types.VISITOR_KEYS[name].every(name => typeof name === "string"),
        name + "'s VISITOR_KEYS should all be strings"
    );
});
Object.keys(types.VISITOR_KEYS).forEach(name => {
    assert(NodeNames.includes(name), name + " should be in NodeNames");
});
output.push("export const BUILDER_KEYS: Record<NodeName, string[]>;");
NodeNames.forEach(name => {
    assert(
        Array.isArray(types.BUILDER_KEYS[name]),
        name + " should be in BUILDER_KEYS"
    );
    assert(
        types.BUILDER_KEYS[name].every(name => typeof name === "string"),
        name + "'s BUILDER_KEYS should all be strings"
    );
});
Object.keys(types.BUILDER_KEYS).forEach(name => {
    assert(NodeNames.includes(name), name + " should be in NodeNames");
});
output.push(
    "export const DEPRECATED_KEYS: Record<NodeName, NodeName | undefined>;"
);
Object.keys(types.DEPRECATED_KEYS).forEach(name => {
    assert(
        typeof types.DEPRECATED_KEYS[name] === "string",
        name + " in DEPRECATED_KEYS should be a string"
    );
});

output.push(
    "export const NODE_FIELDS: Record<NodeName, Record<string, undefined | {default?: any, optional?: boolean, validate?: (node: BabelNode, key: string, val: any) => void}>>;"
);

output.push("");

const ConstantUnions = [
    "STATEMENT_OR_BLOCK_KEYS",
    "FLATTENABLE_KEYS",
    "FOR_INIT_KEYS",
    "COMMENT_KEYS",
    "LOGICAL_OPERATORS",
    "UPDATE_OPERATORS",
    "BOOLEAN_NUMBER_BINARY_OPERATORS",
    "EQUALITY_BINARY_OPERATORS",
    "COMPARISON_BINARY_OPERATORS",
    "BOOLEAN_BINARY_OPERATORS",
    "NUMBER_BINARY_OPERATORS",
    "BINARY_OPERATORS",
    "BOOLEAN_UNARY_OPERATORS",
    "NUMBER_UNARY_OPERATORS",
    "STRING_UNARY_OPERATORS",
    "UNARY_OPERATORS"
].map(unionName => {
    const typeName =
        unionName[0] +
        unionName
            .substr(1)
            .toLowerCase()
            .replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())
            .replace(/s$/, "");
    output.push("export type " + typeName + " =");
    types[unionName].forEach((value, i) => {
        output.push(
            "    | " +
                JSON.stringify(value) +
                (i === types[unionName].length ? ";" : "")
        );
    });
    output.push("export const " + unionName + ": " + typeName + "[];");
    return {
        values: types[unionName],
        typeName
    };
});
output.push(
    "export const INHERIT_KEYS: " + JSON.stringify(types.INHERIT_KEYS) + ";"
);
output.push("export const BLOCK_SCOPED_SYMBOL: unique symbol;");
assert(typeof types.BLOCK_SCOPED_SYMBOL === "symbol");
output.push("export const NOT_LOCAL_BINDING: unique symbol;");
assert(typeof types.NOT_LOCAL_BINDING === "symbol");

AliasNames.forEach(type => {
    assert(Array.isArray(types[`${type.toUpperCase()}_TYPES`]));
    assert(
        types[`${type.toUpperCase()}_TYPES`].every(name =>
            NodeNames.includes(name)
        )
    );
    output.push(`export const ${type.toUpperCase()}_TYPES: NodeName[];`);
});

output.push("");
output.push("export interface Comment {");
output.push("    value: string;");
output.push("    start: number;");
output.push("    end: number;");
output.push("    loc: SourceLocation;");
output.push("}");
output.push("");
output.push("export interface CommentBlock extends Comment {");
output.push('    type: "CommentBlock";');
output.push("}");
output.push("");
output.push("export interface CommentLine extends Comment {");
output.push('    type: "CommentLine";');
output.push("}");
output.push("");
output.push("export interface SourceLocation {");
output.push("    start: {");
output.push("        line: number;");
output.push("        column: number;");
output.push("    };");
output.push("");
output.push("    end: {");
output.push("        line: number;");
output.push("        column: number;");
output.push("    };");
output.push("}");
output.push("");
output.push("export interface NodeBase {");
output.push("    type: NodeName;");
output.push("    leadingComments?: Comment[];");
output.push("    innerComments?: Comment[];");
output.push("    trailingComments?: Comment[];");
output.push("    start: number;");
output.push("    end: number;");
output.push("    loc: SourceLocation;");
output.push("}");
output.push("");

const customTypes = {
    AssignmentExpression: {
        operator:
            '"=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&="'
    },
    File: {
        comments: "Comment[]",
        tokens: "any[]"
    }
};
NodeNames.forEach(name => {
    if (types.NODE_FIELDS[name]) {
        output.push("export interface " + name + " extends NodeBase {");
        output.push("    type: " + JSON.stringify(name) + ";");
        Object.keys(types.NODE_FIELDS[name]).forEach(fieldName => {
            const spec = types.NODE_FIELDS[name][fieldName];
            const customType =
                customTypes[name] && customTypes[name][fieldName];
            output.push(
                "    " +
                    fieldName +
                    (spec.optional ? "?" : "") +
                    ": " +
                    (customType
                        ? customType
                        : typeFromValidator(spec.validate)) +
                    ";"
            );
        });
        output.push("}");
        output.push("");
    }
});
function typeFromValidator(validator) {
    if (validator === undefined) {
        return "any";
    }

    if (validator.each) {
        const elementType = typeFromValidator(validator.each);
        if (/^[a-z]+$/i.test(elementType)) {
            return `${elementType}[]`;
        } else {
            return `Array<${elementType}>`;
        }
    }

    if (validator.chainOf) {
        return typeFromValidator(validator.chainOf[1]);
    }

    if (validator.oneOf) {
        if (
            validator.oneOf.some(v => v === true) &&
            validator.oneOf.some(v => v === false)
        ) {
            return validator.oneOf
                .filter(v => typeof v !== "boolean")
                .map(JSON.stringify)
                .concat(["boolean"])
                .join(" | ");
        }
        for (const union of ConstantUnions) {
            if (
                union.values.every(v => validator.oneOf.includes(v)) &&
                validator.oneOf.every(v => union.values.includes(v))
            ) {
                return union.typeName;
            }
        }
        return validator.oneOf.map(JSON.stringify).join(" | ");
    }

    if (validator.oneOfNodeTypes) {
        return validator.oneOfNodeTypes.map(_ => _).join(" | ");
    }

    if (validator.oneOfNodeOrValueTypes) {
        return validator.oneOfNodeOrValueTypes.join(" | ");
    }

    if (validator.type) {
        return validator.type;
    }

    return ["any"];
}

AliasNames.forEach(name => {
    output.push(
        "export type " + (name === "Function" ? "FunctionNode" : name) + " ="
    );
    types.FLIPPED_ALIAS_KEYS[name].forEach((childName, i) => {
        output.push(
            "    | " +
                childName +
                (i === types.FLIPPED_ALIAS_KEYS[name].length - 1 ? ";" : "")
        );
    });
    output.push("");
});
const reservedNames = ["default", "extends", "import", "super"];
NodeNames.sort().forEach(name => {
    const n = name[0].toLowerCase() + name.substr(1);
    const keys = types.BUILDER_KEYS[name];
    const definition = `(${keys
        .map(
            param =>
                `${
                    reservedNames.includes(param) ? "_" : ""
                }${param}: ${name}['${param}']`
        )
        .join(", ")}): ${name};`;
    if (reservedNames.includes(n)) {
        // TODO: how can I export something with a reserved word as its name
        // output.push(`declare function _${n}${definition}`);
        // output.push(`export {_${n} as ${n}};`);
    } else {
        output.push(`export function ${n}${definition}`);
        if (/^TS/.test(name)) {
            output.push(`export {${n} as ${name.replace(/^TS/, "ts")}};`);
        }
        if (/^JSX/.test(name)) {
            output.push(`export {${n} as ${name.replace(/^JSX/, "jsx")}};`);
        }
    }
    assert(typeof types[n] === "function");
});
output.push("");
output.push(`export function isNode(node: object): node is BabelNode;`);
assert(typeof types.isNode === "function");
types.TYPES.filter(name => !types.DEPRECATED_KEYS[name])
    .sort()
    .forEach(name => {
        output.push(
            `export function is${name}(node?: object, opts?: object): node is ${
                name === "Function" ? "FunctionNode" : name
            };`
        );
        assert(typeof types[`is${name}`] === "function");
    });
output.push("");
output.push(`export function assertNode(node: object): void;`);
assert(typeof types.assertNode === "function");
types.TYPES.filter(name => !types.DEPRECATED_KEYS[name])
    .sort()
    .forEach(name => {
        output.push(
            `export function assert${name}(node: object, opts?: object): void;`
        );
        assert(typeof types[`assert${name}`] === "function");
    });
output.push("");

fs.writeFileSync(
    __dirname + "/../generated.d.ts",
    prettier.format(output.join("\n"), {
        tabWidth: 4,
        parser: "typescript"
    })
);

const testOutput = [
    "// this test is auto-generated by ./scripts/generate.ts",
    ""
];

testOutput.push(`import {`);
Object.keys(types)
    .sort()
    .filter(
        name =>
            name !== "__esModule" &&
            name !== "import" &&
            name !== "super" &&
            !types.DEPRECATED_KEYS[name] &&
            !types.DEPRECATED_KEYS[name.replace(/^assert/, "")] &&
            !types.DEPRECATED_KEYS[name.replace(/^is/, "")] &&
            !types.DEPRECATED_KEYS[name[0].toUpperCase() + name.substr(1)]
    )
    .forEach(name => {
        testOutput.push(`    ${name},`);
    });
testOutput.push(`} from '@babel/types';`);
testOutput.push("");

fs.writeFileSync(
    __dirname + "/../babel__types-tests.ts",
    testOutput.join("\n")
);
