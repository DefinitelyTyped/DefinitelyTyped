// this type definition is auto-generated by ./scripts/generate.ts

export type NodeName =
    | "ArrayExpression"
    | "AssignmentExpression"
    | "BinaryExpression"
    | "Directive"
    | "DirectiveLiteral"
    | "BlockStatement"
    | "BreakStatement"
    | "CallExpression"
    | "CatchClause"
    | "ConditionalExpression"
    | "ContinueStatement"
    | "DebuggerStatement"
    | "DoWhileStatement"
    | "EmptyStatement"
    | "ExpressionStatement"
    | "File"
    | "ForInStatement"
    | "ForStatement"
    | "FunctionDeclaration"
    | "FunctionExpression"
    | "Identifier"
    | "IfStatement"
    | "LabeledStatement"
    | "StringLiteral"
    | "NumericLiteral"
    | "NullLiteral"
    | "BooleanLiteral"
    | "RegExpLiteral"
    | "LogicalExpression"
    | "MemberExpression"
    | "NewExpression"
    | "Program"
    | "ObjectExpression"
    | "ObjectMethod"
    | "ObjectProperty"
    | "RestElement"
    | "ReturnStatement"
    | "SequenceExpression"
    | "SwitchCase"
    | "SwitchStatement"
    | "ThisExpression"
    | "ThrowStatement"
    | "TryStatement"
    | "UnaryExpression"
    | "UpdateExpression"
    | "VariableDeclaration"
    | "VariableDeclarator"
    | "WhileStatement"
    | "WithStatement"
    | "AssignmentPattern"
    | "ArrayPattern"
    | "ArrowFunctionExpression"
    | "ClassBody"
    | "ClassDeclaration"
    | "ClassExpression"
    | "ExportAllDeclaration"
    | "ExportDefaultDeclaration"
    | "ExportNamedDeclaration"
    | "ExportSpecifier"
    | "ForOfStatement"
    | "ImportDeclaration"
    | "ImportDefaultSpecifier"
    | "ImportNamespaceSpecifier"
    | "ImportSpecifier"
    | "MetaProperty"
    | "ClassMethod"
    | "ObjectPattern"
    | "SpreadElement"
    | "Super"
    | "TaggedTemplateExpression"
    | "TemplateElement"
    | "TemplateLiteral"
    | "YieldExpression"
    | "AnyTypeAnnotation"
    | "ArrayTypeAnnotation"
    | "BooleanTypeAnnotation"
    | "BooleanLiteralTypeAnnotation"
    | "NullLiteralTypeAnnotation"
    | "ClassImplements"
    | "DeclareClass"
    | "DeclareFunction"
    | "DeclareInterface"
    | "DeclareModule"
    | "DeclareModuleExports"
    | "DeclareTypeAlias"
    | "DeclareOpaqueType"
    | "DeclareVariable"
    | "DeclareExportDeclaration"
    | "DeclareExportAllDeclaration"
    | "DeclaredPredicate"
    | "ExistsTypeAnnotation"
    | "FunctionTypeAnnotation"
    | "FunctionTypeParam"
    | "GenericTypeAnnotation"
    | "InferredPredicate"
    | "InterfaceExtends"
    | "InterfaceDeclaration"
    | "IntersectionTypeAnnotation"
    | "MixedTypeAnnotation"
    | "EmptyTypeAnnotation"
    | "NullableTypeAnnotation"
    | "NumberLiteralTypeAnnotation"
    | "NumberTypeAnnotation"
    | "ObjectTypeAnnotation"
    | "ObjectTypeCallProperty"
    | "ObjectTypeIndexer"
    | "ObjectTypeProperty"
    | "ObjectTypeSpreadProperty"
    | "OpaqueType"
    | "QualifiedTypeIdentifier"
    | "StringLiteralTypeAnnotation"
    | "StringTypeAnnotation"
    | "ThisTypeAnnotation"
    | "TupleTypeAnnotation"
    | "TypeofTypeAnnotation"
    | "TypeAlias"
    | "TypeAnnotation"
    | "TypeCastExpression"
    | "TypeParameter"
    | "TypeParameterDeclaration"
    | "TypeParameterInstantiation"
    | "UnionTypeAnnotation"
    | "Variance"
    | "VoidTypeAnnotation"
    | "JSXAttribute"
    | "JSXClosingElement"
    | "JSXElement"
    | "JSXEmptyExpression"
    | "JSXExpressionContainer"
    | "JSXSpreadChild"
    | "JSXIdentifier"
    | "JSXMemberExpression"
    | "JSXNamespacedName"
    | "JSXOpeningElement"
    | "JSXSpreadAttribute"
    | "JSXText"
    | "JSXFragment"
    | "JSXOpeningFragment"
    | "JSXClosingFragment"
    | "Noop"
    | "ParenthesizedExpression"
    | "AwaitExpression"
    | "BindExpression"
    | "ClassProperty"
    | "OptionalMemberExpression"
    | "OptionalCallExpression"
    | "Import"
    | "Decorator"
    | "DoExpression"
    | "ExportDefaultSpecifier"
    | "ExportNamespaceSpecifier"
    | "TSParameterProperty"
    | "TSDeclareFunction"
    | "TSDeclareMethod"
    | "TSQualifiedName"
    | "TSCallSignatureDeclaration"
    | "TSConstructSignatureDeclaration"
    | "TSPropertySignature"
    | "TSMethodSignature"
    | "TSIndexSignature"
    | "TSAnyKeyword"
    | "TSNumberKeyword"
    | "TSObjectKeyword"
    | "TSBooleanKeyword"
    | "TSStringKeyword"
    | "TSSymbolKeyword"
    | "TSVoidKeyword"
    | "TSUndefinedKeyword"
    | "TSNullKeyword"
    | "TSNeverKeyword"
    | "TSThisType"
    | "TSFunctionType"
    | "TSConstructorType"
    | "TSTypeReference"
    | "TSTypePredicate"
    | "TSTypeQuery"
    | "TSTypeLiteral"
    | "TSArrayType"
    | "TSTupleType"
    | "TSUnionType"
    | "TSIntersectionType"
    | "TSParenthesizedType"
    | "TSTypeOperator"
    | "TSIndexedAccessType"
    | "TSMappedType"
    | "TSLiteralType"
    | "TSExpressionWithTypeArguments"
    | "TSInterfaceDeclaration"
    | "TSInterfaceBody"
    | "TSTypeAliasDeclaration"
    | "TSAsExpression"
    | "TSTypeAssertion"
    | "TSEnumDeclaration"
    | "TSEnumMember"
    | "TSModuleDeclaration"
    | "TSModuleBlock"
    | "TSImportEqualsDeclaration"
    | "TSExternalModuleReference"
    | "TSNonNullExpression"
    | "TSExportAssignment"
    | "TSNamespaceExportDeclaration"
    | "TSTypeAnnotation"
    | "TSTypeParameterInstantiation"
    | "TSTypeParameterDeclaration"
    | "TSTypeParameter";

export type BabelNode =
    | ArrayExpression
    | AssignmentExpression
    | BinaryExpression
    | Directive
    | DirectiveLiteral
    | BlockStatement
    | BreakStatement
    | CallExpression
    | CatchClause
    | ConditionalExpression
    | ContinueStatement
    | DebuggerStatement
    | DoWhileStatement
    | EmptyStatement
    | ExpressionStatement
    | File
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | Identifier
    | IfStatement
    | LabeledStatement
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | LogicalExpression
    | MemberExpression
    | NewExpression
    | Program
    | ObjectExpression
    | ObjectMethod
    | ObjectProperty
    | RestElement
    | ReturnStatement
    | SequenceExpression
    | SwitchCase
    | SwitchStatement
    | ThisExpression
    | ThrowStatement
    | TryStatement
    | UnaryExpression
    | UpdateExpression
    | VariableDeclaration
    | VariableDeclarator
    | WhileStatement
    | WithStatement
    | AssignmentPattern
    | ArrayPattern
    | ArrowFunctionExpression
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ExportSpecifier
    | ForOfStatement
    | ImportDeclaration
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportSpecifier
    | MetaProperty
    | ClassMethod
    | ObjectPattern
    | SpreadElement
    | Super
    | TaggedTemplateExpression
    | TemplateElement
    | TemplateLiteral
    | YieldExpression
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullLiteralTypeAnnotation
    | ClassImplements
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | DeclaredPredicate
    | ExistsTypeAnnotation
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | GenericTypeAnnotation
    | InferredPredicate
    | InterfaceExtends
    | InterfaceDeclaration
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NullableTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | ObjectTypeAnnotation
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | OpaqueType
    | QualifiedTypeIdentifier
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | ThisTypeAnnotation
    | TupleTypeAnnotation
    | TypeofTypeAnnotation
    | TypeAlias
    | TypeAnnotation
    | TypeCastExpression
    | TypeParameter
    | TypeParameterDeclaration
    | TypeParameterInstantiation
    | UnionTypeAnnotation
    | Variance
    | VoidTypeAnnotation
    | JSXAttribute
    | JSXClosingElement
    | JSXElement
    | JSXEmptyExpression
    | JSXExpressionContainer
    | JSXSpreadChild
    | JSXIdentifier
    | JSXMemberExpression
    | JSXNamespacedName
    | JSXOpeningElement
    | JSXSpreadAttribute
    | JSXText
    | JSXFragment
    | JSXOpeningFragment
    | JSXClosingFragment
    | Noop
    | ParenthesizedExpression
    | AwaitExpression
    | BindExpression
    | ClassProperty
    | OptionalMemberExpression
    | OptionalCallExpression
    | Import
    | Decorator
    | DoExpression
    | ExportDefaultSpecifier
    | ExportNamespaceSpecifier
    | TSParameterProperty
    | TSDeclareFunction
    | TSDeclareMethod
    | TSQualifiedName
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSPropertySignature
    | TSMethodSignature
    | TSIndexSignature
    | TSAnyKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSBooleanKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSVoidKeyword
    | TSUndefinedKeyword
    | TSNullKeyword
    | TSNeverKeyword
    | TSThisType
    | TSFunctionType
    | TSConstructorType
    | TSTypeReference
    | TSTypePredicate
    | TSTypeQuery
    | TSTypeLiteral
    | TSArrayType
    | TSTupleType
    | TSUnionType
    | TSIntersectionType
    | TSParenthesizedType
    | TSTypeOperator
    | TSIndexedAccessType
    | TSMappedType
    | TSLiteralType
    | TSExpressionWithTypeArguments
    | TSInterfaceDeclaration
    | TSInterfaceBody
    | TSTypeAliasDeclaration
    | TSAsExpression
    | TSTypeAssertion
    | TSEnumDeclaration
    | TSEnumMember
    | TSModuleDeclaration
    | TSModuleBlock
    | TSImportEqualsDeclaration
    | TSExternalModuleReference
    | TSNonNullExpression
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSTypeAnnotation
    | TSTypeParameterInstantiation
    | TSTypeParameterDeclaration
    | TSTypeParameter;

export type AliasName =
    | "Expression"
    | "Binary"
    | "Scopable"
    | "BlockParent"
    | "Block"
    | "Statement"
    | "Terminatorless"
    | "CompletionStatement"
    | "Conditional"
    | "Loop"
    | "While"
    | "ExpressionWrapper"
    | "For"
    | "ForXStatement"
    | "Function"
    | "FunctionParent"
    | "Pureish"
    | "Declaration"
    | "PatternLike"
    | "LVal"
    | "TSEntityName"
    | "Literal"
    | "Immutable"
    | "UserWhitespacable"
    | "Method"
    | "ObjectMember"
    | "Property"
    | "UnaryLike"
    | "Pattern"
    | "Class"
    | "ModuleDeclaration"
    | "ExportDeclaration"
    | "ModuleSpecifier"
    | "Flow"
    | "FlowType"
    | "FlowBaseAnnotation"
    | "FlowDeclaration"
    | "FlowPredicate"
    | "JSX"
    | "TSTypeElement"
    | "TSType";

export declare const TYPES: (NodeName | AliasName)[];

export declare const ALIAS_KEYS: Record<NodeName, AliasName[]>;
export declare const FLIPPED_ALIAS_KEYS: Record<AliasName, NodeName[]>;
export declare const VISITOR_KEYS: Record<NodeName, string[]>;
export declare const BUILDER_KEYS: Record<NodeName, string[]>;
export declare const DEPRECATED_KEYS: Record<NodeName, NodeName | void>;
export declare const NODE_FIELDS: Record<NodeName, Record<string, void | {default?: any, optional?: boolean, validate?: (node: Node, key: string, val: any) => void}>>;

export type StatementOrBlockKey =
    | "consequent"
    | "body"
    | "alternate"
export declare const STATEMENT_OR_BLOCK_KEYS: StatementOrBlockKey[];
export type FlattenableKey =
    | "body"
    | "expressions"
export declare const FLATTENABLE_KEYS: FlattenableKey[];
export type ForInitKey =
    | "left"
    | "init"
export declare const FOR_INIT_KEYS: ForInitKey[];
export type CommentKey =
    | "leadingComments"
    | "trailingComments"
    | "innerComments"
export declare const COMMENT_KEYS: CommentKey[];
export type LogicalOperator =
    | "||"
    | "&&"
    | "??"
export declare const LOGICAL_OPERATORS: LogicalOperator[];
export type UpdateOperator =
    | "++"
    | "--"
export declare const UPDATE_OPERATORS: UpdateOperator[];
export type BooleanNumberBinaryOperator =
    | ">"
    | "<"
    | ">="
    | "<="
export declare const BOOLEAN_NUMBER_BINARY_OPERATORS: BooleanNumberBinaryOperator[];
export type EqualityBinaryOperator =
    | "=="
    | "==="
    | "!="
    | "!=="
export declare const EQUALITY_BINARY_OPERATORS: EqualityBinaryOperator[];
export type ComparisonBinaryOperator =
    | "=="
    | "==="
    | "!="
    | "!=="
    | "in"
    | "instanceof"
export declare const COMPARISON_BINARY_OPERATORS: ComparisonBinaryOperator[];
export type BooleanBinaryOperator =
    | "=="
    | "==="
    | "!="
    | "!=="
    | "in"
    | "instanceof"
    | ">"
    | "<"
    | ">="
    | "<="
export declare const BOOLEAN_BINARY_OPERATORS: BooleanBinaryOperator[];
export type NumberBinaryOperator =
    | "-"
    | "/"
    | "%"
    | "*"
    | "**"
    | "&"
    | "|"
    | ">>"
    | ">>>"
    | "<<"
    | "^"
export declare const NUMBER_BINARY_OPERATORS: NumberBinaryOperator[];
export type BinaryOperator =
    | "+"
    | "-"
    | "/"
    | "%"
    | "*"
    | "**"
    | "&"
    | "|"
    | ">>"
    | ">>>"
    | "<<"
    | "^"
    | "=="
    | "==="
    | "!="
    | "!=="
    | "in"
    | "instanceof"
    | ">"
    | "<"
    | ">="
    | "<="
export declare const BINARY_OPERATORS: BinaryOperator[];
export type BooleanUnaryOperator =
    | "delete"
    | "!"
export declare const BOOLEAN_UNARY_OPERATORS: BooleanUnaryOperator[];
export type NumberUnaryOperator =
    | "+"
    | "-"
    | "~"
export declare const NUMBER_UNARY_OPERATORS: NumberUnaryOperator[];
export type StringUnaryOperator =
    | "typeof"
export declare const STRING_UNARY_OPERATORS: StringUnaryOperator[];
export type UnaryOperator =
    | "void"
    | "throw"
    | "delete"
    | "!"
    | "+"
    | "-"
    | "~"
    | "typeof"
export declare const UNARY_OPERATORS: UnaryOperator[];
export declare const INHERIT_KEYS: {"optional":["typeAnnotation","typeParameters","returnType"],"force":["start","loc","end"]};
export declare const BLOCK_SCOPED_SYMBOL: unique symbol;
export declare const NOT_LOCAL_BINDING: unique symbol;
export declare const EXPRESSION_TYPES: NodeName[];
export declare const BINARY_TYPES: NodeName[];
export declare const SCOPABLE_TYPES: NodeName[];
export declare const BLOCKPARENT_TYPES: NodeName[];
export declare const BLOCK_TYPES: NodeName[];
export declare const STATEMENT_TYPES: NodeName[];
export declare const TERMINATORLESS_TYPES: NodeName[];
export declare const COMPLETIONSTATEMENT_TYPES: NodeName[];
export declare const CONDITIONAL_TYPES: NodeName[];
export declare const LOOP_TYPES: NodeName[];
export declare const WHILE_TYPES: NodeName[];
export declare const EXPRESSIONWRAPPER_TYPES: NodeName[];
export declare const FOR_TYPES: NodeName[];
export declare const FORXSTATEMENT_TYPES: NodeName[];
export declare const FUNCTION_TYPES: NodeName[];
export declare const FUNCTIONPARENT_TYPES: NodeName[];
export declare const PUREISH_TYPES: NodeName[];
export declare const DECLARATION_TYPES: NodeName[];
export declare const PATTERNLIKE_TYPES: NodeName[];
export declare const LVAL_TYPES: NodeName[];
export declare const TSENTITYNAME_TYPES: NodeName[];
export declare const LITERAL_TYPES: NodeName[];
export declare const IMMUTABLE_TYPES: NodeName[];
export declare const USERWHITESPACABLE_TYPES: NodeName[];
export declare const METHOD_TYPES: NodeName[];
export declare const OBJECTMEMBER_TYPES: NodeName[];
export declare const PROPERTY_TYPES: NodeName[];
export declare const UNARYLIKE_TYPES: NodeName[];
export declare const PATTERN_TYPES: NodeName[];
export declare const CLASS_TYPES: NodeName[];
export declare const MODULEDECLARATION_TYPES: NodeName[];
export declare const EXPORTDECLARATION_TYPES: NodeName[];
export declare const MODULESPECIFIER_TYPES: NodeName[];
export declare const FLOW_TYPES: NodeName[];
export declare const FLOWTYPE_TYPES: NodeName[];
export declare const FLOWBASEANNOTATION_TYPES: NodeName[];
export declare const FLOWDECLARATION_TYPES: NodeName[];
export declare const FLOWPREDICATE_TYPES: NodeName[];
export declare const JSX_TYPES: NodeName[];
export declare const TSTYPEELEMENT_TYPES: NodeName[];
export declare const TSTYPE_TYPES: NodeName[];

export interface Comment {
    value: string;
    start: number;
    end: number;
    loc: SourceLocation;
}

export interface CommentBlock extends Comment {
    type: "CommentBlock";
}

export interface CommentLine extends Comment {
    type: "CommentLine";
}

export interface SourceLocation {
    start: {
        line: number;
        column: number;
    };

    end: {
        line: number;
        column: number;
    };
}

export interface NodeBase {
    type: NodeName;
    leadingComments?: Comment[];
    innerComments?: Comment[];
    trailingComments?: Comment[];
    start: number;
    end: number;
    loc: SourceLocation;
}

export interface ArrayExpression extends NodeBase {
    type: "ArrayExpression";
    elements: (null | Expression | SpreadElement)[];
}

export interface AssignmentExpression extends NodeBase {
    type: "AssignmentExpression";
    operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=";
    left: LVal;
    right: Expression;
}

export interface BinaryExpression extends NodeBase {
    type: "BinaryExpression";
    operator: BinaryOperator;
    left: Expression;
    right: Expression;
}

export interface Directive extends NodeBase {
    type: "Directive";
    value: DirectiveLiteral;
}

export interface DirectiveLiteral extends NodeBase {
    type: "DirectiveLiteral";
    value: string;
}

export interface BlockStatement extends NodeBase {
    type: "BlockStatement";
    directives: Directive[];
    body: Statement[];
}

export interface BreakStatement extends NodeBase {
    type: "BreakStatement";
    label?: Identifier;
}

export interface CallExpression extends NodeBase {
    type: "CallExpression";
    callee: Expression;
    arguments: (Expression | SpreadElement | JSXNamespacedName)[];
    optional?: boolean;
    typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
}

export interface CatchClause extends NodeBase {
    type: "CatchClause";
    param?: Identifier;
    body: BlockStatement;
}

export interface ConditionalExpression extends NodeBase {
    type: "ConditionalExpression";
    test: Expression;
    consequent: Expression;
    alternate: Expression;
}

export interface ContinueStatement extends NodeBase {
    type: "ContinueStatement";
    label?: Identifier;
}

export interface DebuggerStatement extends NodeBase {
    type: "DebuggerStatement";
}

export interface DoWhileStatement extends NodeBase {
    type: "DoWhileStatement";
    test: Expression;
    body: Statement;
}

export interface EmptyStatement extends NodeBase {
    type: "EmptyStatement";
}

export interface ExpressionStatement extends NodeBase {
    type: "ExpressionStatement";
    expression: Expression;
}

export interface File extends NodeBase {
    type: "File";
    program: Program;
    comments: Comment[];
    tokens: any[];
}

export interface ForInStatement extends NodeBase {
    type: "ForInStatement";
    left: VariableDeclaration | LVal;
    right: Expression;
    body: Statement;
}

export interface ForStatement extends NodeBase {
    type: "ForStatement";
    init?: VariableDeclaration | Expression;
    test?: Expression;
    update?: Expression;
    body: Statement;
}

export interface FunctionDeclaration extends NodeBase {
    type: "FunctionDeclaration";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    declare?: boolean;
    id?: Identifier;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
    body: BlockStatement;
}

export interface FunctionExpression extends NodeBase {
    type: "FunctionExpression";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
    id?: Identifier;
    body: BlockStatement;
}

export interface Identifier extends NodeBase {
    type: "Identifier";
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    name: string;
    optional?: boolean;
}

export interface IfStatement extends NodeBase {
    type: "IfStatement";
    test: Expression;
    consequent: Statement;
    alternate?: Statement;
}

export interface LabeledStatement extends NodeBase {
    type: "LabeledStatement";
    label: Identifier;
    body: Statement;
}

export interface StringLiteral extends NodeBase {
    type: "StringLiteral";
    value: string;
}

export interface NumericLiteral extends NodeBase {
    type: "NumericLiteral";
    value: number;
}

export interface NullLiteral extends NodeBase {
    type: "NullLiteral";
}

export interface BooleanLiteral extends NodeBase {
    type: "BooleanLiteral";
    value: boolean;
}

export interface RegExpLiteral extends NodeBase {
    type: "RegExpLiteral";
    pattern: string;
    flags: string;
}

export interface LogicalExpression extends NodeBase {
    type: "LogicalExpression";
    operator: LogicalOperator;
    left: Expression;
    right: Expression;
}

export interface MemberExpression extends NodeBase {
    type: "MemberExpression";
    object: Expression;
    property: any;
    computed: boolean;
    optional?: boolean;
}

export interface NewExpression extends NodeBase {
    type: "NewExpression";
    callee: Expression;
    arguments: (Expression | SpreadElement | JSXNamespacedName)[];
    optional?: boolean;
    typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
}

export interface Program extends NodeBase {
    type: "Program";
    sourceFile?: string;
    sourceType: "script" | "module";
    directives: Directive[];
    body: Statement[];
}

export interface ObjectExpression extends NodeBase {
    type: "ObjectExpression";
    properties: (ObjectMethod | ObjectProperty | SpreadElement)[];
}

export interface ObjectMethod extends NodeBase {
    type: "ObjectMethod";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
    kind: "method" | "get" | "set";
    computed: boolean;
    key: any;
    decorators?: Decorator[];
    body: BlockStatement;
}

export interface ObjectProperty extends NodeBase {
    type: "ObjectProperty";
    computed: boolean;
    key: any;
    value: Expression | PatternLike;
    shorthand: boolean;
    decorators?: Decorator[];
}

export interface RestElement extends NodeBase {
    type: "RestElement";
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    argument: LVal;
}

export interface ReturnStatement extends NodeBase {
    type: "ReturnStatement";
    argument?: Expression;
}

export interface SequenceExpression extends NodeBase {
    type: "SequenceExpression";
    expressions: Expression[];
}

export interface SwitchCase extends NodeBase {
    type: "SwitchCase";
    test?: Expression;
    consequent: Statement[];
}

export interface SwitchStatement extends NodeBase {
    type: "SwitchStatement";
    discriminant: Expression;
    cases: SwitchCase[];
}

export interface ThisExpression extends NodeBase {
    type: "ThisExpression";
}

export interface ThrowStatement extends NodeBase {
    type: "ThrowStatement";
    argument: Expression;
}

export interface TryStatement extends NodeBase {
    type: "TryStatement";
    block: BlockStatement;
    handler?: CatchClause;
    finalizer?: BlockStatement;
}

export interface UnaryExpression extends NodeBase {
    type: "UnaryExpression";
    prefix: boolean;
    argument: Expression;
    operator: UnaryOperator;
}

export interface UpdateExpression extends NodeBase {
    type: "UpdateExpression";
    prefix: boolean;
    argument: Expression;
    operator: UpdateOperator;
}

export interface VariableDeclaration extends NodeBase {
    type: "VariableDeclaration";
    declare?: boolean;
    kind: "var" | "let" | "const";
    declarations: VariableDeclarator[];
}

export interface VariableDeclarator extends NodeBase {
    type: "VariableDeclarator";
    id: LVal;
    init?: Expression;
}

export interface WhileStatement extends NodeBase {
    type: "WhileStatement";
    test: Expression;
    body: BlockStatement | Statement;
}

export interface WithStatement extends NodeBase {
    type: "WithStatement";
    object: Expression;
    body: BlockStatement | Statement;
}

export interface AssignmentPattern extends NodeBase {
    type: "AssignmentPattern";
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    left: Identifier | ObjectPattern | ArrayPattern;
    right: Expression;
}

export interface ArrayPattern extends NodeBase {
    type: "ArrayPattern";
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    elements: PatternLike[];
}

export interface ArrowFunctionExpression extends NodeBase {
    type: "ArrowFunctionExpression";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
    expression?: boolean;
    body: BlockStatement | Expression;
}

export interface ClassBody extends NodeBase {
    type: "ClassBody";
    body: (ClassMethod | ClassProperty | TSDeclareMethod | TSIndexSignature)[];
}

export interface ClassDeclaration extends NodeBase {
    type: "ClassDeclaration";
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
    body: ClassBody;
    superClass?: Expression;
    superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
    implements?: (TSExpressionWithTypeArguments | ClassImplements)[];
    declare?: boolean;
    abstract?: boolean;
    id?: Identifier;
    decorators?: Decorator[];
    mixins?: any;
}

export interface ClassExpression extends NodeBase {
    type: "ClassExpression";
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
    body: ClassBody;
    superClass?: Expression;
    superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
    implements?: (TSExpressionWithTypeArguments | ClassImplements)[];
    id?: Identifier;
    decorators?: Decorator[];
    mixins?: any;
}

export interface ExportAllDeclaration extends NodeBase {
    type: "ExportAllDeclaration";
    source: StringLiteral;
}

export interface ExportDefaultDeclaration extends NodeBase {
    type: "ExportDefaultDeclaration";
    declaration: FunctionDeclaration | TSDeclareFunction | ClassDeclaration | Expression;
}

export interface ExportNamedDeclaration extends NodeBase {
    type: "ExportNamedDeclaration";
    declaration?: Declaration;
    specifiers: (ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier)[];
    source?: StringLiteral;
}

export interface ExportSpecifier extends NodeBase {
    type: "ExportSpecifier";
    local: Identifier;
    exported: Identifier;
}

export interface ForOfStatement extends NodeBase {
    type: "ForOfStatement";
    left: VariableDeclaration | LVal;
    right: Expression;
    body: Statement;
    await?: boolean;
}

export interface ImportDeclaration extends NodeBase {
    type: "ImportDeclaration";
    specifiers: (ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier)[];
    source: StringLiteral;
}

export interface ImportDefaultSpecifier extends NodeBase {
    type: "ImportDefaultSpecifier";
    local: Identifier;
}

export interface ImportNamespaceSpecifier extends NodeBase {
    type: "ImportNamespaceSpecifier";
    local: Identifier;
}

export interface ImportSpecifier extends NodeBase {
    type: "ImportSpecifier";
    local: Identifier;
    imported: Identifier;
    importKind?: null | "type" | "typeof";
}

export interface MetaProperty extends NodeBase {
    type: "MetaProperty";
    meta: Identifier;
    property: Identifier;
}

export interface ClassMethod extends NodeBase {
    type: "ClassMethod";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    abstract?: boolean;
    accessibility?: "public" | "private" | "protected";
    static?: boolean;
    computed?: boolean;
    optional?: boolean;
    key: Identifier | StringLiteral | NumericLiteral | Expression;
    kind?: "get" | "set" | "method" | "constructor";
    access?: "public" | "private" | "protected";
    decorators?: Decorator[];
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
    typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
    body: BlockStatement;
}

export interface ObjectPattern extends NodeBase {
    type: "ObjectPattern";
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    properties: (RestElement | ObjectProperty)[];
}

export interface SpreadElement extends NodeBase {
    type: "SpreadElement";
    argument: Expression;
}

export interface Super extends NodeBase {
    type: "Super";
}

export interface TaggedTemplateExpression extends NodeBase {
    type: "TaggedTemplateExpression";
    tag: Expression;
    quasi: TemplateLiteral;
}

export interface TemplateElement extends NodeBase {
    type: "TemplateElement";
    value: any;
    tail: boolean;
}

export interface TemplateLiteral extends NodeBase {
    type: "TemplateLiteral";
    quasis: TemplateElement[];
    expressions: Expression[];
}

export interface YieldExpression extends NodeBase {
    type: "YieldExpression";
    delegate: boolean;
    argument?: Expression;
}

export interface AnyTypeAnnotation extends NodeBase {
    type: "AnyTypeAnnotation";
}

export interface ArrayTypeAnnotation extends NodeBase {
    type: "ArrayTypeAnnotation";
    elementType: FlowType;
}

export interface BooleanTypeAnnotation extends NodeBase {
    type: "BooleanTypeAnnotation";
}

export interface BooleanLiteralTypeAnnotation extends NodeBase {
    type: "BooleanLiteralTypeAnnotation";
    value?: boolean;
}

export interface NullLiteralTypeAnnotation extends NodeBase {
    type: "NullLiteralTypeAnnotation";
}

export interface ClassImplements extends NodeBase {
    type: "ClassImplements";
    id: Identifier;
    typeParameters?: TypeParameterInstantiation;
}

export interface DeclareClass extends NodeBase {
    type: "DeclareClass";
    id: Identifier;
    typeParameters?: TypeParameterInstantiation;
    extends?: InterfaceExtends[];
    mixins?: InterfaceExtends[];
    body: ObjectTypeAnnotation;
}

export interface DeclareFunction extends NodeBase {
    type: "DeclareFunction";
    id: Identifier;
    predicate?: DeclaredPredicate;
}

export interface DeclareInterface extends NodeBase {
    type: "DeclareInterface";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    extends?: InterfaceExtends;
    mixins?: Flow[];
    body: ObjectTypeAnnotation;
}

export interface DeclareModule extends NodeBase {
    type: "DeclareModule";
    id: Identifier | StringLiteral;
    body: BlockStatement;
    kind?: "CommonJS" | "ES";
}

export interface DeclareModuleExports extends NodeBase {
    type: "DeclareModuleExports";
    typeAnnotation: TypeAnnotation;
}

export interface DeclareTypeAlias extends NodeBase {
    type: "DeclareTypeAlias";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    right: FlowType;
}

export interface DeclareOpaqueType extends NodeBase {
    type: "DeclareOpaqueType";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    supertype?: FlowType;
}

export interface DeclareVariable extends NodeBase {
    type: "DeclareVariable";
    id: Identifier;
}

export interface DeclareExportDeclaration extends NodeBase {
    type: "DeclareExportDeclaration";
    declaration?: Flow;
    specifiers?: (ExportSpecifier | ExportNamespaceSpecifier)[];
    source?: StringLiteral;
    default?: boolean;
}

export interface DeclareExportAllDeclaration extends NodeBase {
    type: "DeclareExportAllDeclaration";
    source: StringLiteral;
    exportKind?: ["type","value"];
}

export interface DeclaredPredicate extends NodeBase {
    type: "DeclaredPredicate";
    value: Flow;
}

export interface ExistsTypeAnnotation extends NodeBase {
    type: "ExistsTypeAnnotation";
}

export interface FunctionTypeAnnotation extends NodeBase {
    type: "FunctionTypeAnnotation";
    typeParameters?: TypeParameterDeclaration;
    params: FunctionTypeParam[];
    rest?: FunctionTypeParam;
    returnType: FlowType;
}

export interface FunctionTypeParam extends NodeBase {
    type: "FunctionTypeParam";
    name?: Identifier;
    typeAnnotation: FlowType;
    optional?: boolean;
}

export interface GenericTypeAnnotation extends NodeBase {
    type: "GenericTypeAnnotation";
    id: Identifier;
    typeParameters?: TypeParameterInstantiation;
}

export interface InferredPredicate extends NodeBase {
    type: "InferredPredicate";
}

export interface InterfaceExtends extends NodeBase {
    type: "InterfaceExtends";
    id: Identifier;
    typeParameters?: TypeParameterInstantiation;
}

export interface InterfaceDeclaration extends NodeBase {
    type: "InterfaceDeclaration";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    extends: InterfaceExtends[];
    mixins?: InterfaceExtends[];
    body: ObjectTypeAnnotation;
}

export interface IntersectionTypeAnnotation extends NodeBase {
    type: "IntersectionTypeAnnotation";
    types: FlowType[];
}

export interface MixedTypeAnnotation extends NodeBase {
    type: "MixedTypeAnnotation";
}

export interface EmptyTypeAnnotation extends NodeBase {
    type: "EmptyTypeAnnotation";
}

export interface NullableTypeAnnotation extends NodeBase {
    type: "NullableTypeAnnotation";
    typeAnnotation: FlowType;
}

export interface NumberLiteralTypeAnnotation extends NodeBase {
    type: "NumberLiteralTypeAnnotation";
    value?: number;
}

export interface NumberTypeAnnotation extends NodeBase {
    type: "NumberTypeAnnotation";
}

export interface ObjectTypeAnnotation extends NodeBase {
    type: "ObjectTypeAnnotation";
    properties: (ObjectTypeProperty | ObjectTypeSpreadProperty)[];
    indexers?: ObjectTypeIndexer[];
    callProperties?: ObjectTypeCallProperty[];
    exact?: boolean;
}

export interface ObjectTypeCallProperty extends NodeBase {
    type: "ObjectTypeCallProperty";
    value: FlowType;
    static?: boolean;
}

export interface ObjectTypeIndexer extends NodeBase {
    type: "ObjectTypeIndexer";
    id?: Identifier;
    key: FlowType;
    value: FlowType;
    static?: boolean;
    variance?: Variance;
}

export interface ObjectTypeProperty extends NodeBase {
    type: "ObjectTypeProperty";
    key: Identifier;
    value: FlowType;
    kind?: "init" | "get" | "set";
    static?: boolean;
    optional?: boolean;
    variance?: Variance;
}

export interface ObjectTypeSpreadProperty extends NodeBase {
    type: "ObjectTypeSpreadProperty";
    argument: FlowType;
}

export interface OpaqueType extends NodeBase {
    type: "OpaqueType";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    supertype?: FlowType;
    impltype: FlowType;
}

export interface QualifiedTypeIdentifier extends NodeBase {
    type: "QualifiedTypeIdentifier";
    id: Identifier;
    qualification: Identifier | QualifiedTypeIdentifier;
}

export interface StringLiteralTypeAnnotation extends NodeBase {
    type: "StringLiteralTypeAnnotation";
    value?: string;
}

export interface StringTypeAnnotation extends NodeBase {
    type: "StringTypeAnnotation";
}

export interface ThisTypeAnnotation extends NodeBase {
    type: "ThisTypeAnnotation";
}

export interface TupleTypeAnnotation extends NodeBase {
    type: "TupleTypeAnnotation";
    types: FlowType[];
}

export interface TypeofTypeAnnotation extends NodeBase {
    type: "TypeofTypeAnnotation";
    argument: FlowType;
}

export interface TypeAlias extends NodeBase {
    type: "TypeAlias";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    right: FlowType;
}

export interface TypeAnnotation extends NodeBase {
    type: "TypeAnnotation";
    typeAnnotation: FlowType;
}

export interface TypeCastExpression extends NodeBase {
    type: "TypeCastExpression";
    expression: Expression;
    typeAnnotation: TypeAnnotation;
}

export interface TypeParameter extends NodeBase {
    type: "TypeParameter";
    name?: string;
    bound?: TypeAnnotation;
    default?: FlowType;
    variance?: Variance;
}

export interface TypeParameterDeclaration extends NodeBase {
    type: "TypeParameterDeclaration";
    params: TypeParameter[];
}

export interface TypeParameterInstantiation extends NodeBase {
    type: "TypeParameterInstantiation";
    params: FlowType[];
}

export interface UnionTypeAnnotation extends NodeBase {
    type: "UnionTypeAnnotation";
    types: FlowType[];
}

export interface Variance extends NodeBase {
    type: "Variance";
    kind: "minus" | "plus";
}

export interface VoidTypeAnnotation extends NodeBase {
    type: "VoidTypeAnnotation";
}

export interface JSXAttribute extends NodeBase {
    type: "JSXAttribute";
    name: JSXIdentifier | JSXNamespacedName;
    value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer;
}

export interface JSXClosingElement extends NodeBase {
    type: "JSXClosingElement";
    name: JSXIdentifier | JSXMemberExpression;
}

export interface JSXElement extends NodeBase {
    type: "JSXElement";
    openingElement: JSXOpeningElement;
    closingElement?: JSXClosingElement;
    children: (JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment)[];
    selfClosing: any;
}

export interface JSXEmptyExpression extends NodeBase {
    type: "JSXEmptyExpression";
}

export interface JSXExpressionContainer extends NodeBase {
    type: "JSXExpressionContainer";
    expression: Expression;
}

export interface JSXSpreadChild extends NodeBase {
    type: "JSXSpreadChild";
    expression: Expression;
}

export interface JSXIdentifier extends NodeBase {
    type: "JSXIdentifier";
    name: string;
}

export interface JSXMemberExpression extends NodeBase {
    type: "JSXMemberExpression";
    object: JSXMemberExpression | JSXIdentifier;
    property: JSXIdentifier;
}

export interface JSXNamespacedName extends NodeBase {
    type: "JSXNamespacedName";
    namespace: JSXIdentifier;
    name: JSXIdentifier;
}

export interface JSXOpeningElement extends NodeBase {
    type: "JSXOpeningElement";
    name: JSXIdentifier | JSXMemberExpression;
    selfClosing: boolean;
    attributes: (JSXAttribute | JSXSpreadAttribute)[];
}

export interface JSXSpreadAttribute extends NodeBase {
    type: "JSXSpreadAttribute";
    argument: Expression;
}

export interface JSXText extends NodeBase {
    type: "JSXText";
    value: string;
}

export interface JSXFragment extends NodeBase {
    type: "JSXFragment";
    openingFragment: JSXOpeningFragment;
    closingFragment: JSXClosingFragment;
    children: (JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment)[];
}

export interface JSXOpeningFragment extends NodeBase {
    type: "JSXOpeningFragment";
}

export interface JSXClosingFragment extends NodeBase {
    type: "JSXClosingFragment";
}

export interface Noop extends NodeBase {
    type: "Noop";
}

export interface ParenthesizedExpression extends NodeBase {
    type: "ParenthesizedExpression";
    expression: Expression;
}

export interface AwaitExpression extends NodeBase {
    type: "AwaitExpression";
    argument: Expression;
}

export interface BindExpression extends NodeBase {
    type: "BindExpression";
    object: any;
    callee: any;
}

export interface ClassProperty extends NodeBase {
    type: "ClassProperty";
    abstract?: boolean;
    accessibility?: "public" | "private" | "protected";
    static?: boolean;
    computed?: boolean;
    optional?: boolean;
    key: Identifier | StringLiteral | NumericLiteral | Expression;
    value?: Expression;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    readonly?: boolean;
}

export interface OptionalMemberExpression extends NodeBase {
    type: "OptionalMemberExpression";
    object: Expression;
    property: any;
    computed: boolean;
    optional: boolean;
}

export interface OptionalCallExpression extends NodeBase {
    type: "OptionalCallExpression";
    callee: Expression;
    arguments: (Expression | SpreadElement | JSXNamespacedName)[];
    optional: boolean;
    typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
}

export interface Import extends NodeBase {
    type: "Import";
}

export interface Decorator extends NodeBase {
    type: "Decorator";
    expression: Expression;
}

export interface DoExpression extends NodeBase {
    type: "DoExpression";
    body: BlockStatement;
}

export interface ExportDefaultSpecifier extends NodeBase {
    type: "ExportDefaultSpecifier";
    exported: Identifier;
}

export interface ExportNamespaceSpecifier extends NodeBase {
    type: "ExportNamespaceSpecifier";
    exported: Identifier;
}

export interface TSParameterProperty extends NodeBase {
    type: "TSParameterProperty";
    accessibility?: "public" | "private" | "protected";
    readonly?: boolean;
    parameter: Identifier | AssignmentPattern;
}

export interface TSDeclareFunction extends NodeBase {
    type: "TSDeclareFunction";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    declare?: boolean;
    id?: Identifier;
    returnType?: TSTypeAnnotation | Noop;
    typeParameters?: TSTypeParameterDeclaration | Noop;
}

export interface TSDeclareMethod extends NodeBase {
    type: "TSDeclareMethod";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    abstract?: boolean;
    accessibility?: "public" | "private" | "protected";
    static?: boolean;
    computed?: boolean;
    optional?: boolean;
    key: Identifier | StringLiteral | NumericLiteral | Expression;
    kind?: "get" | "set" | "method" | "constructor";
    access?: "public" | "private" | "protected";
    decorators?: Decorator[];
    returnType?: TSTypeAnnotation | Noop;
    typeParameters?: TSTypeParameterDeclaration | Noop;
}

export interface TSQualifiedName extends NodeBase {
    type: "TSQualifiedName";
    left: TSEntityName;
    right: Identifier;
}

export interface TSCallSignatureDeclaration extends NodeBase {
    type: "TSCallSignatureDeclaration";
    typeParameters?: TSTypeParameterDeclaration;
    parameters?: (Identifier | RestElement)[];
    typeAnnotation?: TSTypeAnnotation;
}

export interface TSConstructSignatureDeclaration extends NodeBase {
    type: "TSConstructSignatureDeclaration";
    typeParameters?: TSTypeParameterDeclaration;
    parameters?: (Identifier | RestElement)[];
    typeAnnotation?: TSTypeAnnotation;
}

export interface TSPropertySignature extends NodeBase {
    type: "TSPropertySignature";
    key: Expression;
    computed?: boolean;
    optional?: boolean;
    readonly?: boolean;
    typeAnnotation?: TSTypeAnnotation;
    initializer?: Expression;
}

export interface TSMethodSignature extends NodeBase {
    type: "TSMethodSignature";
    typeParameters?: TSTypeParameterDeclaration;
    parameters?: (Identifier | RestElement)[];
    typeAnnotation?: TSTypeAnnotation;
    key: Expression;
    computed?: boolean;
    optional?: boolean;
}

export interface TSIndexSignature extends NodeBase {
    type: "TSIndexSignature";
    readonly?: boolean;
    parameters: Identifier[];
    typeAnnotation?: TSTypeAnnotation;
}

export interface TSAnyKeyword extends NodeBase {
    type: "TSAnyKeyword";
}

export interface TSNumberKeyword extends NodeBase {
    type: "TSNumberKeyword";
}

export interface TSObjectKeyword extends NodeBase {
    type: "TSObjectKeyword";
}

export interface TSBooleanKeyword extends NodeBase {
    type: "TSBooleanKeyword";
}

export interface TSStringKeyword extends NodeBase {
    type: "TSStringKeyword";
}

export interface TSSymbolKeyword extends NodeBase {
    type: "TSSymbolKeyword";
}

export interface TSVoidKeyword extends NodeBase {
    type: "TSVoidKeyword";
}

export interface TSUndefinedKeyword extends NodeBase {
    type: "TSUndefinedKeyword";
}

export interface TSNullKeyword extends NodeBase {
    type: "TSNullKeyword";
}

export interface TSNeverKeyword extends NodeBase {
    type: "TSNeverKeyword";
}

export interface TSThisType extends NodeBase {
    type: "TSThisType";
}

export interface TSFunctionType extends NodeBase {
    type: "TSFunctionType";
    typeParameters?: TSTypeParameterDeclaration;
    parameters?: (Identifier | RestElement)[];
    typeAnnotation?: TSTypeAnnotation;
}

export interface TSConstructorType extends NodeBase {
    type: "TSConstructorType";
    typeParameters?: TSTypeParameterDeclaration;
    parameters?: (Identifier | RestElement)[];
    typeAnnotation?: TSTypeAnnotation;
}

export interface TSTypeReference extends NodeBase {
    type: "TSTypeReference";
    typeName: TSEntityName;
    typeParameters?: TSTypeParameterInstantiation;
}

export interface TSTypePredicate extends NodeBase {
    type: "TSTypePredicate";
    parameterName: Identifier | TSThisType;
    typeAnnotation: TSTypeAnnotation;
}

export interface TSTypeQuery extends NodeBase {
    type: "TSTypeQuery";
    exprName: TSEntityName;
}

export interface TSTypeLiteral extends NodeBase {
    type: "TSTypeLiteral";
    members: TSTypeElement[];
}

export interface TSArrayType extends NodeBase {
    type: "TSArrayType";
    elementType: TSType;
}

export interface TSTupleType extends NodeBase {
    type: "TSTupleType";
    elementTypes: TSType[];
}

export interface TSUnionType extends NodeBase {
    type: "TSUnionType";
    types: TSType[];
}

export interface TSIntersectionType extends NodeBase {
    type: "TSIntersectionType";
    types: TSType[];
}

export interface TSParenthesizedType extends NodeBase {
    type: "TSParenthesizedType";
    typeAnnotation: TSType;
}

export interface TSTypeOperator extends NodeBase {
    type: "TSTypeOperator";
    operator?: string;
    typeAnnotation: TSType;
}

export interface TSIndexedAccessType extends NodeBase {
    type: "TSIndexedAccessType";
    objectType: TSType;
    indexType: TSType;
}

export interface TSMappedType extends NodeBase {
    type: "TSMappedType";
    readonly?: boolean;
    typeParameter: TSTypeParameter;
    optional?: boolean;
    typeAnnotation?: TSType;
}

export interface TSLiteralType extends NodeBase {
    type: "TSLiteralType";
    literal: NumericLiteral | StringLiteral | BooleanLiteral;
}

export interface TSExpressionWithTypeArguments extends NodeBase {
    type: "TSExpressionWithTypeArguments";
    expression: TSEntityName;
    typeParameters?: TSTypeParameterInstantiation;
}

export interface TSInterfaceDeclaration extends NodeBase {
    type: "TSInterfaceDeclaration";
    declare?: boolean;
    id: Identifier;
    typeParameters?: TSTypeParameterDeclaration;
    extends?: TSExpressionWithTypeArguments[];
    body: TSInterfaceBody;
}

export interface TSInterfaceBody extends NodeBase {
    type: "TSInterfaceBody";
    body: TSTypeElement[];
}

export interface TSTypeAliasDeclaration extends NodeBase {
    type: "TSTypeAliasDeclaration";
    declare?: boolean;
    id: Identifier;
    typeParameters?: TSTypeParameterDeclaration;
    typeAnnotation: TSType;
}

export interface TSAsExpression extends NodeBase {
    type: "TSAsExpression";
    expression: Expression;
    typeAnnotation: TSType;
}

export interface TSTypeAssertion extends NodeBase {
    type: "TSTypeAssertion";
    typeAnnotation: TSType;
    expression: Expression;
}

export interface TSEnumDeclaration extends NodeBase {
    type: "TSEnumDeclaration";
    declare?: boolean;
    const?: boolean;
    id: Identifier;
    members: TSEnumMember[];
    initializer?: Expression;
}

export interface TSEnumMember extends NodeBase {
    type: "TSEnumMember";
    id: Identifier | StringLiteral;
    initializer?: Expression;
}

export interface TSModuleDeclaration extends NodeBase {
    type: "TSModuleDeclaration";
    declare?: boolean;
    global?: boolean;
    id: Identifier | StringLiteral;
    body: TSModuleBlock | TSModuleDeclaration;
}

export interface TSModuleBlock extends NodeBase {
    type: "TSModuleBlock";
    body: Statement[];
}

export interface TSImportEqualsDeclaration extends NodeBase {
    type: "TSImportEqualsDeclaration";
    isExport?: boolean;
    id: Identifier;
    moduleReference: TSEntityName | TSExternalModuleReference;
}

export interface TSExternalModuleReference extends NodeBase {
    type: "TSExternalModuleReference";
    expression: StringLiteral;
}

export interface TSNonNullExpression extends NodeBase {
    type: "TSNonNullExpression";
    expression: Expression;
}

export interface TSExportAssignment extends NodeBase {
    type: "TSExportAssignment";
    expression: Expression;
}

export interface TSNamespaceExportDeclaration extends NodeBase {
    type: "TSNamespaceExportDeclaration";
    id: Identifier;
}

export interface TSTypeAnnotation extends NodeBase {
    type: "TSTypeAnnotation";
    typeAnnotation: TSType;
}

export interface TSTypeParameterInstantiation extends NodeBase {
    type: "TSTypeParameterInstantiation";
    params: TSType[];
}

export interface TSTypeParameterDeclaration extends NodeBase {
    type: "TSTypeParameterDeclaration";
    params: TSTypeParameter[];
}

export interface TSTypeParameter extends NodeBase {
    type: "TSTypeParameter";
    name?: string;
    constraint?: TSType;
    default?: TSType;
}

export type Expression =
    | ArrayExpression
    | AssignmentExpression
    | BinaryExpression
    | CallExpression
    | ConditionalExpression
    | FunctionExpression
    | Identifier
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | LogicalExpression
    | MemberExpression
    | NewExpression
    | ObjectExpression
    | SequenceExpression
    | ThisExpression
    | UnaryExpression
    | UpdateExpression
    | ArrowFunctionExpression
    | ClassExpression
    | MetaProperty
    | Super
    | TaggedTemplateExpression
    | TemplateLiteral
    | YieldExpression
    | TypeCastExpression
    | JSXElement
    | JSXFragment
    | ParenthesizedExpression
    | AwaitExpression
    | BindExpression
    | OptionalMemberExpression
    | OptionalCallExpression
    | Import
    | DoExpression
    | TSAsExpression
    | TSTypeAssertion
    | TSNonNullExpression;

export type Binary =
    | BinaryExpression
    | LogicalExpression;

export type Scopable =
    | BlockStatement
    | CatchClause
    | DoWhileStatement
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | Program
    | ObjectMethod
    | SwitchStatement
    | WhileStatement
    | ArrowFunctionExpression
    | ClassDeclaration
    | ClassExpression
    | ForOfStatement
    | ClassMethod;

export type BlockParent =
    | BlockStatement
    | CatchClause
    | DoWhileStatement
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | Program
    | ObjectMethod
    | SwitchStatement
    | WhileStatement
    | ArrowFunctionExpression
    | ForOfStatement
    | ClassMethod;

export type Block =
    | BlockStatement
    | Program;

export type Statement =
    | BlockStatement
    | BreakStatement
    | ContinueStatement
    | DebuggerStatement
    | DoWhileStatement
    | EmptyStatement
    | ExpressionStatement
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | IfStatement
    | LabeledStatement
    | ReturnStatement
    | SwitchStatement
    | ThrowStatement
    | TryStatement
    | VariableDeclaration
    | WhileStatement
    | WithStatement
    | ClassDeclaration
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ForOfStatement
    | ImportDeclaration
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | InterfaceDeclaration
    | OpaqueType
    | TypeAlias
    | TSDeclareFunction
    | TSInterfaceDeclaration
    | TSTypeAliasDeclaration
    | TSEnumDeclaration
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExportAssignment
    | TSNamespaceExportDeclaration;

export type Terminatorless =
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | ThrowStatement
    | YieldExpression
    | AwaitExpression;

export type CompletionStatement =
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | ThrowStatement;

export type Conditional =
    | ConditionalExpression
    | IfStatement;

export type Loop =
    | DoWhileStatement
    | ForInStatement
    | ForStatement
    | WhileStatement
    | ForOfStatement;

export type While =
    | DoWhileStatement
    | WhileStatement;

export type ExpressionWrapper =
    | ExpressionStatement
    | TypeCastExpression
    | ParenthesizedExpression;

export type For =
    | ForInStatement
    | ForStatement
    | ForOfStatement;

export type ForXStatement =
    | ForInStatement
    | ForOfStatement;

export type Function =
    | FunctionDeclaration
    | FunctionExpression
    | ObjectMethod
    | ArrowFunctionExpression
    | ClassMethod;

export type FunctionParent =
    | FunctionDeclaration
    | FunctionExpression
    | ObjectMethod
    | ArrowFunctionExpression
    | ClassMethod;

export type Pureish =
    | FunctionDeclaration
    | FunctionExpression
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | ArrowFunctionExpression
    | ClassDeclaration
    | ClassExpression;

export type Declaration =
    | FunctionDeclaration
    | VariableDeclaration
    | ClassDeclaration
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ImportDeclaration
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | InterfaceDeclaration
    | OpaqueType
    | TypeAlias
    | TSDeclareFunction
    | TSInterfaceDeclaration
    | TSTypeAliasDeclaration
    | TSEnumDeclaration
    | TSModuleDeclaration;

export type PatternLike =
    | Identifier
    | RestElement
    | AssignmentPattern
    | ArrayPattern
    | ObjectPattern;

export type LVal =
    | Identifier
    | MemberExpression
    | RestElement
    | AssignmentPattern
    | ArrayPattern
    | ObjectPattern
    | TSParameterProperty;

export type TSEntityName =
    | Identifier
    | TSQualifiedName;

export type Literal =
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | TemplateLiteral;

export type Immutable =
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | JSXAttribute
    | JSXClosingElement
    | JSXElement
    | JSXExpressionContainer
    | JSXSpreadChild
    | JSXOpeningElement
    | JSXText
    | JSXFragment
    | JSXOpeningFragment
    | JSXClosingFragment;

export type UserWhitespacable =
    | ObjectMethod
    | ObjectProperty
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty;

export type Method =
    | ObjectMethod
    | ClassMethod;

export type ObjectMember =
    | ObjectMethod
    | ObjectProperty;

export type Property =
    | ObjectProperty
    | ClassProperty;

export type UnaryLike =
    | UnaryExpression
    | SpreadElement;

export type Pattern =
    | AssignmentPattern
    | ArrayPattern
    | ObjectPattern;

export type Class =
    | ClassDeclaration
    | ClassExpression;

export type ModuleDeclaration =
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ImportDeclaration;

export type ExportDeclaration =
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration;

export type ModuleSpecifier =
    | ExportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportSpecifier
    | ExportDefaultSpecifier
    | ExportNamespaceSpecifier;

export type Flow =
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullLiteralTypeAnnotation
    | ClassImplements
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | DeclaredPredicate
    | ExistsTypeAnnotation
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | GenericTypeAnnotation
    | InferredPredicate
    | InterfaceExtends
    | InterfaceDeclaration
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NullableTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | ObjectTypeAnnotation
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | OpaqueType
    | QualifiedTypeIdentifier
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | ThisTypeAnnotation
    | TupleTypeAnnotation
    | TypeofTypeAnnotation
    | TypeAlias
    | TypeAnnotation
    | TypeCastExpression
    | TypeParameter
    | TypeParameterDeclaration
    | TypeParameterInstantiation
    | UnionTypeAnnotation
    | Variance
    | VoidTypeAnnotation;

export type FlowType =
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullLiteralTypeAnnotation
    | ExistsTypeAnnotation
    | FunctionTypeAnnotation
    | GenericTypeAnnotation
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NullableTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | ObjectTypeAnnotation
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | ThisTypeAnnotation
    | TupleTypeAnnotation
    | TypeofTypeAnnotation
    | UnionTypeAnnotation
    | VoidTypeAnnotation;

export type FlowBaseAnnotation =
    | AnyTypeAnnotation
    | BooleanTypeAnnotation
    | NullLiteralTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NumberTypeAnnotation
    | StringTypeAnnotation
    | ThisTypeAnnotation
    | VoidTypeAnnotation;

export type FlowDeclaration =
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | InterfaceDeclaration
    | OpaqueType
    | TypeAlias;

export type FlowPredicate =
    | DeclaredPredicate
    | InferredPredicate;

export type JSX =
    | JSXAttribute
    | JSXClosingElement
    | JSXElement
    | JSXEmptyExpression
    | JSXExpressionContainer
    | JSXSpreadChild
    | JSXIdentifier
    | JSXMemberExpression
    | JSXNamespacedName
    | JSXOpeningElement
    | JSXSpreadAttribute
    | JSXText
    | JSXFragment
    | JSXOpeningFragment
    | JSXClosingFragment;

export type TSTypeElement =
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSPropertySignature
    | TSMethodSignature
    | TSIndexSignature;

export type TSType =
    | TSAnyKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSBooleanKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSVoidKeyword
    | TSUndefinedKeyword
    | TSNullKeyword
    | TSNeverKeyword
    | TSThisType
    | TSFunctionType
    | TSConstructorType
    | TSTypeReference
    | TSTypePredicate
    | TSTypeQuery
    | TSTypeLiteral
    | TSArrayType
    | TSTupleType
    | TSUnionType
    | TSIntersectionType
    | TSParenthesizedType
    | TSTypeOperator
    | TSIndexedAccessType
    | TSMappedType
    | TSLiteralType
    | TSExpressionWithTypeArguments;

export declare function anyTypeAnnotation(): AnyTypeAnnotation;
export declare function arrayExpression(elements: ArrayExpression['elements']): ArrayExpression;
export declare function arrayPattern(elements: ArrayPattern['elements']): ArrayPattern;
export declare function arrayTypeAnnotation(elementType: ArrayTypeAnnotation['elementType']): ArrayTypeAnnotation;
export declare function arrowFunctionExpression(params: ArrowFunctionExpression['params'], body: ArrowFunctionExpression['body'], async: ArrowFunctionExpression['async']): ArrowFunctionExpression;
export declare function assignmentExpression(operator: AssignmentExpression['operator'], left: AssignmentExpression['left'], right: AssignmentExpression['right']): AssignmentExpression;
export declare function assignmentPattern(left: AssignmentPattern['left'], right: AssignmentPattern['right']): AssignmentPattern;
export declare function awaitExpression(argument: AwaitExpression['argument']): AwaitExpression;
export declare function binaryExpression(operator: BinaryExpression['operator'], left: BinaryExpression['left'], right: BinaryExpression['right']): BinaryExpression;
export declare function bindExpression(object: BindExpression['object'], callee: BindExpression['callee']): BindExpression;
export declare function blockStatement(body: BlockStatement['body'], directives: BlockStatement['directives']): BlockStatement;
export declare function booleanLiteral(value: BooleanLiteral['value']): BooleanLiteral;
export declare function booleanLiteralTypeAnnotation(): BooleanLiteralTypeAnnotation;
export declare function booleanTypeAnnotation(): BooleanTypeAnnotation;
export declare function breakStatement(label: BreakStatement['label']): BreakStatement;
export declare function callExpression(callee: CallExpression['callee'], arguments: CallExpression['arguments']): CallExpression;
export declare function catchClause(param: CatchClause['param'], body: CatchClause['body']): CatchClause;
export declare function classBody(body: ClassBody['body']): ClassBody;
export declare function classDeclaration(id: ClassDeclaration['id'], superClass: ClassDeclaration['superClass'], body: ClassDeclaration['body'], decorators: ClassDeclaration['decorators']): ClassDeclaration;
export declare function classExpression(id: ClassExpression['id'], superClass: ClassExpression['superClass'], body: ClassExpression['body'], decorators: ClassExpression['decorators']): ClassExpression;
export declare function classImplements(id: ClassImplements['id'], typeParameters: ClassImplements['typeParameters']): ClassImplements;
export declare function classMethod(kind: ClassMethod['kind'], key: ClassMethod['key'], params: ClassMethod['params'], body: ClassMethod['body'], computed: ClassMethod['computed'], static: ClassMethod['static']): ClassMethod;
export declare function classProperty(key: ClassProperty['key'], value: ClassProperty['value'], typeAnnotation: ClassProperty['typeAnnotation'], decorators: ClassProperty['decorators'], computed: ClassProperty['computed']): ClassProperty;
export declare function conditionalExpression(test: ConditionalExpression['test'], consequent: ConditionalExpression['consequent'], alternate: ConditionalExpression['alternate']): ConditionalExpression;
export declare function continueStatement(label: ContinueStatement['label']): ContinueStatement;
export declare function debuggerStatement(): DebuggerStatement;
export declare function declareClass(id: DeclareClass['id'], typeParameters: DeclareClass['typeParameters'], _extends: DeclareClass['extends'], body: DeclareClass['body']): DeclareClass;
export declare function declareExportAllDeclaration(source: DeclareExportAllDeclaration['source']): DeclareExportAllDeclaration;
export declare function declareExportDeclaration(declaration: DeclareExportDeclaration['declaration'], specifiers: DeclareExportDeclaration['specifiers'], source: DeclareExportDeclaration['source']): DeclareExportDeclaration;
export declare function declareFunction(id: DeclareFunction['id']): DeclareFunction;
export declare function declareInterface(id: DeclareInterface['id'], typeParameters: DeclareInterface['typeParameters'], _extends: DeclareInterface['extends'], body: DeclareInterface['body']): DeclareInterface;
export declare function declareModule(id: DeclareModule['id'], body: DeclareModule['body'], kind: DeclareModule['kind']): DeclareModule;
export declare function declareModuleExports(typeAnnotation: DeclareModuleExports['typeAnnotation']): DeclareModuleExports;
export declare function declareOpaqueType(id: DeclareOpaqueType['id'], typeParameters: DeclareOpaqueType['typeParameters'], supertype: DeclareOpaqueType['supertype']): DeclareOpaqueType;
export declare function declareTypeAlias(id: DeclareTypeAlias['id'], typeParameters: DeclareTypeAlias['typeParameters'], right: DeclareTypeAlias['right']): DeclareTypeAlias;
export declare function declareVariable(id: DeclareVariable['id']): DeclareVariable;
export declare function declaredPredicate(value: DeclaredPredicate['value']): DeclaredPredicate;
export declare function decorator(expression: Decorator['expression']): Decorator;
export declare function directive(value: Directive['value']): Directive;
export declare function directiveLiteral(value: DirectiveLiteral['value']): DirectiveLiteral;
export declare function doExpression(body: DoExpression['body']): DoExpression;
export declare function doWhileStatement(test: DoWhileStatement['test'], body: DoWhileStatement['body']): DoWhileStatement;
export declare function emptyStatement(): EmptyStatement;
export declare function emptyTypeAnnotation(): EmptyTypeAnnotation;
export declare function existsTypeAnnotation(): ExistsTypeAnnotation;
export declare function exportAllDeclaration(source: ExportAllDeclaration['source']): ExportAllDeclaration;
export declare function exportDefaultDeclaration(declaration: ExportDefaultDeclaration['declaration']): ExportDefaultDeclaration;
export declare function exportDefaultSpecifier(exported: ExportDefaultSpecifier['exported']): ExportDefaultSpecifier;
export declare function exportNamedDeclaration(declaration: ExportNamedDeclaration['declaration'], specifiers: ExportNamedDeclaration['specifiers'], source: ExportNamedDeclaration['source']): ExportNamedDeclaration;
export declare function exportNamespaceSpecifier(exported: ExportNamespaceSpecifier['exported']): ExportNamespaceSpecifier;
export declare function exportSpecifier(local: ExportSpecifier['local'], exported: ExportSpecifier['exported']): ExportSpecifier;
export declare function expressionStatement(expression: ExpressionStatement['expression']): ExpressionStatement;
export declare function file(program: File['program'], comments: File['comments'], tokens: File['tokens']): File;
export declare function forInStatement(left: ForInStatement['left'], right: ForInStatement['right'], body: ForInStatement['body']): ForInStatement;
export declare function forOfStatement(left: ForOfStatement['left'], right: ForOfStatement['right'], body: ForOfStatement['body']): ForOfStatement;
export declare function forStatement(init: ForStatement['init'], test: ForStatement['test'], update: ForStatement['update'], body: ForStatement['body']): ForStatement;
export declare function functionDeclaration(id: FunctionDeclaration['id'], params: FunctionDeclaration['params'], body: FunctionDeclaration['body'], generator: FunctionDeclaration['generator'], async: FunctionDeclaration['async']): FunctionDeclaration;
export declare function functionExpression(id: FunctionExpression['id'], params: FunctionExpression['params'], body: FunctionExpression['body'], generator: FunctionExpression['generator'], async: FunctionExpression['async']): FunctionExpression;
export declare function functionTypeAnnotation(typeParameters: FunctionTypeAnnotation['typeParameters'], params: FunctionTypeAnnotation['params'], rest: FunctionTypeAnnotation['rest'], returnType: FunctionTypeAnnotation['returnType']): FunctionTypeAnnotation;
export declare function functionTypeParam(name: FunctionTypeParam['name'], typeAnnotation: FunctionTypeParam['typeAnnotation']): FunctionTypeParam;
export declare function genericTypeAnnotation(id: GenericTypeAnnotation['id'], typeParameters: GenericTypeAnnotation['typeParameters']): GenericTypeAnnotation;
export declare function identifier(name: Identifier['name']): Identifier;
export declare function ifStatement(test: IfStatement['test'], consequent: IfStatement['consequent'], alternate: IfStatement['alternate']): IfStatement;
declare function _import(): Import;
export {_import as import};
export declare function importDeclaration(specifiers: ImportDeclaration['specifiers'], source: ImportDeclaration['source']): ImportDeclaration;
export declare function importDefaultSpecifier(local: ImportDefaultSpecifier['local']): ImportDefaultSpecifier;
export declare function importNamespaceSpecifier(local: ImportNamespaceSpecifier['local']): ImportNamespaceSpecifier;
export declare function importSpecifier(local: ImportSpecifier['local'], imported: ImportSpecifier['imported']): ImportSpecifier;
export declare function inferredPredicate(): InferredPredicate;
export declare function interfaceDeclaration(id: InterfaceDeclaration['id'], typeParameters: InterfaceDeclaration['typeParameters'], _extends: InterfaceDeclaration['extends'], body: InterfaceDeclaration['body']): InterfaceDeclaration;
export declare function interfaceExtends(id: InterfaceExtends['id'], typeParameters: InterfaceExtends['typeParameters']): InterfaceExtends;
export declare function intersectionTypeAnnotation(types: IntersectionTypeAnnotation['types']): IntersectionTypeAnnotation;
export declare function jSXAttribute(name: JSXAttribute['name'], value: JSXAttribute['value']): JSXAttribute;
export {jSXAttribute as jsxAttribute};
export declare function jSXClosingElement(name: JSXClosingElement['name']): JSXClosingElement;
export {jSXClosingElement as jsxClosingElement};
export declare function jSXClosingFragment(): JSXClosingFragment;
export {jSXClosingFragment as jsxClosingFragment};
export declare function jSXElement(openingElement: JSXElement['openingElement'], closingElement: JSXElement['closingElement'], children: JSXElement['children'], selfClosing: JSXElement['selfClosing']): JSXElement;
export {jSXElement as jsxElement};
export declare function jSXEmptyExpression(): JSXEmptyExpression;
export {jSXEmptyExpression as jsxEmptyExpression};
export declare function jSXExpressionContainer(expression: JSXExpressionContainer['expression']): JSXExpressionContainer;
export {jSXExpressionContainer as jsxExpressionContainer};
export declare function jSXFragment(openingFragment: JSXFragment['openingFragment'], closingFragment: JSXFragment['closingFragment'], children: JSXFragment['children']): JSXFragment;
export {jSXFragment as jsxFragment};
export declare function jSXIdentifier(name: JSXIdentifier['name']): JSXIdentifier;
export {jSXIdentifier as jsxIdentifier};
export declare function jSXMemberExpression(object: JSXMemberExpression['object'], property: JSXMemberExpression['property']): JSXMemberExpression;
export {jSXMemberExpression as jsxMemberExpression};
export declare function jSXNamespacedName(namespace: JSXNamespacedName['namespace'], name: JSXNamespacedName['name']): JSXNamespacedName;
export {jSXNamespacedName as jsxNamespacedName};
export declare function jSXOpeningElement(name: JSXOpeningElement['name'], attributes: JSXOpeningElement['attributes'], selfClosing: JSXOpeningElement['selfClosing']): JSXOpeningElement;
export {jSXOpeningElement as jsxOpeningElement};
export declare function jSXOpeningFragment(): JSXOpeningFragment;
export {jSXOpeningFragment as jsxOpeningFragment};
export declare function jSXSpreadAttribute(argument: JSXSpreadAttribute['argument']): JSXSpreadAttribute;
export {jSXSpreadAttribute as jsxSpreadAttribute};
export declare function jSXSpreadChild(expression: JSXSpreadChild['expression']): JSXSpreadChild;
export {jSXSpreadChild as jsxSpreadChild};
export declare function jSXText(value: JSXText['value']): JSXText;
export {jSXText as jsxText};
export declare function labeledStatement(label: LabeledStatement['label'], body: LabeledStatement['body']): LabeledStatement;
export declare function logicalExpression(operator: LogicalExpression['operator'], left: LogicalExpression['left'], right: LogicalExpression['right']): LogicalExpression;
export declare function memberExpression(object: MemberExpression['object'], property: MemberExpression['property'], computed: MemberExpression['computed'], optional: MemberExpression['optional']): MemberExpression;
export declare function metaProperty(meta: MetaProperty['meta'], property: MetaProperty['property']): MetaProperty;
export declare function mixedTypeAnnotation(): MixedTypeAnnotation;
export declare function newExpression(callee: NewExpression['callee'], arguments: NewExpression['arguments']): NewExpression;
export declare function noop(): Noop;
export declare function nullLiteral(): NullLiteral;
export declare function nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation;
export declare function nullableTypeAnnotation(typeAnnotation: NullableTypeAnnotation['typeAnnotation']): NullableTypeAnnotation;
export declare function numberLiteralTypeAnnotation(): NumberLiteralTypeAnnotation;
export declare function numberTypeAnnotation(): NumberTypeAnnotation;
export declare function numericLiteral(value: NumericLiteral['value']): NumericLiteral;
export declare function objectExpression(properties: ObjectExpression['properties']): ObjectExpression;
export declare function objectMethod(kind: ObjectMethod['kind'], key: ObjectMethod['key'], params: ObjectMethod['params'], body: ObjectMethod['body'], computed: ObjectMethod['computed']): ObjectMethod;
export declare function objectPattern(properties: ObjectPattern['properties']): ObjectPattern;
export declare function objectProperty(key: ObjectProperty['key'], value: ObjectProperty['value'], computed: ObjectProperty['computed'], shorthand: ObjectProperty['shorthand'], decorators: ObjectProperty['decorators']): ObjectProperty;
export declare function objectTypeAnnotation(properties: ObjectTypeAnnotation['properties'], indexers: ObjectTypeAnnotation['indexers'], callProperties: ObjectTypeAnnotation['callProperties']): ObjectTypeAnnotation;
export declare function objectTypeCallProperty(value: ObjectTypeCallProperty['value']): ObjectTypeCallProperty;
export declare function objectTypeIndexer(id: ObjectTypeIndexer['id'], key: ObjectTypeIndexer['key'], value: ObjectTypeIndexer['value'], variance: ObjectTypeIndexer['variance']): ObjectTypeIndexer;
export declare function objectTypeProperty(key: ObjectTypeProperty['key'], value: ObjectTypeProperty['value'], variance: ObjectTypeProperty['variance']): ObjectTypeProperty;
export declare function objectTypeSpreadProperty(argument: ObjectTypeSpreadProperty['argument']): ObjectTypeSpreadProperty;
export declare function opaqueType(id: OpaqueType['id'], typeParameters: OpaqueType['typeParameters'], supertype: OpaqueType['supertype'], impltype: OpaqueType['impltype']): OpaqueType;
export declare function optionalCallExpression(callee: OptionalCallExpression['callee'], arguments: OptionalCallExpression['arguments'], optional: OptionalCallExpression['optional']): OptionalCallExpression;
export declare function optionalMemberExpression(object: OptionalMemberExpression['object'], property: OptionalMemberExpression['property'], computed: OptionalMemberExpression['computed'], optional: OptionalMemberExpression['optional']): OptionalMemberExpression;
export declare function parenthesizedExpression(expression: ParenthesizedExpression['expression']): ParenthesizedExpression;
export declare function program(body: Program['body'], directives: Program['directives'], sourceType: Program['sourceType']): Program;
export declare function qualifiedTypeIdentifier(id: QualifiedTypeIdentifier['id'], qualification: QualifiedTypeIdentifier['qualification']): QualifiedTypeIdentifier;
export declare function regExpLiteral(pattern: RegExpLiteral['pattern'], flags: RegExpLiteral['flags']): RegExpLiteral;
export declare function restElement(argument: RestElement['argument']): RestElement;
export declare function returnStatement(argument: ReturnStatement['argument']): ReturnStatement;
export declare function sequenceExpression(expressions: SequenceExpression['expressions']): SequenceExpression;
export declare function spreadElement(argument: SpreadElement['argument']): SpreadElement;
export declare function stringLiteral(value: StringLiteral['value']): StringLiteral;
export declare function stringLiteralTypeAnnotation(): StringLiteralTypeAnnotation;
export declare function stringTypeAnnotation(): StringTypeAnnotation;
declare function _super(): Super;
export {_super as super};
export declare function switchCase(test: SwitchCase['test'], consequent: SwitchCase['consequent']): SwitchCase;
export declare function switchStatement(discriminant: SwitchStatement['discriminant'], cases: SwitchStatement['cases']): SwitchStatement;
export declare function tSAnyKeyword(): TSAnyKeyword;
export {tSAnyKeyword as tsAnyKeyword};
export declare function tSArrayType(elementType: TSArrayType['elementType']): TSArrayType;
export {tSArrayType as tsArrayType};
export declare function tSAsExpression(expression: TSAsExpression['expression'], typeAnnotation: TSAsExpression['typeAnnotation']): TSAsExpression;
export {tSAsExpression as tsAsExpression};
export declare function tSBooleanKeyword(): TSBooleanKeyword;
export {tSBooleanKeyword as tsBooleanKeyword};
export declare function tSCallSignatureDeclaration(typeParameters: TSCallSignatureDeclaration['typeParameters'], parameters: TSCallSignatureDeclaration['parameters'], typeAnnotation: TSCallSignatureDeclaration['typeAnnotation']): TSCallSignatureDeclaration;
export {tSCallSignatureDeclaration as tsCallSignatureDeclaration};
export declare function tSConstructSignatureDeclaration(typeParameters: TSConstructSignatureDeclaration['typeParameters'], parameters: TSConstructSignatureDeclaration['parameters'], typeAnnotation: TSConstructSignatureDeclaration['typeAnnotation']): TSConstructSignatureDeclaration;
export {tSConstructSignatureDeclaration as tsConstructSignatureDeclaration};
export declare function tSConstructorType(typeParameters: TSConstructorType['typeParameters'], typeAnnotation: TSConstructorType['typeAnnotation']): TSConstructorType;
export {tSConstructorType as tsConstructorType};
export declare function tSDeclareFunction(id: TSDeclareFunction['id'], typeParameters: TSDeclareFunction['typeParameters'], params: TSDeclareFunction['params'], returnType: TSDeclareFunction['returnType']): TSDeclareFunction;
export {tSDeclareFunction as tsDeclareFunction};
export declare function tSDeclareMethod(decorators: TSDeclareMethod['decorators'], key: TSDeclareMethod['key'], typeParameters: TSDeclareMethod['typeParameters'], params: TSDeclareMethod['params'], returnType: TSDeclareMethod['returnType']): TSDeclareMethod;
export {tSDeclareMethod as tsDeclareMethod};
export declare function tSEnumDeclaration(id: TSEnumDeclaration['id'], members: TSEnumDeclaration['members']): TSEnumDeclaration;
export {tSEnumDeclaration as tsEnumDeclaration};
export declare function tSEnumMember(id: TSEnumMember['id'], initializer: TSEnumMember['initializer']): TSEnumMember;
export {tSEnumMember as tsEnumMember};
export declare function tSExportAssignment(expression: TSExportAssignment['expression']): TSExportAssignment;
export {tSExportAssignment as tsExportAssignment};
export declare function tSExpressionWithTypeArguments(expression: TSExpressionWithTypeArguments['expression'], typeParameters: TSExpressionWithTypeArguments['typeParameters']): TSExpressionWithTypeArguments;
export {tSExpressionWithTypeArguments as tsExpressionWithTypeArguments};
export declare function tSExternalModuleReference(expression: TSExternalModuleReference['expression']): TSExternalModuleReference;
export {tSExternalModuleReference as tsExternalModuleReference};
export declare function tSFunctionType(typeParameters: TSFunctionType['typeParameters'], typeAnnotation: TSFunctionType['typeAnnotation']): TSFunctionType;
export {tSFunctionType as tsFunctionType};
export declare function tSImportEqualsDeclaration(id: TSImportEqualsDeclaration['id'], moduleReference: TSImportEqualsDeclaration['moduleReference']): TSImportEqualsDeclaration;
export {tSImportEqualsDeclaration as tsImportEqualsDeclaration};
export declare function tSIndexSignature(parameters: TSIndexSignature['parameters'], typeAnnotation: TSIndexSignature['typeAnnotation']): TSIndexSignature;
export {tSIndexSignature as tsIndexSignature};
export declare function tSIndexedAccessType(objectType: TSIndexedAccessType['objectType'], indexType: TSIndexedAccessType['indexType']): TSIndexedAccessType;
export {tSIndexedAccessType as tsIndexedAccessType};
export declare function tSInterfaceBody(body: TSInterfaceBody['body']): TSInterfaceBody;
export {tSInterfaceBody as tsInterfaceBody};
export declare function tSInterfaceDeclaration(id: TSInterfaceDeclaration['id'], typeParameters: TSInterfaceDeclaration['typeParameters'], _extends: TSInterfaceDeclaration['extends'], body: TSInterfaceDeclaration['body']): TSInterfaceDeclaration;
export {tSInterfaceDeclaration as tsInterfaceDeclaration};
export declare function tSIntersectionType(types: TSIntersectionType['types']): TSIntersectionType;
export {tSIntersectionType as tsIntersectionType};
export declare function tSLiteralType(literal: TSLiteralType['literal']): TSLiteralType;
export {tSLiteralType as tsLiteralType};
export declare function tSMappedType(typeParameter: TSMappedType['typeParameter'], typeAnnotation: TSMappedType['typeAnnotation']): TSMappedType;
export {tSMappedType as tsMappedType};
export declare function tSMethodSignature(key: TSMethodSignature['key'], typeParameters: TSMethodSignature['typeParameters'], parameters: TSMethodSignature['parameters'], typeAnnotation: TSMethodSignature['typeAnnotation']): TSMethodSignature;
export {tSMethodSignature as tsMethodSignature};
export declare function tSModuleBlock(body: TSModuleBlock['body']): TSModuleBlock;
export {tSModuleBlock as tsModuleBlock};
export declare function tSModuleDeclaration(id: TSModuleDeclaration['id'], body: TSModuleDeclaration['body']): TSModuleDeclaration;
export {tSModuleDeclaration as tsModuleDeclaration};
export declare function tSNamespaceExportDeclaration(id: TSNamespaceExportDeclaration['id']): TSNamespaceExportDeclaration;
export {tSNamespaceExportDeclaration as tsNamespaceExportDeclaration};
export declare function tSNeverKeyword(): TSNeverKeyword;
export {tSNeverKeyword as tsNeverKeyword};
export declare function tSNonNullExpression(expression: TSNonNullExpression['expression']): TSNonNullExpression;
export {tSNonNullExpression as tsNonNullExpression};
export declare function tSNullKeyword(): TSNullKeyword;
export {tSNullKeyword as tsNullKeyword};
export declare function tSNumberKeyword(): TSNumberKeyword;
export {tSNumberKeyword as tsNumberKeyword};
export declare function tSObjectKeyword(): TSObjectKeyword;
export {tSObjectKeyword as tsObjectKeyword};
export declare function tSParameterProperty(parameter: TSParameterProperty['parameter']): TSParameterProperty;
export {tSParameterProperty as tsParameterProperty};
export declare function tSParenthesizedType(typeAnnotation: TSParenthesizedType['typeAnnotation']): TSParenthesizedType;
export {tSParenthesizedType as tsParenthesizedType};
export declare function tSPropertySignature(key: TSPropertySignature['key'], typeAnnotation: TSPropertySignature['typeAnnotation'], initializer: TSPropertySignature['initializer']): TSPropertySignature;
export {tSPropertySignature as tsPropertySignature};
export declare function tSQualifiedName(left: TSQualifiedName['left'], right: TSQualifiedName['right']): TSQualifiedName;
export {tSQualifiedName as tsQualifiedName};
export declare function tSStringKeyword(): TSStringKeyword;
export {tSStringKeyword as tsStringKeyword};
export declare function tSSymbolKeyword(): TSSymbolKeyword;
export {tSSymbolKeyword as tsSymbolKeyword};
export declare function tSThisType(): TSThisType;
export {tSThisType as tsThisType};
export declare function tSTupleType(elementTypes: TSTupleType['elementTypes']): TSTupleType;
export {tSTupleType as tsTupleType};
export declare function tSTypeAliasDeclaration(id: TSTypeAliasDeclaration['id'], typeParameters: TSTypeAliasDeclaration['typeParameters'], typeAnnotation: TSTypeAliasDeclaration['typeAnnotation']): TSTypeAliasDeclaration;
export {tSTypeAliasDeclaration as tsTypeAliasDeclaration};
export declare function tSTypeAnnotation(typeAnnotation: TSTypeAnnotation['typeAnnotation']): TSTypeAnnotation;
export {tSTypeAnnotation as tsTypeAnnotation};
export declare function tSTypeAssertion(typeAnnotation: TSTypeAssertion['typeAnnotation'], expression: TSTypeAssertion['expression']): TSTypeAssertion;
export {tSTypeAssertion as tsTypeAssertion};
export declare function tSTypeLiteral(members: TSTypeLiteral['members']): TSTypeLiteral;
export {tSTypeLiteral as tsTypeLiteral};
export declare function tSTypeOperator(typeAnnotation: TSTypeOperator['typeAnnotation']): TSTypeOperator;
export {tSTypeOperator as tsTypeOperator};
export declare function tSTypeParameter(constraint: TSTypeParameter['constraint'], _default: TSTypeParameter['default']): TSTypeParameter;
export {tSTypeParameter as tsTypeParameter};
export declare function tSTypeParameterDeclaration(params: TSTypeParameterDeclaration['params']): TSTypeParameterDeclaration;
export {tSTypeParameterDeclaration as tsTypeParameterDeclaration};
export declare function tSTypeParameterInstantiation(params: TSTypeParameterInstantiation['params']): TSTypeParameterInstantiation;
export {tSTypeParameterInstantiation as tsTypeParameterInstantiation};
export declare function tSTypePredicate(parameterName: TSTypePredicate['parameterName'], typeAnnotation: TSTypePredicate['typeAnnotation']): TSTypePredicate;
export {tSTypePredicate as tsTypePredicate};
export declare function tSTypeQuery(exprName: TSTypeQuery['exprName']): TSTypeQuery;
export {tSTypeQuery as tsTypeQuery};
export declare function tSTypeReference(typeName: TSTypeReference['typeName'], typeParameters: TSTypeReference['typeParameters']): TSTypeReference;
export {tSTypeReference as tsTypeReference};
export declare function tSUndefinedKeyword(): TSUndefinedKeyword;
export {tSUndefinedKeyword as tsUndefinedKeyword};
export declare function tSUnionType(types: TSUnionType['types']): TSUnionType;
export {tSUnionType as tsUnionType};
export declare function tSVoidKeyword(): TSVoidKeyword;
export {tSVoidKeyword as tsVoidKeyword};
export declare function taggedTemplateExpression(tag: TaggedTemplateExpression['tag'], quasi: TaggedTemplateExpression['quasi']): TaggedTemplateExpression;
export declare function templateElement(value: TemplateElement['value'], tail: TemplateElement['tail']): TemplateElement;
export declare function templateLiteral(quasis: TemplateLiteral['quasis'], expressions: TemplateLiteral['expressions']): TemplateLiteral;
export declare function thisExpression(): ThisExpression;
export declare function thisTypeAnnotation(): ThisTypeAnnotation;
export declare function throwStatement(argument: ThrowStatement['argument']): ThrowStatement;
export declare function tryStatement(block: TryStatement['block'], handler: TryStatement['handler'], finalizer: TryStatement['finalizer']): TryStatement;
export declare function tupleTypeAnnotation(types: TupleTypeAnnotation['types']): TupleTypeAnnotation;
export declare function typeAlias(id: TypeAlias['id'], typeParameters: TypeAlias['typeParameters'], right: TypeAlias['right']): TypeAlias;
export declare function typeAnnotation(typeAnnotation: TypeAnnotation['typeAnnotation']): TypeAnnotation;
export declare function typeCastExpression(expression: TypeCastExpression['expression'], typeAnnotation: TypeCastExpression['typeAnnotation']): TypeCastExpression;
export declare function typeParameter(bound: TypeParameter['bound'], _default: TypeParameter['default'], variance: TypeParameter['variance']): TypeParameter;
export declare function typeParameterDeclaration(params: TypeParameterDeclaration['params']): TypeParameterDeclaration;
export declare function typeParameterInstantiation(params: TypeParameterInstantiation['params']): TypeParameterInstantiation;
export declare function typeofTypeAnnotation(argument: TypeofTypeAnnotation['argument']): TypeofTypeAnnotation;
export declare function unaryExpression(operator: UnaryExpression['operator'], argument: UnaryExpression['argument'], prefix: UnaryExpression['prefix']): UnaryExpression;
export declare function unionTypeAnnotation(types: UnionTypeAnnotation['types']): UnionTypeAnnotation;
export declare function updateExpression(operator: UpdateExpression['operator'], argument: UpdateExpression['argument'], prefix: UpdateExpression['prefix']): UpdateExpression;
export declare function variableDeclaration(kind: VariableDeclaration['kind'], declarations: VariableDeclaration['declarations']): VariableDeclaration;
export declare function variableDeclarator(id: VariableDeclarator['id'], init: VariableDeclarator['init']): VariableDeclarator;
export declare function variance(kind: Variance['kind']): Variance;
export declare function voidTypeAnnotation(): VoidTypeAnnotation;
export declare function whileStatement(test: WhileStatement['test'], body: WhileStatement['body']): WhileStatement;
export declare function withStatement(object: WithStatement['object'], body: WithStatement['body']): WithStatement;
export declare function yieldExpression(argument: YieldExpression['argument'], delegate: YieldExpression['delegate']): YieldExpression;

export declare function isNode(node: object): node is BabelNode;
export declare function isAnyTypeAnnotation(node?: object, opts?: object): node is AnyTypeAnnotation;
export declare function isArrayExpression(node?: object, opts?: object): node is ArrayExpression;
export declare function isArrayPattern(node?: object, opts?: object): node is ArrayPattern;
export declare function isArrayTypeAnnotation(node?: object, opts?: object): node is ArrayTypeAnnotation;
export declare function isArrowFunctionExpression(node?: object, opts?: object): node is ArrowFunctionExpression;
export declare function isAssignmentExpression(node?: object, opts?: object): node is AssignmentExpression;
export declare function isAssignmentPattern(node?: object, opts?: object): node is AssignmentPattern;
export declare function isAwaitExpression(node?: object, opts?: object): node is AwaitExpression;
export declare function isBinary(node?: object, opts?: object): node is Binary;
export declare function isBinaryExpression(node?: object, opts?: object): node is BinaryExpression;
export declare function isBindExpression(node?: object, opts?: object): node is BindExpression;
export declare function isBlock(node?: object, opts?: object): node is Block;
export declare function isBlockParent(node?: object, opts?: object): node is BlockParent;
export declare function isBlockStatement(node?: object, opts?: object): node is BlockStatement;
export declare function isBooleanLiteral(node?: object, opts?: object): node is BooleanLiteral;
export declare function isBooleanLiteralTypeAnnotation(node?: object, opts?: object): node is BooleanLiteralTypeAnnotation;
export declare function isBooleanTypeAnnotation(node?: object, opts?: object): node is BooleanTypeAnnotation;
export declare function isBreakStatement(node?: object, opts?: object): node is BreakStatement;
export declare function isCallExpression(node?: object, opts?: object): node is CallExpression;
export declare function isCatchClause(node?: object, opts?: object): node is CatchClause;
export declare function isClass(node?: object, opts?: object): node is Class;
export declare function isClassBody(node?: object, opts?: object): node is ClassBody;
export declare function isClassDeclaration(node?: object, opts?: object): node is ClassDeclaration;
export declare function isClassExpression(node?: object, opts?: object): node is ClassExpression;
export declare function isClassImplements(node?: object, opts?: object): node is ClassImplements;
export declare function isClassMethod(node?: object, opts?: object): node is ClassMethod;
export declare function isClassProperty(node?: object, opts?: object): node is ClassProperty;
export declare function isCompletionStatement(node?: object, opts?: object): node is CompletionStatement;
export declare function isConditional(node?: object, opts?: object): node is Conditional;
export declare function isConditionalExpression(node?: object, opts?: object): node is ConditionalExpression;
export declare function isContinueStatement(node?: object, opts?: object): node is ContinueStatement;
export declare function isDebuggerStatement(node?: object, opts?: object): node is DebuggerStatement;
export declare function isDeclaration(node?: object, opts?: object): node is Declaration;
export declare function isDeclareClass(node?: object, opts?: object): node is DeclareClass;
export declare function isDeclareExportAllDeclaration(node?: object, opts?: object): node is DeclareExportAllDeclaration;
export declare function isDeclareExportDeclaration(node?: object, opts?: object): node is DeclareExportDeclaration;
export declare function isDeclareFunction(node?: object, opts?: object): node is DeclareFunction;
export declare function isDeclareInterface(node?: object, opts?: object): node is DeclareInterface;
export declare function isDeclareModule(node?: object, opts?: object): node is DeclareModule;
export declare function isDeclareModuleExports(node?: object, opts?: object): node is DeclareModuleExports;
export declare function isDeclareOpaqueType(node?: object, opts?: object): node is DeclareOpaqueType;
export declare function isDeclareTypeAlias(node?: object, opts?: object): node is DeclareTypeAlias;
export declare function isDeclareVariable(node?: object, opts?: object): node is DeclareVariable;
export declare function isDeclaredPredicate(node?: object, opts?: object): node is DeclaredPredicate;
export declare function isDecorator(node?: object, opts?: object): node is Decorator;
export declare function isDirective(node?: object, opts?: object): node is Directive;
export declare function isDirectiveLiteral(node?: object, opts?: object): node is DirectiveLiteral;
export declare function isDoExpression(node?: object, opts?: object): node is DoExpression;
export declare function isDoWhileStatement(node?: object, opts?: object): node is DoWhileStatement;
export declare function isEmptyStatement(node?: object, opts?: object): node is EmptyStatement;
export declare function isEmptyTypeAnnotation(node?: object, opts?: object): node is EmptyTypeAnnotation;
export declare function isExistsTypeAnnotation(node?: object, opts?: object): node is ExistsTypeAnnotation;
export declare function isExportAllDeclaration(node?: object, opts?: object): node is ExportAllDeclaration;
export declare function isExportDeclaration(node?: object, opts?: object): node is ExportDeclaration;
export declare function isExportDefaultDeclaration(node?: object, opts?: object): node is ExportDefaultDeclaration;
export declare function isExportDefaultSpecifier(node?: object, opts?: object): node is ExportDefaultSpecifier;
export declare function isExportNamedDeclaration(node?: object, opts?: object): node is ExportNamedDeclaration;
export declare function isExportNamespaceSpecifier(node?: object, opts?: object): node is ExportNamespaceSpecifier;
export declare function isExportSpecifier(node?: object, opts?: object): node is ExportSpecifier;
export declare function isExpression(node?: object, opts?: object): node is Expression;
export declare function isExpressionStatement(node?: object, opts?: object): node is ExpressionStatement;
export declare function isExpressionWrapper(node?: object, opts?: object): node is ExpressionWrapper;
export declare function isFile(node?: object, opts?: object): node is File;
export declare function isFlow(node?: object, opts?: object): node is Flow;
export declare function isFlowBaseAnnotation(node?: object, opts?: object): node is FlowBaseAnnotation;
export declare function isFlowDeclaration(node?: object, opts?: object): node is FlowDeclaration;
export declare function isFlowPredicate(node?: object, opts?: object): node is FlowPredicate;
export declare function isFlowType(node?: object, opts?: object): node is FlowType;
export declare function isFor(node?: object, opts?: object): node is For;
export declare function isForInStatement(node?: object, opts?: object): node is ForInStatement;
export declare function isForOfStatement(node?: object, opts?: object): node is ForOfStatement;
export declare function isForStatement(node?: object, opts?: object): node is ForStatement;
export declare function isForXStatement(node?: object, opts?: object): node is ForXStatement;
export declare function isFunction(node?: object, opts?: object): node is Function;
export declare function isFunctionDeclaration(node?: object, opts?: object): node is FunctionDeclaration;
export declare function isFunctionExpression(node?: object, opts?: object): node is FunctionExpression;
export declare function isFunctionParent(node?: object, opts?: object): node is FunctionParent;
export declare function isFunctionTypeAnnotation(node?: object, opts?: object): node is FunctionTypeAnnotation;
export declare function isFunctionTypeParam(node?: object, opts?: object): node is FunctionTypeParam;
export declare function isGenericTypeAnnotation(node?: object, opts?: object): node is GenericTypeAnnotation;
export declare function isIdentifier(node?: object, opts?: object): node is Identifier;
export declare function isIfStatement(node?: object, opts?: object): node is IfStatement;
export declare function isImmutable(node?: object, opts?: object): node is Immutable;
export declare function isImport(node?: object, opts?: object): node is Import;
export declare function isImportDeclaration(node?: object, opts?: object): node is ImportDeclaration;
export declare function isImportDefaultSpecifier(node?: object, opts?: object): node is ImportDefaultSpecifier;
export declare function isImportNamespaceSpecifier(node?: object, opts?: object): node is ImportNamespaceSpecifier;
export declare function isImportSpecifier(node?: object, opts?: object): node is ImportSpecifier;
export declare function isInferredPredicate(node?: object, opts?: object): node is InferredPredicate;
export declare function isInterfaceDeclaration(node?: object, opts?: object): node is InterfaceDeclaration;
export declare function isInterfaceExtends(node?: object, opts?: object): node is InterfaceExtends;
export declare function isIntersectionTypeAnnotation(node?: object, opts?: object): node is IntersectionTypeAnnotation;
export declare function isJSX(node?: object, opts?: object): node is JSX;
export declare function isJSXAttribute(node?: object, opts?: object): node is JSXAttribute;
export declare function isJSXClosingElement(node?: object, opts?: object): node is JSXClosingElement;
export declare function isJSXClosingFragment(node?: object, opts?: object): node is JSXClosingFragment;
export declare function isJSXElement(node?: object, opts?: object): node is JSXElement;
export declare function isJSXEmptyExpression(node?: object, opts?: object): node is JSXEmptyExpression;
export declare function isJSXExpressionContainer(node?: object, opts?: object): node is JSXExpressionContainer;
export declare function isJSXFragment(node?: object, opts?: object): node is JSXFragment;
export declare function isJSXIdentifier(node?: object, opts?: object): node is JSXIdentifier;
export declare function isJSXMemberExpression(node?: object, opts?: object): node is JSXMemberExpression;
export declare function isJSXNamespacedName(node?: object, opts?: object): node is JSXNamespacedName;
export declare function isJSXOpeningElement(node?: object, opts?: object): node is JSXOpeningElement;
export declare function isJSXOpeningFragment(node?: object, opts?: object): node is JSXOpeningFragment;
export declare function isJSXSpreadAttribute(node?: object, opts?: object): node is JSXSpreadAttribute;
export declare function isJSXSpreadChild(node?: object, opts?: object): node is JSXSpreadChild;
export declare function isJSXText(node?: object, opts?: object): node is JSXText;
export declare function isLVal(node?: object, opts?: object): node is LVal;
export declare function isLabeledStatement(node?: object, opts?: object): node is LabeledStatement;
export declare function isLiteral(node?: object, opts?: object): node is Literal;
export declare function isLogicalExpression(node?: object, opts?: object): node is LogicalExpression;
export declare function isLoop(node?: object, opts?: object): node is Loop;
export declare function isMemberExpression(node?: object, opts?: object): node is MemberExpression;
export declare function isMetaProperty(node?: object, opts?: object): node is MetaProperty;
export declare function isMethod(node?: object, opts?: object): node is Method;
export declare function isMixedTypeAnnotation(node?: object, opts?: object): node is MixedTypeAnnotation;
export declare function isModuleDeclaration(node?: object, opts?: object): node is ModuleDeclaration;
export declare function isModuleSpecifier(node?: object, opts?: object): node is ModuleSpecifier;
export declare function isNewExpression(node?: object, opts?: object): node is NewExpression;
export declare function isNoop(node?: object, opts?: object): node is Noop;
export declare function isNullLiteral(node?: object, opts?: object): node is NullLiteral;
export declare function isNullLiteralTypeAnnotation(node?: object, opts?: object): node is NullLiteralTypeAnnotation;
export declare function isNullableTypeAnnotation(node?: object, opts?: object): node is NullableTypeAnnotation;
export declare function isNumberLiteralTypeAnnotation(node?: object, opts?: object): node is NumberLiteralTypeAnnotation;
export declare function isNumberTypeAnnotation(node?: object, opts?: object): node is NumberTypeAnnotation;
export declare function isNumericLiteral(node?: object, opts?: object): node is NumericLiteral;
export declare function isObjectExpression(node?: object, opts?: object): node is ObjectExpression;
export declare function isObjectMember(node?: object, opts?: object): node is ObjectMember;
export declare function isObjectMethod(node?: object, opts?: object): node is ObjectMethod;
export declare function isObjectPattern(node?: object, opts?: object): node is ObjectPattern;
export declare function isObjectProperty(node?: object, opts?: object): node is ObjectProperty;
export declare function isObjectTypeAnnotation(node?: object, opts?: object): node is ObjectTypeAnnotation;
export declare function isObjectTypeCallProperty(node?: object, opts?: object): node is ObjectTypeCallProperty;
export declare function isObjectTypeIndexer(node?: object, opts?: object): node is ObjectTypeIndexer;
export declare function isObjectTypeProperty(node?: object, opts?: object): node is ObjectTypeProperty;
export declare function isObjectTypeSpreadProperty(node?: object, opts?: object): node is ObjectTypeSpreadProperty;
export declare function isOpaqueType(node?: object, opts?: object): node is OpaqueType;
export declare function isOptionalCallExpression(node?: object, opts?: object): node is OptionalCallExpression;
export declare function isOptionalMemberExpression(node?: object, opts?: object): node is OptionalMemberExpression;
export declare function isParenthesizedExpression(node?: object, opts?: object): node is ParenthesizedExpression;
export declare function isPattern(node?: object, opts?: object): node is Pattern;
export declare function isPatternLike(node?: object, opts?: object): node is PatternLike;
export declare function isProgram(node?: object, opts?: object): node is Program;
export declare function isProperty(node?: object, opts?: object): node is Property;
export declare function isPureish(node?: object, opts?: object): node is Pureish;
export declare function isQualifiedTypeIdentifier(node?: object, opts?: object): node is QualifiedTypeIdentifier;
export declare function isRegExpLiteral(node?: object, opts?: object): node is RegExpLiteral;
export declare function isRestElement(node?: object, opts?: object): node is RestElement;
export declare function isReturnStatement(node?: object, opts?: object): node is ReturnStatement;
export declare function isScopable(node?: object, opts?: object): node is Scopable;
export declare function isSequenceExpression(node?: object, opts?: object): node is SequenceExpression;
export declare function isSpreadElement(node?: object, opts?: object): node is SpreadElement;
export declare function isStatement(node?: object, opts?: object): node is Statement;
export declare function isStringLiteral(node?: object, opts?: object): node is StringLiteral;
export declare function isStringLiteralTypeAnnotation(node?: object, opts?: object): node is StringLiteralTypeAnnotation;
export declare function isStringTypeAnnotation(node?: object, opts?: object): node is StringTypeAnnotation;
export declare function isSuper(node?: object, opts?: object): node is Super;
export declare function isSwitchCase(node?: object, opts?: object): node is SwitchCase;
export declare function isSwitchStatement(node?: object, opts?: object): node is SwitchStatement;
export declare function isTSAnyKeyword(node?: object, opts?: object): node is TSAnyKeyword;
export declare function isTSArrayType(node?: object, opts?: object): node is TSArrayType;
export declare function isTSAsExpression(node?: object, opts?: object): node is TSAsExpression;
export declare function isTSBooleanKeyword(node?: object, opts?: object): node is TSBooleanKeyword;
export declare function isTSCallSignatureDeclaration(node?: object, opts?: object): node is TSCallSignatureDeclaration;
export declare function isTSConstructSignatureDeclaration(node?: object, opts?: object): node is TSConstructSignatureDeclaration;
export declare function isTSConstructorType(node?: object, opts?: object): node is TSConstructorType;
export declare function isTSDeclareFunction(node?: object, opts?: object): node is TSDeclareFunction;
export declare function isTSDeclareMethod(node?: object, opts?: object): node is TSDeclareMethod;
export declare function isTSEntityName(node?: object, opts?: object): node is TSEntityName;
export declare function isTSEnumDeclaration(node?: object, opts?: object): node is TSEnumDeclaration;
export declare function isTSEnumMember(node?: object, opts?: object): node is TSEnumMember;
export declare function isTSExportAssignment(node?: object, opts?: object): node is TSExportAssignment;
export declare function isTSExpressionWithTypeArguments(node?: object, opts?: object): node is TSExpressionWithTypeArguments;
export declare function isTSExternalModuleReference(node?: object, opts?: object): node is TSExternalModuleReference;
export declare function isTSFunctionType(node?: object, opts?: object): node is TSFunctionType;
export declare function isTSImportEqualsDeclaration(node?: object, opts?: object): node is TSImportEqualsDeclaration;
export declare function isTSIndexSignature(node?: object, opts?: object): node is TSIndexSignature;
export declare function isTSIndexedAccessType(node?: object, opts?: object): node is TSIndexedAccessType;
export declare function isTSInterfaceBody(node?: object, opts?: object): node is TSInterfaceBody;
export declare function isTSInterfaceDeclaration(node?: object, opts?: object): node is TSInterfaceDeclaration;
export declare function isTSIntersectionType(node?: object, opts?: object): node is TSIntersectionType;
export declare function isTSLiteralType(node?: object, opts?: object): node is TSLiteralType;
export declare function isTSMappedType(node?: object, opts?: object): node is TSMappedType;
export declare function isTSMethodSignature(node?: object, opts?: object): node is TSMethodSignature;
export declare function isTSModuleBlock(node?: object, opts?: object): node is TSModuleBlock;
export declare function isTSModuleDeclaration(node?: object, opts?: object): node is TSModuleDeclaration;
export declare function isTSNamespaceExportDeclaration(node?: object, opts?: object): node is TSNamespaceExportDeclaration;
export declare function isTSNeverKeyword(node?: object, opts?: object): node is TSNeverKeyword;
export declare function isTSNonNullExpression(node?: object, opts?: object): node is TSNonNullExpression;
export declare function isTSNullKeyword(node?: object, opts?: object): node is TSNullKeyword;
export declare function isTSNumberKeyword(node?: object, opts?: object): node is TSNumberKeyword;
export declare function isTSObjectKeyword(node?: object, opts?: object): node is TSObjectKeyword;
export declare function isTSParameterProperty(node?: object, opts?: object): node is TSParameterProperty;
export declare function isTSParenthesizedType(node?: object, opts?: object): node is TSParenthesizedType;
export declare function isTSPropertySignature(node?: object, opts?: object): node is TSPropertySignature;
export declare function isTSQualifiedName(node?: object, opts?: object): node is TSQualifiedName;
export declare function isTSStringKeyword(node?: object, opts?: object): node is TSStringKeyword;
export declare function isTSSymbolKeyword(node?: object, opts?: object): node is TSSymbolKeyword;
export declare function isTSThisType(node?: object, opts?: object): node is TSThisType;
export declare function isTSTupleType(node?: object, opts?: object): node is TSTupleType;
export declare function isTSType(node?: object, opts?: object): node is TSType;
export declare function isTSTypeAliasDeclaration(node?: object, opts?: object): node is TSTypeAliasDeclaration;
export declare function isTSTypeAnnotation(node?: object, opts?: object): node is TSTypeAnnotation;
export declare function isTSTypeAssertion(node?: object, opts?: object): node is TSTypeAssertion;
export declare function isTSTypeElement(node?: object, opts?: object): node is TSTypeElement;
export declare function isTSTypeLiteral(node?: object, opts?: object): node is TSTypeLiteral;
export declare function isTSTypeOperator(node?: object, opts?: object): node is TSTypeOperator;
export declare function isTSTypeParameter(node?: object, opts?: object): node is TSTypeParameter;
export declare function isTSTypeParameterDeclaration(node?: object, opts?: object): node is TSTypeParameterDeclaration;
export declare function isTSTypeParameterInstantiation(node?: object, opts?: object): node is TSTypeParameterInstantiation;
export declare function isTSTypePredicate(node?: object, opts?: object): node is TSTypePredicate;
export declare function isTSTypeQuery(node?: object, opts?: object): node is TSTypeQuery;
export declare function isTSTypeReference(node?: object, opts?: object): node is TSTypeReference;
export declare function isTSUndefinedKeyword(node?: object, opts?: object): node is TSUndefinedKeyword;
export declare function isTSUnionType(node?: object, opts?: object): node is TSUnionType;
export declare function isTSVoidKeyword(node?: object, opts?: object): node is TSVoidKeyword;
export declare function isTaggedTemplateExpression(node?: object, opts?: object): node is TaggedTemplateExpression;
export declare function isTemplateElement(node?: object, opts?: object): node is TemplateElement;
export declare function isTemplateLiteral(node?: object, opts?: object): node is TemplateLiteral;
export declare function isTerminatorless(node?: object, opts?: object): node is Terminatorless;
export declare function isThisExpression(node?: object, opts?: object): node is ThisExpression;
export declare function isThisTypeAnnotation(node?: object, opts?: object): node is ThisTypeAnnotation;
export declare function isThrowStatement(node?: object, opts?: object): node is ThrowStatement;
export declare function isTryStatement(node?: object, opts?: object): node is TryStatement;
export declare function isTupleTypeAnnotation(node?: object, opts?: object): node is TupleTypeAnnotation;
export declare function isTypeAlias(node?: object, opts?: object): node is TypeAlias;
export declare function isTypeAnnotation(node?: object, opts?: object): node is TypeAnnotation;
export declare function isTypeCastExpression(node?: object, opts?: object): node is TypeCastExpression;
export declare function isTypeParameter(node?: object, opts?: object): node is TypeParameter;
export declare function isTypeParameterDeclaration(node?: object, opts?: object): node is TypeParameterDeclaration;
export declare function isTypeParameterInstantiation(node?: object, opts?: object): node is TypeParameterInstantiation;
export declare function isTypeofTypeAnnotation(node?: object, opts?: object): node is TypeofTypeAnnotation;
export declare function isUnaryExpression(node?: object, opts?: object): node is UnaryExpression;
export declare function isUnaryLike(node?: object, opts?: object): node is UnaryLike;
export declare function isUnionTypeAnnotation(node?: object, opts?: object): node is UnionTypeAnnotation;
export declare function isUpdateExpression(node?: object, opts?: object): node is UpdateExpression;
export declare function isUserWhitespacable(node?: object, opts?: object): node is UserWhitespacable;
export declare function isVariableDeclaration(node?: object, opts?: object): node is VariableDeclaration;
export declare function isVariableDeclarator(node?: object, opts?: object): node is VariableDeclarator;
export declare function isVariance(node?: object, opts?: object): node is Variance;
export declare function isVoidTypeAnnotation(node?: object, opts?: object): node is VoidTypeAnnotation;
export declare function isWhile(node?: object, opts?: object): node is While;
export declare function isWhileStatement(node?: object, opts?: object): node is WhileStatement;
export declare function isWithStatement(node?: object, opts?: object): node is WithStatement;
export declare function isYieldExpression(node?: object, opts?: object): node is YieldExpression;

export declare function assertNode(node: object): void;
export declare function assertAnyTypeAnnotation(node: object, opts?: object): void;
export declare function assertArrayExpression(node: object, opts?: object): void;
export declare function assertArrayPattern(node: object, opts?: object): void;
export declare function assertArrayTypeAnnotation(node: object, opts?: object): void;
export declare function assertArrowFunctionExpression(node: object, opts?: object): void;
export declare function assertAssignmentExpression(node: object, opts?: object): void;
export declare function assertAssignmentPattern(node: object, opts?: object): void;
export declare function assertAwaitExpression(node: object, opts?: object): void;
export declare function assertBinary(node: object, opts?: object): void;
export declare function assertBinaryExpression(node: object, opts?: object): void;
export declare function assertBindExpression(node: object, opts?: object): void;
export declare function assertBlock(node: object, opts?: object): void;
export declare function assertBlockParent(node: object, opts?: object): void;
export declare function assertBlockStatement(node: object, opts?: object): void;
export declare function assertBooleanLiteral(node: object, opts?: object): void;
export declare function assertBooleanLiteralTypeAnnotation(node: object, opts?: object): void;
export declare function assertBooleanTypeAnnotation(node: object, opts?: object): void;
export declare function assertBreakStatement(node: object, opts?: object): void;
export declare function assertCallExpression(node: object, opts?: object): void;
export declare function assertCatchClause(node: object, opts?: object): void;
export declare function assertClass(node: object, opts?: object): void;
export declare function assertClassBody(node: object, opts?: object): void;
export declare function assertClassDeclaration(node: object, opts?: object): void;
export declare function assertClassExpression(node: object, opts?: object): void;
export declare function assertClassImplements(node: object, opts?: object): void;
export declare function assertClassMethod(node: object, opts?: object): void;
export declare function assertClassProperty(node: object, opts?: object): void;
export declare function assertCompletionStatement(node: object, opts?: object): void;
export declare function assertConditional(node: object, opts?: object): void;
export declare function assertConditionalExpression(node: object, opts?: object): void;
export declare function assertContinueStatement(node: object, opts?: object): void;
export declare function assertDebuggerStatement(node: object, opts?: object): void;
export declare function assertDeclaration(node: object, opts?: object): void;
export declare function assertDeclareClass(node: object, opts?: object): void;
export declare function assertDeclareExportAllDeclaration(node: object, opts?: object): void;
export declare function assertDeclareExportDeclaration(node: object, opts?: object): void;
export declare function assertDeclareFunction(node: object, opts?: object): void;
export declare function assertDeclareInterface(node: object, opts?: object): void;
export declare function assertDeclareModule(node: object, opts?: object): void;
export declare function assertDeclareModuleExports(node: object, opts?: object): void;
export declare function assertDeclareOpaqueType(node: object, opts?: object): void;
export declare function assertDeclareTypeAlias(node: object, opts?: object): void;
export declare function assertDeclareVariable(node: object, opts?: object): void;
export declare function assertDeclaredPredicate(node: object, opts?: object): void;
export declare function assertDecorator(node: object, opts?: object): void;
export declare function assertDirective(node: object, opts?: object): void;
export declare function assertDirectiveLiteral(node: object, opts?: object): void;
export declare function assertDoExpression(node: object, opts?: object): void;
export declare function assertDoWhileStatement(node: object, opts?: object): void;
export declare function assertEmptyStatement(node: object, opts?: object): void;
export declare function assertEmptyTypeAnnotation(node: object, opts?: object): void;
export declare function assertExistsTypeAnnotation(node: object, opts?: object): void;
export declare function assertExportAllDeclaration(node: object, opts?: object): void;
export declare function assertExportDeclaration(node: object, opts?: object): void;
export declare function assertExportDefaultDeclaration(node: object, opts?: object): void;
export declare function assertExportDefaultSpecifier(node: object, opts?: object): void;
export declare function assertExportNamedDeclaration(node: object, opts?: object): void;
export declare function assertExportNamespaceSpecifier(node: object, opts?: object): void;
export declare function assertExportSpecifier(node: object, opts?: object): void;
export declare function assertExpression(node: object, opts?: object): void;
export declare function assertExpressionStatement(node: object, opts?: object): void;
export declare function assertExpressionWrapper(node: object, opts?: object): void;
export declare function assertFile(node: object, opts?: object): void;
export declare function assertFlow(node: object, opts?: object): void;
export declare function assertFlowBaseAnnotation(node: object, opts?: object): void;
export declare function assertFlowDeclaration(node: object, opts?: object): void;
export declare function assertFlowPredicate(node: object, opts?: object): void;
export declare function assertFlowType(node: object, opts?: object): void;
export declare function assertFor(node: object, opts?: object): void;
export declare function assertForInStatement(node: object, opts?: object): void;
export declare function assertForOfStatement(node: object, opts?: object): void;
export declare function assertForStatement(node: object, opts?: object): void;
export declare function assertForXStatement(node: object, opts?: object): void;
export declare function assertFunction(node: object, opts?: object): void;
export declare function assertFunctionDeclaration(node: object, opts?: object): void;
export declare function assertFunctionExpression(node: object, opts?: object): void;
export declare function assertFunctionParent(node: object, opts?: object): void;
export declare function assertFunctionTypeAnnotation(node: object, opts?: object): void;
export declare function assertFunctionTypeParam(node: object, opts?: object): void;
export declare function assertGenericTypeAnnotation(node: object, opts?: object): void;
export declare function assertIdentifier(node: object, opts?: object): void;
export declare function assertIfStatement(node: object, opts?: object): void;
export declare function assertImmutable(node: object, opts?: object): void;
export declare function assertImport(node: object, opts?: object): void;
export declare function assertImportDeclaration(node: object, opts?: object): void;
export declare function assertImportDefaultSpecifier(node: object, opts?: object): void;
export declare function assertImportNamespaceSpecifier(node: object, opts?: object): void;
export declare function assertImportSpecifier(node: object, opts?: object): void;
export declare function assertInferredPredicate(node: object, opts?: object): void;
export declare function assertInterfaceDeclaration(node: object, opts?: object): void;
export declare function assertInterfaceExtends(node: object, opts?: object): void;
export declare function assertIntersectionTypeAnnotation(node: object, opts?: object): void;
export declare function assertJSX(node: object, opts?: object): void;
export declare function assertJSXAttribute(node: object, opts?: object): void;
export declare function assertJSXClosingElement(node: object, opts?: object): void;
export declare function assertJSXClosingFragment(node: object, opts?: object): void;
export declare function assertJSXElement(node: object, opts?: object): void;
export declare function assertJSXEmptyExpression(node: object, opts?: object): void;
export declare function assertJSXExpressionContainer(node: object, opts?: object): void;
export declare function assertJSXFragment(node: object, opts?: object): void;
export declare function assertJSXIdentifier(node: object, opts?: object): void;
export declare function assertJSXMemberExpression(node: object, opts?: object): void;
export declare function assertJSXNamespacedName(node: object, opts?: object): void;
export declare function assertJSXOpeningElement(node: object, opts?: object): void;
export declare function assertJSXOpeningFragment(node: object, opts?: object): void;
export declare function assertJSXSpreadAttribute(node: object, opts?: object): void;
export declare function assertJSXSpreadChild(node: object, opts?: object): void;
export declare function assertJSXText(node: object, opts?: object): void;
export declare function assertLVal(node: object, opts?: object): void;
export declare function assertLabeledStatement(node: object, opts?: object): void;
export declare function assertLiteral(node: object, opts?: object): void;
export declare function assertLogicalExpression(node: object, opts?: object): void;
export declare function assertLoop(node: object, opts?: object): void;
export declare function assertMemberExpression(node: object, opts?: object): void;
export declare function assertMetaProperty(node: object, opts?: object): void;
export declare function assertMethod(node: object, opts?: object): void;
export declare function assertMixedTypeAnnotation(node: object, opts?: object): void;
export declare function assertModuleDeclaration(node: object, opts?: object): void;
export declare function assertModuleSpecifier(node: object, opts?: object): void;
export declare function assertNewExpression(node: object, opts?: object): void;
export declare function assertNoop(node: object, opts?: object): void;
export declare function assertNullLiteral(node: object, opts?: object): void;
export declare function assertNullLiteralTypeAnnotation(node: object, opts?: object): void;
export declare function assertNullableTypeAnnotation(node: object, opts?: object): void;
export declare function assertNumberLiteralTypeAnnotation(node: object, opts?: object): void;
export declare function assertNumberTypeAnnotation(node: object, opts?: object): void;
export declare function assertNumericLiteral(node: object, opts?: object): void;
export declare function assertObjectExpression(node: object, opts?: object): void;
export declare function assertObjectMember(node: object, opts?: object): void;
export declare function assertObjectMethod(node: object, opts?: object): void;
export declare function assertObjectPattern(node: object, opts?: object): void;
export declare function assertObjectProperty(node: object, opts?: object): void;
export declare function assertObjectTypeAnnotation(node: object, opts?: object): void;
export declare function assertObjectTypeCallProperty(node: object, opts?: object): void;
export declare function assertObjectTypeIndexer(node: object, opts?: object): void;
export declare function assertObjectTypeProperty(node: object, opts?: object): void;
export declare function assertObjectTypeSpreadProperty(node: object, opts?: object): void;
export declare function assertOpaqueType(node: object, opts?: object): void;
export declare function assertOptionalCallExpression(node: object, opts?: object): void;
export declare function assertOptionalMemberExpression(node: object, opts?: object): void;
export declare function assertParenthesizedExpression(node: object, opts?: object): void;
export declare function assertPattern(node: object, opts?: object): void;
export declare function assertPatternLike(node: object, opts?: object): void;
export declare function assertProgram(node: object, opts?: object): void;
export declare function assertProperty(node: object, opts?: object): void;
export declare function assertPureish(node: object, opts?: object): void;
export declare function assertQualifiedTypeIdentifier(node: object, opts?: object): void;
export declare function assertRegExpLiteral(node: object, opts?: object): void;
export declare function assertRestElement(node: object, opts?: object): void;
export declare function assertReturnStatement(node: object, opts?: object): void;
export declare function assertScopable(node: object, opts?: object): void;
export declare function assertSequenceExpression(node: object, opts?: object): void;
export declare function assertSpreadElement(node: object, opts?: object): void;
export declare function assertStatement(node: object, opts?: object): void;
export declare function assertStringLiteral(node: object, opts?: object): void;
export declare function assertStringLiteralTypeAnnotation(node: object, opts?: object): void;
export declare function assertStringTypeAnnotation(node: object, opts?: object): void;
export declare function assertSuper(node: object, opts?: object): void;
export declare function assertSwitchCase(node: object, opts?: object): void;
export declare function assertSwitchStatement(node: object, opts?: object): void;
export declare function assertTSAnyKeyword(node: object, opts?: object): void;
export declare function assertTSArrayType(node: object, opts?: object): void;
export declare function assertTSAsExpression(node: object, opts?: object): void;
export declare function assertTSBooleanKeyword(node: object, opts?: object): void;
export declare function assertTSCallSignatureDeclaration(node: object, opts?: object): void;
export declare function assertTSConstructSignatureDeclaration(node: object, opts?: object): void;
export declare function assertTSConstructorType(node: object, opts?: object): void;
export declare function assertTSDeclareFunction(node: object, opts?: object): void;
export declare function assertTSDeclareMethod(node: object, opts?: object): void;
export declare function assertTSEntityName(node: object, opts?: object): void;
export declare function assertTSEnumDeclaration(node: object, opts?: object): void;
export declare function assertTSEnumMember(node: object, opts?: object): void;
export declare function assertTSExportAssignment(node: object, opts?: object): void;
export declare function assertTSExpressionWithTypeArguments(node: object, opts?: object): void;
export declare function assertTSExternalModuleReference(node: object, opts?: object): void;
export declare function assertTSFunctionType(node: object, opts?: object): void;
export declare function assertTSImportEqualsDeclaration(node: object, opts?: object): void;
export declare function assertTSIndexSignature(node: object, opts?: object): void;
export declare function assertTSIndexedAccessType(node: object, opts?: object): void;
export declare function assertTSInterfaceBody(node: object, opts?: object): void;
export declare function assertTSInterfaceDeclaration(node: object, opts?: object): void;
export declare function assertTSIntersectionType(node: object, opts?: object): void;
export declare function assertTSLiteralType(node: object, opts?: object): void;
export declare function assertTSMappedType(node: object, opts?: object): void;
export declare function assertTSMethodSignature(node: object, opts?: object): void;
export declare function assertTSModuleBlock(node: object, opts?: object): void;
export declare function assertTSModuleDeclaration(node: object, opts?: object): void;
export declare function assertTSNamespaceExportDeclaration(node: object, opts?: object): void;
export declare function assertTSNeverKeyword(node: object, opts?: object): void;
export declare function assertTSNonNullExpression(node: object, opts?: object): void;
export declare function assertTSNullKeyword(node: object, opts?: object): void;
export declare function assertTSNumberKeyword(node: object, opts?: object): void;
export declare function assertTSObjectKeyword(node: object, opts?: object): void;
export declare function assertTSParameterProperty(node: object, opts?: object): void;
export declare function assertTSParenthesizedType(node: object, opts?: object): void;
export declare function assertTSPropertySignature(node: object, opts?: object): void;
export declare function assertTSQualifiedName(node: object, opts?: object): void;
export declare function assertTSStringKeyword(node: object, opts?: object): void;
export declare function assertTSSymbolKeyword(node: object, opts?: object): void;
export declare function assertTSThisType(node: object, opts?: object): void;
export declare function assertTSTupleType(node: object, opts?: object): void;
export declare function assertTSType(node: object, opts?: object): void;
export declare function assertTSTypeAliasDeclaration(node: object, opts?: object): void;
export declare function assertTSTypeAnnotation(node: object, opts?: object): void;
export declare function assertTSTypeAssertion(node: object, opts?: object): void;
export declare function assertTSTypeElement(node: object, opts?: object): void;
export declare function assertTSTypeLiteral(node: object, opts?: object): void;
export declare function assertTSTypeOperator(node: object, opts?: object): void;
export declare function assertTSTypeParameter(node: object, opts?: object): void;
export declare function assertTSTypeParameterDeclaration(node: object, opts?: object): void;
export declare function assertTSTypeParameterInstantiation(node: object, opts?: object): void;
export declare function assertTSTypePredicate(node: object, opts?: object): void;
export declare function assertTSTypeQuery(node: object, opts?: object): void;
export declare function assertTSTypeReference(node: object, opts?: object): void;
export declare function assertTSUndefinedKeyword(node: object, opts?: object): void;
export declare function assertTSUnionType(node: object, opts?: object): void;
export declare function assertTSVoidKeyword(node: object, opts?: object): void;
export declare function assertTaggedTemplateExpression(node: object, opts?: object): void;
export declare function assertTemplateElement(node: object, opts?: object): void;
export declare function assertTemplateLiteral(node: object, opts?: object): void;
export declare function assertTerminatorless(node: object, opts?: object): void;
export declare function assertThisExpression(node: object, opts?: object): void;
export declare function assertThisTypeAnnotation(node: object, opts?: object): void;
export declare function assertThrowStatement(node: object, opts?: object): void;
export declare function assertTryStatement(node: object, opts?: object): void;
export declare function assertTupleTypeAnnotation(node: object, opts?: object): void;
export declare function assertTypeAlias(node: object, opts?: object): void;
export declare function assertTypeAnnotation(node: object, opts?: object): void;
export declare function assertTypeCastExpression(node: object, opts?: object): void;
export declare function assertTypeParameter(node: object, opts?: object): void;
export declare function assertTypeParameterDeclaration(node: object, opts?: object): void;
export declare function assertTypeParameterInstantiation(node: object, opts?: object): void;
export declare function assertTypeofTypeAnnotation(node: object, opts?: object): void;
export declare function assertUnaryExpression(node: object, opts?: object): void;
export declare function assertUnaryLike(node: object, opts?: object): void;
export declare function assertUnionTypeAnnotation(node: object, opts?: object): void;
export declare function assertUpdateExpression(node: object, opts?: object): void;
export declare function assertUserWhitespacable(node: object, opts?: object): void;
export declare function assertVariableDeclaration(node: object, opts?: object): void;
export declare function assertVariableDeclarator(node: object, opts?: object): void;
export declare function assertVariance(node: object, opts?: object): void;
export declare function assertVoidTypeAnnotation(node: object, opts?: object): void;
export declare function assertWhile(node: object, opts?: object): void;
export declare function assertWhileStatement(node: object, opts?: object): void;
export declare function assertWithStatement(node: object, opts?: object): void;
export declare function assertYieldExpression(node: object, opts?: object): void;
