// this type definition is auto-generated by ./scripts/generate.ts

export type NodeName =
    | "ArrayExpression"
    | "AssignmentExpression"
    | "BinaryExpression"
    | "Directive"
    | "DirectiveLiteral"
    | "BlockStatement"
    | "BreakStatement"
    | "CallExpression"
    | "CatchClause"
    | "ConditionalExpression"
    | "ContinueStatement"
    | "DebuggerStatement"
    | "DoWhileStatement"
    | "EmptyStatement"
    | "ExpressionStatement"
    | "File"
    | "ForInStatement"
    | "ForStatement"
    | "FunctionDeclaration"
    | "FunctionExpression"
    | "Identifier"
    | "IfStatement"
    | "LabeledStatement"
    | "StringLiteral"
    | "NumericLiteral"
    | "NullLiteral"
    | "BooleanLiteral"
    | "RegExpLiteral"
    | "LogicalExpression"
    | "MemberExpression"
    | "NewExpression"
    | "Program"
    | "ObjectExpression"
    | "ObjectMethod"
    | "ObjectProperty"
    | "RestElement"
    | "ReturnStatement"
    | "SequenceExpression"
    | "SwitchCase"
    | "SwitchStatement"
    | "ThisExpression"
    | "ThrowStatement"
    | "TryStatement"
    | "UnaryExpression"
    | "UpdateExpression"
    | "VariableDeclaration"
    | "VariableDeclarator"
    | "WhileStatement"
    | "WithStatement"
    | "AssignmentPattern"
    | "ArrayPattern"
    | "ArrowFunctionExpression"
    | "ClassBody"
    | "ClassDeclaration"
    | "ClassExpression"
    | "ExportAllDeclaration"
    | "ExportDefaultDeclaration"
    | "ExportNamedDeclaration"
    | "ExportSpecifier"
    | "ForOfStatement"
    | "ImportDeclaration"
    | "ImportDefaultSpecifier"
    | "ImportNamespaceSpecifier"
    | "ImportSpecifier"
    | "MetaProperty"
    | "ClassMethod"
    | "ObjectPattern"
    | "SpreadElement"
    | "Super"
    | "TaggedTemplateExpression"
    | "TemplateElement"
    | "TemplateLiteral"
    | "YieldExpression"
    | "AnyTypeAnnotation"
    | "ArrayTypeAnnotation"
    | "BooleanTypeAnnotation"
    | "BooleanLiteralTypeAnnotation"
    | "NullLiteralTypeAnnotation"
    | "ClassImplements"
    | "DeclareClass"
    | "DeclareFunction"
    | "DeclareInterface"
    | "DeclareModule"
    | "DeclareModuleExports"
    | "DeclareTypeAlias"
    | "DeclareOpaqueType"
    | "DeclareVariable"
    | "DeclareExportDeclaration"
    | "DeclareExportAllDeclaration"
    | "DeclaredPredicate"
    | "ExistsTypeAnnotation"
    | "FunctionTypeAnnotation"
    | "FunctionTypeParam"
    | "GenericTypeAnnotation"
    | "InferredPredicate"
    | "InterfaceExtends"
    | "InterfaceDeclaration"
    | "IntersectionTypeAnnotation"
    | "MixedTypeAnnotation"
    | "EmptyTypeAnnotation"
    | "NullableTypeAnnotation"
    | "NumberLiteralTypeAnnotation"
    | "NumberTypeAnnotation"
    | "ObjectTypeAnnotation"
    | "ObjectTypeCallProperty"
    | "ObjectTypeIndexer"
    | "ObjectTypeProperty"
    | "ObjectTypeSpreadProperty"
    | "OpaqueType"
    | "QualifiedTypeIdentifier"
    | "StringLiteralTypeAnnotation"
    | "StringTypeAnnotation"
    | "ThisTypeAnnotation"
    | "TupleTypeAnnotation"
    | "TypeofTypeAnnotation"
    | "TypeAlias"
    | "TypeAnnotation"
    | "TypeCastExpression"
    | "TypeParameter"
    | "TypeParameterDeclaration"
    | "TypeParameterInstantiation"
    | "UnionTypeAnnotation"
    | "Variance"
    | "VoidTypeAnnotation"
    | "JSXAttribute"
    | "JSXClosingElement"
    | "JSXElement"
    | "JSXEmptyExpression"
    | "JSXExpressionContainer"
    | "JSXSpreadChild"
    | "JSXIdentifier"
    | "JSXMemberExpression"
    | "JSXNamespacedName"
    | "JSXOpeningElement"
    | "JSXSpreadAttribute"
    | "JSXText"
    | "JSXFragment"
    | "JSXOpeningFragment"
    | "JSXClosingFragment"
    | "Noop"
    | "ParenthesizedExpression"
    | "AwaitExpression"
    | "BindExpression"
    | "ClassProperty"
    | "OptionalMemberExpression"
    | "OptionalCallExpression"
    | "Import"
    | "Decorator"
    | "DoExpression"
    | "ExportDefaultSpecifier"
    | "ExportNamespaceSpecifier"
    | "TSParameterProperty"
    | "TSDeclareFunction"
    | "TSDeclareMethod"
    | "TSQualifiedName"
    | "TSCallSignatureDeclaration"
    | "TSConstructSignatureDeclaration"
    | "TSPropertySignature"
    | "TSMethodSignature"
    | "TSIndexSignature"
    | "TSAnyKeyword"
    | "TSNumberKeyword"
    | "TSObjectKeyword"
    | "TSBooleanKeyword"
    | "TSStringKeyword"
    | "TSSymbolKeyword"
    | "TSVoidKeyword"
    | "TSUndefinedKeyword"
    | "TSNullKeyword"
    | "TSNeverKeyword"
    | "TSThisType"
    | "TSFunctionType"
    | "TSConstructorType"
    | "TSTypeReference"
    | "TSTypePredicate"
    | "TSTypeQuery"
    | "TSTypeLiteral"
    | "TSArrayType"
    | "TSTupleType"
    | "TSUnionType"
    | "TSIntersectionType"
    | "TSParenthesizedType"
    | "TSTypeOperator"
    | "TSIndexedAccessType"
    | "TSMappedType"
    | "TSLiteralType"
    | "TSExpressionWithTypeArguments"
    | "TSInterfaceDeclaration"
    | "TSInterfaceBody"
    | "TSTypeAliasDeclaration"
    | "TSAsExpression"
    | "TSTypeAssertion"
    | "TSEnumDeclaration"
    | "TSEnumMember"
    | "TSModuleDeclaration"
    | "TSModuleBlock"
    | "TSImportEqualsDeclaration"
    | "TSExternalModuleReference"
    | "TSNonNullExpression"
    | "TSExportAssignment"
    | "TSNamespaceExportDeclaration"
    | "TSTypeAnnotation"
    | "TSTypeParameterInstantiation"
    | "TSTypeParameterDeclaration"
    | "TSTypeParameter";

export type BabelNode =
    | ArrayExpression
    | AssignmentExpression
    | BinaryExpression
    | Directive
    | DirectiveLiteral
    | BlockStatement
    | BreakStatement
    | CallExpression
    | CatchClause
    | ConditionalExpression
    | ContinueStatement
    | DebuggerStatement
    | DoWhileStatement
    | EmptyStatement
    | ExpressionStatement
    | File
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | Identifier
    | IfStatement
    | LabeledStatement
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | LogicalExpression
    | MemberExpression
    | NewExpression
    | Program
    | ObjectExpression
    | ObjectMethod
    | ObjectProperty
    | RestElement
    | ReturnStatement
    | SequenceExpression
    | SwitchCase
    | SwitchStatement
    | ThisExpression
    | ThrowStatement
    | TryStatement
    | UnaryExpression
    | UpdateExpression
    | VariableDeclaration
    | VariableDeclarator
    | WhileStatement
    | WithStatement
    | AssignmentPattern
    | ArrayPattern
    | ArrowFunctionExpression
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ExportSpecifier
    | ForOfStatement
    | ImportDeclaration
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportSpecifier
    | MetaProperty
    | ClassMethod
    | ObjectPattern
    | SpreadElement
    | Super
    | TaggedTemplateExpression
    | TemplateElement
    | TemplateLiteral
    | YieldExpression
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullLiteralTypeAnnotation
    | ClassImplements
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | DeclaredPredicate
    | ExistsTypeAnnotation
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | GenericTypeAnnotation
    | InferredPredicate
    | InterfaceExtends
    | InterfaceDeclaration
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NullableTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | ObjectTypeAnnotation
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | OpaqueType
    | QualifiedTypeIdentifier
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | ThisTypeAnnotation
    | TupleTypeAnnotation
    | TypeofTypeAnnotation
    | TypeAlias
    | TypeAnnotation
    | TypeCastExpression
    | TypeParameter
    | TypeParameterDeclaration
    | TypeParameterInstantiation
    | UnionTypeAnnotation
    | Variance
    | VoidTypeAnnotation
    | JSXAttribute
    | JSXClosingElement
    | JSXElement
    | JSXEmptyExpression
    | JSXExpressionContainer
    | JSXSpreadChild
    | JSXIdentifier
    | JSXMemberExpression
    | JSXNamespacedName
    | JSXOpeningElement
    | JSXSpreadAttribute
    | JSXText
    | JSXFragment
    | JSXOpeningFragment
    | JSXClosingFragment
    | Noop
    | ParenthesizedExpression
    | AwaitExpression
    | BindExpression
    | ClassProperty
    | OptionalMemberExpression
    | OptionalCallExpression
    | Import
    | Decorator
    | DoExpression
    | ExportDefaultSpecifier
    | ExportNamespaceSpecifier
    | TSParameterProperty
    | TSDeclareFunction
    | TSDeclareMethod
    | TSQualifiedName
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSPropertySignature
    | TSMethodSignature
    | TSIndexSignature
    | TSAnyKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSBooleanKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSVoidKeyword
    | TSUndefinedKeyword
    | TSNullKeyword
    | TSNeverKeyword
    | TSThisType
    | TSFunctionType
    | TSConstructorType
    | TSTypeReference
    | TSTypePredicate
    | TSTypeQuery
    | TSTypeLiteral
    | TSArrayType
    | TSTupleType
    | TSUnionType
    | TSIntersectionType
    | TSParenthesizedType
    | TSTypeOperator
    | TSIndexedAccessType
    | TSMappedType
    | TSLiteralType
    | TSExpressionWithTypeArguments
    | TSInterfaceDeclaration
    | TSInterfaceBody
    | TSTypeAliasDeclaration
    | TSAsExpression
    | TSTypeAssertion
    | TSEnumDeclaration
    | TSEnumMember
    | TSModuleDeclaration
    | TSModuleBlock
    | TSImportEqualsDeclaration
    | TSExternalModuleReference
    | TSNonNullExpression
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSTypeAnnotation
    | TSTypeParameterInstantiation
    | TSTypeParameterDeclaration
    | TSTypeParameter;

export type AliasName =
    | "Expression"
    | "Binary"
    | "Scopable"
    | "BlockParent"
    | "Block"
    | "Statement"
    | "Terminatorless"
    | "CompletionStatement"
    | "Conditional"
    | "Loop"
    | "While"
    | "ExpressionWrapper"
    | "For"
    | "ForXStatement"
    | "Function"
    | "FunctionParent"
    | "Pureish"
    | "Declaration"
    | "PatternLike"
    | "LVal"
    | "TSEntityName"
    | "Literal"
    | "Immutable"
    | "UserWhitespacable"
    | "Method"
    | "ObjectMember"
    | "Property"
    | "UnaryLike"
    | "Pattern"
    | "Class"
    | "ModuleDeclaration"
    | "ExportDeclaration"
    | "ModuleSpecifier"
    | "Flow"
    | "FlowType"
    | "FlowBaseAnnotation"
    | "FlowDeclaration"
    | "FlowPredicate"
    | "JSX"
    | "TSTypeElement"
    | "TSType";

export const TYPES: Array<NodeName | AliasName>;

export const ALIAS_KEYS: Record<NodeName, AliasName[]>;
export const FLIPPED_ALIAS_KEYS: Record<AliasName, NodeName[]>;
export const VISITOR_KEYS: Record<NodeName, string[]>;
export const BUILDER_KEYS: Record<NodeName, string[]>;
export const DEPRECATED_KEYS: Record<NodeName, NodeName | undefined>;
export const NODE_FIELDS: Record<
    NodeName,
    Record<
        string,
        | undefined
        | {
              default?: any;
              optional?: boolean;
              validate?: (node: BabelNode, key: string, val: any) => void;
          }
    >
>;

export type StatementOrBlockKey = "consequent" | "body" | "alternate";
export const STATEMENT_OR_BLOCK_KEYS: StatementOrBlockKey[];
export type FlattenableKey = "body" | "expressions";
export const FLATTENABLE_KEYS: FlattenableKey[];
export type ForInitKey = "left" | "init";
export const FOR_INIT_KEYS: ForInitKey[];
export type CommentKey =
    | "leadingComments"
    | "trailingComments"
    | "innerComments";
export const COMMENT_KEYS: CommentKey[];
export type LogicalOperator = "||" | "&&" | "??";
export const LOGICAL_OPERATORS: LogicalOperator[];
export type UpdateOperator = "++" | "--";
export const UPDATE_OPERATORS: UpdateOperator[];
export type BooleanNumberBinaryOperator = ">" | "<" | ">=" | "<=";
export const BOOLEAN_NUMBER_BINARY_OPERATORS: BooleanNumberBinaryOperator[];
export type EqualityBinaryOperator = "==" | "===" | "!=" | "!==";
export const EQUALITY_BINARY_OPERATORS: EqualityBinaryOperator[];
export type ComparisonBinaryOperator =
    | "=="
    | "==="
    | "!="
    | "!=="
    | "in"
    | "instanceof";
export const COMPARISON_BINARY_OPERATORS: ComparisonBinaryOperator[];
export type BooleanBinaryOperator =
    | "=="
    | "==="
    | "!="
    | "!=="
    | "in"
    | "instanceof"
    | ">"
    | "<"
    | ">="
    | "<=";
export const BOOLEAN_BINARY_OPERATORS: BooleanBinaryOperator[];
export type NumberBinaryOperator =
    | "-"
    | "/"
    | "%"
    | "*"
    | "**"
    | "&"
    | "|"
    | ">>"
    | ">>>"
    | "<<"
    | "^";
export const NUMBER_BINARY_OPERATORS: NumberBinaryOperator[];
export type BinaryOperator =
    | "+"
    | "-"
    | "/"
    | "%"
    | "*"
    | "**"
    | "&"
    | "|"
    | ">>"
    | ">>>"
    | "<<"
    | "^"
    | "=="
    | "==="
    | "!="
    | "!=="
    | "in"
    | "instanceof"
    | ">"
    | "<"
    | ">="
    | "<=";
export const BINARY_OPERATORS: BinaryOperator[];
export type BooleanUnaryOperator = "delete" | "!";
export const BOOLEAN_UNARY_OPERATORS: BooleanUnaryOperator[];
export type NumberUnaryOperator = "+" | "-" | "~";
export const NUMBER_UNARY_OPERATORS: NumberUnaryOperator[];
export type StringUnaryOperator = "typeof";
export const STRING_UNARY_OPERATORS: StringUnaryOperator[];
export type UnaryOperator =
    | "void"
    | "throw"
    | "delete"
    | "!"
    | "+"
    | "-"
    | "~"
    | "typeof";
export const UNARY_OPERATORS: UnaryOperator[];
export const INHERIT_KEYS: {
    optional: ["typeAnnotation", "typeParameters", "returnType"];
    force: ["start", "loc", "end"];
};
export const BLOCK_SCOPED_SYMBOL: keyof symbol;
export const NOT_LOCAL_BINDING: keyof symbol;
export const EXPRESSION_TYPES: NodeName[];
export const BINARY_TYPES: NodeName[];
export const SCOPABLE_TYPES: NodeName[];
export const BLOCKPARENT_TYPES: NodeName[];
export const BLOCK_TYPES: NodeName[];
export const STATEMENT_TYPES: NodeName[];
export const TERMINATORLESS_TYPES: NodeName[];
export const COMPLETIONSTATEMENT_TYPES: NodeName[];
export const CONDITIONAL_TYPES: NodeName[];
export const LOOP_TYPES: NodeName[];
export const WHILE_TYPES: NodeName[];
export const EXPRESSIONWRAPPER_TYPES: NodeName[];
export const FOR_TYPES: NodeName[];
export const FORXSTATEMENT_TYPES: NodeName[];
export const FUNCTION_TYPES: NodeName[];
export const FUNCTIONPARENT_TYPES: NodeName[];
export const PUREISH_TYPES: NodeName[];
export const DECLARATION_TYPES: NodeName[];
export const PATTERNLIKE_TYPES: NodeName[];
export const LVAL_TYPES: NodeName[];
export const TSENTITYNAME_TYPES: NodeName[];
export const LITERAL_TYPES: NodeName[];
export const IMMUTABLE_TYPES: NodeName[];
export const USERWHITESPACABLE_TYPES: NodeName[];
export const METHOD_TYPES: NodeName[];
export const OBJECTMEMBER_TYPES: NodeName[];
export const PROPERTY_TYPES: NodeName[];
export const UNARYLIKE_TYPES: NodeName[];
export const PATTERN_TYPES: NodeName[];
export const CLASS_TYPES: NodeName[];
export const MODULEDECLARATION_TYPES: NodeName[];
export const EXPORTDECLARATION_TYPES: NodeName[];
export const MODULESPECIFIER_TYPES: NodeName[];
export const FLOW_TYPES: NodeName[];
export const FLOWTYPE_TYPES: NodeName[];
export const FLOWBASEANNOTATION_TYPES: NodeName[];
export const FLOWDECLARATION_TYPES: NodeName[];
export const FLOWPREDICATE_TYPES: NodeName[];
export const JSX_TYPES: NodeName[];
export const TSTYPEELEMENT_TYPES: NodeName[];
export const TSTYPE_TYPES: NodeName[];

export interface Comment {
    value: string;
    start: number;
    end: number;
    loc: SourceLocation;
}

export interface CommentBlock extends Comment {
    type: "CommentBlock";
}

export interface CommentLine extends Comment {
    type: "CommentLine";
}

export interface SourceLocation {
    start: {
        line: number;
        column: number;
    };

    end: {
        line: number;
        column: number;
    };
}

export interface NodeBase {
    type: NodeName;
    leadingComments?: Comment[];
    innerComments?: Comment[];
    trailingComments?: Comment[];
    start: number;
    end: number;
    loc: SourceLocation;
}

export interface ArrayExpression extends NodeBase {
    type: "ArrayExpression";
    elements: Array<null | Expression | SpreadElement>;
}

export interface AssignmentExpression extends NodeBase {
    type: "AssignmentExpression";
    operator:
        | "="
        | "+="
        | "-="
        | "*="
        | "/="
        | "%="
        | "<<="
        | ">>="
        | ">>>="
        | "|="
        | "^="
        | "&=";
    left: LVal;
    right: Expression;
}

export interface BinaryExpression extends NodeBase {
    type: "BinaryExpression";
    operator: BinaryOperator;
    left: Expression;
    right: Expression;
}

export interface Directive extends NodeBase {
    type: "Directive";
    value: DirectiveLiteral;
}

export interface DirectiveLiteral extends NodeBase {
    type: "DirectiveLiteral";
    value: string;
}

export interface BlockStatement extends NodeBase {
    type: "BlockStatement";
    directives: Directive[];
    body: Statement[];
}

export interface BreakStatement extends NodeBase {
    type: "BreakStatement";
    label?: Identifier;
}

export interface CallExpression extends NodeBase {
    type: "CallExpression";
    callee: Expression;
    arguments: Array<Expression | SpreadElement | JSXNamespacedName>;
    optional?: boolean;
    typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
}

export interface CatchClause extends NodeBase {
    type: "CatchClause";
    param?: Identifier;
    body: BlockStatement;
}

export interface ConditionalExpression extends NodeBase {
    type: "ConditionalExpression";
    test: Expression;
    consequent: Expression;
    alternate: Expression;
}

export interface ContinueStatement extends NodeBase {
    type: "ContinueStatement";
    label?: Identifier;
}

export interface DebuggerStatement extends NodeBase {
    type: "DebuggerStatement";
}

export interface DoWhileStatement extends NodeBase {
    type: "DoWhileStatement";
    test: Expression;
    body: Statement;
}

export interface EmptyStatement extends NodeBase {
    type: "EmptyStatement";
}

export interface ExpressionStatement extends NodeBase {
    type: "ExpressionStatement";
    expression: Expression;
}

export interface File extends NodeBase {
    type: "File";
    program: Program;
    comments: Comment[];
    tokens: any[];
}

export interface ForInStatement extends NodeBase {
    type: "ForInStatement";
    left: VariableDeclaration | LVal;
    right: Expression;
    body: Statement;
}

export interface ForStatement extends NodeBase {
    type: "ForStatement";
    init?: VariableDeclaration | Expression;
    test?: Expression;
    update?: Expression;
    body: Statement;
}

export interface FunctionDeclaration extends NodeBase {
    type: "FunctionDeclaration";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    declare?: boolean;
    id?: Identifier;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
    typeParameters?:
        | TypeParameterDeclaration
        | TSTypeParameterDeclaration
        | Noop;
    body: BlockStatement;
}

export interface FunctionExpression extends NodeBase {
    type: "FunctionExpression";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
    typeParameters?:
        | TypeParameterDeclaration
        | TSTypeParameterDeclaration
        | Noop;
    id?: Identifier;
    body: BlockStatement;
}

export interface Identifier extends NodeBase {
    type: "Identifier";
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    name: string;
    optional?: boolean;
}

export interface IfStatement extends NodeBase {
    type: "IfStatement";
    test: Expression;
    consequent: Statement;
    alternate?: Statement;
}

export interface LabeledStatement extends NodeBase {
    type: "LabeledStatement";
    label: Identifier;
    body: Statement;
}

export interface StringLiteral extends NodeBase {
    type: "StringLiteral";
    value: string;
}

export interface NumericLiteral extends NodeBase {
    type: "NumericLiteral";
    value: number;
}

export interface NullLiteral extends NodeBase {
    type: "NullLiteral";
}

export interface BooleanLiteral extends NodeBase {
    type: "BooleanLiteral";
    value: boolean;
}

export interface RegExpLiteral extends NodeBase {
    type: "RegExpLiteral";
    pattern: string;
    flags: string;
}

export interface LogicalExpression extends NodeBase {
    type: "LogicalExpression";
    operator: LogicalOperator;
    left: Expression;
    right: Expression;
}

export interface MemberExpression extends NodeBase {
    type: "MemberExpression";
    object: Expression;
    property: any;
    computed: boolean;
    optional?: boolean;
}

export interface NewExpression extends NodeBase {
    type: "NewExpression";
    callee: Expression;
    arguments: Array<Expression | SpreadElement | JSXNamespacedName>;
    optional?: boolean;
    typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
}

export interface Program extends NodeBase {
    type: "Program";
    sourceFile?: string;
    sourceType: "script" | "module";
    directives: Directive[];
    body: Statement[];
}

export interface ObjectExpression extends NodeBase {
    type: "ObjectExpression";
    properties: Array<ObjectMethod | ObjectProperty | SpreadElement>;
}

export interface ObjectMethod extends NodeBase {
    type: "ObjectMethod";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
    typeParameters?:
        | TypeParameterDeclaration
        | TSTypeParameterDeclaration
        | Noop;
    kind: "method" | "get" | "set";
    computed: boolean;
    key: any;
    decorators?: Decorator[];
    body: BlockStatement;
}

export interface ObjectProperty extends NodeBase {
    type: "ObjectProperty";
    computed: boolean;
    key: any;
    value: Expression | PatternLike;
    shorthand: boolean;
    decorators?: Decorator[];
}

export interface RestElement extends NodeBase {
    type: "RestElement";
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    argument: LVal;
}

export interface ReturnStatement extends NodeBase {
    type: "ReturnStatement";
    argument?: Expression;
}

export interface SequenceExpression extends NodeBase {
    type: "SequenceExpression";
    expressions: Expression[];
}

export interface SwitchCase extends NodeBase {
    type: "SwitchCase";
    test?: Expression;
    consequent: Statement[];
}

export interface SwitchStatement extends NodeBase {
    type: "SwitchStatement";
    discriminant: Expression;
    cases: SwitchCase[];
}

export interface ThisExpression extends NodeBase {
    type: "ThisExpression";
}

export interface ThrowStatement extends NodeBase {
    type: "ThrowStatement";
    argument: Expression;
}

export interface TryStatement extends NodeBase {
    type: "TryStatement";
    block: BlockStatement;
    handler?: CatchClause;
    finalizer?: BlockStatement;
}

export interface UnaryExpression extends NodeBase {
    type: "UnaryExpression";
    prefix: boolean;
    argument: Expression;
    operator: UnaryOperator;
}

export interface UpdateExpression extends NodeBase {
    type: "UpdateExpression";
    prefix: boolean;
    argument: Expression;
    operator: UpdateOperator;
}

export interface VariableDeclaration extends NodeBase {
    type: "VariableDeclaration";
    declare?: boolean;
    kind: "var" | "let" | "const";
    declarations: VariableDeclarator[];
}

export interface VariableDeclarator extends NodeBase {
    type: "VariableDeclarator";
    id: LVal;
    init?: Expression;
}

export interface WhileStatement extends NodeBase {
    type: "WhileStatement";
    test: Expression;
    body: BlockStatement | Statement;
}

export interface WithStatement extends NodeBase {
    type: "WithStatement";
    object: Expression;
    body: BlockStatement | Statement;
}

export interface AssignmentPattern extends NodeBase {
    type: "AssignmentPattern";
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    left: Identifier | ObjectPattern | ArrayPattern;
    right: Expression;
}

export interface ArrayPattern extends NodeBase {
    type: "ArrayPattern";
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    elements: PatternLike[];
}

export interface ArrowFunctionExpression extends NodeBase {
    type: "ArrowFunctionExpression";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
    typeParameters?:
        | TypeParameterDeclaration
        | TSTypeParameterDeclaration
        | Noop;
    expression?: boolean;
    body: BlockStatement | Expression;
}

export interface ClassBody extends NodeBase {
    type: "ClassBody";
    body: Array<
        ClassMethod | ClassProperty | TSDeclareMethod | TSIndexSignature
    >;
}

export interface ClassDeclaration extends NodeBase {
    type: "ClassDeclaration";
    typeParameters?:
        | TypeParameterDeclaration
        | TSTypeParameterDeclaration
        | Noop;
    body: ClassBody;
    superClass?: Expression;
    superTypeParameters?:
        | TypeParameterInstantiation
        | TSTypeParameterInstantiation;
    implements?: Array<TSExpressionWithTypeArguments | ClassImplements>;
    declare?: boolean;
    abstract?: boolean;
    id?: Identifier;
    decorators?: Decorator[];
    mixins?: any;
}

export interface ClassExpression extends NodeBase {
    type: "ClassExpression";
    typeParameters?:
        | TypeParameterDeclaration
        | TSTypeParameterDeclaration
        | Noop;
    body: ClassBody;
    superClass?: Expression;
    superTypeParameters?:
        | TypeParameterInstantiation
        | TSTypeParameterInstantiation;
    implements?: Array<TSExpressionWithTypeArguments | ClassImplements>;
    id?: Identifier;
    decorators?: Decorator[];
    mixins?: any;
}

export interface ExportAllDeclaration extends NodeBase {
    type: "ExportAllDeclaration";
    source: StringLiteral;
}

export interface ExportDefaultDeclaration extends NodeBase {
    type: "ExportDefaultDeclaration";
    declaration:
        | FunctionDeclaration
        | TSDeclareFunction
        | ClassDeclaration
        | Expression;
}

export interface ExportNamedDeclaration extends NodeBase {
    type: "ExportNamedDeclaration";
    declaration?: Declaration;
    specifiers: Array<
        ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier
    >;
    source?: StringLiteral;
}

export interface ExportSpecifier extends NodeBase {
    type: "ExportSpecifier";
    local: Identifier;
    exported: Identifier;
}

export interface ForOfStatement extends NodeBase {
    type: "ForOfStatement";
    left: VariableDeclaration | LVal;
    right: Expression;
    body: Statement;
    await?: boolean;
}

export interface ImportDeclaration extends NodeBase {
    type: "ImportDeclaration";
    specifiers: Array<
        ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier
    >;
    source: StringLiteral;
}

export interface ImportDefaultSpecifier extends NodeBase {
    type: "ImportDefaultSpecifier";
    local: Identifier;
}

export interface ImportNamespaceSpecifier extends NodeBase {
    type: "ImportNamespaceSpecifier";
    local: Identifier;
}

export interface ImportSpecifier extends NodeBase {
    type: "ImportSpecifier";
    local: Identifier;
    imported: Identifier;
    importKind?: null | "type" | "typeof";
}

export interface MetaProperty extends NodeBase {
    type: "MetaProperty";
    meta: Identifier;
    property: Identifier;
}

export interface ClassMethod extends NodeBase {
    type: "ClassMethod";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    abstract?: boolean;
    accessibility?: "public" | "private" | "protected";
    static?: boolean;
    computed?: boolean;
    optional?: boolean;
    key: Identifier | StringLiteral | NumericLiteral | Expression;
    kind?: "get" | "set" | "method" | "constructor";
    access?: "public" | "private" | "protected";
    decorators?: Decorator[];
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
    typeParameters?:
        | TypeParameterDeclaration
        | TSTypeParameterDeclaration
        | Noop;
    body: BlockStatement;
}

export interface ObjectPattern extends NodeBase {
    type: "ObjectPattern";
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    properties: Array<RestElement | ObjectProperty>;
}

export interface SpreadElement extends NodeBase {
    type: "SpreadElement";
    argument: Expression;
}

export interface Super extends NodeBase {
    type: "Super";
}

export interface TaggedTemplateExpression extends NodeBase {
    type: "TaggedTemplateExpression";
    tag: Expression;
    quasi: TemplateLiteral;
}

export interface TemplateElement extends NodeBase {
    type: "TemplateElement";
    value: any;
    tail: boolean;
}

export interface TemplateLiteral extends NodeBase {
    type: "TemplateLiteral";
    quasis: TemplateElement[];
    expressions: Expression[];
}

export interface YieldExpression extends NodeBase {
    type: "YieldExpression";
    delegate: boolean;
    argument?: Expression;
}

export interface AnyTypeAnnotation extends NodeBase {
    type: "AnyTypeAnnotation";
}

export interface ArrayTypeAnnotation extends NodeBase {
    type: "ArrayTypeAnnotation";
    elementType: FlowType;
}

export interface BooleanTypeAnnotation extends NodeBase {
    type: "BooleanTypeAnnotation";
}

export interface BooleanLiteralTypeAnnotation extends NodeBase {
    type: "BooleanLiteralTypeAnnotation";
    value?: boolean;
}

export interface NullLiteralTypeAnnotation extends NodeBase {
    type: "NullLiteralTypeAnnotation";
}

export interface ClassImplements extends NodeBase {
    type: "ClassImplements";
    id: Identifier;
    typeParameters?: TypeParameterInstantiation;
}

export interface DeclareClass extends NodeBase {
    type: "DeclareClass";
    id: Identifier;
    typeParameters?: TypeParameterInstantiation;
    extends?: InterfaceExtends[];
    mixins?: InterfaceExtends[];
    body: ObjectTypeAnnotation;
}

export interface DeclareFunction extends NodeBase {
    type: "DeclareFunction";
    id: Identifier;
    predicate?: DeclaredPredicate;
}

export interface DeclareInterface extends NodeBase {
    type: "DeclareInterface";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    extends?: InterfaceExtends;
    mixins?: Flow[];
    body: ObjectTypeAnnotation;
}

export interface DeclareModule extends NodeBase {
    type: "DeclareModule";
    id: Identifier | StringLiteral;
    body: BlockStatement;
    kind?: "CommonJS" | "ES";
}

export interface DeclareModuleExports extends NodeBase {
    type: "DeclareModuleExports";
    typeAnnotation: TypeAnnotation;
}

export interface DeclareTypeAlias extends NodeBase {
    type: "DeclareTypeAlias";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    right: FlowType;
}

export interface DeclareOpaqueType extends NodeBase {
    type: "DeclareOpaqueType";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    supertype?: FlowType;
}

export interface DeclareVariable extends NodeBase {
    type: "DeclareVariable";
    id: Identifier;
}

export interface DeclareExportDeclaration extends NodeBase {
    type: "DeclareExportDeclaration";
    declaration?: Flow;
    specifiers?: Array<ExportSpecifier | ExportNamespaceSpecifier>;
    source?: StringLiteral;
    default?: boolean;
}

export interface DeclareExportAllDeclaration extends NodeBase {
    type: "DeclareExportAllDeclaration";
    source: StringLiteral;
    exportKind?: ["type", "value"];
}

export interface DeclaredPredicate extends NodeBase {
    type: "DeclaredPredicate";
    value: Flow;
}

export interface ExistsTypeAnnotation extends NodeBase {
    type: "ExistsTypeAnnotation";
}

export interface FunctionTypeAnnotation extends NodeBase {
    type: "FunctionTypeAnnotation";
    typeParameters?: TypeParameterDeclaration;
    params: FunctionTypeParam[];
    rest?: FunctionTypeParam;
    returnType: FlowType;
}

export interface FunctionTypeParam extends NodeBase {
    type: "FunctionTypeParam";
    name?: Identifier;
    typeAnnotation: FlowType;
    optional?: boolean;
}

export interface GenericTypeAnnotation extends NodeBase {
    type: "GenericTypeAnnotation";
    id: Identifier;
    typeParameters?: TypeParameterInstantiation;
}

export interface InferredPredicate extends NodeBase {
    type: "InferredPredicate";
}

export interface InterfaceExtends extends NodeBase {
    type: "InterfaceExtends";
    id: Identifier;
    typeParameters?: TypeParameterInstantiation;
}

export interface InterfaceDeclaration extends NodeBase {
    type: "InterfaceDeclaration";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    extends: InterfaceExtends[];
    mixins?: InterfaceExtends[];
    body: ObjectTypeAnnotation;
}

export interface IntersectionTypeAnnotation extends NodeBase {
    type: "IntersectionTypeAnnotation";
    types: FlowType[];
}

export interface MixedTypeAnnotation extends NodeBase {
    type: "MixedTypeAnnotation";
}

export interface EmptyTypeAnnotation extends NodeBase {
    type: "EmptyTypeAnnotation";
}

export interface NullableTypeAnnotation extends NodeBase {
    type: "NullableTypeAnnotation";
    typeAnnotation: FlowType;
}

export interface NumberLiteralTypeAnnotation extends NodeBase {
    type: "NumberLiteralTypeAnnotation";
    value?: number;
}

export interface NumberTypeAnnotation extends NodeBase {
    type: "NumberTypeAnnotation";
}

export interface ObjectTypeAnnotation extends NodeBase {
    type: "ObjectTypeAnnotation";
    properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>;
    indexers?: ObjectTypeIndexer[];
    callProperties?: ObjectTypeCallProperty[];
    exact?: boolean;
}

export interface ObjectTypeCallProperty extends NodeBase {
    type: "ObjectTypeCallProperty";
    value: FlowType;
    static?: boolean;
}

export interface ObjectTypeIndexer extends NodeBase {
    type: "ObjectTypeIndexer";
    id?: Identifier;
    key: FlowType;
    value: FlowType;
    static?: boolean;
    variance?: Variance;
}

export interface ObjectTypeProperty extends NodeBase {
    type: "ObjectTypeProperty";
    key: Identifier;
    value: FlowType;
    kind?: "init" | "get" | "set";
    static?: boolean;
    optional?: boolean;
    variance?: Variance;
}

export interface ObjectTypeSpreadProperty extends NodeBase {
    type: "ObjectTypeSpreadProperty";
    argument: FlowType;
}

export interface OpaqueType extends NodeBase {
    type: "OpaqueType";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    supertype?: FlowType;
    impltype: FlowType;
}

export interface QualifiedTypeIdentifier extends NodeBase {
    type: "QualifiedTypeIdentifier";
    id: Identifier;
    qualification: Identifier | QualifiedTypeIdentifier;
}

export interface StringLiteralTypeAnnotation extends NodeBase {
    type: "StringLiteralTypeAnnotation";
    value?: string;
}

export interface StringTypeAnnotation extends NodeBase {
    type: "StringTypeAnnotation";
}

export interface ThisTypeAnnotation extends NodeBase {
    type: "ThisTypeAnnotation";
}

export interface TupleTypeAnnotation extends NodeBase {
    type: "TupleTypeAnnotation";
    types: FlowType[];
}

export interface TypeofTypeAnnotation extends NodeBase {
    type: "TypeofTypeAnnotation";
    argument: FlowType;
}

export interface TypeAlias extends NodeBase {
    type: "TypeAlias";
    id: Identifier;
    typeParameters?: TypeParameterDeclaration;
    right: FlowType;
}

export interface TypeAnnotation extends NodeBase {
    type: "TypeAnnotation";
    typeAnnotation: FlowType;
}

export interface TypeCastExpression extends NodeBase {
    type: "TypeCastExpression";
    expression: Expression;
    typeAnnotation: TypeAnnotation;
}

export interface TypeParameter extends NodeBase {
    type: "TypeParameter";
    name?: string;
    bound?: TypeAnnotation;
    default?: FlowType;
    variance?: Variance;
}

export interface TypeParameterDeclaration extends NodeBase {
    type: "TypeParameterDeclaration";
    params: TypeParameter[];
}

export interface TypeParameterInstantiation extends NodeBase {
    type: "TypeParameterInstantiation";
    params: FlowType[];
}

export interface UnionTypeAnnotation extends NodeBase {
    type: "UnionTypeAnnotation";
    types: FlowType[];
}

export interface Variance extends NodeBase {
    type: "Variance";
    kind: "minus" | "plus";
}

export interface VoidTypeAnnotation extends NodeBase {
    type: "VoidTypeAnnotation";
}

export interface JSXAttribute extends NodeBase {
    type: "JSXAttribute";
    name: JSXIdentifier | JSXNamespacedName;
    value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer;
}

export interface JSXClosingElement extends NodeBase {
    type: "JSXClosingElement";
    name: JSXIdentifier | JSXMemberExpression;
}

export interface JSXElement extends NodeBase {
    type: "JSXElement";
    openingElement: JSXOpeningElement;
    closingElement?: JSXClosingElement;
    children: Array<
        | JSXText
        | JSXExpressionContainer
        | JSXSpreadChild
        | JSXElement
        | JSXFragment
    >;
    selfClosing: any;
}

export interface JSXEmptyExpression extends NodeBase {
    type: "JSXEmptyExpression";
}

export interface JSXExpressionContainer extends NodeBase {
    type: "JSXExpressionContainer";
    expression: Expression;
}

export interface JSXSpreadChild extends NodeBase {
    type: "JSXSpreadChild";
    expression: Expression;
}

export interface JSXIdentifier extends NodeBase {
    type: "JSXIdentifier";
    name: string;
}

export interface JSXMemberExpression extends NodeBase {
    type: "JSXMemberExpression";
    object: JSXMemberExpression | JSXIdentifier;
    property: JSXIdentifier;
}

export interface JSXNamespacedName extends NodeBase {
    type: "JSXNamespacedName";
    namespace: JSXIdentifier;
    name: JSXIdentifier;
}

export interface JSXOpeningElement extends NodeBase {
    type: "JSXOpeningElement";
    name: JSXIdentifier | JSXMemberExpression;
    selfClosing: boolean;
    attributes: Array<JSXAttribute | JSXSpreadAttribute>;
}

export interface JSXSpreadAttribute extends NodeBase {
    type: "JSXSpreadAttribute";
    argument: Expression;
}

export interface JSXText extends NodeBase {
    type: "JSXText";
    value: string;
}

export interface JSXFragment extends NodeBase {
    type: "JSXFragment";
    openingFragment: JSXOpeningFragment;
    closingFragment: JSXClosingFragment;
    children: Array<
        | JSXText
        | JSXExpressionContainer
        | JSXSpreadChild
        | JSXElement
        | JSXFragment
    >;
}

export interface JSXOpeningFragment extends NodeBase {
    type: "JSXOpeningFragment";
}

export interface JSXClosingFragment extends NodeBase {
    type: "JSXClosingFragment";
}

export interface Noop extends NodeBase {
    type: "Noop";
}

export interface ParenthesizedExpression extends NodeBase {
    type: "ParenthesizedExpression";
    expression: Expression;
}

export interface AwaitExpression extends NodeBase {
    type: "AwaitExpression";
    argument: Expression;
}

export interface BindExpression extends NodeBase {
    type: "BindExpression";
    object: any;
    callee: any;
}

export interface ClassProperty extends NodeBase {
    type: "ClassProperty";
    abstract?: boolean;
    accessibility?: "public" | "private" | "protected";
    static?: boolean;
    computed?: boolean;
    optional?: boolean;
    key: Identifier | StringLiteral | NumericLiteral | Expression;
    value?: Expression;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
    decorators?: Decorator[];
    readonly?: boolean;
}

export interface OptionalMemberExpression extends NodeBase {
    type: "OptionalMemberExpression";
    object: Expression;
    property: any;
    computed: boolean;
    optional: boolean;
}

export interface OptionalCallExpression extends NodeBase {
    type: "OptionalCallExpression";
    callee: Expression;
    arguments: Array<Expression | SpreadElement | JSXNamespacedName>;
    optional: boolean;
    typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
}

export interface Import extends NodeBase {
    type: "Import";
}

export interface Decorator extends NodeBase {
    type: "Decorator";
    expression: Expression;
}

export interface DoExpression extends NodeBase {
    type: "DoExpression";
    body: BlockStatement;
}

export interface ExportDefaultSpecifier extends NodeBase {
    type: "ExportDefaultSpecifier";
    exported: Identifier;
}

export interface ExportNamespaceSpecifier extends NodeBase {
    type: "ExportNamespaceSpecifier";
    exported: Identifier;
}

export interface TSParameterProperty extends NodeBase {
    type: "TSParameterProperty";
    accessibility?: "public" | "private" | "protected";
    readonly?: boolean;
    parameter: Identifier | AssignmentPattern;
}

export interface TSDeclareFunction extends NodeBase {
    type: "TSDeclareFunction";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    declare?: boolean;
    id?: Identifier;
    returnType?: TSTypeAnnotation | Noop;
    typeParameters?: TSTypeParameterDeclaration | Noop;
}

export interface TSDeclareMethod extends NodeBase {
    type: "TSDeclareMethod";
    params: LVal[];
    generator?: boolean;
    async?: boolean;
    abstract?: boolean;
    accessibility?: "public" | "private" | "protected";
    static?: boolean;
    computed?: boolean;
    optional?: boolean;
    key: Identifier | StringLiteral | NumericLiteral | Expression;
    kind?: "get" | "set" | "method" | "constructor";
    access?: "public" | "private" | "protected";
    decorators?: Decorator[];
    returnType?: TSTypeAnnotation | Noop;
    typeParameters?: TSTypeParameterDeclaration | Noop;
}

export interface TSQualifiedName extends NodeBase {
    type: "TSQualifiedName";
    left: TSEntityName;
    right: Identifier;
}

export interface TSCallSignatureDeclaration extends NodeBase {
    type: "TSCallSignatureDeclaration";
    typeParameters?: TSTypeParameterDeclaration;
    parameters?: Array<Identifier | RestElement>;
    typeAnnotation?: TSTypeAnnotation;
}

export interface TSConstructSignatureDeclaration extends NodeBase {
    type: "TSConstructSignatureDeclaration";
    typeParameters?: TSTypeParameterDeclaration;
    parameters?: Array<Identifier | RestElement>;
    typeAnnotation?: TSTypeAnnotation;
}

export interface TSPropertySignature extends NodeBase {
    type: "TSPropertySignature";
    key: Expression;
    computed?: boolean;
    optional?: boolean;
    readonly?: boolean;
    typeAnnotation?: TSTypeAnnotation;
    initializer?: Expression;
}

export interface TSMethodSignature extends NodeBase {
    type: "TSMethodSignature";
    typeParameters?: TSTypeParameterDeclaration;
    parameters?: Array<Identifier | RestElement>;
    typeAnnotation?: TSTypeAnnotation;
    key: Expression;
    computed?: boolean;
    optional?: boolean;
}

export interface TSIndexSignature extends NodeBase {
    type: "TSIndexSignature";
    readonly?: boolean;
    parameters: Identifier[];
    typeAnnotation?: TSTypeAnnotation;
}

export interface TSAnyKeyword extends NodeBase {
    type: "TSAnyKeyword";
}

export interface TSNumberKeyword extends NodeBase {
    type: "TSNumberKeyword";
}

export interface TSObjectKeyword extends NodeBase {
    type: "TSObjectKeyword";
}

export interface TSBooleanKeyword extends NodeBase {
    type: "TSBooleanKeyword";
}

export interface TSStringKeyword extends NodeBase {
    type: "TSStringKeyword";
}

export interface TSSymbolKeyword extends NodeBase {
    type: "TSSymbolKeyword";
}

export interface TSVoidKeyword extends NodeBase {
    type: "TSVoidKeyword";
}

export interface TSUndefinedKeyword extends NodeBase {
    type: "TSUndefinedKeyword";
}

export interface TSNullKeyword extends NodeBase {
    type: "TSNullKeyword";
}

export interface TSNeverKeyword extends NodeBase {
    type: "TSNeverKeyword";
}

export interface TSThisType extends NodeBase {
    type: "TSThisType";
}

export interface TSFunctionType extends NodeBase {
    type: "TSFunctionType";
    typeParameters?: TSTypeParameterDeclaration;
    parameters?: Array<Identifier | RestElement>;
    typeAnnotation?: TSTypeAnnotation;
}

export interface TSConstructorType extends NodeBase {
    type: "TSConstructorType";
    typeParameters?: TSTypeParameterDeclaration;
    parameters?: Array<Identifier | RestElement>;
    typeAnnotation?: TSTypeAnnotation;
}

export interface TSTypeReference extends NodeBase {
    type: "TSTypeReference";
    typeName: TSEntityName;
    typeParameters?: TSTypeParameterInstantiation;
}

export interface TSTypePredicate extends NodeBase {
    type: "TSTypePredicate";
    parameterName: Identifier | TSThisType;
    typeAnnotation: TSTypeAnnotation;
}

export interface TSTypeQuery extends NodeBase {
    type: "TSTypeQuery";
    exprName: TSEntityName;
}

export interface TSTypeLiteral extends NodeBase {
    type: "TSTypeLiteral";
    members: TSTypeElement[];
}

export interface TSArrayType extends NodeBase {
    type: "TSArrayType";
    elementType: TSType;
}

export interface TSTupleType extends NodeBase {
    type: "TSTupleType";
    elementTypes: TSType[];
}

export interface TSUnionType extends NodeBase {
    type: "TSUnionType";
    types: TSType[];
}

export interface TSIntersectionType extends NodeBase {
    type: "TSIntersectionType";
    types: TSType[];
}

export interface TSParenthesizedType extends NodeBase {
    type: "TSParenthesizedType";
    typeAnnotation: TSType;
}

export interface TSTypeOperator extends NodeBase {
    type: "TSTypeOperator";
    operator?: string;
    typeAnnotation: TSType;
}

export interface TSIndexedAccessType extends NodeBase {
    type: "TSIndexedAccessType";
    objectType: TSType;
    indexType: TSType;
}

export interface TSMappedType extends NodeBase {
    type: "TSMappedType";
    readonly?: boolean;
    typeParameter: TSTypeParameter;
    optional?: boolean;
    typeAnnotation?: TSType;
}

export interface TSLiteralType extends NodeBase {
    type: "TSLiteralType";
    literal: NumericLiteral | StringLiteral | BooleanLiteral;
}

export interface TSExpressionWithTypeArguments extends NodeBase {
    type: "TSExpressionWithTypeArguments";
    expression: TSEntityName;
    typeParameters?: TSTypeParameterInstantiation;
}

export interface TSInterfaceDeclaration extends NodeBase {
    type: "TSInterfaceDeclaration";
    declare?: boolean;
    id: Identifier;
    typeParameters?: TSTypeParameterDeclaration;
    extends?: TSExpressionWithTypeArguments[];
    body: TSInterfaceBody;
}

export interface TSInterfaceBody extends NodeBase {
    type: "TSInterfaceBody";
    body: TSTypeElement[];
}

export interface TSTypeAliasDeclaration extends NodeBase {
    type: "TSTypeAliasDeclaration";
    declare?: boolean;
    id: Identifier;
    typeParameters?: TSTypeParameterDeclaration;
    typeAnnotation: TSType;
}

export interface TSAsExpression extends NodeBase {
    type: "TSAsExpression";
    expression: Expression;
    typeAnnotation: TSType;
}

export interface TSTypeAssertion extends NodeBase {
    type: "TSTypeAssertion";
    typeAnnotation: TSType;
    expression: Expression;
}

export interface TSEnumDeclaration extends NodeBase {
    type: "TSEnumDeclaration";
    declare?: boolean;
    const?: boolean;
    id: Identifier;
    members: TSEnumMember[];
    initializer?: Expression;
}

export interface TSEnumMember extends NodeBase {
    type: "TSEnumMember";
    id: Identifier | StringLiteral;
    initializer?: Expression;
}

export interface TSModuleDeclaration extends NodeBase {
    type: "TSModuleDeclaration";
    declare?: boolean;
    global?: boolean;
    id: Identifier | StringLiteral;
    body: TSModuleBlock | TSModuleDeclaration;
}

export interface TSModuleBlock extends NodeBase {
    type: "TSModuleBlock";
    body: Statement[];
}

export interface TSImportEqualsDeclaration extends NodeBase {
    type: "TSImportEqualsDeclaration";
    isExport?: boolean;
    id: Identifier;
    moduleReference: TSEntityName | TSExternalModuleReference;
}

export interface TSExternalModuleReference extends NodeBase {
    type: "TSExternalModuleReference";
    expression: StringLiteral;
}

export interface TSNonNullExpression extends NodeBase {
    type: "TSNonNullExpression";
    expression: Expression;
}

export interface TSExportAssignment extends NodeBase {
    type: "TSExportAssignment";
    expression: Expression;
}

export interface TSNamespaceExportDeclaration extends NodeBase {
    type: "TSNamespaceExportDeclaration";
    id: Identifier;
}

export interface TSTypeAnnotation extends NodeBase {
    type: "TSTypeAnnotation";
    typeAnnotation: TSType;
}

export interface TSTypeParameterInstantiation extends NodeBase {
    type: "TSTypeParameterInstantiation";
    params: TSType[];
}

export interface TSTypeParameterDeclaration extends NodeBase {
    type: "TSTypeParameterDeclaration";
    params: TSTypeParameter[];
}

export interface TSTypeParameter extends NodeBase {
    type: "TSTypeParameter";
    name?: string;
    constraint?: TSType;
    default?: TSType;
}

export type Expression =
    | ArrayExpression
    | AssignmentExpression
    | BinaryExpression
    | CallExpression
    | ConditionalExpression
    | FunctionExpression
    | Identifier
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | LogicalExpression
    | MemberExpression
    | NewExpression
    | ObjectExpression
    | SequenceExpression
    | ThisExpression
    | UnaryExpression
    | UpdateExpression
    | ArrowFunctionExpression
    | ClassExpression
    | MetaProperty
    | Super
    | TaggedTemplateExpression
    | TemplateLiteral
    | YieldExpression
    | TypeCastExpression
    | JSXElement
    | JSXFragment
    | ParenthesizedExpression
    | AwaitExpression
    | BindExpression
    | OptionalMemberExpression
    | OptionalCallExpression
    | Import
    | DoExpression
    | TSAsExpression
    | TSTypeAssertion
    | TSNonNullExpression;

export type Binary = BinaryExpression | LogicalExpression;

export type Scopable =
    | BlockStatement
    | CatchClause
    | DoWhileStatement
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | Program
    | ObjectMethod
    | SwitchStatement
    | WhileStatement
    | ArrowFunctionExpression
    | ClassDeclaration
    | ClassExpression
    | ForOfStatement
    | ClassMethod;

export type BlockParent =
    | BlockStatement
    | CatchClause
    | DoWhileStatement
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | Program
    | ObjectMethod
    | SwitchStatement
    | WhileStatement
    | ArrowFunctionExpression
    | ForOfStatement
    | ClassMethod;

export type Block = BlockStatement | Program;

export type Statement =
    | BlockStatement
    | BreakStatement
    | ContinueStatement
    | DebuggerStatement
    | DoWhileStatement
    | EmptyStatement
    | ExpressionStatement
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | IfStatement
    | LabeledStatement
    | ReturnStatement
    | SwitchStatement
    | ThrowStatement
    | TryStatement
    | VariableDeclaration
    | WhileStatement
    | WithStatement
    | ClassDeclaration
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ForOfStatement
    | ImportDeclaration
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | InterfaceDeclaration
    | OpaqueType
    | TypeAlias
    | TSDeclareFunction
    | TSInterfaceDeclaration
    | TSTypeAliasDeclaration
    | TSEnumDeclaration
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExportAssignment
    | TSNamespaceExportDeclaration;

export type Terminatorless =
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | ThrowStatement
    | YieldExpression
    | AwaitExpression;

export type CompletionStatement =
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | ThrowStatement;

export type Conditional = ConditionalExpression | IfStatement;

export type Loop =
    | DoWhileStatement
    | ForInStatement
    | ForStatement
    | WhileStatement
    | ForOfStatement;

export type While = DoWhileStatement | WhileStatement;

export type ExpressionWrapper =
    | ExpressionStatement
    | TypeCastExpression
    | ParenthesizedExpression;

export type For = ForInStatement | ForStatement | ForOfStatement;

export type ForXStatement = ForInStatement | ForOfStatement;

export type FunctionNode =
    | FunctionDeclaration
    | FunctionExpression
    | ObjectMethod
    | ArrowFunctionExpression
    | ClassMethod;

export type FunctionParent =
    | FunctionDeclaration
    | FunctionExpression
    | ObjectMethod
    | ArrowFunctionExpression
    | ClassMethod;

export type Pureish =
    | FunctionDeclaration
    | FunctionExpression
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | ArrowFunctionExpression
    | ClassDeclaration
    | ClassExpression;

export type Declaration =
    | FunctionDeclaration
    | VariableDeclaration
    | ClassDeclaration
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ImportDeclaration
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | InterfaceDeclaration
    | OpaqueType
    | TypeAlias
    | TSDeclareFunction
    | TSInterfaceDeclaration
    | TSTypeAliasDeclaration
    | TSEnumDeclaration
    | TSModuleDeclaration;

export type PatternLike =
    | Identifier
    | RestElement
    | AssignmentPattern
    | ArrayPattern
    | ObjectPattern;

export type LVal =
    | Identifier
    | MemberExpression
    | RestElement
    | AssignmentPattern
    | ArrayPattern
    | ObjectPattern
    | TSParameterProperty;

export type TSEntityName = Identifier | TSQualifiedName;

export type Literal =
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | TemplateLiteral;

export type Immutable =
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | JSXAttribute
    | JSXClosingElement
    | JSXElement
    | JSXExpressionContainer
    | JSXSpreadChild
    | JSXOpeningElement
    | JSXText
    | JSXFragment
    | JSXOpeningFragment
    | JSXClosingFragment;

export type UserWhitespacable =
    | ObjectMethod
    | ObjectProperty
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty;

export type Method = ObjectMethod | ClassMethod;

export type ObjectMember = ObjectMethod | ObjectProperty;

export type Property = ObjectProperty | ClassProperty;

export type UnaryLike = UnaryExpression | SpreadElement;

export type Pattern = AssignmentPattern | ArrayPattern | ObjectPattern;

export type Class = ClassDeclaration | ClassExpression;

export type ModuleDeclaration =
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ImportDeclaration;

export type ExportDeclaration =
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration;

export type ModuleSpecifier =
    | ExportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportSpecifier
    | ExportDefaultSpecifier
    | ExportNamespaceSpecifier;

export type Flow =
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullLiteralTypeAnnotation
    | ClassImplements
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | DeclaredPredicate
    | ExistsTypeAnnotation
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | GenericTypeAnnotation
    | InferredPredicate
    | InterfaceExtends
    | InterfaceDeclaration
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NullableTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | ObjectTypeAnnotation
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | OpaqueType
    | QualifiedTypeIdentifier
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | ThisTypeAnnotation
    | TupleTypeAnnotation
    | TypeofTypeAnnotation
    | TypeAlias
    | TypeAnnotation
    | TypeCastExpression
    | TypeParameter
    | TypeParameterDeclaration
    | TypeParameterInstantiation
    | UnionTypeAnnotation
    | Variance
    | VoidTypeAnnotation;

export type FlowType =
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullLiteralTypeAnnotation
    | ExistsTypeAnnotation
    | FunctionTypeAnnotation
    | GenericTypeAnnotation
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NullableTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | ObjectTypeAnnotation
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | ThisTypeAnnotation
    | TupleTypeAnnotation
    | TypeofTypeAnnotation
    | UnionTypeAnnotation
    | VoidTypeAnnotation;

export type FlowBaseAnnotation =
    | AnyTypeAnnotation
    | BooleanTypeAnnotation
    | NullLiteralTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NumberTypeAnnotation
    | StringTypeAnnotation
    | ThisTypeAnnotation
    | VoidTypeAnnotation;

export type FlowDeclaration =
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | InterfaceDeclaration
    | OpaqueType
    | TypeAlias;

export type FlowPredicate = DeclaredPredicate | InferredPredicate;

export type JSX =
    | JSXAttribute
    | JSXClosingElement
    | JSXElement
    | JSXEmptyExpression
    | JSXExpressionContainer
    | JSXSpreadChild
    | JSXIdentifier
    | JSXMemberExpression
    | JSXNamespacedName
    | JSXOpeningElement
    | JSXSpreadAttribute
    | JSXText
    | JSXFragment
    | JSXOpeningFragment
    | JSXClosingFragment;

export type TSTypeElement =
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSPropertySignature
    | TSMethodSignature
    | TSIndexSignature;

export type TSType =
    | TSAnyKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSBooleanKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSVoidKeyword
    | TSUndefinedKeyword
    | TSNullKeyword
    | TSNeverKeyword
    | TSThisType
    | TSFunctionType
    | TSConstructorType
    | TSTypeReference
    | TSTypePredicate
    | TSTypeQuery
    | TSTypeLiteral
    | TSArrayType
    | TSTupleType
    | TSUnionType
    | TSIntersectionType
    | TSParenthesizedType
    | TSTypeOperator
    | TSIndexedAccessType
    | TSMappedType
    | TSLiteralType
    | TSExpressionWithTypeArguments;

export function anyTypeAnnotation(): AnyTypeAnnotation;
export function arrayExpression(
    elements: ArrayExpression["elements"]
): ArrayExpression;
export function arrayPattern(elements: ArrayPattern["elements"]): ArrayPattern;
export function arrayTypeAnnotation(
    elementType: ArrayTypeAnnotation["elementType"]
): ArrayTypeAnnotation;
export function arrowFunctionExpression(
    params: ArrowFunctionExpression["params"],
    body: ArrowFunctionExpression["body"],
    async: ArrowFunctionExpression["async"]
): ArrowFunctionExpression;
export function assignmentExpression(
    operator: AssignmentExpression["operator"],
    left: AssignmentExpression["left"],
    right: AssignmentExpression["right"]
): AssignmentExpression;
export function assignmentPattern(
    left: AssignmentPattern["left"],
    right: AssignmentPattern["right"]
): AssignmentPattern;
export function awaitExpression(
    argument: AwaitExpression["argument"]
): AwaitExpression;
export function binaryExpression(
    operator: BinaryExpression["operator"],
    left: BinaryExpression["left"],
    right: BinaryExpression["right"]
): BinaryExpression;
export function bindExpression(
    object: BindExpression["object"],
    callee: BindExpression["callee"]
): BindExpression;
export function blockStatement(
    body: BlockStatement["body"],
    directives: BlockStatement["directives"]
): BlockStatement;
export function booleanLiteral(value: BooleanLiteral["value"]): BooleanLiteral;
export function booleanLiteralTypeAnnotation(): BooleanLiteralTypeAnnotation;
export function booleanTypeAnnotation(): BooleanTypeAnnotation;
export function breakStatement(label: BreakStatement["label"]): BreakStatement;
export function callExpression(
    callee: CallExpression["callee"],
    arguments: CallExpression["arguments"]
): CallExpression;
export function catchClause(
    param: CatchClause["param"],
    body: CatchClause["body"]
): CatchClause;
export function classBody(body: ClassBody["body"]): ClassBody;
export function classDeclaration(
    id: ClassDeclaration["id"],
    superClass: ClassDeclaration["superClass"],
    body: ClassDeclaration["body"],
    decorators: ClassDeclaration["decorators"]
): ClassDeclaration;
export function classExpression(
    id: ClassExpression["id"],
    superClass: ClassExpression["superClass"],
    body: ClassExpression["body"],
    decorators: ClassExpression["decorators"]
): ClassExpression;
export function classImplements(
    id: ClassImplements["id"],
    typeParameters: ClassImplements["typeParameters"]
): ClassImplements;
export function classMethod(
    kind: ClassMethod["kind"],
    key: ClassMethod["key"],
    params: ClassMethod["params"],
    body: ClassMethod["body"],
    computed: ClassMethod["computed"],
    static: ClassMethod["static"]
): ClassMethod;
export function classProperty(
    key: ClassProperty["key"],
    value: ClassProperty["value"],
    typeAnnotation: ClassProperty["typeAnnotation"],
    decorators: ClassProperty["decorators"],
    computed: ClassProperty["computed"]
): ClassProperty;
export function conditionalExpression(
    test: ConditionalExpression["test"],
    consequent: ConditionalExpression["consequent"],
    alternate: ConditionalExpression["alternate"]
): ConditionalExpression;
export function continueStatement(
    label: ContinueStatement["label"]
): ContinueStatement;
export function debuggerStatement(): DebuggerStatement;
export function declareClass(
    id: DeclareClass["id"],
    typeParameters: DeclareClass["typeParameters"],
    _extends: DeclareClass["extends"],
    body: DeclareClass["body"]
): DeclareClass;
export function declareExportAllDeclaration(
    source: DeclareExportAllDeclaration["source"]
): DeclareExportAllDeclaration;
export function declareExportDeclaration(
    declaration: DeclareExportDeclaration["declaration"],
    specifiers: DeclareExportDeclaration["specifiers"],
    source: DeclareExportDeclaration["source"]
): DeclareExportDeclaration;
export function declareFunction(id: DeclareFunction["id"]): DeclareFunction;
export function declareInterface(
    id: DeclareInterface["id"],
    typeParameters: DeclareInterface["typeParameters"],
    _extends: DeclareInterface["extends"],
    body: DeclareInterface["body"]
): DeclareInterface;
export function declareModule(
    id: DeclareModule["id"],
    body: DeclareModule["body"],
    kind: DeclareModule["kind"]
): DeclareModule;
export function declareModuleExports(
    typeAnnotation: DeclareModuleExports["typeAnnotation"]
): DeclareModuleExports;
export function declareOpaqueType(
    id: DeclareOpaqueType["id"],
    typeParameters: DeclareOpaqueType["typeParameters"],
    supertype: DeclareOpaqueType["supertype"]
): DeclareOpaqueType;
export function declareTypeAlias(
    id: DeclareTypeAlias["id"],
    typeParameters: DeclareTypeAlias["typeParameters"],
    right: DeclareTypeAlias["right"]
): DeclareTypeAlias;
export function declareVariable(id: DeclareVariable["id"]): DeclareVariable;
export function declaredPredicate(
    value: DeclaredPredicate["value"]
): DeclaredPredicate;
export function decorator(expression: Decorator["expression"]): Decorator;
export function directive(value: Directive["value"]): Directive;
export function directiveLiteral(
    value: DirectiveLiteral["value"]
): DirectiveLiteral;
export function doExpression(body: DoExpression["body"]): DoExpression;
export function doWhileStatement(
    test: DoWhileStatement["test"],
    body: DoWhileStatement["body"]
): DoWhileStatement;
export function emptyStatement(): EmptyStatement;
export function emptyTypeAnnotation(): EmptyTypeAnnotation;
export function existsTypeAnnotation(): ExistsTypeAnnotation;
export function exportAllDeclaration(
    source: ExportAllDeclaration["source"]
): ExportAllDeclaration;
export function exportDefaultDeclaration(
    declaration: ExportDefaultDeclaration["declaration"]
): ExportDefaultDeclaration;
export function exportDefaultSpecifier(
    exported: ExportDefaultSpecifier["exported"]
): ExportDefaultSpecifier;
export function exportNamedDeclaration(
    declaration: ExportNamedDeclaration["declaration"],
    specifiers: ExportNamedDeclaration["specifiers"],
    source: ExportNamedDeclaration["source"]
): ExportNamedDeclaration;
export function exportNamespaceSpecifier(
    exported: ExportNamespaceSpecifier["exported"]
): ExportNamespaceSpecifier;
export function exportSpecifier(
    local: ExportSpecifier["local"],
    exported: ExportSpecifier["exported"]
): ExportSpecifier;
export function expressionStatement(
    expression: ExpressionStatement["expression"]
): ExpressionStatement;
export function file(
    program: File["program"],
    comments: File["comments"],
    tokens: File["tokens"]
): File;
export function forInStatement(
    left: ForInStatement["left"],
    right: ForInStatement["right"],
    body: ForInStatement["body"]
): ForInStatement;
export function forOfStatement(
    left: ForOfStatement["left"],
    right: ForOfStatement["right"],
    body: ForOfStatement["body"]
): ForOfStatement;
export function forStatement(
    init: ForStatement["init"],
    test: ForStatement["test"],
    update: ForStatement["update"],
    body: ForStatement["body"]
): ForStatement;
export function functionDeclaration(
    id: FunctionDeclaration["id"],
    params: FunctionDeclaration["params"],
    body: FunctionDeclaration["body"],
    generator: FunctionDeclaration["generator"],
    async: FunctionDeclaration["async"]
): FunctionDeclaration;
export function functionExpression(
    id: FunctionExpression["id"],
    params: FunctionExpression["params"],
    body: FunctionExpression["body"],
    generator: FunctionExpression["generator"],
    async: FunctionExpression["async"]
): FunctionExpression;
export function functionTypeAnnotation(
    typeParameters: FunctionTypeAnnotation["typeParameters"],
    params: FunctionTypeAnnotation["params"],
    rest: FunctionTypeAnnotation["rest"],
    returnType: FunctionTypeAnnotation["returnType"]
): FunctionTypeAnnotation;
export function functionTypeParam(
    name: FunctionTypeParam["name"],
    typeAnnotation: FunctionTypeParam["typeAnnotation"]
): FunctionTypeParam;
export function genericTypeAnnotation(
    id: GenericTypeAnnotation["id"],
    typeParameters: GenericTypeAnnotation["typeParameters"]
): GenericTypeAnnotation;
export function identifier(name: Identifier["name"]): Identifier;
export function ifStatement(
    test: IfStatement["test"],
    consequent: IfStatement["consequent"],
    alternate: IfStatement["alternate"]
): IfStatement;
export function importDeclaration(
    specifiers: ImportDeclaration["specifiers"],
    source: ImportDeclaration["source"]
): ImportDeclaration;
export function importDefaultSpecifier(
    local: ImportDefaultSpecifier["local"]
): ImportDefaultSpecifier;
export function importNamespaceSpecifier(
    local: ImportNamespaceSpecifier["local"]
): ImportNamespaceSpecifier;
export function importSpecifier(
    local: ImportSpecifier["local"],
    imported: ImportSpecifier["imported"]
): ImportSpecifier;
export function inferredPredicate(): InferredPredicate;
export function interfaceDeclaration(
    id: InterfaceDeclaration["id"],
    typeParameters: InterfaceDeclaration["typeParameters"],
    _extends: InterfaceDeclaration["extends"],
    body: InterfaceDeclaration["body"]
): InterfaceDeclaration;
export function interfaceExtends(
    id: InterfaceExtends["id"],
    typeParameters: InterfaceExtends["typeParameters"]
): InterfaceExtends;
export function intersectionTypeAnnotation(
    types: IntersectionTypeAnnotation["types"]
): IntersectionTypeAnnotation;
export function jSXAttribute(
    name: JSXAttribute["name"],
    value: JSXAttribute["value"]
): JSXAttribute;
export { jSXAttribute as jsxAttribute };
export function jSXClosingElement(
    name: JSXClosingElement["name"]
): JSXClosingElement;
export { jSXClosingElement as jsxClosingElement };
export function jSXClosingFragment(): JSXClosingFragment;
export { jSXClosingFragment as jsxClosingFragment };
export function jSXElement(
    openingElement: JSXElement["openingElement"],
    closingElement: JSXElement["closingElement"],
    children: JSXElement["children"],
    selfClosing: JSXElement["selfClosing"]
): JSXElement;
export { jSXElement as jsxElement };
export function jSXEmptyExpression(): JSXEmptyExpression;
export { jSXEmptyExpression as jsxEmptyExpression };
export function jSXExpressionContainer(
    expression: JSXExpressionContainer["expression"]
): JSXExpressionContainer;
export { jSXExpressionContainer as jsxExpressionContainer };
export function jSXFragment(
    openingFragment: JSXFragment["openingFragment"],
    closingFragment: JSXFragment["closingFragment"],
    children: JSXFragment["children"]
): JSXFragment;
export { jSXFragment as jsxFragment };
export function jSXIdentifier(name: JSXIdentifier["name"]): JSXIdentifier;
export { jSXIdentifier as jsxIdentifier };
export function jSXMemberExpression(
    object: JSXMemberExpression["object"],
    property: JSXMemberExpression["property"]
): JSXMemberExpression;
export { jSXMemberExpression as jsxMemberExpression };
export function jSXNamespacedName(
    namespace: JSXNamespacedName["namespace"],
    name: JSXNamespacedName["name"]
): JSXNamespacedName;
export { jSXNamespacedName as jsxNamespacedName };
export function jSXOpeningElement(
    name: JSXOpeningElement["name"],
    attributes: JSXOpeningElement["attributes"],
    selfClosing: JSXOpeningElement["selfClosing"]
): JSXOpeningElement;
export { jSXOpeningElement as jsxOpeningElement };
export function jSXOpeningFragment(): JSXOpeningFragment;
export { jSXOpeningFragment as jsxOpeningFragment };
export function jSXSpreadAttribute(
    argument: JSXSpreadAttribute["argument"]
): JSXSpreadAttribute;
export { jSXSpreadAttribute as jsxSpreadAttribute };
export function jSXSpreadChild(
    expression: JSXSpreadChild["expression"]
): JSXSpreadChild;
export { jSXSpreadChild as jsxSpreadChild };
export function jSXText(value: JSXText["value"]): JSXText;
export { jSXText as jsxText };
export function labeledStatement(
    label: LabeledStatement["label"],
    body: LabeledStatement["body"]
): LabeledStatement;
export function logicalExpression(
    operator: LogicalExpression["operator"],
    left: LogicalExpression["left"],
    right: LogicalExpression["right"]
): LogicalExpression;
export function memberExpression(
    object: MemberExpression["object"],
    property: MemberExpression["property"],
    computed: MemberExpression["computed"],
    optional: MemberExpression["optional"]
): MemberExpression;
export function metaProperty(
    meta: MetaProperty["meta"],
    property: MetaProperty["property"]
): MetaProperty;
export function mixedTypeAnnotation(): MixedTypeAnnotation;
export function newExpression(
    callee: NewExpression["callee"],
    arguments: NewExpression["arguments"]
): NewExpression;
export function noop(): Noop;
export function nullLiteral(): NullLiteral;
export function nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation;
export function nullableTypeAnnotation(
    typeAnnotation: NullableTypeAnnotation["typeAnnotation"]
): NullableTypeAnnotation;
export function numberLiteralTypeAnnotation(): NumberLiteralTypeAnnotation;
export function numberTypeAnnotation(): NumberTypeAnnotation;
export function numericLiteral(value: NumericLiteral["value"]): NumericLiteral;
export function objectExpression(
    properties: ObjectExpression["properties"]
): ObjectExpression;
export function objectMethod(
    kind: ObjectMethod["kind"],
    key: ObjectMethod["key"],
    params: ObjectMethod["params"],
    body: ObjectMethod["body"],
    computed: ObjectMethod["computed"]
): ObjectMethod;
export function objectPattern(
    properties: ObjectPattern["properties"]
): ObjectPattern;
export function objectProperty(
    key: ObjectProperty["key"],
    value: ObjectProperty["value"],
    computed: ObjectProperty["computed"],
    shorthand: ObjectProperty["shorthand"],
    decorators: ObjectProperty["decorators"]
): ObjectProperty;
export function objectTypeAnnotation(
    properties: ObjectTypeAnnotation["properties"],
    indexers: ObjectTypeAnnotation["indexers"],
    callProperties: ObjectTypeAnnotation["callProperties"]
): ObjectTypeAnnotation;
export function objectTypeCallProperty(
    value: ObjectTypeCallProperty["value"]
): ObjectTypeCallProperty;
export function objectTypeIndexer(
    id: ObjectTypeIndexer["id"],
    key: ObjectTypeIndexer["key"],
    value: ObjectTypeIndexer["value"],
    variance: ObjectTypeIndexer["variance"]
): ObjectTypeIndexer;
export function objectTypeProperty(
    key: ObjectTypeProperty["key"],
    value: ObjectTypeProperty["value"],
    variance: ObjectTypeProperty["variance"]
): ObjectTypeProperty;
export function objectTypeSpreadProperty(
    argument: ObjectTypeSpreadProperty["argument"]
): ObjectTypeSpreadProperty;
export function opaqueType(
    id: OpaqueType["id"],
    typeParameters: OpaqueType["typeParameters"],
    supertype: OpaqueType["supertype"],
    impltype: OpaqueType["impltype"]
): OpaqueType;
export function optionalCallExpression(
    callee: OptionalCallExpression["callee"],
    arguments: OptionalCallExpression["arguments"],
    optional: OptionalCallExpression["optional"]
): OptionalCallExpression;
export function optionalMemberExpression(
    object: OptionalMemberExpression["object"],
    property: OptionalMemberExpression["property"],
    computed: OptionalMemberExpression["computed"],
    optional: OptionalMemberExpression["optional"]
): OptionalMemberExpression;
export function parenthesizedExpression(
    expression: ParenthesizedExpression["expression"]
): ParenthesizedExpression;
export function program(
    body: Program["body"],
    directives: Program["directives"],
    sourceType: Program["sourceType"]
): Program;
export function qualifiedTypeIdentifier(
    id: QualifiedTypeIdentifier["id"],
    qualification: QualifiedTypeIdentifier["qualification"]
): QualifiedTypeIdentifier;
export function regExpLiteral(
    pattern: RegExpLiteral["pattern"],
    flags: RegExpLiteral["flags"]
): RegExpLiteral;
export function restElement(argument: RestElement["argument"]): RestElement;
export function returnStatement(
    argument: ReturnStatement["argument"]
): ReturnStatement;
export function sequenceExpression(
    expressions: SequenceExpression["expressions"]
): SequenceExpression;
export function spreadElement(
    argument: SpreadElement["argument"]
): SpreadElement;
export function stringLiteral(value: StringLiteral["value"]): StringLiteral;
export function stringLiteralTypeAnnotation(): StringLiteralTypeAnnotation;
export function stringTypeAnnotation(): StringTypeAnnotation;
export function switchCase(
    test: SwitchCase["test"],
    consequent: SwitchCase["consequent"]
): SwitchCase;
export function switchStatement(
    discriminant: SwitchStatement["discriminant"],
    cases: SwitchStatement["cases"]
): SwitchStatement;
export function tSAnyKeyword(): TSAnyKeyword;
export { tSAnyKeyword as tsAnyKeyword };
export function tSArrayType(
    elementType: TSArrayType["elementType"]
): TSArrayType;
export { tSArrayType as tsArrayType };
export function tSAsExpression(
    expression: TSAsExpression["expression"],
    typeAnnotation: TSAsExpression["typeAnnotation"]
): TSAsExpression;
export { tSAsExpression as tsAsExpression };
export function tSBooleanKeyword(): TSBooleanKeyword;
export { tSBooleanKeyword as tsBooleanKeyword };
export function tSCallSignatureDeclaration(
    typeParameters: TSCallSignatureDeclaration["typeParameters"],
    parameters: TSCallSignatureDeclaration["parameters"],
    typeAnnotation: TSCallSignatureDeclaration["typeAnnotation"]
): TSCallSignatureDeclaration;
export { tSCallSignatureDeclaration as tsCallSignatureDeclaration };
export function tSConstructSignatureDeclaration(
    typeParameters: TSConstructSignatureDeclaration["typeParameters"],
    parameters: TSConstructSignatureDeclaration["parameters"],
    typeAnnotation: TSConstructSignatureDeclaration["typeAnnotation"]
): TSConstructSignatureDeclaration;
export { tSConstructSignatureDeclaration as tsConstructSignatureDeclaration };
export function tSConstructorType(
    typeParameters: TSConstructorType["typeParameters"],
    typeAnnotation: TSConstructorType["typeAnnotation"]
): TSConstructorType;
export { tSConstructorType as tsConstructorType };
export function tSDeclareFunction(
    id: TSDeclareFunction["id"],
    typeParameters: TSDeclareFunction["typeParameters"],
    params: TSDeclareFunction["params"],
    returnType: TSDeclareFunction["returnType"]
): TSDeclareFunction;
export { tSDeclareFunction as tsDeclareFunction };
export function tSDeclareMethod(
    decorators: TSDeclareMethod["decorators"],
    key: TSDeclareMethod["key"],
    typeParameters: TSDeclareMethod["typeParameters"],
    params: TSDeclareMethod["params"],
    returnType: TSDeclareMethod["returnType"]
): TSDeclareMethod;
export { tSDeclareMethod as tsDeclareMethod };
export function tSEnumDeclaration(
    id: TSEnumDeclaration["id"],
    members: TSEnumDeclaration["members"]
): TSEnumDeclaration;
export { tSEnumDeclaration as tsEnumDeclaration };
export function tSEnumMember(
    id: TSEnumMember["id"],
    initializer: TSEnumMember["initializer"]
): TSEnumMember;
export { tSEnumMember as tsEnumMember };
export function tSExportAssignment(
    expression: TSExportAssignment["expression"]
): TSExportAssignment;
export { tSExportAssignment as tsExportAssignment };
export function tSExpressionWithTypeArguments(
    expression: TSExpressionWithTypeArguments["expression"],
    typeParameters: TSExpressionWithTypeArguments["typeParameters"]
): TSExpressionWithTypeArguments;
export { tSExpressionWithTypeArguments as tsExpressionWithTypeArguments };
export function tSExternalModuleReference(
    expression: TSExternalModuleReference["expression"]
): TSExternalModuleReference;
export { tSExternalModuleReference as tsExternalModuleReference };
export function tSFunctionType(
    typeParameters: TSFunctionType["typeParameters"],
    typeAnnotation: TSFunctionType["typeAnnotation"]
): TSFunctionType;
export { tSFunctionType as tsFunctionType };
export function tSImportEqualsDeclaration(
    id: TSImportEqualsDeclaration["id"],
    moduleReference: TSImportEqualsDeclaration["moduleReference"]
): TSImportEqualsDeclaration;
export { tSImportEqualsDeclaration as tsImportEqualsDeclaration };
export function tSIndexSignature(
    parameters: TSIndexSignature["parameters"],
    typeAnnotation: TSIndexSignature["typeAnnotation"]
): TSIndexSignature;
export { tSIndexSignature as tsIndexSignature };
export function tSIndexedAccessType(
    objectType: TSIndexedAccessType["objectType"],
    indexType: TSIndexedAccessType["indexType"]
): TSIndexedAccessType;
export { tSIndexedAccessType as tsIndexedAccessType };
export function tSInterfaceBody(body: TSInterfaceBody["body"]): TSInterfaceBody;
export { tSInterfaceBody as tsInterfaceBody };
export function tSInterfaceDeclaration(
    id: TSInterfaceDeclaration["id"],
    typeParameters: TSInterfaceDeclaration["typeParameters"],
    _extends: TSInterfaceDeclaration["extends"],
    body: TSInterfaceDeclaration["body"]
): TSInterfaceDeclaration;
export { tSInterfaceDeclaration as tsInterfaceDeclaration };
export function tSIntersectionType(
    types: TSIntersectionType["types"]
): TSIntersectionType;
export { tSIntersectionType as tsIntersectionType };
export function tSLiteralType(literal: TSLiteralType["literal"]): TSLiteralType;
export { tSLiteralType as tsLiteralType };
export function tSMappedType(
    typeParameter: TSMappedType["typeParameter"],
    typeAnnotation: TSMappedType["typeAnnotation"]
): TSMappedType;
export { tSMappedType as tsMappedType };
export function tSMethodSignature(
    key: TSMethodSignature["key"],
    typeParameters: TSMethodSignature["typeParameters"],
    parameters: TSMethodSignature["parameters"],
    typeAnnotation: TSMethodSignature["typeAnnotation"]
): TSMethodSignature;
export { tSMethodSignature as tsMethodSignature };
export function tSModuleBlock(body: TSModuleBlock["body"]): TSModuleBlock;
export { tSModuleBlock as tsModuleBlock };
export function tSModuleDeclaration(
    id: TSModuleDeclaration["id"],
    body: TSModuleDeclaration["body"]
): TSModuleDeclaration;
export { tSModuleDeclaration as tsModuleDeclaration };
export function tSNamespaceExportDeclaration(
    id: TSNamespaceExportDeclaration["id"]
): TSNamespaceExportDeclaration;
export { tSNamespaceExportDeclaration as tsNamespaceExportDeclaration };
export function tSNeverKeyword(): TSNeverKeyword;
export { tSNeverKeyword as tsNeverKeyword };
export function tSNonNullExpression(
    expression: TSNonNullExpression["expression"]
): TSNonNullExpression;
export { tSNonNullExpression as tsNonNullExpression };
export function tSNullKeyword(): TSNullKeyword;
export { tSNullKeyword as tsNullKeyword };
export function tSNumberKeyword(): TSNumberKeyword;
export { tSNumberKeyword as tsNumberKeyword };
export function tSObjectKeyword(): TSObjectKeyword;
export { tSObjectKeyword as tsObjectKeyword };
export function tSParameterProperty(
    parameter: TSParameterProperty["parameter"]
): TSParameterProperty;
export { tSParameterProperty as tsParameterProperty };
export function tSParenthesizedType(
    typeAnnotation: TSParenthesizedType["typeAnnotation"]
): TSParenthesizedType;
export { tSParenthesizedType as tsParenthesizedType };
export function tSPropertySignature(
    key: TSPropertySignature["key"],
    typeAnnotation: TSPropertySignature["typeAnnotation"],
    initializer: TSPropertySignature["initializer"]
): TSPropertySignature;
export { tSPropertySignature as tsPropertySignature };
export function tSQualifiedName(
    left: TSQualifiedName["left"],
    right: TSQualifiedName["right"]
): TSQualifiedName;
export { tSQualifiedName as tsQualifiedName };
export function tSStringKeyword(): TSStringKeyword;
export { tSStringKeyword as tsStringKeyword };
export function tSSymbolKeyword(): TSSymbolKeyword;
export { tSSymbolKeyword as tsSymbolKeyword };
export function tSThisType(): TSThisType;
export { tSThisType as tsThisType };
export function tSTupleType(
    elementTypes: TSTupleType["elementTypes"]
): TSTupleType;
export { tSTupleType as tsTupleType };
export function tSTypeAliasDeclaration(
    id: TSTypeAliasDeclaration["id"],
    typeParameters: TSTypeAliasDeclaration["typeParameters"],
    typeAnnotation: TSTypeAliasDeclaration["typeAnnotation"]
): TSTypeAliasDeclaration;
export { tSTypeAliasDeclaration as tsTypeAliasDeclaration };
export function tSTypeAnnotation(
    typeAnnotation: TSTypeAnnotation["typeAnnotation"]
): TSTypeAnnotation;
export { tSTypeAnnotation as tsTypeAnnotation };
export function tSTypeAssertion(
    typeAnnotation: TSTypeAssertion["typeAnnotation"],
    expression: TSTypeAssertion["expression"]
): TSTypeAssertion;
export { tSTypeAssertion as tsTypeAssertion };
export function tSTypeLiteral(members: TSTypeLiteral["members"]): TSTypeLiteral;
export { tSTypeLiteral as tsTypeLiteral };
export function tSTypeOperator(
    typeAnnotation: TSTypeOperator["typeAnnotation"]
): TSTypeOperator;
export { tSTypeOperator as tsTypeOperator };
export function tSTypeParameter(
    constraint: TSTypeParameter["constraint"],
    _default: TSTypeParameter["default"]
): TSTypeParameter;
export { tSTypeParameter as tsTypeParameter };
export function tSTypeParameterDeclaration(
    params: TSTypeParameterDeclaration["params"]
): TSTypeParameterDeclaration;
export { tSTypeParameterDeclaration as tsTypeParameterDeclaration };
export function tSTypeParameterInstantiation(
    params: TSTypeParameterInstantiation["params"]
): TSTypeParameterInstantiation;
export { tSTypeParameterInstantiation as tsTypeParameterInstantiation };
export function tSTypePredicate(
    parameterName: TSTypePredicate["parameterName"],
    typeAnnotation: TSTypePredicate["typeAnnotation"]
): TSTypePredicate;
export { tSTypePredicate as tsTypePredicate };
export function tSTypeQuery(exprName: TSTypeQuery["exprName"]): TSTypeQuery;
export { tSTypeQuery as tsTypeQuery };
export function tSTypeReference(
    typeName: TSTypeReference["typeName"],
    typeParameters: TSTypeReference["typeParameters"]
): TSTypeReference;
export { tSTypeReference as tsTypeReference };
export function tSUndefinedKeyword(): TSUndefinedKeyword;
export { tSUndefinedKeyword as tsUndefinedKeyword };
export function tSUnionType(types: TSUnionType["types"]): TSUnionType;
export { tSUnionType as tsUnionType };
export function tSVoidKeyword(): TSVoidKeyword;
export { tSVoidKeyword as tsVoidKeyword };
export function taggedTemplateExpression(
    tag: TaggedTemplateExpression["tag"],
    quasi: TaggedTemplateExpression["quasi"]
): TaggedTemplateExpression;
export function templateElement(
    value: TemplateElement["value"],
    tail: TemplateElement["tail"]
): TemplateElement;
export function templateLiteral(
    quasis: TemplateLiteral["quasis"],
    expressions: TemplateLiteral["expressions"]
): TemplateLiteral;
export function thisExpression(): ThisExpression;
export function thisTypeAnnotation(): ThisTypeAnnotation;
export function throwStatement(
    argument: ThrowStatement["argument"]
): ThrowStatement;
export function tryStatement(
    block: TryStatement["block"],
    handler: TryStatement["handler"],
    finalizer: TryStatement["finalizer"]
): TryStatement;
export function tupleTypeAnnotation(
    types: TupleTypeAnnotation["types"]
): TupleTypeAnnotation;
export function typeAlias(
    id: TypeAlias["id"],
    typeParameters: TypeAlias["typeParameters"],
    right: TypeAlias["right"]
): TypeAlias;
export function typeAnnotation(
    typeAnnotation: TypeAnnotation["typeAnnotation"]
): TypeAnnotation;
export function typeCastExpression(
    expression: TypeCastExpression["expression"],
    typeAnnotation: TypeCastExpression["typeAnnotation"]
): TypeCastExpression;
export function typeParameter(
    bound: TypeParameter["bound"],
    _default: TypeParameter["default"],
    variance: TypeParameter["variance"]
): TypeParameter;
export function typeParameterDeclaration(
    params: TypeParameterDeclaration["params"]
): TypeParameterDeclaration;
export function typeParameterInstantiation(
    params: TypeParameterInstantiation["params"]
): TypeParameterInstantiation;
export function typeofTypeAnnotation(
    argument: TypeofTypeAnnotation["argument"]
): TypeofTypeAnnotation;
export function unaryExpression(
    operator: UnaryExpression["operator"],
    argument: UnaryExpression["argument"],
    prefix: UnaryExpression["prefix"]
): UnaryExpression;
export function unionTypeAnnotation(
    types: UnionTypeAnnotation["types"]
): UnionTypeAnnotation;
export function updateExpression(
    operator: UpdateExpression["operator"],
    argument: UpdateExpression["argument"],
    prefix: UpdateExpression["prefix"]
): UpdateExpression;
export function variableDeclaration(
    kind: VariableDeclaration["kind"],
    declarations: VariableDeclaration["declarations"]
): VariableDeclaration;
export function variableDeclarator(
    id: VariableDeclarator["id"],
    init: VariableDeclarator["init"]
): VariableDeclarator;
export function variance(kind: Variance["kind"]): Variance;
export function voidTypeAnnotation(): VoidTypeAnnotation;
export function whileStatement(
    test: WhileStatement["test"],
    body: WhileStatement["body"]
): WhileStatement;
export function withStatement(
    object: WithStatement["object"],
    body: WithStatement["body"]
): WithStatement;
export function yieldExpression(
    argument: YieldExpression["argument"],
    delegate: YieldExpression["delegate"]
): YieldExpression;

export function isNode(node: object): node is BabelNode;
export function isAnyTypeAnnotation(
    node?: object,
    opts?: object
): node is AnyTypeAnnotation;
export function isArrayExpression(
    node?: object,
    opts?: object
): node is ArrayExpression;
export function isArrayPattern(
    node?: object,
    opts?: object
): node is ArrayPattern;
export function isArrayTypeAnnotation(
    node?: object,
    opts?: object
): node is ArrayTypeAnnotation;
export function isArrowFunctionExpression(
    node?: object,
    opts?: object
): node is ArrowFunctionExpression;
export function isAssignmentExpression(
    node?: object,
    opts?: object
): node is AssignmentExpression;
export function isAssignmentPattern(
    node?: object,
    opts?: object
): node is AssignmentPattern;
export function isAwaitExpression(
    node?: object,
    opts?: object
): node is AwaitExpression;
export function isBinary(node?: object, opts?: object): node is Binary;
export function isBinaryExpression(
    node?: object,
    opts?: object
): node is BinaryExpression;
export function isBindExpression(
    node?: object,
    opts?: object
): node is BindExpression;
export function isBlock(node?: object, opts?: object): node is Block;
export function isBlockParent(
    node?: object,
    opts?: object
): node is BlockParent;
export function isBlockStatement(
    node?: object,
    opts?: object
): node is BlockStatement;
export function isBooleanLiteral(
    node?: object,
    opts?: object
): node is BooleanLiteral;
export function isBooleanLiteralTypeAnnotation(
    node?: object,
    opts?: object
): node is BooleanLiteralTypeAnnotation;
export function isBooleanTypeAnnotation(
    node?: object,
    opts?: object
): node is BooleanTypeAnnotation;
export function isBreakStatement(
    node?: object,
    opts?: object
): node is BreakStatement;
export function isCallExpression(
    node?: object,
    opts?: object
): node is CallExpression;
export function isCatchClause(
    node?: object,
    opts?: object
): node is CatchClause;
export function isClass(node?: object, opts?: object): node is Class;
export function isClassBody(node?: object, opts?: object): node is ClassBody;
export function isClassDeclaration(
    node?: object,
    opts?: object
): node is ClassDeclaration;
export function isClassExpression(
    node?: object,
    opts?: object
): node is ClassExpression;
export function isClassImplements(
    node?: object,
    opts?: object
): node is ClassImplements;
export function isClassMethod(
    node?: object,
    opts?: object
): node is ClassMethod;
export function isClassProperty(
    node?: object,
    opts?: object
): node is ClassProperty;
export function isCompletionStatement(
    node?: object,
    opts?: object
): node is CompletionStatement;
export function isConditional(
    node?: object,
    opts?: object
): node is Conditional;
export function isConditionalExpression(
    node?: object,
    opts?: object
): node is ConditionalExpression;
export function isContinueStatement(
    node?: object,
    opts?: object
): node is ContinueStatement;
export function isDebuggerStatement(
    node?: object,
    opts?: object
): node is DebuggerStatement;
export function isDeclaration(
    node?: object,
    opts?: object
): node is Declaration;
export function isDeclareClass(
    node?: object,
    opts?: object
): node is DeclareClass;
export function isDeclareExportAllDeclaration(
    node?: object,
    opts?: object
): node is DeclareExportAllDeclaration;
export function isDeclareExportDeclaration(
    node?: object,
    opts?: object
): node is DeclareExportDeclaration;
export function isDeclareFunction(
    node?: object,
    opts?: object
): node is DeclareFunction;
export function isDeclareInterface(
    node?: object,
    opts?: object
): node is DeclareInterface;
export function isDeclareModule(
    node?: object,
    opts?: object
): node is DeclareModule;
export function isDeclareModuleExports(
    node?: object,
    opts?: object
): node is DeclareModuleExports;
export function isDeclareOpaqueType(
    node?: object,
    opts?: object
): node is DeclareOpaqueType;
export function isDeclareTypeAlias(
    node?: object,
    opts?: object
): node is DeclareTypeAlias;
export function isDeclareVariable(
    node?: object,
    opts?: object
): node is DeclareVariable;
export function isDeclaredPredicate(
    node?: object,
    opts?: object
): node is DeclaredPredicate;
export function isDecorator(node?: object, opts?: object): node is Decorator;
export function isDirective(node?: object, opts?: object): node is Directive;
export function isDirectiveLiteral(
    node?: object,
    opts?: object
): node is DirectiveLiteral;
export function isDoExpression(
    node?: object,
    opts?: object
): node is DoExpression;
export function isDoWhileStatement(
    node?: object,
    opts?: object
): node is DoWhileStatement;
export function isEmptyStatement(
    node?: object,
    opts?: object
): node is EmptyStatement;
export function isEmptyTypeAnnotation(
    node?: object,
    opts?: object
): node is EmptyTypeAnnotation;
export function isExistsTypeAnnotation(
    node?: object,
    opts?: object
): node is ExistsTypeAnnotation;
export function isExportAllDeclaration(
    node?: object,
    opts?: object
): node is ExportAllDeclaration;
export function isExportDeclaration(
    node?: object,
    opts?: object
): node is ExportDeclaration;
export function isExportDefaultDeclaration(
    node?: object,
    opts?: object
): node is ExportDefaultDeclaration;
export function isExportDefaultSpecifier(
    node?: object,
    opts?: object
): node is ExportDefaultSpecifier;
export function isExportNamedDeclaration(
    node?: object,
    opts?: object
): node is ExportNamedDeclaration;
export function isExportNamespaceSpecifier(
    node?: object,
    opts?: object
): node is ExportNamespaceSpecifier;
export function isExportSpecifier(
    node?: object,
    opts?: object
): node is ExportSpecifier;
export function isExpression(node?: object, opts?: object): node is Expression;
export function isExpressionStatement(
    node?: object,
    opts?: object
): node is ExpressionStatement;
export function isExpressionWrapper(
    node?: object,
    opts?: object
): node is ExpressionWrapper;
export function isFile(node?: object, opts?: object): node is File;
export function isFlow(node?: object, opts?: object): node is Flow;
export function isFlowBaseAnnotation(
    node?: object,
    opts?: object
): node is FlowBaseAnnotation;
export function isFlowDeclaration(
    node?: object,
    opts?: object
): node is FlowDeclaration;
export function isFlowPredicate(
    node?: object,
    opts?: object
): node is FlowPredicate;
export function isFlowType(node?: object, opts?: object): node is FlowType;
export function isFor(node?: object, opts?: object): node is For;
export function isForInStatement(
    node?: object,
    opts?: object
): node is ForInStatement;
export function isForOfStatement(
    node?: object,
    opts?: object
): node is ForOfStatement;
export function isForStatement(
    node?: object,
    opts?: object
): node is ForStatement;
export function isForXStatement(
    node?: object,
    opts?: object
): node is ForXStatement;
export function isFunction(node?: object, opts?: object): node is FunctionNode;
export function isFunctionDeclaration(
    node?: object,
    opts?: object
): node is FunctionDeclaration;
export function isFunctionExpression(
    node?: object,
    opts?: object
): node is FunctionExpression;
export function isFunctionParent(
    node?: object,
    opts?: object
): node is FunctionParent;
export function isFunctionTypeAnnotation(
    node?: object,
    opts?: object
): node is FunctionTypeAnnotation;
export function isFunctionTypeParam(
    node?: object,
    opts?: object
): node is FunctionTypeParam;
export function isGenericTypeAnnotation(
    node?: object,
    opts?: object
): node is GenericTypeAnnotation;
export function isIdentifier(node?: object, opts?: object): node is Identifier;
export function isIfStatement(
    node?: object,
    opts?: object
): node is IfStatement;
export function isImmutable(node?: object, opts?: object): node is Immutable;
export function isImport(node?: object, opts?: object): node is Import;
export function isImportDeclaration(
    node?: object,
    opts?: object
): node is ImportDeclaration;
export function isImportDefaultSpecifier(
    node?: object,
    opts?: object
): node is ImportDefaultSpecifier;
export function isImportNamespaceSpecifier(
    node?: object,
    opts?: object
): node is ImportNamespaceSpecifier;
export function isImportSpecifier(
    node?: object,
    opts?: object
): node is ImportSpecifier;
export function isInferredPredicate(
    node?: object,
    opts?: object
): node is InferredPredicate;
export function isInterfaceDeclaration(
    node?: object,
    opts?: object
): node is InterfaceDeclaration;
export function isInterfaceExtends(
    node?: object,
    opts?: object
): node is InterfaceExtends;
export function isIntersectionTypeAnnotation(
    node?: object,
    opts?: object
): node is IntersectionTypeAnnotation;
export function isJSX(node?: object, opts?: object): node is JSX;
export function isJSXAttribute(
    node?: object,
    opts?: object
): node is JSXAttribute;
export function isJSXClosingElement(
    node?: object,
    opts?: object
): node is JSXClosingElement;
export function isJSXClosingFragment(
    node?: object,
    opts?: object
): node is JSXClosingFragment;
export function isJSXElement(node?: object, opts?: object): node is JSXElement;
export function isJSXEmptyExpression(
    node?: object,
    opts?: object
): node is JSXEmptyExpression;
export function isJSXExpressionContainer(
    node?: object,
    opts?: object
): node is JSXExpressionContainer;
export function isJSXFragment(
    node?: object,
    opts?: object
): node is JSXFragment;
export function isJSXIdentifier(
    node?: object,
    opts?: object
): node is JSXIdentifier;
export function isJSXMemberExpression(
    node?: object,
    opts?: object
): node is JSXMemberExpression;
export function isJSXNamespacedName(
    node?: object,
    opts?: object
): node is JSXNamespacedName;
export function isJSXOpeningElement(
    node?: object,
    opts?: object
): node is JSXOpeningElement;
export function isJSXOpeningFragment(
    node?: object,
    opts?: object
): node is JSXOpeningFragment;
export function isJSXSpreadAttribute(
    node?: object,
    opts?: object
): node is JSXSpreadAttribute;
export function isJSXSpreadChild(
    node?: object,
    opts?: object
): node is JSXSpreadChild;
export function isJSXText(node?: object, opts?: object): node is JSXText;
export function isLVal(node?: object, opts?: object): node is LVal;
export function isLabeledStatement(
    node?: object,
    opts?: object
): node is LabeledStatement;
export function isLiteral(node?: object, opts?: object): node is Literal;
export function isLogicalExpression(
    node?: object,
    opts?: object
): node is LogicalExpression;
export function isLoop(node?: object, opts?: object): node is Loop;
export function isMemberExpression(
    node?: object,
    opts?: object
): node is MemberExpression;
export function isMetaProperty(
    node?: object,
    opts?: object
): node is MetaProperty;
export function isMethod(node?: object, opts?: object): node is Method;
export function isMixedTypeAnnotation(
    node?: object,
    opts?: object
): node is MixedTypeAnnotation;
export function isModuleDeclaration(
    node?: object,
    opts?: object
): node is ModuleDeclaration;
export function isModuleSpecifier(
    node?: object,
    opts?: object
): node is ModuleSpecifier;
export function isNewExpression(
    node?: object,
    opts?: object
): node is NewExpression;
export function isNoop(node?: object, opts?: object): node is Noop;
export function isNullLiteral(
    node?: object,
    opts?: object
): node is NullLiteral;
export function isNullLiteralTypeAnnotation(
    node?: object,
    opts?: object
): node is NullLiteralTypeAnnotation;
export function isNullableTypeAnnotation(
    node?: object,
    opts?: object
): node is NullableTypeAnnotation;
export function isNumberLiteralTypeAnnotation(
    node?: object,
    opts?: object
): node is NumberLiteralTypeAnnotation;
export function isNumberTypeAnnotation(
    node?: object,
    opts?: object
): node is NumberTypeAnnotation;
export function isNumericLiteral(
    node?: object,
    opts?: object
): node is NumericLiteral;
export function isObjectExpression(
    node?: object,
    opts?: object
): node is ObjectExpression;
export function isObjectMember(
    node?: object,
    opts?: object
): node is ObjectMember;
export function isObjectMethod(
    node?: object,
    opts?: object
): node is ObjectMethod;
export function isObjectPattern(
    node?: object,
    opts?: object
): node is ObjectPattern;
export function isObjectProperty(
    node?: object,
    opts?: object
): node is ObjectProperty;
export function isObjectTypeAnnotation(
    node?: object,
    opts?: object
): node is ObjectTypeAnnotation;
export function isObjectTypeCallProperty(
    node?: object,
    opts?: object
): node is ObjectTypeCallProperty;
export function isObjectTypeIndexer(
    node?: object,
    opts?: object
): node is ObjectTypeIndexer;
export function isObjectTypeProperty(
    node?: object,
    opts?: object
): node is ObjectTypeProperty;
export function isObjectTypeSpreadProperty(
    node?: object,
    opts?: object
): node is ObjectTypeSpreadProperty;
export function isOpaqueType(node?: object, opts?: object): node is OpaqueType;
export function isOptionalCallExpression(
    node?: object,
    opts?: object
): node is OptionalCallExpression;
export function isOptionalMemberExpression(
    node?: object,
    opts?: object
): node is OptionalMemberExpression;
export function isParenthesizedExpression(
    node?: object,
    opts?: object
): node is ParenthesizedExpression;
export function isPattern(node?: object, opts?: object): node is Pattern;
export function isPatternLike(
    node?: object,
    opts?: object
): node is PatternLike;
export function isProgram(node?: object, opts?: object): node is Program;
export function isProperty(node?: object, opts?: object): node is Property;
export function isPureish(node?: object, opts?: object): node is Pureish;
export function isQualifiedTypeIdentifier(
    node?: object,
    opts?: object
): node is QualifiedTypeIdentifier;
export function isRegExpLiteral(
    node?: object,
    opts?: object
): node is RegExpLiteral;
export function isRestElement(
    node?: object,
    opts?: object
): node is RestElement;
export function isReturnStatement(
    node?: object,
    opts?: object
): node is ReturnStatement;
export function isScopable(node?: object, opts?: object): node is Scopable;
export function isSequenceExpression(
    node?: object,
    opts?: object
): node is SequenceExpression;
export function isSpreadElement(
    node?: object,
    opts?: object
): node is SpreadElement;
export function isStatement(node?: object, opts?: object): node is Statement;
export function isStringLiteral(
    node?: object,
    opts?: object
): node is StringLiteral;
export function isStringLiteralTypeAnnotation(
    node?: object,
    opts?: object
): node is StringLiteralTypeAnnotation;
export function isStringTypeAnnotation(
    node?: object,
    opts?: object
): node is StringTypeAnnotation;
export function isSuper(node?: object, opts?: object): node is Super;
export function isSwitchCase(node?: object, opts?: object): node is SwitchCase;
export function isSwitchStatement(
    node?: object,
    opts?: object
): node is SwitchStatement;
export function isTSAnyKeyword(
    node?: object,
    opts?: object
): node is TSAnyKeyword;
export function isTSArrayType(
    node?: object,
    opts?: object
): node is TSArrayType;
export function isTSAsExpression(
    node?: object,
    opts?: object
): node is TSAsExpression;
export function isTSBooleanKeyword(
    node?: object,
    opts?: object
): node is TSBooleanKeyword;
export function isTSCallSignatureDeclaration(
    node?: object,
    opts?: object
): node is TSCallSignatureDeclaration;
export function isTSConstructSignatureDeclaration(
    node?: object,
    opts?: object
): node is TSConstructSignatureDeclaration;
export function isTSConstructorType(
    node?: object,
    opts?: object
): node is TSConstructorType;
export function isTSDeclareFunction(
    node?: object,
    opts?: object
): node is TSDeclareFunction;
export function isTSDeclareMethod(
    node?: object,
    opts?: object
): node is TSDeclareMethod;
export function isTSEntityName(
    node?: object,
    opts?: object
): node is TSEntityName;
export function isTSEnumDeclaration(
    node?: object,
    opts?: object
): node is TSEnumDeclaration;
export function isTSEnumMember(
    node?: object,
    opts?: object
): node is TSEnumMember;
export function isTSExportAssignment(
    node?: object,
    opts?: object
): node is TSExportAssignment;
export function isTSExpressionWithTypeArguments(
    node?: object,
    opts?: object
): node is TSExpressionWithTypeArguments;
export function isTSExternalModuleReference(
    node?: object,
    opts?: object
): node is TSExternalModuleReference;
export function isTSFunctionType(
    node?: object,
    opts?: object
): node is TSFunctionType;
export function isTSImportEqualsDeclaration(
    node?: object,
    opts?: object
): node is TSImportEqualsDeclaration;
export function isTSIndexSignature(
    node?: object,
    opts?: object
): node is TSIndexSignature;
export function isTSIndexedAccessType(
    node?: object,
    opts?: object
): node is TSIndexedAccessType;
export function isTSInterfaceBody(
    node?: object,
    opts?: object
): node is TSInterfaceBody;
export function isTSInterfaceDeclaration(
    node?: object,
    opts?: object
): node is TSInterfaceDeclaration;
export function isTSIntersectionType(
    node?: object,
    opts?: object
): node is TSIntersectionType;
export function isTSLiteralType(
    node?: object,
    opts?: object
): node is TSLiteralType;
export function isTSMappedType(
    node?: object,
    opts?: object
): node is TSMappedType;
export function isTSMethodSignature(
    node?: object,
    opts?: object
): node is TSMethodSignature;
export function isTSModuleBlock(
    node?: object,
    opts?: object
): node is TSModuleBlock;
export function isTSModuleDeclaration(
    node?: object,
    opts?: object
): node is TSModuleDeclaration;
export function isTSNamespaceExportDeclaration(
    node?: object,
    opts?: object
): node is TSNamespaceExportDeclaration;
export function isTSNeverKeyword(
    node?: object,
    opts?: object
): node is TSNeverKeyword;
export function isTSNonNullExpression(
    node?: object,
    opts?: object
): node is TSNonNullExpression;
export function isTSNullKeyword(
    node?: object,
    opts?: object
): node is TSNullKeyword;
export function isTSNumberKeyword(
    node?: object,
    opts?: object
): node is TSNumberKeyword;
export function isTSObjectKeyword(
    node?: object,
    opts?: object
): node is TSObjectKeyword;
export function isTSParameterProperty(
    node?: object,
    opts?: object
): node is TSParameterProperty;
export function isTSParenthesizedType(
    node?: object,
    opts?: object
): node is TSParenthesizedType;
export function isTSPropertySignature(
    node?: object,
    opts?: object
): node is TSPropertySignature;
export function isTSQualifiedName(
    node?: object,
    opts?: object
): node is TSQualifiedName;
export function isTSStringKeyword(
    node?: object,
    opts?: object
): node is TSStringKeyword;
export function isTSSymbolKeyword(
    node?: object,
    opts?: object
): node is TSSymbolKeyword;
export function isTSThisType(node?: object, opts?: object): node is TSThisType;
export function isTSTupleType(
    node?: object,
    opts?: object
): node is TSTupleType;
export function isTSType(node?: object, opts?: object): node is TSType;
export function isTSTypeAliasDeclaration(
    node?: object,
    opts?: object
): node is TSTypeAliasDeclaration;
export function isTSTypeAnnotation(
    node?: object,
    opts?: object
): node is TSTypeAnnotation;
export function isTSTypeAssertion(
    node?: object,
    opts?: object
): node is TSTypeAssertion;
export function isTSTypeElement(
    node?: object,
    opts?: object
): node is TSTypeElement;
export function isTSTypeLiteral(
    node?: object,
    opts?: object
): node is TSTypeLiteral;
export function isTSTypeOperator(
    node?: object,
    opts?: object
): node is TSTypeOperator;
export function isTSTypeParameter(
    node?: object,
    opts?: object
): node is TSTypeParameter;
export function isTSTypeParameterDeclaration(
    node?: object,
    opts?: object
): node is TSTypeParameterDeclaration;
export function isTSTypeParameterInstantiation(
    node?: object,
    opts?: object
): node is TSTypeParameterInstantiation;
export function isTSTypePredicate(
    node?: object,
    opts?: object
): node is TSTypePredicate;
export function isTSTypeQuery(
    node?: object,
    opts?: object
): node is TSTypeQuery;
export function isTSTypeReference(
    node?: object,
    opts?: object
): node is TSTypeReference;
export function isTSUndefinedKeyword(
    node?: object,
    opts?: object
): node is TSUndefinedKeyword;
export function isTSUnionType(
    node?: object,
    opts?: object
): node is TSUnionType;
export function isTSVoidKeyword(
    node?: object,
    opts?: object
): node is TSVoidKeyword;
export function isTaggedTemplateExpression(
    node?: object,
    opts?: object
): node is TaggedTemplateExpression;
export function isTemplateElement(
    node?: object,
    opts?: object
): node is TemplateElement;
export function isTemplateLiteral(
    node?: object,
    opts?: object
): node is TemplateLiteral;
export function isTerminatorless(
    node?: object,
    opts?: object
): node is Terminatorless;
export function isThisExpression(
    node?: object,
    opts?: object
): node is ThisExpression;
export function isThisTypeAnnotation(
    node?: object,
    opts?: object
): node is ThisTypeAnnotation;
export function isThrowStatement(
    node?: object,
    opts?: object
): node is ThrowStatement;
export function isTryStatement(
    node?: object,
    opts?: object
): node is TryStatement;
export function isTupleTypeAnnotation(
    node?: object,
    opts?: object
): node is TupleTypeAnnotation;
export function isTypeAlias(node?: object, opts?: object): node is TypeAlias;
export function isTypeAnnotation(
    node?: object,
    opts?: object
): node is TypeAnnotation;
export function isTypeCastExpression(
    node?: object,
    opts?: object
): node is TypeCastExpression;
export function isTypeParameter(
    node?: object,
    opts?: object
): node is TypeParameter;
export function isTypeParameterDeclaration(
    node?: object,
    opts?: object
): node is TypeParameterDeclaration;
export function isTypeParameterInstantiation(
    node?: object,
    opts?: object
): node is TypeParameterInstantiation;
export function isTypeofTypeAnnotation(
    node?: object,
    opts?: object
): node is TypeofTypeAnnotation;
export function isUnaryExpression(
    node?: object,
    opts?: object
): node is UnaryExpression;
export function isUnaryLike(node?: object, opts?: object): node is UnaryLike;
export function isUnionTypeAnnotation(
    node?: object,
    opts?: object
): node is UnionTypeAnnotation;
export function isUpdateExpression(
    node?: object,
    opts?: object
): node is UpdateExpression;
export function isUserWhitespacable(
    node?: object,
    opts?: object
): node is UserWhitespacable;
export function isVariableDeclaration(
    node?: object,
    opts?: object
): node is VariableDeclaration;
export function isVariableDeclarator(
    node?: object,
    opts?: object
): node is VariableDeclarator;
export function isVariance(node?: object, opts?: object): node is Variance;
export function isVoidTypeAnnotation(
    node?: object,
    opts?: object
): node is VoidTypeAnnotation;
export function isWhile(node?: object, opts?: object): node is While;
export function isWhileStatement(
    node?: object,
    opts?: object
): node is WhileStatement;
export function isWithStatement(
    node?: object,
    opts?: object
): node is WithStatement;
export function isYieldExpression(
    node?: object,
    opts?: object
): node is YieldExpression;

export function assertNode(node: object): void;
export function assertAnyTypeAnnotation(node: object, opts?: object): void;
export function assertArrayExpression(node: object, opts?: object): void;
export function assertArrayPattern(node: object, opts?: object): void;
export function assertArrayTypeAnnotation(node: object, opts?: object): void;
export function assertArrowFunctionExpression(
    node: object,
    opts?: object
): void;
export function assertAssignmentExpression(node: object, opts?: object): void;
export function assertAssignmentPattern(node: object, opts?: object): void;
export function assertAwaitExpression(node: object, opts?: object): void;
export function assertBinary(node: object, opts?: object): void;
export function assertBinaryExpression(node: object, opts?: object): void;
export function assertBindExpression(node: object, opts?: object): void;
export function assertBlock(node: object, opts?: object): void;
export function assertBlockParent(node: object, opts?: object): void;
export function assertBlockStatement(node: object, opts?: object): void;
export function assertBooleanLiteral(node: object, opts?: object): void;
export function assertBooleanLiteralTypeAnnotation(
    node: object,
    opts?: object
): void;
export function assertBooleanTypeAnnotation(node: object, opts?: object): void;
export function assertBreakStatement(node: object, opts?: object): void;
export function assertCallExpression(node: object, opts?: object): void;
export function assertCatchClause(node: object, opts?: object): void;
export function assertClass(node: object, opts?: object): void;
export function assertClassBody(node: object, opts?: object): void;
export function assertClassDeclaration(node: object, opts?: object): void;
export function assertClassExpression(node: object, opts?: object): void;
export function assertClassImplements(node: object, opts?: object): void;
export function assertClassMethod(node: object, opts?: object): void;
export function assertClassProperty(node: object, opts?: object): void;
export function assertCompletionStatement(node: object, opts?: object): void;
export function assertConditional(node: object, opts?: object): void;
export function assertConditionalExpression(node: object, opts?: object): void;
export function assertContinueStatement(node: object, opts?: object): void;
export function assertDebuggerStatement(node: object, opts?: object): void;
export function assertDeclaration(node: object, opts?: object): void;
export function assertDeclareClass(node: object, opts?: object): void;
export function assertDeclareExportAllDeclaration(
    node: object,
    opts?: object
): void;
export function assertDeclareExportDeclaration(
    node: object,
    opts?: object
): void;
export function assertDeclareFunction(node: object, opts?: object): void;
export function assertDeclareInterface(node: object, opts?: object): void;
export function assertDeclareModule(node: object, opts?: object): void;
export function assertDeclareModuleExports(node: object, opts?: object): void;
export function assertDeclareOpaqueType(node: object, opts?: object): void;
export function assertDeclareTypeAlias(node: object, opts?: object): void;
export function assertDeclareVariable(node: object, opts?: object): void;
export function assertDeclaredPredicate(node: object, opts?: object): void;
export function assertDecorator(node: object, opts?: object): void;
export function assertDirective(node: object, opts?: object): void;
export function assertDirectiveLiteral(node: object, opts?: object): void;
export function assertDoExpression(node: object, opts?: object): void;
export function assertDoWhileStatement(node: object, opts?: object): void;
export function assertEmptyStatement(node: object, opts?: object): void;
export function assertEmptyTypeAnnotation(node: object, opts?: object): void;
export function assertExistsTypeAnnotation(node: object, opts?: object): void;
export function assertExportAllDeclaration(node: object, opts?: object): void;
export function assertExportDeclaration(node: object, opts?: object): void;
export function assertExportDefaultDeclaration(
    node: object,
    opts?: object
): void;
export function assertExportDefaultSpecifier(node: object, opts?: object): void;
export function assertExportNamedDeclaration(node: object, opts?: object): void;
export function assertExportNamespaceSpecifier(
    node: object,
    opts?: object
): void;
export function assertExportSpecifier(node: object, opts?: object): void;
export function assertExpression(node: object, opts?: object): void;
export function assertExpressionStatement(node: object, opts?: object): void;
export function assertExpressionWrapper(node: object, opts?: object): void;
export function assertFile(node: object, opts?: object): void;
export function assertFlow(node: object, opts?: object): void;
export function assertFlowBaseAnnotation(node: object, opts?: object): void;
export function assertFlowDeclaration(node: object, opts?: object): void;
export function assertFlowPredicate(node: object, opts?: object): void;
export function assertFlowType(node: object, opts?: object): void;
export function assertFor(node: object, opts?: object): void;
export function assertForInStatement(node: object, opts?: object): void;
export function assertForOfStatement(node: object, opts?: object): void;
export function assertForStatement(node: object, opts?: object): void;
export function assertForXStatement(node: object, opts?: object): void;
export function assertFunction(node: object, opts?: object): void;
export function assertFunctionDeclaration(node: object, opts?: object): void;
export function assertFunctionExpression(node: object, opts?: object): void;
export function assertFunctionParent(node: object, opts?: object): void;
export function assertFunctionTypeAnnotation(node: object, opts?: object): void;
export function assertFunctionTypeParam(node: object, opts?: object): void;
export function assertGenericTypeAnnotation(node: object, opts?: object): void;
export function assertIdentifier(node: object, opts?: object): void;
export function assertIfStatement(node: object, opts?: object): void;
export function assertImmutable(node: object, opts?: object): void;
export function assertImport(node: object, opts?: object): void;
export function assertImportDeclaration(node: object, opts?: object): void;
export function assertImportDefaultSpecifier(node: object, opts?: object): void;
export function assertImportNamespaceSpecifier(
    node: object,
    opts?: object
): void;
export function assertImportSpecifier(node: object, opts?: object): void;
export function assertInferredPredicate(node: object, opts?: object): void;
export function assertInterfaceDeclaration(node: object, opts?: object): void;
export function assertInterfaceExtends(node: object, opts?: object): void;
export function assertIntersectionTypeAnnotation(
    node: object,
    opts?: object
): void;
export function assertJSX(node: object, opts?: object): void;
export function assertJSXAttribute(node: object, opts?: object): void;
export function assertJSXClosingElement(node: object, opts?: object): void;
export function assertJSXClosingFragment(node: object, opts?: object): void;
export function assertJSXElement(node: object, opts?: object): void;
export function assertJSXEmptyExpression(node: object, opts?: object): void;
export function assertJSXExpressionContainer(node: object, opts?: object): void;
export function assertJSXFragment(node: object, opts?: object): void;
export function assertJSXIdentifier(node: object, opts?: object): void;
export function assertJSXMemberExpression(node: object, opts?: object): void;
export function assertJSXNamespacedName(node: object, opts?: object): void;
export function assertJSXOpeningElement(node: object, opts?: object): void;
export function assertJSXOpeningFragment(node: object, opts?: object): void;
export function assertJSXSpreadAttribute(node: object, opts?: object): void;
export function assertJSXSpreadChild(node: object, opts?: object): void;
export function assertJSXText(node: object, opts?: object): void;
export function assertLVal(node: object, opts?: object): void;
export function assertLabeledStatement(node: object, opts?: object): void;
export function assertLiteral(node: object, opts?: object): void;
export function assertLogicalExpression(node: object, opts?: object): void;
export function assertLoop(node: object, opts?: object): void;
export function assertMemberExpression(node: object, opts?: object): void;
export function assertMetaProperty(node: object, opts?: object): void;
export function assertMethod(node: object, opts?: object): void;
export function assertMixedTypeAnnotation(node: object, opts?: object): void;
export function assertModuleDeclaration(node: object, opts?: object): void;
export function assertModuleSpecifier(node: object, opts?: object): void;
export function assertNewExpression(node: object, opts?: object): void;
export function assertNoop(node: object, opts?: object): void;
export function assertNullLiteral(node: object, opts?: object): void;
export function assertNullLiteralTypeAnnotation(
    node: object,
    opts?: object
): void;
export function assertNullableTypeAnnotation(node: object, opts?: object): void;
export function assertNumberLiteralTypeAnnotation(
    node: object,
    opts?: object
): void;
export function assertNumberTypeAnnotation(node: object, opts?: object): void;
export function assertNumericLiteral(node: object, opts?: object): void;
export function assertObjectExpression(node: object, opts?: object): void;
export function assertObjectMember(node: object, opts?: object): void;
export function assertObjectMethod(node: object, opts?: object): void;
export function assertObjectPattern(node: object, opts?: object): void;
export function assertObjectProperty(node: object, opts?: object): void;
export function assertObjectTypeAnnotation(node: object, opts?: object): void;
export function assertObjectTypeCallProperty(node: object, opts?: object): void;
export function assertObjectTypeIndexer(node: object, opts?: object): void;
export function assertObjectTypeProperty(node: object, opts?: object): void;
export function assertObjectTypeSpreadProperty(
    node: object,
    opts?: object
): void;
export function assertOpaqueType(node: object, opts?: object): void;
export function assertOptionalCallExpression(node: object, opts?: object): void;
export function assertOptionalMemberExpression(
    node: object,
    opts?: object
): void;
export function assertParenthesizedExpression(
    node: object,
    opts?: object
): void;
export function assertPattern(node: object, opts?: object): void;
export function assertPatternLike(node: object, opts?: object): void;
export function assertProgram(node: object, opts?: object): void;
export function assertProperty(node: object, opts?: object): void;
export function assertPureish(node: object, opts?: object): void;
export function assertQualifiedTypeIdentifier(
    node: object,
    opts?: object
): void;
export function assertRegExpLiteral(node: object, opts?: object): void;
export function assertRestElement(node: object, opts?: object): void;
export function assertReturnStatement(node: object, opts?: object): void;
export function assertScopable(node: object, opts?: object): void;
export function assertSequenceExpression(node: object, opts?: object): void;
export function assertSpreadElement(node: object, opts?: object): void;
export function assertStatement(node: object, opts?: object): void;
export function assertStringLiteral(node: object, opts?: object): void;
export function assertStringLiteralTypeAnnotation(
    node: object,
    opts?: object
): void;
export function assertStringTypeAnnotation(node: object, opts?: object): void;
export function assertSuper(node: object, opts?: object): void;
export function assertSwitchCase(node: object, opts?: object): void;
export function assertSwitchStatement(node: object, opts?: object): void;
export function assertTSAnyKeyword(node: object, opts?: object): void;
export function assertTSArrayType(node: object, opts?: object): void;
export function assertTSAsExpression(node: object, opts?: object): void;
export function assertTSBooleanKeyword(node: object, opts?: object): void;
export function assertTSCallSignatureDeclaration(
    node: object,
    opts?: object
): void;
export function assertTSConstructSignatureDeclaration(
    node: object,
    opts?: object
): void;
export function assertTSConstructorType(node: object, opts?: object): void;
export function assertTSDeclareFunction(node: object, opts?: object): void;
export function assertTSDeclareMethod(node: object, opts?: object): void;
export function assertTSEntityName(node: object, opts?: object): void;
export function assertTSEnumDeclaration(node: object, opts?: object): void;
export function assertTSEnumMember(node: object, opts?: object): void;
export function assertTSExportAssignment(node: object, opts?: object): void;
export function assertTSExpressionWithTypeArguments(
    node: object,
    opts?: object
): void;
export function assertTSExternalModuleReference(
    node: object,
    opts?: object
): void;
export function assertTSFunctionType(node: object, opts?: object): void;
export function assertTSImportEqualsDeclaration(
    node: object,
    opts?: object
): void;
export function assertTSIndexSignature(node: object, opts?: object): void;
export function assertTSIndexedAccessType(node: object, opts?: object): void;
export function assertTSInterfaceBody(node: object, opts?: object): void;
export function assertTSInterfaceDeclaration(node: object, opts?: object): void;
export function assertTSIntersectionType(node: object, opts?: object): void;
export function assertTSLiteralType(node: object, opts?: object): void;
export function assertTSMappedType(node: object, opts?: object): void;
export function assertTSMethodSignature(node: object, opts?: object): void;
export function assertTSModuleBlock(node: object, opts?: object): void;
export function assertTSModuleDeclaration(node: object, opts?: object): void;
export function assertTSNamespaceExportDeclaration(
    node: object,
    opts?: object
): void;
export function assertTSNeverKeyword(node: object, opts?: object): void;
export function assertTSNonNullExpression(node: object, opts?: object): void;
export function assertTSNullKeyword(node: object, opts?: object): void;
export function assertTSNumberKeyword(node: object, opts?: object): void;
export function assertTSObjectKeyword(node: object, opts?: object): void;
export function assertTSParameterProperty(node: object, opts?: object): void;
export function assertTSParenthesizedType(node: object, opts?: object): void;
export function assertTSPropertySignature(node: object, opts?: object): void;
export function assertTSQualifiedName(node: object, opts?: object): void;
export function assertTSStringKeyword(node: object, opts?: object): void;
export function assertTSSymbolKeyword(node: object, opts?: object): void;
export function assertTSThisType(node: object, opts?: object): void;
export function assertTSTupleType(node: object, opts?: object): void;
export function assertTSType(node: object, opts?: object): void;
export function assertTSTypeAliasDeclaration(node: object, opts?: object): void;
export function assertTSTypeAnnotation(node: object, opts?: object): void;
export function assertTSTypeAssertion(node: object, opts?: object): void;
export function assertTSTypeElement(node: object, opts?: object): void;
export function assertTSTypeLiteral(node: object, opts?: object): void;
export function assertTSTypeOperator(node: object, opts?: object): void;
export function assertTSTypeParameter(node: object, opts?: object): void;
export function assertTSTypeParameterDeclaration(
    node: object,
    opts?: object
): void;
export function assertTSTypeParameterInstantiation(
    node: object,
    opts?: object
): void;
export function assertTSTypePredicate(node: object, opts?: object): void;
export function assertTSTypeQuery(node: object, opts?: object): void;
export function assertTSTypeReference(node: object, opts?: object): void;
export function assertTSUndefinedKeyword(node: object, opts?: object): void;
export function assertTSUnionType(node: object, opts?: object): void;
export function assertTSVoidKeyword(node: object, opts?: object): void;
export function assertTaggedTemplateExpression(
    node: object,
    opts?: object
): void;
export function assertTemplateElement(node: object, opts?: object): void;
export function assertTemplateLiteral(node: object, opts?: object): void;
export function assertTerminatorless(node: object, opts?: object): void;
export function assertThisExpression(node: object, opts?: object): void;
export function assertThisTypeAnnotation(node: object, opts?: object): void;
export function assertThrowStatement(node: object, opts?: object): void;
export function assertTryStatement(node: object, opts?: object): void;
export function assertTupleTypeAnnotation(node: object, opts?: object): void;
export function assertTypeAlias(node: object, opts?: object): void;
export function assertTypeAnnotation(node: object, opts?: object): void;
export function assertTypeCastExpression(node: object, opts?: object): void;
export function assertTypeParameter(node: object, opts?: object): void;
export function assertTypeParameterDeclaration(
    node: object,
    opts?: object
): void;
export function assertTypeParameterInstantiation(
    node: object,
    opts?: object
): void;
export function assertTypeofTypeAnnotation(node: object, opts?: object): void;
export function assertUnaryExpression(node: object, opts?: object): void;
export function assertUnaryLike(node: object, opts?: object): void;
export function assertUnionTypeAnnotation(node: object, opts?: object): void;
export function assertUpdateExpression(node: object, opts?: object): void;
export function assertUserWhitespacable(node: object, opts?: object): void;
export function assertVariableDeclaration(node: object, opts?: object): void;
export function assertVariableDeclarator(node: object, opts?: object): void;
export function assertVariance(node: object, opts?: object): void;
export function assertVoidTypeAnnotation(node: object, opts?: object): void;
export function assertWhile(node: object, opts?: object): void;
export function assertWhileStatement(node: object, opts?: object): void;
export function assertWithStatement(node: object, opts?: object): void;
export function assertYieldExpression(node: object, opts?: object): void;
