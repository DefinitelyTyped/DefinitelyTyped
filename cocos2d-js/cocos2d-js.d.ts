// Type definitions for Cocos2d-JS-v3.2
// Project: http://cocos2d-x.org/
// Definitions by: Johnson Zhong <http: />/zhongzf.cnblogs.com/>
// Definitions: https://github.com/borisyankov/DefinitelyTyped


declare module cc {
        /**
        * 
the device accelerometer reports values for each axis in units of g-force

        */
        export class Acceleration  {
            /**
            * the device accelerometer reports values for each axis in units of g-force
            */
            constructor(x?: number, y?: number, z?: number, timestamp?: number);
        }
    }
declare module cc {
        /**
        * 
Base class for cc.Action objects.

        */
        export class Action extends cc.Class {
            /**
            * Base class for cc.Action objects.
            */
            constructor();
            /**
            * Please use cc.action instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Action;
            /**
            * - The original target of the action.
            */
            originalTarget: cc.Node;
            /**
            * - The tag of the action, can be used to find the action.
            */
            tag: number;
            /**
            * - The target will be set with the &#39;startWithTarget&#39; method.
            */
            target: cc.Node;
            /**
            * {cc.Action}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.Action}

            */
            clone(): cc.Action;
            /**
            * {cc.Action}
copy()
to copy object with deep copy.
Deprecated:
since v3.0 please use .clone
Returns:
{cc.Action}

            */
            copy(): cc.Action;
            /**
            * ctor()
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {cc.Node}
getOriginalTarget()
get the original target.
Returns:
{cc.Node}

            */
            getOriginalTarget(): cc.Node;
            /**
            * {Number}
getTag()
get tag number.
Returns:
{Number}

            */
            getTag(): number;
            /**
            * {cc.Node}
getTarget()
get the target.
Returns:
{cc.Node}

            */
            getTarget(): cc.Node;
            /**
            * {Boolean}
isDone()
return true if the action has finished.
Returns:
{Boolean}

            */
            isDone(): boolean;
            /**
            * release()
Currently JavaScript Bindigns (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
This is a hack, and should be removed once JSB fixes the retain/release bug.

            */
            release();
            /**
            * retain()
Currently JavaScript Bindigns (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
This is a hack, and should be removed once JSB fixes the retain/release bug.

            */
            retain();
            /**
            * setOriginalTarget(originalTarget)
Set the original target, since target can be nil.
Is the target that were used to run the action.
Unless you are doing something complex, like cc.ActionManager, you should NOT call this method.
The target is &#39;assigned&#39;, it is not &#39;retained&#39;.
Parameters:
{cc.Node} originalTarget

            */
            setOriginalTarget(originalTarget?: cc.Node);
            /**
            * setTag(tag)
set tag number.
Parameters:
{Number} tag

            */
            setTag(tag?: number);
            /**
            * setTarget(target)
The action will modify the target properties.
Parameters:
{cc.Node} target

            */
            setTarget(target?: cc.Node);
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * step(dt)
called every frame with it&#39;s delta time.
DON&#39;T override unless you know what you are doing.
Parameters:
{Number} dt

            */
            step(dt?: number);
            /**
            * stop()
called after the action has finished. It will set the &#39;target&#39; to nil.
IMPORTANT: You should never call &quot;action stop&quot; manually. Instead, use: &quot;target.stopAction(action);&quot;

            */
            stop();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Base class for Easing actions

        */
        export class ActionEase extends cc.ActionInterval {
            /**
            * Base class for Easing actions
            */
            constructor(action?: cc.ActionInterval);
            /**
            * Please use cc.actionEase instead
creates the action of ActionEase
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ActionEase;
            /**
            * {cc.ActionEase}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.ActionEase}

            */
            clone(): cc.ActionEase;
            /**
            * ctor(action)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates the action of ActionEase.
Parameters:
{cc.ActionInterval} action

            */
            ctor(action?: cc.ActionInterval);
            /**
            * {cc.ActionInterval}
getInnerAction()
Get inner Action.
Returns:
{cc.ActionInterval}

            */
            getInnerAction(): cc.ActionInterval;
            /**
            * {Boolean}
initWithAction(action)
initializes the action
Parameters:
{cc.ActionInterval} action
Returns:
{Boolean}

            */
            initWithAction(action?: cc.ActionInterval): boolean;
            /**
            * {cc.ActionEase}
reverse()
Create new action to original operation effect opposite.
For example:
- The action will be x coordinates of 0 move to 100.
- The reversed action will be x of 100 move to 0.
- Will be rewritten
Returns:
{cc.ActionEase}

            */
            reverse(): cc.ActionEase;
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * stop()
Stop the action.

            */
            stop();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Instant actions are immediate actions. They don&#39;t have a duration like.
the CCIntervalAction actions.

        */
        export class ActionInstant extends cc.FiniteTimeAction {
            /**
            * Instant actions are immediate actions.
            */
            constructor();
            /**
            * {cc.FiniteTimeAction}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.FiniteTimeAction}

            */
            clone(): cc.FiniteTimeAction;
            /**
            * {Boolean}
isDone()
return true if the action has finished.
Returns:
{Boolean}

            */
            isDone(): boolean;
            /**
            * {cc.Action}
reverse()
returns a reversed action.
For example:
- The action will be x coordinates of 0 move to 100.
- The reversed action will be x of 100 move to 0.
- Will be rewritten
Returns:
{cc.Action}

            */
            reverse(): cc.Action;
            /**
            * step(dt)
called every frame with it&#39;s delta time.
DON&#39;T override unless you know what you are doing.
Parameters:
{Number} dt

            */
            step(dt?: number);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
An interval action is an action that takes place within a certain period of time.
It has an start time, and a finish time. The finish time is the parameter
duration plus the start time.

These CCActionInterval actions have some interesting properties, like:
- They can run normally (default)
- They can run reversed with the reverse method
- They can run with the time altered with the Accelerate, AccelDeccel and Speed actions.

For example, you can simulate a Ping Pong effect running the action normally and
then running it again in Reverse mode.

        */
        export class ActionInterval extends cc.FiniteTimeAction {
            /**
            * An interval action is an action that takes place within a certain period of time.
            */
            constructor(d?: number);
            /**
            * Please use cc.actionInterval instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ActionInterval;
            /**
            * {cc.ActionInterval}
clone()
Returns a new clone of the action.
Returns:
{cc.ActionInterval}

            */
            clone(): cc.ActionInterval;
            /**
            * ctor(d)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} d
duration in seconds

            */
            ctor(d?: number);
            /**
            * {cc.ActionInterval}
easing(easeObj)
Implementation of ease motion.
//example
action.easeing(cc.easeIn(3.0));
Parameters:
{Object} easeObj
Returns:
{cc.ActionInterval}

            */
            easing(easeObj?: Object): cc.ActionInterval;
            /**
            * {Number}
getAmplitudeRate()
Get amplitude rate.
Returns:
{Number} 0

            */
            getAmplitudeRate(): number;
            /**
            * {Number}
getElapsed()
How many seconds had elapsed since the actions started to run.
Returns:
{Number}

            */
            getElapsed(): number;
            /**
            * {Number}
getSpeed()
Get this action speed.
Returns:
{Number}

            */
            getSpeed(): number;
            /**
            * {Boolean}
initWithDuration(d)
Initializes the action.
Parameters:
{Number} d
duration in seconds
Returns:
{Boolean}

            */
            initWithDuration(d?: number): boolean;
            /**
            * {Boolean}
isDone()
Returns true if the action has finished.
Returns:
{Boolean}

            */
            isDone(): boolean;
            /**
            * {cc.ActionInterval}
repeat(times)
Repeats an action a number of times.
To repeat an action forever use the CCRepeatForever action.
Parameters:
times
Returns:
{cc.ActionInterval}

            */
            repeat(): cc.ActionInterval;
            /**
            * {cc.ActionInterval}
repeatForever()
Repeats an action for ever.
To repeat the an action for a limited number of times use the Repeat action.
Returns:
{cc.ActionInterval}

            */
            repeatForever(): cc.ActionInterval;
            /**
            * {null}
reverse()
returns a reversed action.
Will be overwrite.
Returns:
{null}

            */
            reverse(): void;
            /**
            * setAmplitudeRate(amp)
Set amplitude rate.
Parameters:
{Number} amp

            */
            setAmplitudeRate(amp?: number);
            /**
            * {cc.ActionInterval}
setSpeed(speed)
Set this action speed.
Parameters:
{Number} speed
Returns:
{cc.ActionInterval}

            */
            setSpeed(speed?: number): cc.ActionInterval;
            /**
            * {cc.Action}
speed(speed)
Changes the speed of an action, making it take longer (speed&gt;1)
or less (speed
Useful to simulate &#39;slow motion&#39; or &#39;fast forward&#39; effect.
Parameters:
speed
Returns:
{cc.Action}

            */
            speed(): cc.Action;
            /**
            * startWithTarget(target)
Start this action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * step(dt)
called every frame with it&#39;s delta time.
DON&#39;T override unless you know what you are doing.
Parameters:
{Number} dt

            */
            step(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.ActionManager is a class that can manage actions.
Normally you won&#39;t need to use this class directly. 99% of the cases you will use the CCNode interface,
which uses this class&#39;s singleton object.
But there are some cases where you might need to use this class.
Examples:
- When you want to run an action where the target is different from a CCNode.
- When you want to pause / resume the actions

        */
        export class ActionManager extends cc.Class {
            /**
            * cc.ActionManager is a class that can manage actions.
            */
            constructor();
            /**
            * addAction(action, target, paused)
Adds an action with a target.
If the target is already present, then the action will be added to the existing target.
If the target is not present, a new instance of this target will be created either paused or not, and the action will be added to the newly created target.
When the target is paused, the queued actions won&#39;t be &#39;ticked&#39;.
Parameters:
{cc.Action} action
{cc.Node} target
{Boolean} paused

            */
            addAction(action?: cc.Action, target?: cc.Node, paused?: boolean);
            /**
            * {cc.Action|Null}
getActionByTag(tag, target)
Gets an action given its tag an a target
Parameters:
{Number} tag
{object} target
Returns:
{cc.Action|Null} return the Action with the given tag on success

            */
            getActionByTag(tag?: number, target?: any): any;
            /**
            * {Number}
numberOfRunningActionsInTarget(target)
Returns the numbers of actions that are running in a certain target.
Composable actions are counted as 1 action.
Example:
- If you are running 1 Sequence of 7 actions, it will return 1.
- If you are running 7 Sequences of 2 actions, it will return 7.
Parameters:
{object} target
Returns:
{Number}

            */
            numberOfRunningActionsInTarget(target?: any): number;
            /**
            * {Array}
pauseAllRunningActions()
Pauses all running actions, returning a list of targets whose actions were paused.
Returns:
{Array} a list of targets whose actions were paused.

            */
            pauseAllRunningActions(): Array<any>;
            /**
            * pauseTarget(target)
Pauses the target: all running actions and newly added actions will be paused.
Parameters:
{object} target

            */
            pauseTarget(target?: any);
            /**
            * purgeSharedManager()
purges the shared action manager. It releases the retained instance.
because it uses this, so it can not be static

            */
            purgeSharedManager();
            /**
            * removeAction(action)
Removes an action given an action reference.
Parameters:
{cc.Action} action

            */
            removeAction(action?: cc.Action);
            /**
            * removeActionByTag(tag, target)
Removes an action given its tag and the target
Parameters:
{Number} tag
{object} target

            */
            removeActionByTag(tag?: number, target?: any);
            /**
            * removeAllActions()
Removes all actions from all the targets.

            */
            removeAllActions();
            /**
            * removeAllActionsFromTarget(target, forceDelete)
Removes all actions from a certain target.
All the actions that belongs to the target will be removed.
Parameters:
{object} target
{boolean} forceDelete

            */
            removeAllActionsFromTarget(target?: any, forceDelete?: boolean);
            /**
            * resumeTarget(target)
Resumes the target. All queued actions will be resumed.
Parameters:
{object} target

            */
            resumeTarget(target?: any);
            /**
            * resumeTargets(targetsToResume)
Resume a set of targets (convenience function to reverse a pauseAllRunningActions call)
Parameters:
{Array} targetsToResume

            */
            resumeTargets(targetsToResume?: Array<any>);
            /**
            * update(dt)
Parameters:
{Number} dt
delta time in seconds

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.ActionTween
cc.ActionTween is an action that lets you update any property of an object.

        */
        export class ActionTween extends cc.ActionInterval {
            /**
            * cc.ActionTween
cc.ActionTween is an action that lets you update any property of an object.
            */
            constructor(duration?: number, key?: string, from?: number, to?: number);
            /**
            * Please use cc.actionTween instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ActionTween;
            /**
            * &amp;lt;static&amp;gt;
{cc.ActionTween}
cc.ActionTween.clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.ActionTween}

            */
            static clone(): cc.ActionTween;
            /**
            * &amp;lt;static&amp;gt;
cc.ActionTween.ctor(duration, key, from, to)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates an initializes the action with the property name (key), and the from and to parameters.
Parameters:
{Number} duration
{String} key
{Number} from
{Number} to

            */
            static ctor(duration?: number, key?: string, from?: number, to?: number);
            /**
            * &amp;lt;static&amp;gt;
{Boolean}
cc.ActionTween.initWithDuration(duration, key, from, to)
initializes the action with the property name (key), and the from and to parameters.
Parameters:
{Number} duration
{String} key
{Number} from
{Number} to
Returns:
{Boolean}

            */
            static initWithDuration(duration?: number, key?: string, from?: number, to?: number): boolean;
            /**
            * &amp;lt;static&amp;gt;
{cc.ActionTween}
cc.ActionTween.reverse()
returns a reversed action.
Returns:
{cc.ActionTween}

            */
            static reverse(): cc.ActionTween;
            /**
            * &amp;lt;static&amp;gt;
cc.ActionTween.startWithTarget(target)
Start this tween with target.
Parameters:
{cc.ActionTweenDelegate} target

            */
            static startWithTarget(target?: cc.ActionTweenDelegate);
            /**
            * &amp;lt;static&amp;gt;
cc.ActionTween.update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            static update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
        */
        export class ActionTweenDelegate extends cc.Class {
            /**
            * 
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
cc.ActionTweenDelegate.updateTweenAction(value, key)
Update Tween Action.
Parameters:
value
key

            */
            static updateTweenAction();
        }
    }
declare module cc {
        /**
        * 
cc.AffineTransform class represent an affine transform matrix. It&#39;s composed basically by translation, rotation, scale transformations.
Please do not use its constructor directly, use cc.affineTransformMake alias function instead.

        */
        export class AffineTransform  {
            /**
            * cc.AffineTransform class represent an affine transform matrix.
            */
            constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);
        }
    }
declare module cc {
        /**
        * 
Animates a sprite given the name of an Animation

        */
        export class Animate extends cc.ActionInterval {
            /**
            * Animates a sprite given the name of an Animation
            */
            constructor(animation?: cc.Animation);
            /**
            * Please use cc.animate instead
create the animate with animation
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Animate;
            /**
            * {cc.Animate}
clone()
returns a new clone of the action
Returns:
{cc.Animate}

            */
            clone(): cc.Animate;
            /**
            * ctor(animation)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
create the animate with animation.
Parameters:
{cc.Animation} animation

            */
            ctor(animation?: cc.Animation);
            /**
            * {cc.Animation}
getAnimation()
Returns:
{cc.Animation}

            */
            getAnimation(): cc.Animation;
            /**
            * {Boolean}
initWithAnimation(animation)
Parameters:
{cc.Animation} animation
Returns:
{Boolean}

            */
            initWithAnimation(animation?: cc.Animation): boolean;
            /**
            * {cc.Animate}
reverse()
Returns a reversed action.
Returns:
{cc.Animate}

            */
            reverse(): cc.Animate;
            /**
            * setAnimation(animation)
Parameters:
{cc.Animation} animation

            */
            setAnimation(animation?: cc.Animation);
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Sprite} target

            */
            startWithTarget(target?: cc.Sprite);
            /**
            * stop()
stop the action

            */
            stop();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * A cc.Animation object is used to perform animations on the cc.Sprite objects.
The cc.Animation object contains cc.SpriteFrame objects, and a possible delay between the frames.
You can animate a cc.Animation object by using the cc.Animate action.

        */
        export class Animation extends cc.Class {
            /**
            * 
A cc.Animation object is used to perform animations on the cc.Sprite objects.
            */
            constructor(frames?: Array<any>, delay?: number, loops?: number);
            /**
            * 
            */
            static createWithAnimationFrames;
            /**
            * addSpriteFrame(frame)
Adds a frame to a cc.Animation, the frame will be added with one &quot;delay unit&quot;.
Parameters:
{cc.SpriteFrame} frame

            */
            addSpriteFrame(frame?: cc.SpriteFrame);
            /**
            * addSpriteFrameWithFile(fileName)
Adds a frame with an image filename. Internally it will create a cc.SpriteFrame and it will add it. The frame will be added with one &quot;delay unit&quot;.
Parameters:
{String} fileName

            */
            addSpriteFrameWithFile(fileName?: string);
            /**
            * addSpriteFrameWithTexture(texture, rect)
Adds a frame with a texture and a rect. Internally it will create a cc.SpriteFrame and it will add it. The frame will be added with one &quot;delay unit&quot;.
Parameters:
{cc.Texture2D} texture
{cc.Rect} rect

            */
            addSpriteFrameWithTexture(texture?: cc.Texture2D, rect?: cc.Rect);
            /**
            * {cc.Animation}
clone()
Clone the current animation
Returns:
{cc.Animation}

            */
            clone(): cc.Animation;
            /**
            * {cc.Animation}
copy(pZone)
Clone the current animation
Parameters:
pZone
Returns:
{cc.Animation}

            */
            copy(): cc.Animation;
            /**
            * {cc.Animation}
copyWithZone(pZone)
Clone the current animation
Parameters:
pZone
Returns:
{cc.Animation}

            */
            copyWithZone(): cc.Animation;
            /**
            * &amp;lt;static&amp;gt;
{cc.Animation}
cc.Animation.create(frames, delay, loops)
Creates an animation.
Parameters:
{Array} frames
{Number} delay
{Number} loops
Optional, Default: 1
Deprecated:
since v3.0, please use new construction instead
Returns:
{cc.Animation}
See:
cc.Animation

            */
            static create(frames?: Array<any>, delay?: number, loops?: number): cc.Animation;
            /**
            * {Number}
getDelayPerUnit()
Returns delay in seconds of the &quot;delay unit&quot;
Returns:
{Number}

            */
            getDelayPerUnit(): number;
            /**
            * {Number}
getDuration()
Returns duration in seconds of the whole animation. It is the result of totalDelayUnits * delayPerUnit
Returns:
{Number}

            */
            getDuration(): number;
            /**
            * {Array}
getFrames()
Returns the array of animation frames
Returns:
{Array}

            */
            getFrames(): Array<any>;
            /**
            * {Number}
getLoops()
Returns how many times the animation is going to loop. 0 means animation is not animated. 1, animation is executed one time, ...
Returns:
{Number}

            */
            getLoops(): number;
            /**
            * {Boolean}
getRestoreOriginalFrame()
Returns whether or not it shall restore the original frame when the animation finishes
Returns:
{Boolean}

            */
            getRestoreOriginalFrame(): boolean;
            /**
            * {Number}
getTotalDelayUnits()
Returns total delay units of the cc.Animation.
Returns:
{Number}

            */
            getTotalDelayUnits(): number;
            /**
            * initWithAnimationFrames(arrayOfAnimationFrames, delayPerUnit, loops)
Initializes a cc.Animation with cc.AnimationFrame, do not call this method yourself, please pass parameters to constructor to initialize.
Parameters:
{Array} arrayOfAnimationFrames
{Number} delayPerUnit
{Number} loops
Optional, Default: 1

            */
            initWithAnimationFrames(arrayOfAnimationFrames?: Array<any>, delayPerUnit?: number, loops?: number);
            /**
            * initWithSpriteFrames(frames, delay, loops)
Initializes a cc.Animation with frames and a delay between frames, do not call this method yourself, please pass parameters to constructor to initialize.
Parameters:
{Array} frames
{Number} delay
{Number} loops
Optional, Default: 1

            */
            initWithSpriteFrames(frames?: Array<any>, delay?: number, loops?: number);
            /**
            * release()
Currently JavaScript Bindings (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
This is a hack, and should be removed once JSB fixes the retain/release bug
You will need to retain an object if you created an engine object and haven&#39;t added it into the scene graph during the same frame.
Otherwise, JSB&#39;s native autorelease pool will consider this object a useless one and release it directly,
when you want to use it later, a &quot;Invalid Native Object&quot; error will be raised.
The retain function can increase a reference count for the native object to avoid it being released,
you need to manually invoke release function when you think this object is no longer needed, otherwise, there will be memory learks.
retain and release function call should be paired in developer&#39;s game code.
See:
cc.Animation#retain

            */
            release();
            /**
            * retain()
Currently JavaScript Bindings (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
This is a hack, and should be removed once JSB fixes the retain/release bug
You will need to retain an object if you created an engine object and haven&#39;t added it into the scene graph during the same frame.
Otherwise, JSB&#39;s native autorelease pool will consider this object a useless one and release it directly,
when you want to use it later, a &quot;Invalid Native Object&quot; error will be raised.
The retain function can increase a reference count for the native object to avoid it being released,
you need to manually invoke release function when you think this object is no longer needed, otherwise, there will be memory learks.
retain and release function call should be paired in developer&#39;s game code.
See:
cc.Animation#release

            */
            retain();
            /**
            * setDelayPerUnit(delayPerUnit)
Sets delay in seconds of the &quot;delay unit&quot;
Parameters:
{Number} delayPerUnit

            */
            setDelayPerUnit(delayPerUnit?: number);
            /**
            * setFrames(frames)
Sets array of animation frames
Parameters:
{Array} frames

            */
            setFrames(frames?: Array<any>);
            /**
            * setLoops(value)
Sets how many times the animation is going to loop. 0 means animation is not animated. 1, animation is executed one time, ...
Parameters:
{Number} value

            */
            setLoops(value?: number);
            /**
            * setRestoreOriginalFrame(restOrigFrame)
Sets whether or not it shall restore the original frame when the animation finishes
Parameters:
{Boolean} restOrigFrame

            */
            setRestoreOriginalFrame(restOrigFrame?: boolean);
        }
    }
declare module cc {
        /**
        * cc.animationCache is a singleton object that manages the Animations.
It saves in a cache the animations. You should use this class if you want to save your animations in a cache.

example
cc.animationCache.addAnimation(animation,&quot;animation1&quot;);

        */
        export class animationCache  {
            /**
            * 
cc.animationCache is a singleton object that manages the Animations.
            */
            constructor();
            /**
            * addAnimation(animation, name)
Adds a cc.Animation with a name.
Parameters:
{cc.Animation} animation
{String} name

            */
            addAnimation(animation?: cc.Animation, name?: string);
            /**
            * addAnimations(plist)
Adds an animations from a plist file.
Make sure that the frames were previously loaded in the cc.SpriteFrameCache.
Parameters:
{String} plist

            */
            addAnimations(plist?: string);
            /**
            * {cc.Animation}
getAnimation(name)
Returns a cc.Animation that was previously added.
If the name is not found it will return nil.
You should retain the returned copy if you are going to use it.
Parameters:
{String} name
Returns:
{cc.Animation}

            */
            getAnimation(name?: string): cc.Animation;
            /**
            * removeAnimation(name)
Deletes a cc.Animation from the cache.
Parameters:
{String} name

            */
            removeAnimation(name?: string);
        }
    }
declare module cc {
        /**
        * cc.AnimationFrame
A frame of the animation. It contains information like:
- sprite frame name
- # of delay units.
- offset

        */
        export class AnimationFrame extends cc.Class {
            /**
            * 
cc.AnimationFrame
A frame of the animation.
            */
            constructor();
            /**
            * {AnimationFrame}
clone()
Create a new animation frame and copy all contents into it
Returns:
{AnimationFrame}

            */
            clone(): AnimationFrame;
            /**
            * {AnimationFrame}
copy(pZone)
Create a new animation frame and copy all contents into it
Parameters:
pZone
Returns:
{AnimationFrame}

            */
            copy(): AnimationFrame;
            /**
            * {AnimationFrame}
copyWithZone(pZone)
Create a new animation frame and copy all contents into it
Parameters:
pZone
Returns:
{AnimationFrame}

            */
            copyWithZone(): AnimationFrame;
            /**
            * &amp;lt;static&amp;gt;
cc.AnimationFrame.create(spriteFrame, delayUnits, userInfo)
Creates an animation frame.
Parameters:
{cc.SpriteFrame} spriteFrame
{Number} delayUnits
{object} userInfo
Deprecated:
since v3.0, please use the new construction instead
See:
cc.AnimationFrame

            */
            static create(spriteFrame?: cc.SpriteFrame, delayUnits?: number, userInfo?: any);
            /**
            * {Number}
getDelayUnits()
Returns how many units of time the frame takes getter
Returns:
{Number}

            */
            getDelayUnits(): number;
            /**
            * {cc.SpriteFrame}
getSpriteFrame()
Returns sprite frame to be used
Returns:
{cc.SpriteFrame}

            */
            getSpriteFrame(): cc.SpriteFrame;
            /**
            * {object}
getUserInfo()
Returns the user custom information
Returns:
{object}

            */
            getUserInfo(): any;
            /**
            * initWithSpriteFrame(spriteFrame, delayUnits, userInfo)
initializes the animation frame with a spriteframe, number of delay units and a notification user info
Parameters:
{cc.SpriteFrame} spriteFrame
{Number} delayUnits
{object} userInfo

            */
            initWithSpriteFrame(spriteFrame?: cc.SpriteFrame, delayUnits?: number, userInfo?: any);
            /**
            * setDelayUnits(delayUnits)
Sets how many units of time the frame takes setter
Parameters:
delayUnits

            */
            setDelayUnits();
            /**
            * setSpriteFrame(spriteFrame)
Sets sprite frame to be used
Parameters:
{cc.SpriteFrame} spriteFrame

            */
            setSpriteFrame(spriteFrame?: cc.SpriteFrame);
            /**
            * setUserInfo(userInfo)
Sets the user custom information
Parameters:
{object} userInfo

            */
            setUserInfo(userInfo?: any);
        }
    }
declare module cc {
        /**
        * 
Array for object sorting utils

        */
        export class ArrayForObjectSorting  {
            /**
            * Array for object sorting utils
            */
            constructor();
            /**
            * insertSortedObject(addObject)
Inserts a given object into array.

Inserts a given object into array with key and value that are used in
sorting. &quot;value&quot; must respond to message, compare:, which returns
(NSComparisonResult). If it does not respond to the message, it is appended.
If the compare message does not result NSComparisonResult, sorting behavior
is not defined. It ignores duplicate entries and inserts next to it.
Parameters:
{Object} addObject
Object to insert

            */
            insertSortedObject(addObject?: Object);
        }
    }
declare module cc {
        /**
        * 
        */
        export class async  {
            /**
            * 
            */
            constructor();
            /**
            * {cc.AsyncPool}
map(tasks, iterator, callback, target)
Do tasks by iterator.
Parameters:
{Array|Object} tasks
{function|Object} iterator
{function} callback
Optional
{Object} target
Optional
Returns:
{cc.AsyncPool}

            */
            map(tasks?: any, iterator?: any, callback?: any, target?: Object): cc.AsyncPool;
            /**
            * mapLimit(tasks, limit, iterator, cb, target)
Do tasks by iterator limit.
Parameters:
{Array|Object} tasks
{Number} limit
{function} iterator
{function} cb
callback
{Object} target
Optional

            */
            mapLimit(tasks?: any, limit?: number, iterator?: any, cb?: any, target?: Object);
            /**
            * {cc.AsyncPool}
parallel(tasks, cb, target)
Do tasks parallel.
Parameters:
{Array|Object} tasks
{function} cb
callback
{Object} target
Optional
Returns:
{cc.AsyncPool}

            */
            parallel(tasks?: any, cb?: any, target?: Object): cc.AsyncPool;
            /**
            * {cc.AsyncPool}
series(tasks, cb, target)
Do tasks series.
Parameters:
{Array|Object} tasks
{function} cb
Optional
callback
{Object} target
Optional
Returns:
{cc.AsyncPool}

            */
            series(tasks?: any, cb?: any, target?: Object): cc.AsyncPool;
            /**
            * {cc.AsyncPool}
waterfall(tasks, cb, target)
Do tasks waterfall.
Parameters:
{Array|Object} tasks
{function} cb
callback
{Object} target
Optional
Returns:
{cc.AsyncPool}

            */
            waterfall(tasks?: any, cb?: any, target?: Object): cc.AsyncPool;
        }
    }
declare module cc {
        /**
        * 
Async Pool class, a helper of cc.async

        */
        export class AsyncPool  {
            /**
            * Async Pool class, a helper of cc.async
            */
            constructor(srcObj?: any, limit?: number, iterator?: any, onEnd?: any, target?: any);
        }
    }
declare module cc {
        /**
        * 
cc.AtlasNode is a subclass of cc.Node, it knows how to render a TextureAtlas object.

If you are going to render a TextureAtlas consider subclassing cc.AtlasNode (or a subclass of cc.AtlasNode)

All features from cc.Node are valid

You can create a cc.AtlasNode with an Atlas file, the width, the height of each item and the quantity of items to render

        */
        export class AtlasNode extends cc.Node {
            /**
            * cc.AtlasNode is a subclass of cc.Node, it knows how to render a TextureAtlas object.
            */
            constructor(tile?: string, tileWidth?: number, tileHeight?: number, itemsToRender?: number);
            /**
            * - Number of quads to draw
            */
            quadsToDraw: number;
            /**
            * - Current used texture
            */
            texture: cc.Texture2D;
            /**
            * - Texture atlas for cc.AtlasNode
            */
            textureAtlas: cc.TextureAtlas;
            /**
            * &amp;lt;static&amp;gt;
{cc.AtlasNode}
cc.AtlasNode.create(tile, tileWidth, tileHeight, itemsToRender)
Creates a cc.AtlasNode with an Atlas file the width and height of each item and the quantity of items to render
Parameters:
{String} tile
{Number} tileWidth
{Number} tileHeight
{Number} itemsToRender
Deprecated:
since v3.0, please use new construction instead
Returns:
{cc.AtlasNode}

            */
            static create(tile?: string, tileWidth?: number, tileHeight?: number, itemsToRender?: number): cc.AtlasNode;
            /**
            * ctor(tile, tileWidth, tileHeight, itemsToRender)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{String} tile
{Number} tileWidth
{Number} tileHeight
{Number} itemsToRender

            */
            ctor(tile?: string, tileWidth?: number, tileHeight?: number, itemsToRender?: number);
            /**
            * {cc.BlendFunc}
getBlendFunc()
Get node&#39;s blend function
Returns:
{cc.BlendFunc}

            */
            getBlendFunc(): cc.BlendFunc;
            /**
            * {cc.Color}
getColor()
Get color value of the atlas node
Returns:
{cc.Color}

            */
            getColor(): cc.Color;
            /**
            * {Number}
getQuadsToDraw()
Get the number of quads to be rendered
Returns:
{Number}

            */
            getQuadsToDraw(): number;
            /**
            * {cc.Texture2D}
getTexture()
Get the current texture
Returns:
{cc.Texture2D}

            */
            getTexture(): cc.Texture2D;
            /**
            * {cc.TextureAtlas}
getTextureAtlas()
Get the atlas texture
Returns:
{cc.TextureAtlas}

            */
            getTextureAtlas(): cc.TextureAtlas;
            /**
            * {Boolean}
initWithTexture(texture, tileWidth, tileHeight, itemsToRender)
Initializes an CCAtlasNode with an atlas texture, the width, the height of each tile and the quantity of tiles to render
Parameters:
{cc.Texture2D} texture
The atlas texture
{Number} tileWidth
The width of each tile
{Number} tileHeight
The height of each tile
{Number} itemsToRender
The quantity of tiles to be rendered
Returns:
{Boolean}

            */
            initWithTexture(texture?: cc.Texture2D, tileWidth?: number, tileHeight?: number, itemsToRender?: number): boolean;
            /**
            * {Boolean}
initWithTileFile(tile, tileWidth, tileHeight, itemsToRender)
Initializes an cc.AtlasNode object with an atlas texture file name, the width, the height of each tile and the quantity of tiles to render
Parameters:
{String} tile
The atlas texture file name
{Number} tileWidth
The width of each tile
{Number} tileHeight
The height of each tile
{Number} itemsToRender
The quantity of tiles to be rendered
Returns:
{Boolean}

            */
            initWithTileFile(tile?: string, tileWidth?: number, tileHeight?: number, itemsToRender?: number): boolean;
            /**
            * {Boolean}
isOpacityModifyRGB()
Get whether color should be changed with the opacity value
Returns:
{Boolean}

            */
            isOpacityModifyRGB(): boolean;
            /**
            * setBlendFunc(src, dst)
Set node&#39;s blend function
This function accept either cc.BlendFunc object or source value and destination value
Parameters:
{Number | cc.BlendFunc} src
{Number} dst

            */
            setBlendFunc(src?: any, dst?: number);
            /**
            * setColor(color)
Set node&#39;s color
Parameters:
{cc.Color} color
Color object created with cc.color(r, g, b).

            */
            setColor(color?: cc.Color);
            /**
            * setOpacity(opacity)
Set node&#39;s opacity
Parameters:
{Number} opacity
The opacity value

            */
            setOpacity(opacity?: number);
            /**
            * setOpacityModifyRGB(value)
Set whether color should be changed with the opacity value,
if true, node color will change while opacity changes.
Parameters:
{Boolean} value

            */
            setOpacityModifyRGB(value?: boolean);
            /**
            * setQuadsToDraw(quadsToDraw)
Set the number of quads to be rendered
Parameters:
{Number} quadsToDraw

            */
            setQuadsToDraw(quadsToDraw?: number);
            /**
            * setTexture(texture)
Replace the current texture with a new one
Parameters:
{cc.Texture2D} texture
The new texture

            */
            setTexture(texture?: cc.Texture2D);
            /**
            * setTextureAtlas(value)
Set the atlas texture
Parameters:
{cc.TextureAtlas} value
The texture

            */
            setTextureAtlas(value?: cc.TextureAtlas);
            /**
            * updateAtlasValues()
Updates the Atlas (indexed vertex array).
Empty implementation, shall be overridden in subclasses

            */
            updateAtlasValues();
        }
    }
declare module cc {
        /**
        * 
End music and effects.

        */
        export class audioEngine  {
            /**
            * End music and effects.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.end()
End music and effects.

            */
            static end();
            /**
            * &amp;lt;static&amp;gt;
{Number}
cc.audioEngine.getEffectsVolume()
The volume of the effects max value is 1.0,the min value is 0.0 .
//example
var effectVolume = cc.audioEngine.getEffectsVolume();
Returns:
{Number}

            */
            static getEffectsVolume(): number;
            /**
            * &amp;lt;static&amp;gt;
{Number}
cc.audioEngine.getMusicVolume()
The volume of the music max value is 1.0,the min value is 0.0 .
//example
var volume = cc.audioEngine.getMusicVolume();
Returns:
{Number}

            */
            static getMusicVolume(): number;
            /**
            * &amp;lt;static&amp;gt;
{Boolean}
cc.audioEngine.isMusicPlaying()
Whether the music is playing.
//example
if (cc.audioEngine.isMusicPlaying()) {
cc.log(&quot;music is playing&quot;);
}
else {
cc.log(&quot;music is not playing&quot;);
}
Returns:
{Boolean} If is playing return true,or return false.

            */
            static isMusicPlaying(): boolean;
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.pauseAllEffects()
Pause all playing sound effect.
//example
cc.audioEngine.pauseAllEffects();

            */
            static pauseAllEffects();
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.pauseEffect()
Pause playing sound effect.
//example
cc.audioEngine.pauseEffect(audioID);
Parameters:
{Number} cc.Audio
The return value of function playEffect.

            */
            static pauseEffect();
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.pauseMusic()
Pause playing music.
//example
cc.audioEngine.pauseMusic();

            */
            static pauseMusic();
            /**
            * &amp;lt;static&amp;gt;
{Number|null}
cc.audioEngine.playEffect(url, loop)
Play sound effect.
//example
var soundId = cc.audioEngine.playEffect(path);
Parameters:
{String} url
The path of the sound effect with filename extension.
{Boolean} loop
Whether to loop the effect playing, default value is false
Returns:
{Number|null} the audio id

            */
            static playEffect(url?: string, loop?: boolean): any;
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.playMusic(url, loop)
Play music.
//example
cc.audioEngine.playMusic(path, false);
Parameters:
{String} url
The path of the music file without filename extension.
{Boolean} loop
Whether the music loop or not.

            */
            static playMusic(url?: string, loop?: boolean);
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.resumeAllEffects()
Resume all playing sound effect
//example
cc.audioEngine.resumeAllEffects();

            */
            static resumeAllEffects();
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.resumeEffect()
Resume playing sound effect.
Parameters:
{Number} cc.Audio
The return value of function playEffect.

            */
            static resumeEffect();
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.resumeMusic()
Resume playing music.
//example
cc.audioEngine.resumeMusic();

            */
            static resumeMusic();
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.rewindMusic()
Rewind playing music.
//example
cc.audioEngine.rewindMusic();

            */
            static rewindMusic();
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.setEffectsVolume(volume)
Set the volume of sound effects.
//example
cc.audioEngine.setEffectsVolume(0.5);
Parameters:
{Number} volume
Volume must be in 0.0~1.0 .

            */
            static setEffectsVolume(volume?: number);
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.setMusicVolume(volume)
Set the volume of music.
//example
cc.audioEngine.setMusicVolume(0.5);
Parameters:
{Number} volume
Volume must be in 0.0~1.0 .

            */
            static setMusicVolume(volume?: number);
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.stopAllEffects()
Stop all playing sound effects.
//example
cc.audioEngine.stopAllEffects();

            */
            static stopAllEffects();
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.stopEffect()
Stop playing sound effect.
//example
cc.audioEngine.stopEffect(audioID);
Parameters:
{Number} cc.Audio
The return value of function playEffect.

            */
            static stopEffect();
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.stopMusic(releaseData)
Stop playing music.
//example
cc.audioEngine.stopMusic();
Parameters:
{Boolean} releaseData
Optional
If release the music data or not.As default value is false.

            */
            static stopMusic(releaseData?: boolean);
            /**
            * &amp;lt;static&amp;gt;
cc.audioEngine.unloadEffect(url)
Unload the preloaded effect from internal buffer
//example
cc.audioEngine.unloadEffect(EFFECT_FILE);
Parameters:
{String} url

            */
            static unloadEffect(url?: string);
            /**
            * &amp;lt;static&amp;gt;
{boolean}
cc.audioEngine.willPlayMusic()
Indicates whether any background music can be played or not.
Returns:
{boolean} true if the background music is playing, otherwise false

            */
            static willPlayMusic(): boolean;
        }
    }
declare module cc {
        /**
        * 
An action that moves the target with a cubic Bezier curve by a certain distance.
Relative to its movement.

        */
        export class BezierBy extends cc.ActionInterval {
            /**
            * An action that moves the target with a cubic Bezier curve by a certain distance.
            */
            constructor(t?: number, c?: Array<any>);
            /**
            * Please use cc.bezierBy instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.BezierBy;
            /**
            * {cc.BezierBy}
clone()
returns a new clone of the action
Returns:
{cc.BezierBy}

            */
            clone(): cc.BezierBy;
            /**
            * ctor(t, c)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} t
time in seconds
{Array} c
Array of points

            */
            ctor(t?: number, c?: Array<any>);
            /**
            * {Boolean}
initWithDuration(t, c)
Initializes the action.
Parameters:
{Number} t
time in seconds
{Array} c
Array of points
Returns:
{Boolean}

            */
            initWithDuration(t?: number, c?: Array<any>): boolean;
            /**
            * {cc.BezierBy}
reverse()
Returns a reversed action.
Returns:
{cc.BezierBy}

            */
            reverse(): cc.BezierBy;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
An action that moves the target with a cubic Bezier curve to a destination point.

        */
        export class BezierTo extends cc.BezierBy {
            /**
            * An action that moves the target with a cubic Bezier curve to a destination point.
            */
            constructor(t?: number, c?: Array<any>);
            /**
            * Please use cc.bezierTo instead
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.BezierTo;
            /**
            * {cc.BezierTo}
clone()
returns a new clone of the action
Returns:
{cc.BezierTo}

            */
            clone(): cc.BezierTo;
            /**
            * ctor(t, c)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} t
{Array} c
array of points
var bezierTo = new cc.BezierTo(2, bezier);

            */
            ctor(t?: number, c?: Array<any>);
            /**
            * {Boolean}
initWithDuration(t, c)
Initializes the action.
Parameters:
{Number} t
time in seconds
{Array} c
Array of points
Returns:
{Boolean}

            */
            initWithDuration(t?: number, c?: Array<any>): boolean;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
        }
    }
declare module cc {
        /**
        * 
Binary Stream Reader

        */
        export class BinaryStreamReader  {
            /**
            * Binary Stream Reader
            */
            constructor();
        }
    }
declare module cc {
        /**
        * 
Blinks a cc.Node object by modifying it&#39;s visible attribute

        */
        export class Blink extends cc.ActionInterval {
            /**
            * Blinks a cc.Node object by modifying it&#39;s visible attribute
            */
            constructor(duration?: number, blinks?: number);
            /**
            * Please use cc.blink instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Blink;
            /**
            * {cc.Blink}
clone()
returns a new clone of the action
Returns:
{cc.Blink}

            */
            clone(): cc.Blink;
            /**
            * ctor(duration, blinks)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
duration in seconds
{Number} blinks
blinks in times

            */
            ctor(duration?: number, blinks?: number);
            /**
            * {Boolean}
initWithDuration(duration, blinks)
Initializes the action.
Parameters:
{Number} duration
duration in seconds
{Number} blinks
blinks in times
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, blinks?: number): boolean;
            /**
            * {cc.Blink}
reverse()
Returns a reversed action.
Returns:
{cc.Blink}

            */
            reverse(): cc.Blink;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * stop()
stop the action

            */
            stop();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt
time in seconds

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Calls a &#39;callback&#39;.

        */
        export class CallFunc extends cc.ActionInstant {
            /**
            * Calls a &#39;callback&#39;.
            */
            constructor(selector?: any, selectorTarget?: any, data?: any);
            /**
            * Please use cc.callFunc instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.CallFunc;
            /**
            * {cc.CallFunc}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.CallFunc}

            */
            clone(): cc.CallFunc;
            /**
            * ctor(selector, selectorTarget, data)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates a CallFunc action with the callback.
Parameters:
{function} selector
{object|null} selectorTarget
Optional
{*|null} data
Optional
data for function, it accepts all data types.

            */
            ctor(selector?: any, selectorTarget?: any, data?: any);
            /**
            * execute()
execute the function.

            */
            execute();
            /**
            * {object}
getTargetCallback()
Get selectorTarget.
Returns:
{object}

            */
            getTargetCallback(): any;
            /**
            * {Boolean}
initWithFunction(selector, selectorTarget, data)
Initializes the action with a function or function and its target
Parameters:
{function} selector
{object|Null} selectorTarget
{*|Null} data
Optional
data for function, it accepts all data types.
Returns:
{Boolean}

            */
            initWithFunction(selector?: any, selectorTarget?: any, data?: any): boolean;
            /**
            * setTargetCallback(sel)
Set selectorTarget.
Parameters:
{object} sel

            */
            setTargetCallback(sel?: any);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Cardinal Spline path. http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline
Relative coordinates.

        */
        export class CardinalSplineBy extends cc.CardinalSplineTo {
            /**
            * Cardinal Spline path.
            */
            constructor(duration?: number, points?: Array<any>, tension?: number);
            /**
            * {cc.CardinalSplineBy}
clone()
returns a new clone of the action
Returns:
{cc.CardinalSplineBy}

            */
            clone(): cc.CardinalSplineBy;
            /**
            * &amp;lt;static&amp;gt;
{cc.CardinalSplineBy}
cc.CardinalSplineBy.create(duration, points, tension)
Please use cc.cardinalSplineBy instead.
creates an action with a Cardinal Spline array of points and tension.
Parameters:
{Number} duration
{Array} points
{Number} tension
Deprecated:
since v3.0 please use cc.cardinalSplineBy(duration, points, tension);
Returns:
{cc.CardinalSplineBy}

            */
            static create(duration?: number, points?: Array<any>, tension?: number): cc.CardinalSplineBy;
            /**
            * ctor(duration, points, tension)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates an action with a Cardinal Spline array of points and tension.
Parameters:
{Number} duration
{Array} points
{Number} tension

            */
            ctor(duration?: number, points?: Array<any>, tension?: number);
            /**
            * {cc.CardinalSplineBy}
reverse()
reverse a new cc.CardinalSplineBy
Returns:
{cc.CardinalSplineBy}

            */
            reverse(): cc.CardinalSplineBy;
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * updatePosition(newPos)
update position of target
Parameters:
{cc.Point} newPos

            */
            updatePosition(newPos?: cc.Point);
        }
    }
declare module cc {
        /**
        * 
Cardinal Spline path. http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline
Absolute coordinates.

        */
        export class CardinalSplineTo extends cc.ActionInterval {
            /**
            * Cardinal Spline path.
            */
            constructor(duration?: number, points?: Array<any>, tension?: number);
            /**
            * {cc.CardinalSplineTo}
clone()
returns a new clone of the action
Returns:
{cc.CardinalSplineTo}

            */
            clone(): cc.CardinalSplineTo;
            /**
            * &amp;lt;static&amp;gt;
{cc.CardinalSplineTo}
cc.CardinalSplineTo.create(duration, points, tension)
Please use cc.cardinalSplineTo instead.
creates an action with a Cardinal Spline array of points and tension
Parameters:
{Number} duration
{Array} points
array of control points
{Number} tension
Deprecated:
since v3.0 please use cc.cardinalSplineTo(duration, points, tension) instead.
Returns:
{cc.CardinalSplineTo}

            */
            static create(duration?: number, points?: Array<any>, tension?: number): cc.CardinalSplineTo;
            /**
            * ctor(duration, points, tension)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates an action with a Cardinal Spline array of points and tension.
Parameters:
{Number} duration
{Array} points
array of control points
{Number} tension

            */
            ctor(duration?: number, points?: Array<any>, tension?: number);
            /**
            * {Array}
getPoints()
Points getter
Returns:
{Array}

            */
            getPoints(): Array<any>;
            /**
            * {Boolean}
initWithDuration(duration, points, tension)
initializes the action with a duration and an array of points
Parameters:
{Number} duration
{Array} points
array of control points
{Number} tension
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, points?: Array<any>, tension?: number): boolean;
            /**
            * {cc.CardinalSplineTo}
reverse()
reverse a new cc.CardinalSplineTo.
Along the track of movement in the opposite.
Returns:
{cc.CardinalSplineTo}

            */
            reverse(): cc.CardinalSplineTo;
            /**
            * setPoints(points)
Points setter
Parameters:
{Array} points

            */
            setPoints(points?: Array<any>);
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
            /**
            * updatePosition(newPos)
update position of target
Parameters:
{cc.Point} newPos

            */
            updatePosition(newPos?: cc.Point);
        }
    }
declare module cc {
        /**
        * 
An action that moves the target with a CatmullRom curve by a certain distance.
A Catmull Rom is a Cardinal Spline with a tension of 0.5.
http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull.E2.80.93Rom_spline
Relative coordinates.

        */
        export class CatmullRomBy extends cc.CardinalSplineBy {
            /**
            * An action that moves the target with a CatmullRom curve by a certain distance.
            */
            constructor(dt?: number, points?: Array<any>);
            /**
            * Please use cc.catmullRomBy instead
Creates an action with a Cardinal Spline array of points and tension
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): CatmullRomBy;
        }
    }
declare module cc {
        /**
        * 
An action that moves the target with a CatmullRom curve to a destination point.
A Catmull Rom is a Cardinal Spline with a tension of 0.5.
http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull.E2.80.93Rom_spline
Absolute coordinates.

        */
        export class CatmullRomTo extends cc.CardinalSplineTo {
            /**
            * An action that moves the target with a CatmullRom curve to a destination point.
            */
            constructor(dt?: number, points?: Array<any>);
            /**
            * Please use cc.catmullRomTo instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.CatmullRomTo;
            /**
            * {cc.CatmullRomTo}
clone()
returns a new clone of the action
Returns:
{cc.CatmullRomTo}

            */
            clone(): cc.CatmullRomTo;
            /**
            * ctor(dt, points)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates an action with a Cardinal Spline array of points and tension.
Parameters:
{Number} dt
{Array} points

            */
            ctor(dt?: number, points?: Array<any>);
            /**
            * initWithDuration(dt, points)
Initializes the action with a duration and an array of points
Parameters:
{Number} dt
{Array} points

            */
            initWithDuration(dt?: number, points?: Array<any>);
        }
    }
declare module cc {
        /**
        * 
The base Class implementation (does nothing)

        */
        export class Class  {
            /**
            * The base Class implementation (does nothing)
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{function}
cc.Class.extend(props)
Create a new Class that inherits from this Class
Parameters:
{object} props
Returns:
{function}

            */
            static extend(props?: any): any;
        }
    }
declare module cc {
        /**
        * cc.ClippingNode is a subclass of cc.Node.
It draws its content (children) clipped using a stencil.
The stencil is an other cc.Node that will not be drawn.
The clipping is done using the alpha part of the stencil (adjusted with an alphaThreshold).

        */
        export class ClippingNode extends cc.Node {
            /**
            * 
cc.ClippingNode is a subclass of cc.Node.
            */
            constructor(stencil?: cc.Node);
            /**
            * - Threshold for alpha value.
            */
            alphaThreshold: number;
            /**
            * - Indicate whether in inverted mode.
            */
            inverted: boolean;
            /**
            * &amp;lt;static&amp;gt;
{cc.ClippingNode}
cc.ClippingNode.create(stencil)
Creates and initializes a clipping node with an other node as its stencil.
The stencil node will be retained.
//example
new cc.ClippingNode(stencil);
Parameters:
{cc.Node} stencil
Optional, Default: null
Deprecated:
since v3.0, please use &quot;new cc.ClippingNode(stencil)&quot; instead
Returns:
{cc.ClippingNode}

            */
            static create(stencil?: cc.Node): cc.ClippingNode;
            /**
            * ctor(stencil)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{cc.Node} stencil
Optional, Default: null

            */
            ctor(stencil?: cc.Node);
            /**
            * {Number}
getAlphaThreshold()
The alpha threshold.
The content is drawn only where the stencil have pixel with alpha greater than the alphaThreshold.
Should be a float between 0 and 1.
This default to 1 (so alpha test is disabled).
Returns:
{Number}

            */
            getAlphaThreshold(): number;
            /**
            * {cc.Node}
getStencil()
The cc.Node to use as a stencil to do the clipping.
The stencil node will be retained. This default to nil.
Returns:
{cc.Node}

            */
            getStencil(): cc.Node;
            /**
            * init(stencil)
Initialization of the node, please do not call this function by yourself, you should pass the parameters to constructor to initialize it
.
Parameters:
{cc.Node} stencil
Optional, Default: null

            */
            init(stencil?: cc.Node);
            /**
            * {Boolean}
isInverted()
Inverted. If this is set to YES,
the stencil is inverted, so the content is drawn where the stencil is NOT drawn.
This default to NO.
Returns:
{Boolean}

            */
            isInverted(): boolean;
            /**
            * onEnter()
Event callback that is invoked every time when node enters the &#39;stage&#39;.
If the CCNode enters the &#39;stage&#39; with a transition, this event is called when the transition starts.
During onEnter you can&#39;t access a &quot;sister/brother&quot; node.
If you override onEnter, you must call its parent&#39;s onEnter function with this._super().

            */
            onEnter();
            /**
            * onEnterTransitionDidFinish()
Event callback that is invoked when the node enters in the &#39;stage&#39;.
If the node enters the &#39;stage&#39; with a transition, this event is called when the transition finishes.
If you override onEnterTransitionDidFinish, you shall call its parent&#39;s onEnterTransitionDidFinish with this._super()

            */
            onEnterTransitionDidFinish();
            /**
            * onExit()
callback that is called every time the node leaves the &#39;stage&#39;.
If the node leaves the &#39;stage&#39; with a transition, this callback is called when the transition finishes.
During onExit you can&#39;t access a sibling node.
If you override onExit, you shall call its parent&#39;s onExit with this._super().

            */
            onExit();
            /**
            * onExitTransitionDidStart()
callback that is called every time the node leaves the &#39;stage&#39;.
If the node leaves the &#39;stage&#39; with a transition, this callback is called when the transition starts.
If you override onExitTransitionDidStart, you shall call its parent&#39;s onExitTransitionDidStart with this._super()

            */
            onExitTransitionDidStart();
            /**
            * setAlphaThreshold(alphaThreshold)
set alpha threshold.
Parameters:
{Number} alphaThreshold

            */
            setAlphaThreshold(alphaThreshold?: number);
            /**
            * setInverted(inverted)
set whether or not invert of stencil
Parameters:
{Boolean} inverted

            */
            setInverted(inverted?: boolean);
            /**
            * setStencil(stencil)
Set stencil.
Parameters:
{cc.Node} stencil

            */
            setStencil(stencil?: cc.Node);
        }
    }
declare module cc {
        /**
        * 
Color class, please use cc.color() to construct a color

        */
        export class Color  {
            /**
            * Color class, please use cc.color() to construct a color
            */
            constructor(r?: number, g?: number, b?: number, a?: number);
        }
    }
declare module cc {
        /**
        * 
The base class of component in CocoStudio

        */
        export class Component extends cc.Class {
            /**
            * The base class of component in CocoStudio
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.Component}
cc.Component.create()
Allocates and initializes a component.
Deprecated:
since v3.0, please use new construction instead.
Returns:
{cc.Component}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.Component;
            /**
            * ctor()
Construction of cc.Component

            */
            ctor();
            /**
            * {string}
getName()
Returns the name of cc.Component.
Returns:
{string}

            */
            getName(): string;
            /**
            * {*}
getOwner()
Returns the owner of cc.Component.
Returns:
{*}

            */
            getOwner(): any;
            /**
            * {boolean}
init()
Initializes a cc.Component.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * {boolean}
isEnabled()
Returns component whether is enabled.
Returns:
{boolean}

            */
            isEnabled(): boolean;
            /**
            * onEnter()
The callback when a component enter stage.

            */
            onEnter();
            /**
            * onExit()
The callback when a component exit stage.

            */
            onExit();
            /**
            * serialize(reader)
Serialize a component object.
Parameters:
reader

            */
            serialize();
            /**
            * setEnabled(enable)
Sets component whether is enabled.
Parameters:
enable

            */
            setEnabled();
            /**
            * setName(name)
Sets the name to cc.Component.
Parameters:
{String} name

            */
            setName(name?: string);
            /**
            * setOwner(owner)
Sets the owner to cc.Component.
Parameters:
owner

            */
            setOwner();
            /**
            * update(delta)
The callback per every frame if it schedules update.
Parameters:
delta

            */
            update();
        }
    }
declare module cc {
        /**
        * 
The component container for Cocostudio, it has some components.

        */
        export class ComponentContainer extends cc.Class {
            /**
            * The component container for Cocostudio, it has some components.
            */
            constructor();
            /**
            * {boolean}
add(component)
Adds a component to container
Parameters:
{cc.Component} component
Returns:
{boolean}

            */
            add(component?: cc.Component): boolean;
            /**
            * ctor(node)
Construction of cc.ComponentContainer
Parameters:
node

            */
            ctor();
            /**
            * {*}
getComponent(name)
Gets component by name.
Parameters:
name
Returns:
{*}

            */
            getComponent(): any;
            /**
            * {boolean}
isEmpty()
Returns the container whether is empty.
Returns:
{boolean}

            */
            isEmpty(): boolean;
            /**
            * {boolean}
remove(name)
Removes component from container by name or component object.
Parameters:
{String|cc.Component} name
component name or component object.
Returns:
{boolean}

            */
            remove(name?: any): boolean;
            /**
            * removeAll()
Removes all components of container.

            */
            removeAll();
            /**
            * visit(delta)
Visit callback by director. it calls every frame.
Parameters:
{Number} delta

            */
            visit(delta?: number);
        }
    }
declare module cc {
        /**
        * 
cc.configuration is a singleton object which contains some openGL variables

        */
        export class configuration  {
            /**
            * cc.configuration is a singleton object which contains some openGL variables
            */
            constructor();
            /**
            * checkForGLExtension(searchName)
returns whether or not an OpenGL is supported
Parameters:
{String} searchName

            */
            checkForGLExtension(searchName?: string);
            /**
            * dumpInfo()
Dumps the current configuration on the console

            */
            dumpInfo();
            /**
            * gatherGPUInfo()
gathers OpenGL / GPU information

            */
            gatherGPUInfo();
            /**
            * {Number}
getMaxModelviewStackDepth()
OpenGL Max Modelview Stack Depth.
Returns:
{Number}

            */
            getMaxModelviewStackDepth(): number;
            /**
            * {Number}
getMaxTextureSize()
OpenGL Max texture size.
Returns:
{Number}

            */
            getMaxTextureSize(): number;
            /**
            * {Number}
getMaxTextureUnits()
returns the maximum texture units
Returns:
{Number}

            */
            getMaxTextureUnits(): number;
            /**
            * {String|Bool|Number|Object}
getValue(key, default_value)
Returns the value of a given key.  If the key is not found, it will return the default value
Parameters:
{String} key
{String|Bool|Number|Object} default_value
Optional, Default: null
Returns:
{String|Bool|Number|Object}

            */
            getValue(key?: string, default_value?: any): any;
            /**
            * loadConfigFile(url)
Loads a config file. If the keys are already present, then they are going to be replaced. Otherwise the new keys are added.
Parameters:
{string} url

            */
            loadConfigFile(url?: string);
            /**
            * setValue(key, value)
Sets a new key/value pair  in the configuration dictionary
Parameters:
{string} key
{String|Bool|Number|Object} value

            */
            setValue(key?: string, value?: any);
            /**
            * {Boolean}
supportsATITC()
Whether or not ATITC Texture Compressed is supported
Returns:
{Boolean}

            */
            supportsATITC(): boolean;
            /**
            * {Boolean}
supportsBGRA8888()
Whether or not BGRA8888 textures are supported.
Returns:
{Boolean}

            */
            supportsBGRA8888(): boolean;
            /**
            * {Boolean}
supportsDiscardFramebuffer()
Whether or not glDiscardFramebufferEXT is supported
Returns:
{Boolean}

            */
            supportsDiscardFramebuffer(): boolean;
            /**
            * {Boolean}
supportsETC()
Whether or not ETC Texture Compressed is supported
Returns:
{Boolean}

            */
            supportsETC(): boolean;
            /**
            * {Boolean}
supportsNPOT()
Whether or not the GPU supports NPOT (Non Power Of Two) textures.
OpenGL ES 2.0 already supports NPOT (iOS).
Returns:
{Boolean}

            */
            supportsNPOT(): boolean;
            /**
            * {Boolean}
supportsPVRTC()
Whether or not PVR Texture Compressed is supported
Returns:
{Boolean}

            */
            supportsPVRTC(): boolean;
            /**
            * {Boolean}
supportsS3TC()
Whether or not S3TC Texture Compressed is supported
Returns:
{Boolean}

            */
            supportsS3TC(): boolean;
            /**
            * {Boolean}
supportsShareableVAO()
Whether or not shareable VAOs are supported.
Returns:
{Boolean}

            */
            supportsShareableVAO(): boolean;
        }
    }
declare module cc {
        /**
        * 
cc.ContainerStrategy class is the root strategy class of container&#39;s scale strategy,
it controls the behavior of how to scale the cc.container and cc._canvas object

        */
        export class ContainerStrategy extends cc.Class {
            /**
            * cc.ContainerStrategy class is the root strategy class of container&#39;s scale strategy,
it controls the behavior of how to scale the cc.container and cc._canvas object
            */
            constructor();
            /**
            * apply(view, designedResolution)
Function to apply this strategy
Parameters:
{cc.view} view
{cc.Size} designedResolution

            */
            apply(view?: cc.view, designedResolution?: cc.Size);
            /**
            * postApply(view)
Manipulation after applying the strategy
Parameters:
{cc.view} view
The target view

            */
            postApply(view?: cc.view);
            /**
            * preApply(The)
Manipulation before appling the strategy
Parameters:
{cc.view} The
target view

            */
            preApply(The?: cc.view);
        }
    }
declare module cc {
        /**
        * 
cc.ContentStrategy class is the root strategy class of content&#39;s scale strategy,
it controls the behavior of how to scale the scene and setup the viewport for the game

        */
        export class ContentStrategy extends cc.Class {
            /**
            * cc.ContentStrategy class is the root strategy class of content&#39;s scale strategy,
it controls the behavior of how to scale the scene and setup the viewport for the game
            */
            constructor();
            /**
            * {object}
apply(view, designedResolution)
Function to apply this strategy
The return value is {scale: [scaleX, scaleY], viewport: {cc.Rect}},
The target view can then apply these value to itself, it&#39;s preferred not to modify directly its private variables
Parameters:
{cc.view} view
{cc.Size} designedResolution
Returns:
{object} scaleAndViewportRect

            */
            apply(view?: cc.view, designedResolution?: cc.Size): any;
            /**
            * postApply(view)
Manipulation after applying the strategy
Parameters:
{cc.view} view
The target view

            */
            postApply(view?: cc.view);
            /**
            * preApply(view)
Manipulation before applying the strategy
Parameters:
{cc.view} view
The target view

            */
            preApply(view?: cc.view);
        }
    }
declare module cc {
        /**
        * 
CCControl is inspired by the UIControl API class from the UIKit library of
CocoaTouch. It provides a base class for control CCSprites such as CCButton
or CCSlider that convey user intent to the application.
The goal of CCControl is to define an interface and base implementation for
preparing action messages and initially dispatching them to their targets when
certain events occur.
To use the CCControl you have to subclass it.

        */
        export class Control extends cc.Layer {
            /**
            * CCControl is inspired by the UIControl API class from the UIKit library of
CocoaTouch.
            */
            constructor();
            /**
            * - Indicate whether the control node is enbaled
            */
            enabled: boolean;
            /**
            * - Indicate whether the control node is highlighted
            */
            highlighted: boolean;
            /**
            * - Indicate whether the control node is selected
            */
            selected: boolean;
            /**
            * -  The current control state: cc.CONTROL_STATE_NORMAL | cc.CONTROL_STATE_HIGHLIGHTED | cc.CONTROL_STATE_DISABLED | cc.CONTROL_STATE_SELECTED | cc.CONTROL_STATE_INITIAL
            */
            state: number;
            /**
            * addTargetWithActionForControlEvents(target, action, controlEvents)
Adds a target and action for a particular event (or events) to an internal
dispatch table.
The action message may optionally include the sender and the event as
parameters, in that order.
When you call this method, target is not retained.
Parameters:
{Object} target
The target object that is, the object to which the action message is sent. It cannot be nil. The target is not retained.
{function} action
A selector identifying an action message. It cannot be NULL.
{Number} controlEvents
A bitmask specifying the control events for which the action message is sent. See &quot;CCControlEvent&quot; for bitmask constants.

            */
            addTargetWithActionForControlEvents(target?: Object, action?: any, controlEvents?: number);
            /**
            * getTouchLocation(touch)
Returns a point corresponding to the touh location converted into the
control space coordinates.
Parameters:
{cc.Touch} touch
A CCTouch object that represents a touch.

            */
            getTouchLocation(touch?: cc.Touch);
            /**
            * {Boolean}
isTouchInside(touch)
Returns a boolean value that indicates whether a touch is inside the bounds of the receiver. The given touch must be relative to the world.
Parameters:
{cc.Touch} touch
A cc.Touch object that represents a touch.
Returns:
{Boolean} YES whether a touch is inside the receiver&#39;s rect.

            */
            isTouchInside(touch?: cc.Touch): boolean;
            /**
            * needsLayout()
Updates the control layout using its current internal state.

            */
            needsLayout();
            /**
            * removeTargetWithActionForControlEvents(target, action, controlEvents)
Removes a target and action for a particular event (or events) from an internal dispatch table.
Parameters:
{Object} target
The target object that is, the object to which the action message is sent. Pass nil to remove all targets paired with action and the specified control events.
{function} action
A selector identifying an action message. Pass NULL to remove all action messages paired with target.
{Number} controlEvents
A bitmask specifying the control events associated with target and action. See &quot;CCControlEvent&quot; for bitmask constants.

            */
            removeTargetWithActionForControlEvents(target?: Object, action?: any, controlEvents?: number);
            /**
            * sendActionsForControlEvents(controlEvents)
Sends action messages for the given control events.
which action messages are sent. See &quot;CCControlEvent&quot; for bitmask constants.
Parameters:
{Number} controlEvents
A bitmask whose set flags specify the control events for

            */
            sendActionsForControlEvents(controlEvents?: number);
            /**
            * setEnabled(enabled)
Tells whether the control is enabled
Parameters:
{Boolean} enabled

            */
            setEnabled(enabled?: boolean);
            /**
            * setHighlighted(highlighted)
A Boolean value that determines whether the control is highlighted.
Parameters:
{Boolean} highlighted

            */
            setHighlighted(highlighted?: boolean);
            /**
            * setSelected(selected)
A Boolean value that determines the control selected state.
Parameters:
{Boolean} selected

            */
            setSelected(selected?: boolean);
        }
    }
declare module cc {
        /**
        * 
CCControlButton: Button control for Cocos2D.

        */
        export class ControlButton extends cc.Control {
            /**
            * CCControlButton: Button control for Cocos2D.
            */
            constructor();
            /**
            * - Indicate whether the background image will be adjusted
            */
            adjustBackgroundImage: boolean;
            /**
            * - The anchor point for the label of the control button
            */
            labelAnchor: boolean;
            /**
            * - The preferred size of the control button
            */
            preferredSize: cc.Size;
            /**
            * - Indicate whether the button will be zoomed while touch down
            */
            zoomOnTouchDown: boolean;
            /**
            * &amp;lt;static&amp;gt;
{ControlButton}
cc.ControlButton.create(label, backgroundSprite, fontSize)
Parameters:
label
backgroundSprite
fontSize
Returns:
{ControlButton}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ControlButton;
            /**
            * {Boolean}
doesAdjustBackgroundImage()
Adjust the background image. YES by default. If the property is set to NO, the background will use the prefered size of the background image.
Returns:
{Boolean}

            */
            doesAdjustBackgroundImage(): boolean;
            /**
            * getBackgroundSpriteForState(state)
Returns the background sprite used for a state.
Parameters:
{Number} state
The state that uses the background sprite. Possible values are described in &quot;CCControlState&quot;.

            */
            getBackgroundSpriteForState(state?: number);
            /**
            * getPreferredSize()
The prefered size of the button, if label is larger it will be expanded.

            */
            getPreferredSize();
            /**
            * {cc.Color}
getTitleColorForState(state)
Returns the title color used for a state.
Parameters:
{Number} state
The state that uses the specified color. The values are described in &quot;CCControlState&quot;.
Returns:
{cc.Color} The color of the title for the specified state.

            */
            getTitleColorForState(state?: number): cc.Color;
            /**
            * {string}
getTitleForState(state)
Returns the title used for a state.
Parameters:
{Number} state
The state that uses the title. Possible values are described in &quot;CCControlState&quot;.
Returns:
{string} The title for the specified state.

            */
            getTitleForState(state?: number): string;
            /**
            * {cc.Node}
getTitleLabelForState(state)
Returns the title label used for a state.
Parameters:
state
The state that uses the title label. Possible values are described in &quot;CCControlState&quot;.
Returns:
{cc.Node} the title label used for a state.

            */
            getTitleLabelForState(): cc.Node;
            /**
            * {string}
getTitleTTFForState(state)
return the title TTF filename to use for the specified state.
Parameters:
{Number} state
Returns:
{string}

            */
            getTitleTTFForState(state?: number): string;
            /**
            * {Number}
getTitleTTFSizeForState(state)
return the font size of LabelTTF to use for the specified state
Parameters:
{Number} state
Returns:
{Number}

            */
            getTitleTTFSizeForState(state?: number): number;
            /**
            * getZoomOnTouchDown()
Adjust the button zooming on touchdown. Default value is YES.

            */
            getZoomOnTouchDown();
            /**
            * isPushed()
Flag to know if the button is currently pushed.

            */
            isPushed();
            /**
            * setBackgroundSpriteForState(sprite, state)
Sets the background sprite to use for the specified button state.
Parameters:
{Scale9Sprite} sprite
The background sprite to use for the specified state.
{Number} state
The state that uses the specified image. The values are described in &quot;CCControlState&quot;.

            */
            setBackgroundSpriteForState(sprite?: Scale9Sprite, state?: number);
            /**
            * setBackgroundSpriteFrameForState(spriteFrame, state)
Sets the background spriteFrame to use for the specified button state.
Parameters:
{SpriteFrame} spriteFrame
The background spriteFrame to use for the specified state.
{Number} state
The state that uses the specified image. The values are described in &quot;CCControlState&quot;.

            */
            setBackgroundSpriteFrameForState(spriteFrame?: SpriteFrame, state?: number);
            /**
            * setMargins(marginH, marginV)
set the margins at once (so we only have to do one call of needsLayout)
Parameters:
{Number} marginH
{Number} marginV

            */
            setMargins(marginH?: number, marginV?: number);
            /**
            * setTitleBMFontForState(fntFile, state)
Sets the font of the label, changes the label to a CCLabelBMFont if necessary.
Parameters:
{string} fntFile
The name of the font to change to
{Number} state
The state that uses the specified fntFile. The values are described in &quot;CCControlState&quot;.

            */
            setTitleBMFontForState(fntFile?: string, state?: number);
            /**
            * setTitleColorForState(color, state)
Sets the color of the title to use for the specified state.
Parameters:
{cc.Color} color
The color of the title to use for the specified state.
{Number} state
The state that uses the specified color. The values are described in &quot;CCControlState&quot;.

            */
            setTitleColorForState(color?: cc.Color, state?: number);
            /**
            * setTitleForState(title, state)
Sets the title string to use for the specified state.
If a property is not specified for a state, the default is to use the CCButtonStateNormal value.
Parameters:
{string} title
The title string to use for the specified state.
{Number} state
The state that uses the specified title. The values are described in &quot;CCControlState&quot;.

            */
            setTitleForState(title?: string, state?: number);
            /**
            * setTitleLabelForState(titleLabel, state)
Sets the title label to use for the specified state.
If a property is not specified for a state, the default is to use the CCButtonStateNormal value.
Parameters:
{cc.Node} titleLabel
The title label to use for the specified state.
{Number} state
The state that uses the specified title. The values are described in &quot;CCControlState&quot;.

            */
            setTitleLabelForState(titleLabel?: cc.Node, state?: number);
            /**
            * setTitleTTFForState(fntFile, state)
Sets the title TTF filename to use for the specified state.
Parameters:
{string} fntFile
{Number} state

            */
            setTitleTTFForState(fntFile?: string, state?: number);
            /**
            * setTitleTTFSizeForState(size, state)
Parameters:
{Number} size
{Number} state

            */
            setTitleTTFSizeForState(size?: number, state?: number);
        }
    }
declare module cc {
        /**
        * 
ControlColourPicker: color picker ui component.

        */
        export class ControlColourPicker extends cc.Control {
            /**
            * ControlColourPicker: color picker ui component.
            */
            constructor();
            /**
            * -  The background sprite
            */
            background: cc.Sprite;
            /**
            * &amp;lt;static&amp;gt;
{ControlColourPicker}
cc.ControlColourPicker.create()
Returns:
{ControlColourPicker}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ControlColourPicker;
        }
    }
declare module cc {
        /**
        * 
ControlHuePicker: HUE picker ui component.

        */
        export class ControlHuePicker extends cc.Control {
            /**
            * ControlHuePicker: HUE picker ui component.
            */
            constructor();
            /**
            * -  The background sprite
            */
            background: cc.Sprite;
            /**
            * - The hue value
            */
            hue: number;
            /**
            * - The hue value in percentage
            */
            huePercent: number;
            /**
            * -  The slider sprite
            */
            slider: cc.Sprite;
            /**
            * -  The start position of the picker
            */
            startPos: cc.Point;
            /**
            * &amp;lt;static&amp;gt;
{ControlHuePicker}
cc.ControlHuePicker.create(target, pos)
Parameters:
target
pos
Returns:
{ControlHuePicker}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ControlHuePicker;
            /**
            * ctor(target, pos)
The constructor of cc.ControlHuePicker
Parameters:
{cc.Node} target
{cc.Point} pos
position

            */
            ctor(target?: cc.Node, pos?: cc.Point);
        }
    }
declare module cc {
        /**
        * 
CCControlPotentiometer: Potentiometer control for Cocos2D.

        */
        export class ControlPotentiometer extends cc.Control {
            /**
            * CCControlPotentiometer: Potentiometer control for Cocos2D.
            */
            constructor();
            /**
            * - The maximum value of the potentionmeter
            */
            maxValue: number;
            /**
            * - The minimum value of the potentionmeter
            */
            minValue: number;
            /**
            * - The previous location of the potentionmeter
            */
            prevLocation: cc.Point;
            /**
            * - The progress timer of the potentionmeter
            */
            progressTimer: cc.ProgressTimer;
            /**
            * - The thumb sprite of the potentionmeter
            */
            thumbSprite: cc.Sprite;
            /**
            * - The current value of the potentionmeter
            */
            value: number;
            /**
            * {Number}
angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(beginLineA, endLineA, beginLineB, endLineB)
the angle in degree between line1 and line2.
Parameters:
{cc.Point} beginLineA
{cc.Point} endLineA
{cc.Point} beginLineB
{cc.Point} endLineB
Returns:
{Number}

            */
            angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(beginLineA?: cc.Point, endLineA?: cc.Point, beginLineB?: cc.Point, endLineB?: cc.Point): number;
            /**
            * &amp;lt;static&amp;gt;
{ControlPotentiometer}
cc.ControlPotentiometer.create(backgroundFile, progressFile, thumbFile)
Parameters:
backgroundFile
progressFile
thumbFile
Returns:
{ControlPotentiometer}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ControlPotentiometer;
            /**
            * {Number}
distanceBetweenPointAndPoint(point1, point2)
the distance between the point1 and point2
Parameters:
{cc.Point} point1
{cc.Point} point2
Returns:
{Number}

            */
            distanceBetweenPointAndPoint(point1?: cc.Point, point2?: cc.Point): number;
            /**
            * {Boolean}
initWithTrackSprite_ProgressTimer_ThumbSprite(trackSprite, progressTimer, thumbSprite)
Parameters:
{cc.Sprite} trackSprite
{cc.ProgressTimer} progressTimer
{cc.Sprite} thumbSprite
Returns:
{Boolean}

            */
            initWithTrackSprite_ProgressTimer_ThumbSprite(trackSprite?: cc.Sprite, progressTimer?: cc.ProgressTimer, thumbSprite?: cc.Sprite): boolean;
        }
    }
declare module cc {
        /**
        * 
ControlSaturationBrightnessPicker: Saturation brightness picker ui component.

        */
        export class ControlSaturationBrightnessPicker extends cc.Control {
            /**
            * ControlSaturationBrightnessPicker: Saturation brightness picker ui component.
            */
            constructor();
            /**
            * -  The background sprite
            */
            background: cc.Sprite;
            /**
            * -  Brightness value of the picker
            */
            brightness: number;
            /**
            * -  The overlay sprite
            */
            overlay: cc.Sprite;
            /**
            * -  Saturation value of the picker
            */
            saturation: number;
            /**
            * -  The shadow sprite
            */
            shadow: cc.Sprite;
            /**
            * -  The slider sprite
            */
            slider: cc.Sprite;
            /**
            * -  The start position of the picker
            */
            startPos: cc.Point;
            /**
            * &amp;lt;static&amp;gt;
{ControlSaturationBrightnessPicker}
cc.ControlSaturationBrightnessPicker.create(target, pos)
Creates a cc.ControlSaturationBrightnessPicker
Parameters:
{cc.Node} target
{cc.Point} pos
position
Returns:
{ControlSaturationBrightnessPicker}

            */
            static create(target?: cc.Node, pos?: cc.Point): ControlSaturationBrightnessPicker;
            /**
            * ctor(target, pos)
The constructor of cc.ControlSaturationBrightnessPicker
Parameters:
{cc.Node} target
{cc.Point} pos
position

            */
            ctor(target?: cc.Node, pos?: cc.Point);
        }
    }
declare module cc {
        /**
        * 
ControlSlider: Slider ui component.

        */
        export class ControlSlider extends cc.Control {
            /**
            * ControlSlider: Slider ui component.
            */
            constructor();
            /**
            * -  The overlay sprite
            */
            backgroundSprite: cc.Sprite;
            /**
            * - The maximum allowed value of the slider
            */
            maxAllowedValue: number;
            /**
            * - The maximum value of the slider
            */
            maxValue: number;
            /**
            * - The minimum allowed value of the slider
            */
            minAllowedValue: number;
            /**
            * - The minimum value of the slider
            */
            minValue: number;
            /**
            * -  The background sprite
            */
            progressSprite: cc.Sprite;
            /**
            * -  Brightness value of the picker
            */
            thumbSprite: number;
            /**
            * - The value of the slider
            */
            value: number;
            /**
            * &amp;lt;static&amp;gt;
cc.ControlSlider.create(bgFile, progressFile, thumbFile)
Creates a slider with a given background sprite and a progress bar and a
thumb item.
Parameters:
bgFile
progressFile
thumbFile
See:
cc.ControlSlider

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ControlSlider;
            /**
            * initWithSprites(backgroundSprite, progressSprite, thumbSprite)
Initializes a slider with a background sprite, a progress bar and a thumb
item.
Parameters:
{cc.Sprite} backgroundSprite
CCSprite, that is used as a background.
{cc.Sprite} progressSprite
CCSprite, that is used as a progress bar.
{cc.Sprite} thumbSprite
CCMenuItem, that is used as a thumb.

            */
            initWithSprites(backgroundSprite?: cc.Sprite, progressSprite?: cc.Sprite, thumbSprite?: cc.Sprite);
            /**
            * valueForLocation(location)
Returns the value for the given location.
Parameters:
location

            */
            valueForLocation();
        }
    }
declare module cc {
        /**
        * 
ControlStepper: Stepper ui component.

        */
        export class ControlStepper extends cc.Control {
            /**
            * ControlStepper: Stepper ui component.
            */
            constructor();
            /**
            * -  Indicate whether the stepper value is continuous
            */
            continuous: boolean;
            /**
            * - The maximum value of the stepper control
            */
            maxValue: number;
            /**
            * - The label for minus button of the stepper control
            */
            minusLabel: cc.LabelTTF;
            /**
            * - The sprite for minus button of the stepper control
            */
            minusSprite: cc.Sprite;
            /**
            * - The minimum value of the stepper control
            */
            minValue: number;
            /**
            * - The label for plus button of the stepper control
            */
            plusSLabel: cc.LabelTTF;
            /**
            * - The sprite for plus button of the stepper control
            */
            plusSprite: cc.Sprite;
            /**
            * - The interval value for each step of the stepper control
            */
            stepValue: number;
            /**
            * - The value of the stepper control
            */
            value: number;
            /**
            * - Indicate whether the stepper wraps
            */
            wraps: boolean;
            /**
            * &amp;lt;static&amp;gt;
{ControlStepper}
cc.ControlStepper.create(minusSprite, plusSprite)
Creates a cc.ControlStepper
Parameters:
{cc.Sprite} minusSprite
{cc.Sprite} plusSprite
Returns:
{ControlStepper}

            */
            static create(minusSprite?: cc.Sprite, plusSprite?: cc.Sprite): ControlStepper;
            /**
            * stopAutorepeat()
Stop the autorepeat.

            */
            stopAutorepeat();
        }
    }
declare module cc {
        /**
        * 
CCControlSwitch: Switch control ui component

        */
        export class ControlSwitch extends cc.Control {
            /**
            * CCControlSwitch: Switch control ui component
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
cc.ControlSwitch.create(maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel)
Creates a switch with a mask sprite, on/off sprites for on/off states and a thumb sprite.
Parameters:
maskSprite
onSprite
offSprite
thumbSprite
onLabel
offLabel

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ControlSwitch;
            /**
            * initWithMaskSprite(maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel)
Creates a switch with a mask sprite, on/off sprites for on/off states, a thumb sprite and an on/off labels.
Parameters:
maskSprite
onSprite
offSprite
thumbSprite
onLabel
offLabel

            */
            initWithMaskSprite();
        }
    }
declare module cc {
        /**
        * 
ControlSwitchSprite: Sprite switch control ui component

        */
        export class ControlSwitchSprite extends cc.Sprite {
            /**
            * ControlSwitchSprite: Sprite switch control ui component
            */
            constructor();
            /**
            * - The position of the mask
            */
            maskPos: cc.Point;
            /**
            * - The texture of the mask
            */
            maskTexture: cc.Texture2D;
            /**
            * - The sprite of switch off
            */
            offLabel: cc.LabelTTF;
            /**
            * - The position of slider when switch is off
            */
            offPos: cc.Point;
            /**
            * -  The width of the off side of the switch control
            */
            offSideWidth: number;
            /**
            * - The sprite of switch off
            */
            offSprite: cc.Sprite;
            /**
            * - The sprite of switch on
            */
            onLabel: cc.LabelTTF;
            /**
            * - The position of slider when switch is on
            */
            onPos: cc.Point;
            /**
            * -  The width of the on side of the switch control
            */
            onSideWidth: number;
            /**
            * - The sprite of switch on
            */
            onSprite: cc.Sprite;
            /**
            * - Slider&#39;s x position
            */
            sliderX: number;
            /**
            * - The position of the texture
            */
            texturePos: cc.Point;
            /**
            * - The thumb sprite of the switch control
            */
            thumbSprite: cc.Sprite;
        }
    }
declare module cc {
        /**
        * 
Delays the action a certain amount of seconds

        */
        export class DelayTime extends cc.ActionInterval {
            /**
            * Delays the action a certain amount of seconds
            */
            constructor();
            /**
            * Please use cc.delayTime instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.DelayTime;
            /**
            * {cc.DelayTime}
clone()
returns a new clone of the action
Returns:
{cc.DelayTime}

            */
            clone(): cc.DelayTime;
            /**
            * {cc.DelayTime}
reverse()
Returns a reversed action.
Returns:
{cc.DelayTime}

            */
            reverse(): cc.DelayTime;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Will be overwrite.
Parameters:
{Number} dt
time in seconds

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * ATTENTION: USE cc.director INSTEAD OF cc.Director.
cc.director is a singleton object which manage your game&#39;s logic flow.
Since the cc.director is a singleton, you don&#39;t need to call any constructor or create functions,
the standard way to use it is by calling:
- cc.director.methodName();

It creates and handle the main Window and manages how and when to execute the Scenes.
The cc.director is also responsible for:
- initializing the OpenGL context
- setting the OpenGL pixel format (default on is RGB565)
- setting the OpenGL pixel format (default on is RGB565)
- setting the OpenGL buffer depth (default one is 0-bit)
- setting the projection (default one is 3D)
- setting the orientation (default one is Portrait)
The cc.director also sets the default OpenGL context:
- GL_TEXTURE_2D is enabled
- GL_VERTEX_ARRAY is enabled
- GL_COLOR_ARRAY is enabled
- GL_TEXTURE_COORD_ARRAY is enabled
cc.director also synchronizes timers with the refresh rate of the display.
Features and Limitations:
- Scheduled timers &amp; drawing are synchronizes with the refresh rate of the display
- Only supports animation intervals of 1/60 1/30 &amp; 1/15

        */
        export class Director  {
            /**
            * 
ATTENTION: USE cc.director INSTEAD OF cc.Director.
            */
            constructor();
            /**
            * The event after draw of cc.Director
            */
            static EVENT_AFTER_DRAW;
            /**
            * The event after update of cc.Director
            */
            static EVENT_AFTER_UPDATE;
            /**
            * The event after visit of cc.Director
            */
            static EVENT_AFTER_VISIT;
            /**
            * The event projection changed of cc.Director
            */
            static EVENT_PROJECTION_CHANGED;
            /**
            * Constant for 2D projection (orthogonal projection)
            */
            static PROJECTION_2D;
            /**
            * Constant for 3D projection with a fovy=60, znear=0.5f and zfar=1500.
            */
            static PROJECTION_3D;
            /**
            * Constant for custom projection, if cc.Director&#39;s projection set to it, it calls &quot;updateProjection&quot; on the projection delegate.
            */
            static PROJECTION_CUSTOM;
            /**
            * Constant for default projection of cc.Director, default projection is 3D projection
            */
            static PROJECTION_DEFAULT;
            /**
            * calculateDeltaTime()
calculates delta time since last time it was called

            */
            calculateDeltaTime();
            /**
            * {cc.Point}
convertToGL(uiPoint)
Converts a view coordinate to an WebGL coordinate
Useful to convert (multi) touches coordinates to the current layout (portrait or landscape)
Implementation can be found in CCDirectorWebGL
Parameters:
{cc.Point} uiPoint
Returns:
{cc.Point}

            */
            convertToGL(uiPoint?: cc.Point): cc.Point;
            /**
            * {cc.Point}
convertToUI(glPoint)
Converts an WebGL coordinate to a view coordinate
Useful to convert node points to window points for calls such as glScissor
Implementation can be found in CCDirectorWebGL
Parameters:
{cc.Point} glPoint
Returns:
{cc.Point}

            */
            convertToUI(glPoint?: cc.Point): cc.Point;
            /**
            * drawScene()
Draw the scene. This method is called every frame. Don&#39;t call it manually.

            */
            drawScene();
            /**
            * end()
End the life of director in the next frame

            */
            end();
            /**
            * {cc.ActionManager}
getActionManager()
Returns the cc.ActionManager associated with this director
Returns:
{cc.ActionManager}

            */
            getActionManager(): cc.ActionManager;
            /**
            * {Number}
getAnimationInterval()
Returns the FPS value
Returns:
{Number}

            */
            getAnimationInterval(): number;
            /**
            * {Number}
getContentScaleFactor()
Returns the size in pixels of the surface. It could be different than the screen size.
High-res devices might have a higher surface size than the screen size.
Returns:
{Number}

            */
            getContentScaleFactor(): number;
            /**
            * {cc.DirectorDelegate}
getDelegate()
Returns the cc.director delegate.
Returns:
{cc.DirectorDelegate}

            */
            getDelegate(): cc.DirectorDelegate;
            /**
            * {Number}
getDeltaTime()
Returns the delta time since last frame
Returns:
{Number}

            */
            getDeltaTime(): number;
            /**
            * {cc.Node}
getNotificationNode()
This object will be visited after the main scene is visited.
This object MUST implement the &quot;visit&quot; selector.
Useful to hook a notification object
Returns:
{cc.Node}

            */
            getNotificationNode(): cc.Node;
            /**
            * {cc.view}
getOpenGLView()
Get the CCEGLView, where everything is rendered.
Implementation can be found in CCDirectorCanvas.js/CCDirectorWebGL.js.
Returns:
{cc.view}

            */
            getOpenGLView(): cc.view;
            /**
            * {Number}
getProjection()
Sets an OpenGL projection.
Implementation can be found in CCDirectorCanvas.js/CCDirectorWebGL.js.
Returns:
{Number}

            */
            getProjection(): number;
            /**
            * {cc.Scene}
getRunningScene()
Returns current running Scene. Director can only run one Scene at the time
Returns:
{cc.Scene}

            */
            getRunningScene(): cc.Scene;
            /**
            * {cc.Scheduler}
getScheduler()
Returns the cc.Scheduler associated with this director
Returns:
{cc.Scheduler}

            */
            getScheduler(): cc.Scheduler;
            /**
            * {Number}
getSecondsPerFrame()
Returns seconds per frame
Returns:
{Number}

            */
            getSecondsPerFrame(): number;
            /**
            * {Number}
getTotalFrames()
Returns how many frames were called since the director started
Returns:
{Number}

            */
            getTotalFrames(): number;
            /**
            * {cc.Point}
getVisibleOrigin()
Returns the visible origin of the running scene
Returns:
{cc.Point}

            */
            getVisibleOrigin(): cc.Point;
            /**
            * {cc.Size}
getVisibleSize()
Returns the visible size of the running scene
Returns:
{cc.Size}

            */
            getVisibleSize(): cc.Size;
            /**
            * {cc.Size}
getWinSize()
Returns the size of the WebGL view in points.
It takes into account any possible rotation (device orientation) of the window
Returns:
{cc.Size}

            */
            getWinSize(): cc.Size;
            /**
            * {cc.Size}
getWinSizeInPixels()
Returns the size of the OpenGL view in pixels.
It takes into account any possible rotation (device orientation) of the window.
On Mac winSize and winSizeInPixels return the same value.
Returns:
{cc.Size}

            */
            getWinSizeInPixels(): cc.Size;
            /**
            * {Number}
getZEye()
Returns the z eye, only available in WebGL mode
Returns:
{Number}

            */
            getZEye(): number;
            /**
            * {Boolean}
isDisplayStats()
Returns whether or not to display the FPS informations
Returns:
{Boolean}

            */
            isDisplayStats(): boolean;
            /**
            * {Boolean}
isNextDeltaTimeZero()
Returns whether next delta time equals to zero
Returns:
{Boolean}

            */
            isNextDeltaTimeZero(): boolean;
            /**
            * {Boolean}
isPaused()
Returns whether or not the Director is paused
Returns:
{Boolean}

            */
            isPaused(): boolean;
            /**
            * {Boolean}
isSendCleanupToScene()
Returns whether or not the replaced scene will receive the cleanup message.
If the new scene is pushed, then the old scene won&#39;t receive the &quot;cleanup&quot; message.
If the new scene replaces the old one, the it will receive the &quot;cleanup&quot; message.
Returns:
{Boolean}

            */
            isSendCleanupToScene(): boolean;
            /**
            * mainLoop()
Run main loop of director

            */
            mainLoop();
            /**
            * pause()
Pause the director&#39;s ticker

            */
            pause();
            /**
            * popScene()
Pops out a scene from the queue.
This scene will replace the running one.
The running scene will be deleted. If there are no more scenes in the stack the execution is terminated.
ONLY call it if there is a running scene.

            */
            popScene();
            /**
            * popToRootScene()
Pops out all scenes from the queue until the root scene in the queue.
This scene will replace the running one.
Internally it will call &quot;popToSceneStackLevel(1)&quot;

            */
            popToRootScene();
            /**
            * popToSceneStackLevel(level)
Pops out all scenes from the queue until it reaches &quot;level&quot;.
If level is 0, it will end the director.
If level is 1, it will pop all scenes until it reaches to root scene.
If level is
Parameters:
{Number} level

            */
            popToSceneStackLevel(level?: number);
            /**
            * purgeCachedData()
Removes cached all cocos2d cached data. It will purge the cc.textureCache, cc.spriteFrameCache, cc.animationCache

            */
            purgeCachedData();
            /**
            * purgeDirector()
Purge the cc.director itself, including unschedule all schedule, remove all event listeners, clean up and exit the running scene, stops all animations, clear cached data.

            */
            purgeDirector();
            /**
            * pushScene(scene)
Suspends the execution of the running scene, pushing it on the stack of suspended scenes.
The new scene will be executed.
Try to avoid big stacks of pushed scenes to reduce memory allocation.
ONLY call it if there is a running scene.
Parameters:
{cc.Scene} scene

            */
            pushScene(scene?: cc.Scene);
            /**
            * resume()
Resume director after pause, if the current scene is not paused, nothing will happen.

            */
            resume();
            /**
            * runScene(scene)
Run a scene. Replaces the running scene with a new one or enter the first scene.
Parameters:
{cc.Scene} scene

            */
            runScene(scene?: cc.Scene);
            /**
            * setActionManager(actionManager)
Sets the cc.ActionManager associated with this director
Parameters:
{cc.ActionManager} actionManager

            */
            setActionManager(actionManager?: cc.ActionManager);
            /**
            * setAlphaBlending(on)
Enables/disables OpenGL alpha blending.
Implementation can be found in CCDirectorCanvas.js/CCDirectorWebGL.js.
Parameters:
{Boolean} on

            */
            setAlphaBlending(on?: boolean);
            /**
            * setAnimationInterval(value)
Sets animation interval
Parameters:
{Number} value
the animation interval desired

            */
            setAnimationInterval(value?: number);
            /**
            * setContentScaleFactor(scaleFactor)
The size in pixels of the surface. It could be different than the screen size.
High-res devices might have a higher surface size than the screen size.
Parameters:
{Number} scaleFactor

            */
            setContentScaleFactor(scaleFactor?: number);
            /**
            * setDefaultValues()
Sets the default values based on the CCConfiguration info

            */
            setDefaultValues();
            /**
            * {cc.DirectorDelegate}
setDelegate(delegate)
Sets the cc.director delegate. It shall implement the CCDirectorDelegate protocol
Parameters:
delegate
Returns:
{cc.DirectorDelegate}

            */
            setDelegate(): cc.DirectorDelegate;
            /**
            * setDepthTest(on)
Enables or disables WebGL depth test.
Implementation can be found in CCDirectorCanvas.js/CCDirectorWebGL.js
Parameters:
{Boolean} on

            */
            setDepthTest(on?: boolean);
            /**
            * setDisplayStats(displayStats)
Sets whether display the FPS on the bottom-left corner
Parameters:
{Boolean} displayStats

            */
            setDisplayStats(displayStats?: boolean);
            /**
            * setNextDeltaTimeZero(nextDeltaTimeZero)
Sets whether next delta time equals to zero
Parameters:
{Boolean} nextDeltaTimeZero

            */
            setNextDeltaTimeZero(nextDeltaTimeZero?: boolean);
            /**
            * setNextScene()
Starts the registered next scene

            */
            setNextScene();
            /**
            * setNotificationNode(node)
Sets Notification Node
Parameters:
{cc.Node} node

            */
            setNotificationNode(node?: cc.Node);
            /**
            * setOpenGLView(openGLView)
Sets the view, where everything is rendered, do not call this function.
Implementation can be found in CCDirectorCanvas.js/CCDirectorWebGL.js.
Parameters:
{cc.view} openGLView

            */
            setOpenGLView(openGLView?: cc.view);
            /**
            * setProjection(projection)
Sets an OpenGL projection.
Implementation can be found in CCDirectorCanvas.js/CCDirectorWebGL.js.
Parameters:
{Number} projection

            */
            setProjection(projection?: number);
            /**
            * setScheduler(scheduler)
Sets the cc.Scheduler associated with this director
Parameters:
{cc.Scheduler} scheduler

            */
            setScheduler(scheduler?: cc.Scheduler);
            /**
            * setViewport()
Update the view port.
Implementation can be found in CCDirectorCanvas.js/CCDirectorWebGL.js.

            */
            setViewport();
            /**
            * startAnimation()
Starts Animation

            */
            startAnimation();
            /**
            * stopAnimation()
Stops animation

            */
            stopAnimation();
        }
    }
declare module cc {
        /**
        * 
CCDrawNode
Node that draws dots, segments and polygons.
Faster than the &quot;drawing primitives&quot; since they it draws everything in one single batch.

        */
        export class DrawNode extends cc.Node {
            /**
            * CCDrawNode
Node that draws dots, segments and polygons.
            */
            constructor();
            /**
            * clear()
Clear the geometry in the node&#39;s buffer.

            */
            clear();
            /**
            * &amp;lt;static&amp;gt;
{cc.DrawNode}
cc.DrawNode.create()
Creates a DrawNode
Deprecated:
since v3.0 please use new cc.DrawNode() instead.
Returns:
{cc.DrawNode}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.DrawNode;
            /**
            * ctor()
The cc.DrawNodeCanvas&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.DrawNodeCanvas()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * drawCardinalSpline(config, tension, segments, lineWidth, color)
draw a cardinal spline path
Parameters:
{Array} config
{Number} tension
{Number} segments
{Number} lineWidth
{cc.Color} color

            */
            drawCardinalSpline(config?: Array<any>, tension?: number, segments?: number, lineWidth?: number, color?: cc.Color);
            /**
            * drawCatmullRom(points, segments, lineWidth, color)
draw a CatmullRom curve
Parameters:
{Array} points
{Number} segments
{Number} lineWidth
{cc.Color} color

            */
            drawCatmullRom(points?: Array<any>, segments?: number, lineWidth?: number, color?: cc.Color);
            /**
            * drawCircle(center, radius, angle, segments, drawLineToCenter, lineWidth, color)
draws a circle given the center, radius and number of segments.
Parameters:
{cc.Point} center
center of circle
{Number} radius
{Number} angle
angle in radians
{Number} segments
{Boolean} drawLineToCenter
{Number} lineWidth
{cc.Color} color

            */
            drawCircle(center?: cc.Point, radius?: number, angle?: number, segments?: number, drawLineToCenter?: boolean, lineWidth?: number, color?: cc.Color);
            /**
            * drawCubicBezier(origin, control1, control2, destination, segments, lineWidth, color)
draws a cubic bezier path
Parameters:
{cc.Point} origin
{cc.Point} control1
{cc.Point} control2
{cc.Point} destination
{Number} segments
{Number} lineWidth
{cc.Color} color

            */
            drawCubicBezier(origin?: cc.Point, control1?: cc.Point, control2?: cc.Point, destination?: cc.Point, segments?: number, lineWidth?: number, color?: cc.Color);
            /**
            * drawDot(pos, radius, color)
draw a dot at a position, with a given radius and color
Parameters:
{cc.Point} pos
{Number} radius
{cc.Color} color

            */
            drawDot(pos?: cc.Point, radius?: number, color?: cc.Color);
            /**
            * drawDots(points, radius, color)
draws an array of points.
Parameters:
{Array} points
point of array
{Number} radius
{cc.Color} color

            */
            drawDots(points?: Array<any>, radius?: number, color?: cc.Color);
            /**
            * drawPoly(verts, fillColor, lineWidth, color)
draw a polygon with a fill color and line color, copying the vertex list
Parameters:
{Array} verts
{cc.Color} fillColor
{Number} lineWidth
{cc.Color} color

            */
            drawPoly(verts?: Array<any>, fillColor?: cc.Color, lineWidth?: number, color?: cc.Color);
            /**
            * drawPoly_(verts, fillColor, lineWidth, color)
draw a polygon with a fill color and line color without copying the vertex list
Parameters:
{Array} verts
{cc.Color} fillColor
{Number} lineWidth
{cc.Color} color

            */
            drawPoly_(verts?: Array<any>, fillColor?: cc.Color, lineWidth?: number, color?: cc.Color);
            /**
            * drawQuadBezier(origin, control, destination, segments, lineWidth, color)
draws a quad bezier path
Parameters:
{cc.Point} origin
{cc.Point} control
{cc.Point} destination
{Number} segments
{Number} lineWidth
{cc.Color} color

            */
            drawQuadBezier(origin?: cc.Point, control?: cc.Point, destination?: cc.Point, segments?: number, lineWidth?: number, color?: cc.Color);
            /**
            * drawRect(origin, destination, fillColor, lineWidth, lineColor)
draws a rectangle given the origin and destination point measured in points.
Parameters:
{cc.Point} origin
{cc.Point} destination
{cc.Color} fillColor
{Number} lineWidth
{cc.Color} lineColor

            */
            drawRect(origin?: cc.Point, destination?: cc.Point, fillColor?: cc.Color, lineWidth?: number, lineColor?: cc.Color);
            /**
            * drawSegment(from, to, lineWidth, color)
draw a segment with a radius and color
Parameters:
{cc.Point} from
{cc.Point} to
{Number} lineWidth
{cc.Color} color

            */
            drawSegment(from?: cc.Point, to?: cc.Point, lineWidth?: number, color?: cc.Color);
            /**
            * {Object}
getBlendFunc()
Gets the blend func
Returns:
{Object}

            */
            getBlendFunc(): Object;
            /**
            * {cc.Color}
getDrawColor()
draw color getter
Returns:
{cc.Color}

            */
            getDrawColor(): cc.Color;
            /**
            * {Number}
getLineWidth()
line width getter
Returns:
{Number}

            */
            getLineWidth(): number;
            /**
            * setBlendFunc(blendFunc, dst)
Set the blend func
Parameters:
blendFunc
dst

            */
            setBlendFunc();
            /**
            * setDrawColor(color)
draw color setter
Parameters:
{cc.Color} color

            */
            setDrawColor(color?: cc.Color);
            /**
            * setLineWidth(width)
line width setter
Parameters:
{Number} width

            */
            setLineWidth(width?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseBackIn action.
In the opposite direction to move slowly, and then accelerated to the right direction.

        */
        export class EaseBackIn extends cc.ActionEase {
            /**
            * cc.EaseBackIn action.
            */
            constructor();
            /**
            * {cc.EaseBackIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseBackIn}

            */
            clone(): cc.EaseBackIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseBackIn}
cc.EaseBackIn.create(action)
Creates the cc.EaseBackIn.
In the opposite direction to move slowly, and then accelerated to the right direction.
//The old usage
cc.EaseBackIn.create(action);
//The new usage
action.easing(cc.easeBackIn());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeBackIn())
Returns:
{cc.EaseBackIn}

            */
            static create(action?: cc.ActionInterval): cc.EaseBackIn;
            /**
            * {cc.EaseBackOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseBackOut}

            */
            reverse(): cc.EaseBackOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseBackInOut action.
Begining of cc.EaseBackIn. Ending of cc.EaseBackOut.

        */
        export class EaseBackInOut extends cc.ActionEase {
            /**
            * cc.EaseBackInOut action.
            */
            constructor();
            /**
            * {cc.EaseBackInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseBackInOut}

            */
            clone(): cc.EaseBackInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseBackInOut}
cc.EaseBackInOut.create(action)
Creates the action.
Begining of cc.EaseBackIn. Ending of cc.EaseBackOut.
//The old usage
cc.EaseBackInOut.create(action);
//The new usage
action.easing(cc.easeBackInOut());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeBackInOut())
Returns:
{cc.EaseBackInOut}

            */
            static create(action?: cc.ActionInterval): cc.EaseBackInOut;
            /**
            * {cc.EaseBackInOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseBackInOut}

            */
            reverse(): cc.EaseBackInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseBackOut action.
Fast moving more than the finish, and then slowly back to the finish.

        */
        export class EaseBackOut extends cc.ActionEase {
            /**
            * cc.EaseBackOut action.
            */
            constructor();
            /**
            * {cc.EaseBackOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseBackOut}

            */
            clone(): cc.EaseBackOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseBackOut}
cc.EaseBackOut.create(action)
Creates the action.
Fast moving more than the finish, and then slowly back to the finish.
//The old usage
cc.EaseBackOut.create(action);
//The new usage
action.easing(cc.easeBackOut());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeBackOut());
Returns:
{cc.EaseBackOut}

            */
            static create(action?: cc.ActionInterval): cc.EaseBackOut;
            /**
            * {cc.EaseBackIn}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseBackIn}

            */
            reverse(): cc.EaseBackIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseBezierAction action.
Manually set a 4 order Bessel curve.
According to the set point, calculate the trajectory.

        */
        export class EaseBezierAction extends cc.ActionEase {
            /**
            * cc.EaseBezierAction action.
            */
            constructor(action?: cc.Action);
            /**
            * {cc.EaseBezierAction}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseBezierAction}

            */
            clone(): cc.EaseBezierAction;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseBezierAction}
cc.EaseBezierAction.create(action)
Creates the action.
After creating the cc.EaseBezierAction, also need to manually call setBezierParamer.
According to the set point, calculate the trajectory.
//The old usage
var action = cc.EaseBezierAction.create(action);
action.setBezierParamer(0.5, 0.5, 1.0, 1.0);
//The new usage
action.easing(cc.easeBezierAction(0.5, 0.5, 1.0, 1.0));
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeBezierAction())
Returns:
{cc.EaseBezierAction}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseBezierAction;
            /**
            * ctor(action)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Initialization requires the application of Bessel curve of action.
Parameters:
{cc.Action} action

            */
            ctor(action?: cc.Action);
            /**
            * {cc.EaseBezierAction}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseBezierAction}

            */
            reverse(): cc.EaseBezierAction;
            /**
            * setBezierParamer(p0, p1, p2, p3)
Set of 4 reference point
Parameters:
p0
p1
p2
p3

            */
            setBezierParamer();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseBounce abstract class.

        */
        export class EaseBounce extends cc.ActionEase {
            /**
            * cc.EaseBounce abstract class.
            */
            constructor();
            /**
            * {Number}
bounceTime(time1)
Parameters:
{Number} time1
Returns:
{Number}

            */
            bounceTime(time1?: number): number;
            /**
            * {cc.EaseBounce}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseBounce}

            */
            clone(): cc.EaseBounce;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseBounce}
cc.EaseBounce.create(action)
Creates an ease bounce action.
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0 Does not recommend the use of the base object.
Returns:
{cc.EaseBounce}

            */
            static create(action?: cc.ActionInterval): cc.EaseBounce;
            /**
            * {cc.EaseBounce}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseBounce}

            */
            reverse(): cc.EaseBounce;
        }
    }
declare module cc {
        /**
        * 
cc.EaseBounceIn action.
Eased bounce effect at the beginning.

        */
        export class EaseBounceIn extends cc.EaseBounce {
            /**
            * cc.EaseBounceIn action.
            */
            constructor();
            /**
            * {cc.EaseBounceIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseBounceIn}

            */
            clone(): cc.EaseBounceIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseBounceIn}
cc.EaseBounceIn.create(action)
Creates the action.
Eased bounce effect at the beginning.
//The old usage
cc.EaseBounceIn.create(action);
//The new usage
action.easing(cc.easeBounceIn());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeBounceIn())
Returns:
{cc.EaseBounceIn}

            */
            static create(action?: cc.ActionInterval): cc.EaseBounceIn;
            /**
            * {cc.EaseBounceOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseBounceOut}

            */
            reverse(): cc.EaseBounceOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseBounceInOut action.
Eased bounce effect at the begining and ending.

        */
        export class EaseBounceInOut extends cc.EaseBounce {
            /**
            * cc.EaseBounceInOut action.
            */
            constructor();
            /**
            * {cc.EaseBounceInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseBounceInOut}

            */
            clone(): cc.EaseBounceInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseBounceInOut}
cc.EaseBounceInOut.create(action)
Creates the action.
Eased bounce effect at the begining and ending.
//The old usage
cc.EaseBounceInOut.create(action);
//The new usage
action.easing(cc.easeBounceInOut());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeBounceInOut())
Returns:
{cc.EaseBounceInOut}

            */
            static create(action?: cc.ActionInterval): cc.EaseBounceInOut;
            /**
            * {cc.EaseBounceInOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseBounceInOut}

            */
            reverse(): cc.EaseBounceInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseBounceOut action.
Eased bounce effect at the ending.

        */
        export class EaseBounceOut extends cc.EaseBounce {
            /**
            * cc.EaseBounceOut action.
            */
            constructor();
            /**
            * {cc.EaseBounceOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseBounceOut}

            */
            clone(): cc.EaseBounceOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseBounceOut}
cc.EaseBounceOut.create(action)
Creates the action.
Eased bounce effect at the ending.
//The old usage
cc.EaseBounceOut.create(action);
//The new usage
action.easing(cc.easeBounceOut());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0 please use action.easing(cc.easeBounceOut())
Returns:
{cc.EaseBounceOut}

            */
            static create(action?: cc.ActionInterval): cc.EaseBounceOut;
            /**
            * {cc.EaseBounceIn}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseBounceIn}

            */
            reverse(): cc.EaseBounceIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseCircleActionIn action.
Reference easeInCirc:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseCircleActionIn extends cc.ActionEase {
            /**
            * cc.EaseCircleActionIn action.
            */
            constructor();
            /**
            * {cc.EaseCircleActionIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseCircleActionIn}

            */
            clone(): cc.EaseCircleActionIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseCircleActionIn}
cc.EaseCircleActionIn.create(action)
Creates the action.
Reference easeInCirc:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseCircleActionIn.create(action);
//The new usage
action.easing(cc.easeCircleActionIn());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeCircleActionIn());
Returns:
{cc.EaseCircleActionIn}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseCircleActionIn;
            /**
            * {cc.EaseCircleActionIn}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseCircleActionIn}

            */
            reverse(): cc.EaseCircleActionIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseCircleActionInOut action.
Reference easeInOutCirc:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseCircleActionInOut extends cc.ActionEase {
            /**
            * cc.EaseCircleActionInOut action.
            */
            constructor();
            /**
            * {cc.EaseCircleActionInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseCircleActionInOut}

            */
            clone(): cc.EaseCircleActionInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseCircleActionInOut}
cc.EaseCircleActionInOut.create(action)
Creates the action.
Reference easeInOutCirc:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseCircleActionInOut.create(action);
//The new usage
action.easing(cc.easeCircleActionInOut());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeCircleActionInOut());
Returns:
{cc.EaseCircleActionInOut}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseCircleActionInOut;
            /**
            * {cc.EaseCircleActionInOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseCircleActionInOut}

            */
            reverse(): cc.EaseCircleActionInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseCircleActionOut action.
Reference easeOutCirc:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseCircleActionOut extends cc.ActionEase {
            /**
            * cc.EaseCircleActionOut action.
            */
            constructor();
            /**
            * {cc.EaseCircleActionOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseCircleActionOut}

            */
            clone(): cc.EaseCircleActionOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseCircleActionOut}
cc.EaseCircleActionOut.create(action)
Creates the action.
Reference easeOutCirc:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseCircleActionOut.create(action);
//The new usage
action.easing(cc.easeCircleActionOut());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeCircleActionOut());
Returns:
{cc.EaseCircleActionOut}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseCircleActionOut;
            /**
            * {cc.EaseCircleActionOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseCircleActionOut}

            */
            reverse(): cc.EaseCircleActionOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseCubicActionIn action.
Reference easeInCubic:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseCubicActionIn extends cc.ActionEase {
            /**
            * cc.EaseCubicActionIn action.
            */
            constructor();
            /**
            * {cc.EaseCubicActionIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseCubicActionIn}

            */
            clone(): cc.EaseCubicActionIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseCubicActionIn}
cc.EaseCubicActionIn.create(action)
Creates the action.
Reference easeInCubic:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseCubicActionIn.create(action);
//The new usage
action.easing(cc.easeCubicActionIn());
Parameters:
action
Deprecated:
since v3.0  action.easing(cc.easeCubicActionIn());
Returns:
{cc.EaseCubicActionIn}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseCubicActionIn;
            /**
            * {cc.EaseCubicActionIn}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseCubicActionIn}

            */
            reverse(): cc.EaseCubicActionIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseCubicActionInOut action.
Reference easeInOutCubic:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseCubicActionInOut extends cc.ActionEase {
            /**
            * cc.EaseCubicActionInOut action.
            */
            constructor();
            /**
            * {cc.EaseCubicActionInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseCubicActionInOut}

            */
            clone(): cc.EaseCubicActionInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseCubicActionInOut}
cc.EaseCubicActionInOut.create(action)
Creates the action.
Reference easeInOutCubic:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseCubicActionInOut.create(action);
//The new usage
action.easing(cc.easeCubicActionInOut());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeCubicActionInOut());
Returns:
{cc.EaseCubicActionInOut}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseCubicActionInOut;
            /**
            * {cc.EaseCubicActionInOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseCubicActionInOut}

            */
            reverse(): cc.EaseCubicActionInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseCubicActionOut action.
Reference easeOutCubic:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseCubicActionOut extends cc.ActionEase {
            /**
            * cc.EaseCubicActionOut action.
            */
            constructor();
            /**
            * {cc.EaseCubicActionOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseCubicActionOut}

            */
            clone(): cc.EaseCubicActionOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseCubicActionOut}
cc.EaseCubicActionOut.create(action)
Creates the action.
Reference easeOutCubic:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseCubicActionOut.create(action);
//The new usage
action.easing(cc.easeCubicActionOut());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeCubicActionOut());
Returns:
{cc.EaseCubicActionOut}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseCubicActionOut;
            /**
            * {cc.EaseCubicActionOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseCubicActionOut}

            */
            reverse(): cc.EaseCubicActionOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Ease Elastic abstract class.

        */
        export class EaseElastic extends cc.ActionEase {
            /**
            * Ease Elastic abstract class.
            */
            constructor(action?: cc.ActionInterval, period?: number);
            /**
            * {cc.EaseElastic}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseElastic}

            */
            clone(): cc.EaseElastic;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseElastic}
cc.EaseElastic.create(action, period)
Creates the action with the inner action and the period in radians (default is 0.3).
Parameters:
{cc.ActionInterval} action
{Number} period
Optional, Default: 0.3
Deprecated:
since v3.0 Does not recommend the use of the base object.
Returns:
{cc.EaseElastic}

            */
            static create(action?: cc.ActionInterval, period?: number): cc.EaseElastic;
            /**
            * ctor(action, period)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates the action with the inner action and the period in radians (default is 0.3).
Parameters:
{cc.ActionInterval} action
{Number} period
Optional, Default: 0.3

            */
            ctor(action?: cc.ActionInterval, period?: number);
            /**
            * {Number}
getPeriod()
get period of the wave in radians. default is 0.3
Returns:
{Number}

            */
            getPeriod(): number;
            /**
            * {Boolean}
initWithAction(action, period)
Initializes the action with the inner action and the period in radians (default is 0.3)
Parameters:
{cc.ActionInterval} action
{Number} period
Optional, Default: 0.3
Returns:
{Boolean}

            */
            initWithAction(action?: cc.ActionInterval, period?: number): boolean;
            /**
            * {null}
reverse()
Create a action. Opposite with the original motion trajectory.
Will be overwrite.
Returns:
{null}

            */
            reverse(): void;
            /**
            * setPeriod(period)
set period of the wave in radians.
Parameters:
{Number} period

            */
            setPeriod(period?: number);
        }
    }
declare module cc {
        /**
        * 
Ease Elastic In action.
Reference easeInElastic:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseElasticIn extends cc.EaseElastic {
            /**
            * Ease Elastic In action.
            */
            constructor();
            /**
            * {cc.EaseElasticIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseElasticIn}

            */
            clone(): cc.EaseElasticIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseElasticIn}
cc.EaseElasticIn.create(action, period)
Creates the action with the inner action and the period in radians (default is 0.3).
Reference easeInElastic:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseElasticIn.create(action, period);
//The new usage
action.easing(cc.easeElasticIn(period));
Parameters:
{cc.ActionInterval} action
{Number} period
Optional, Default: 0.3
Deprecated:
since v3.0  Please use action.easing(cc.easeElasticIn(period))
Returns:
{cc.EaseElasticIn}

            */
            static create(action?: cc.ActionInterval, period?: number): cc.EaseElasticIn;
            /**
            * {cc.EaseElasticOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseElasticOut}

            */
            reverse(): cc.EaseElasticOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Ease Elastic InOut action.
Reference easeInOutElastic:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseElasticInOut extends cc.EaseElastic {
            /**
            * Ease Elastic InOut action.
            */
            constructor();
            /**
            * {cc.EaseElasticInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseElasticInOut}

            */
            clone(): cc.EaseElasticInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseElasticInOut}
cc.EaseElasticInOut.create(action, period)
Creates the action with the inner action and the period in radians (default is 0.3).
Reference easeInOutElastic:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseElasticInOut.create(action, period);
//The new usage
action.easing(cc.easeElasticInOut(period));
Parameters:
{cc.ActionInterval} action
{Number} period
Optional, Default: 0.3
Deprecated:
since v3.0  Please use action.easing(cc.easeElasticInOut(period))
Returns:
{cc.EaseElasticInOut}

            */
            static create(action?: cc.ActionInterval, period?: number): cc.EaseElasticInOut;
            /**
            * {cc.EaseElasticInOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseElasticInOut}

            */
            reverse(): cc.EaseElasticInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Ease Elastic Out action.
Reference easeOutElastic:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseElasticOut extends cc.EaseElastic {
            /**
            * Ease Elastic Out action.
            */
            constructor();
            /**
            * {cc.EaseElasticOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseElasticOut}

            */
            clone(): cc.EaseElasticOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseElasticOut}
cc.EaseElasticOut.create(action, period)
Creates the action with the inner action and the period in radians (default is 0.3).
Reference easeOutElastic:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseElasticOut.create(action, period);
//The new usage
action.easing(cc.easeElasticOut(period));
Parameters:
{cc.ActionInterval} action
{Number} period
Optional, Default: 0.3
Deprecated:
since v3.0  Please use action.easing(cc.easeElasticOut(period))
Returns:
{cc.EaseElasticOut}

            */
            static create(action?: cc.ActionInterval, period?: number): cc.EaseElasticOut;
            /**
            * {cc.EaseElasticIn}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseElasticIn}

            */
            reverse(): cc.EaseElasticIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Ease Exponential In. Slow to Fast.
Reference easeInExpo:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseExponentialIn extends cc.ActionEase {
            /**
            * cc.Ease Exponential In.
            */
            constructor();
            /**
            * {cc.EaseExponentialIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseExponentialIn}

            */
            clone(): cc.EaseExponentialIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseExponentialIn}
cc.EaseExponentialIn.create(action)
Creates the action easing object with the rate parameter.
Reference easeInExpo:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseExponentialIn.create(action);
//The new usage
action.easing(cc.easeExponentialIn());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeExponentialIn())
Returns:
{cc.EaseExponentialIn}

            */
            static create(action?: cc.ActionInterval): cc.EaseExponentialIn;
            /**
            * {cc.EaseExponentialOut}
reverse()
Create a cc.EaseExponentialOut action. Opposite with the original motion trajectory.
Returns:
{cc.EaseExponentialOut}

            */
            reverse(): cc.EaseExponentialOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Ease Exponential InOut.
Reference easeInOutExpo:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseExponentialInOut extends cc.ActionEase {
            /**
            * Ease Exponential InOut.
            */
            constructor();
            /**
            * {cc.EaseExponentialInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseExponentialInOut}

            */
            clone(): cc.EaseExponentialInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseExponentialInOut}
cc.EaseExponentialInOut.create(action)
creates an EaseExponentialInOut action.
Reference easeInOutExpo:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseExponentialInOut.create(action);
//The new usage
action.easing(cc.easeExponentialInOut());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeExponentialInOut)
Returns:
{cc.EaseExponentialInOut}

            */
            static create(action?: cc.ActionInterval): cc.EaseExponentialInOut;
            /**
            * {cc.EaseExponentialInOut}
reverse()
Create a cc.EaseExponentialInOut action. Opposite with the original motion trajectory.
Returns:
{cc.EaseExponentialInOut}

            */
            reverse(): cc.EaseExponentialInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Ease Exponential Out.
Reference easeOutExpo:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseExponentialOut extends cc.ActionEase {
            /**
            * Ease Exponential Out.
            */
            constructor();
            /**
            * {cc.EaseExponentialOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseExponentialOut}

            */
            clone(): cc.EaseExponentialOut;
            /**
            * &amp;lt;static&amp;gt;
{Object}
cc.EaseExponentialOut.create(action)
Creates the action easing object with the rate parameter.
Reference easeOutExpo:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseExponentialOut.create(action);
//The new usage
action.easing(cc.easeExponentialOut());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeExponentialOut())
Returns:
{Object}

            */
            static create(action?: cc.ActionInterval): Object;
            /**
            * {cc.EaseExponentialIn}
reverse()
Create a cc.EaseExponentialIn action. Opposite with the original motion trajectory.
Returns:
{cc.EaseExponentialIn}

            */
            reverse(): cc.EaseExponentialIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseIn action with a rate. From slow to fast.

        */
        export class EaseIn extends cc.EaseRateAction {
            /**
            * cc.EaseIn action with a rate.
            */
            constructor();
            /**
            * {cc.EaseIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseIn}

            */
            clone(): cc.EaseIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseIn}
cc.EaseIn.create(action, rate)
Creates the action with the inner action and the rate parameter.
From slow to fast.
//The old usage
cc.EaseIn.create(action, 3);
//The new usage
action.easing(cc.easeIn(3.0));
Parameters:
{cc.ActionInterval} action
{Number} rate
Deprecated:
since v3.0  Please use action.easing(cc.easeIn(3))
Returns:
{cc.EaseIn}

            */
            static create(action?: cc.ActionInterval, rate?: number): cc.EaseIn;
            /**
            * {cc.EaseIn}
reverse()
Create a cc.easeIn action. Opposite with the original motion trajectory.
Returns:
{cc.EaseIn}

            */
            reverse(): cc.EaseIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseInOut action with a rate.
Slow to fast then to slow.

        */
        export class EaseInOut extends cc.EaseRateAction {
            /**
            * cc.EaseInOut action with a rate.
            */
            constructor();
            /**
            * {cc.EaseInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseInOut}

            */
            clone(): cc.EaseInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseInOut}
cc.EaseInOut.create(action, rate)
Creates the action with the inner action and the rate parameter.
Slow to fast then to slow.
//The old usage
cc.EaseInOut.create(action, 3);
//The new usage
action.easing(cc.easeInOut(3.0));
Parameters:
{cc.ActionInterval} action
{Number} rate
Deprecated:
since v3.0  Please use action.easing(cc.easeInOut(3.0))
Returns:
{cc.EaseInOut}

            */
            static create(action?: cc.ActionInterval, rate?: number): cc.EaseInOut;
            /**
            * {cc.EaseInOut}
reverse()
Create a cc.EaseInOut action. Opposite with the original motion trajectory.
Returns:
{cc.EaseInOut}

            */
            reverse(): cc.EaseInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseOut action with a rate. From fast to slow.

        */
        export class EaseOut extends cc.EaseRateAction {
            /**
            * cc.EaseOut action with a rate.
            */
            constructor();
            /**
            * {cc.EaseOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseOut}

            */
            clone(): cc.EaseOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseOut}
cc.EaseOut.create(action, rate)
Creates the action with the inner action and the rate parameter.
From fast to slow.
//The old usage
cc.EaseOut.create(action, 3);
//The new usage
action.easing(cc.easeOut(3.0));
Parameters:
{cc.ActionInterval} action
{Number} rate
Deprecated:
since v3.0  Please use cc.easeOut instead.
Returns:
{cc.EaseOut}

            */
            static create(action?: cc.ActionInterval, rate?: number): cc.EaseOut;
            /**
            * {cc.EaseOut}
reverse()
Create a cc.easeIn action. Opposite with the original motion trajectory.
Returns:
{cc.EaseOut}

            */
            reverse(): cc.EaseOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseQuadraticActionIn action.
Reference easeInQuad:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseQuadraticActionIn extends cc.ActionEase {
            /**
            * cc.EaseQuadraticActionIn action.
            */
            constructor();
            /**
            * {cc.EaseQuadraticActionIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseQuadraticActionIn}

            */
            clone(): cc.EaseQuadraticActionIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseQuadraticActionIn}
cc.EaseQuadraticActionIn.create(action)
Creates the cc.EaseQuadRaticActionIn.
Reference easeInQuad:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseQuadraticActionIn.create(action);
//The new usage
action.easing(cc.easeQuadraticActionIn());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeQuadraticAction())
Returns:
{cc.EaseQuadraticActionIn}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseQuadraticActionIn;
            /**
            * {cc.EaseQuadraticActionIn}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseQuadraticActionIn}

            */
            reverse(): cc.EaseQuadraticActionIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseQuadraticActionInOut action.
Reference easeInOutQuad:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseQuadraticActionInOut extends cc.ActionEase {
            /**
            * cc.EaseQuadraticActionInOut action.
            */
            constructor();
            /**
            * {cc.EaseQuadraticActionInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseQuadraticActionInOut}

            */
            clone(): cc.EaseQuadraticActionInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseQuadraticActionInOut}
cc.EaseQuadraticActionInOut.create(action)
Creates the action.
Reference easeInOutQuad:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseQuadraticActionInOut.create(action);
//The new usage
action.easing(cc.easeQuadraticActionInOut());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeQuadraticActionInOut())
Returns:
{cc.EaseQuadraticActionInOut}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseQuadraticActionInOut;
            /**
            * {cc.EaseQuadraticActionInOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseQuadraticActionInOut}

            */
            reverse(): cc.EaseQuadraticActionInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseQuadraticActionIn action.
Reference easeOutQuad:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseQuadraticActionOut extends cc.ActionEase {
            /**
            * cc.EaseQuadraticActionIn action.
            */
            constructor();
            /**
            * {cc.EaseQuadraticActionOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseQuadraticActionOut}

            */
            clone(): cc.EaseQuadraticActionOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseQuadraticActionOut}
cc.EaseQuadraticActionOut.create(action)
Creates the action.
Reference easeOutQuad:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseQuadraticActionOut.create(action);
//The new usage
action.easing(cc.easeQuadraticActionOut());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeQuadraticActionOut())
Returns:
{cc.EaseQuadraticActionOut}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseQuadraticActionOut;
            /**
            * {cc.EaseQuadraticActionOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseQuadraticActionOut}

            */
            reverse(): cc.EaseQuadraticActionOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseQuarticActionIn action.
Reference easeInQuart:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseQuarticActionIn extends cc.ActionEase {
            /**
            * cc.EaseQuarticActionIn action.
            */
            constructor();
            /**
            * {cc.EaseQuarticActionIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseQuarticActionIn}

            */
            clone(): cc.EaseQuarticActionIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseQuarticActionIn}
cc.EaseQuarticActionIn.create(action)
Creates the action.
Reference easeInQuart:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseQuarticActionIn.create(action);
//The new usage
action.easing(cc.easeQuarticActionIn());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeQuarticActionIn());
Returns:
{cc.EaseQuarticActionIn}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseQuarticActionIn;
            /**
            * {cc.EaseQuarticActionIn}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseQuarticActionIn}

            */
            reverse(): cc.EaseQuarticActionIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseQuarticActionInOut action.
Reference easeInOutQuart:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseQuarticActionInOut extends cc.ActionEase {
            /**
            * cc.EaseQuarticActionInOut action.
            */
            constructor();
            /**
            * {cc.EaseQuarticActionInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseQuarticActionInOut}

            */
            clone(): cc.EaseQuarticActionInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseQuarticActionInOut}
cc.EaseQuarticActionInOut.create(action)
Creates the action.
Reference easeInOutQuart:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseQuarticActionInOut.create(action);
//The new usage
action.easing(cc.easeQuarticActionInOut());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeQuarticActionInOut());
Returns:
{cc.EaseQuarticActionInOut}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseQuarticActionInOut;
            /**
            * {cc.EaseQuarticActionInOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseQuarticActionInOut}

            */
            reverse(): cc.EaseQuarticActionInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseQuarticActionOut action.
Reference easeOutQuart:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseQuarticActionOut extends cc.ActionEase {
            /**
            * cc.EaseQuarticActionOut action.
            */
            constructor();
            /**
            * {cc.EaseQuarticActionOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseQuarticActionOut}

            */
            clone(): cc.EaseQuarticActionOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseQuarticActionOut}
cc.EaseQuarticActionOut.create(action)
Creates the action.
Reference easeOutQuart:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseQuarticActionOut.create(action);
//The new usage
action.easing(cc.EaseQuarticActionOut());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.QuarticActionOut());
Returns:
{cc.EaseQuarticActionOut}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseQuarticActionOut;
            /**
            * {cc.EaseQuarticActionOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseQuarticActionOut}

            */
            reverse(): cc.EaseQuarticActionOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseQuinticActionIn action.
Reference easeInQuint:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseQuinticActionIn extends cc.ActionEase {
            /**
            * cc.EaseQuinticActionIn action.
            */
            constructor();
            /**
            * {cc.EaseQuinticActionIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseQuinticActionIn}

            */
            clone(): cc.EaseQuinticActionIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseQuinticActionIn}
cc.EaseQuinticActionIn.create(action)
Creates the action.
Reference easeInQuint:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseQuinticActionIn.create(action);
//The new usage
action.easing(cc.easeQuinticActionIn());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeQuinticActionIn());
Returns:
{cc.EaseQuinticActionIn}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseQuinticActionIn;
            /**
            * {cc.EaseQuinticActionIn}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseQuinticActionIn}

            */
            reverse(): cc.EaseQuinticActionIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseQuinticActionInOut action.
Reference easeInOutQuint:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseQuinticActionInOut extends cc.ActionEase {
            /**
            * cc.EaseQuinticActionInOut action.
            */
            constructor();
            /**
            * {cc.EaseQuinticActionInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseQuinticActionInOut}

            */
            clone(): cc.EaseQuinticActionInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseQuinticActionInOut}
cc.EaseQuinticActionInOut.create(action)
Creates the action.
Reference easeInOutQuint:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseQuinticActionInOut.create(action);
//The new usage
action.easing(cc.easeQuinticActionInOut());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeQuinticActionInOut());
Returns:
{cc.EaseQuinticActionInOut}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseQuinticActionInOut;
            /**
            * {cc.EaseQuinticActionInOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseQuinticActionInOut}

            */
            reverse(): cc.EaseQuinticActionInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EaseQuinticActionOut action.
Reference easeQuint:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseQuinticActionOut extends cc.ActionEase {
            /**
            * cc.EaseQuinticActionOut action.
            */
            constructor();
            /**
            * {cc.EaseQuinticActionOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseQuinticActionOut}

            */
            clone(): cc.EaseQuinticActionOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseQuinticActionOut}
cc.EaseQuinticActionOut.create(action)
Creates the action.
Reference easeOutQuint:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseQuinticActionOut.create(action);
//The new usage
action.easing(cc.easeQuadraticActionOut());
Parameters:
action
Deprecated:
since v3.0  Please use action.easing(cc.easeQuadraticActionOut());
Returns:
{cc.EaseQuinticActionOut}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.EaseQuinticActionOut;
            /**
            * {cc.EaseQuinticActionOut}
reverse()
Create a action. Opposite with the original motion trajectory.
Returns:
{cc.EaseQuinticActionOut}

            */
            reverse(): cc.EaseQuinticActionOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Base class for Easing actions with rate parameters

        */
        export class EaseRateAction extends cc.ActionEase {
            /**
            * Base class for Easing actions with rate parameters
            */
            constructor(action?: cc.ActionInterval, rate?: number);
            /**
            * Please use cc.easeRateAction instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.EaseRateAction;
            /**
            * {cc.EaseRateAction}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseRateAction}

            */
            clone(): cc.EaseRateAction;
            /**
            * ctor(action, rate)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates the action with the inner action and the rate parameter.
Parameters:
{cc.ActionInterval} action
{Number} rate

            */
            ctor(action?: cc.ActionInterval, rate?: number);
            /**
            * {Number}
getRate()
get rate value for the actions
Returns:
{Number}

            */
            getRate(): number;
            /**
            * {Boolean}
initWithAction(action, rate)
Initializes the action with the inner action and the rate parameter
Parameters:
{cc.ActionInterval} action
{Number} rate
Returns:
{Boolean}

            */
            initWithAction(action?: cc.ActionInterval, rate?: number): boolean;
            /**
            * {cc.EaseRateAction}
reverse()
Create new action to original operation effect opposite.
For example:
- The action will be x coordinates of 0 move to 100.
- The reversed action will be x of 100 move to 0.
- Will be rewritten
Returns:
{cc.EaseRateAction}

            */
            reverse(): cc.EaseRateAction;
            /**
            * setRate(rate)
set rate value for the actions
Parameters:
{Number} rate

            */
            setRate(rate?: number);
        }
    }
declare module cc {
        /**
        * 
Ease Sine In.
Reference easeInSine:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseSineIn extends cc.ActionEase {
            /**
            * Ease Sine In.
            */
            constructor();
            /**
            * {cc.EaseSineIn}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseSineIn}

            */
            clone(): cc.EaseSineIn;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseSineIn}
cc.EaseSineIn.create(action)
creates an EaseSineIn action.
Reference easeInSine:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseSineIn.create(action);
//The new usage
action.easing(cc.easeSineIn());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeSineIn())
Returns:
{cc.EaseSineIn}

            */
            static create(action?: cc.ActionInterval): cc.EaseSineIn;
            /**
            * {cc.EaseSineOut}
reverse()
Create a cc.EaseSineOut action. Opposite with the original motion trajectory.
Returns:
{cc.EaseSineOut}

            */
            reverse(): cc.EaseSineOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Ease Sine InOut.
Reference easeInOutSine:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseSineInOut extends cc.ActionEase {
            /**
            * Ease Sine InOut.
            */
            constructor();
            /**
            * {cc.EaseSineInOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseSineInOut}

            */
            clone(): cc.EaseSineInOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseSineInOut}
cc.EaseSineInOut.create(action)
Creates the action.
Reference easeInOutSine:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseSineInOut.create(action);
//The new usage
action.easing(cc.easeSineInOut());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeSineInOut())
Returns:
{cc.EaseSineInOut}

            */
            static create(action?: cc.ActionInterval): cc.EaseSineInOut;
            /**
            * {cc.EaseSineInOut}
reverse()
Create a cc.EaseSineInOut action. Opposite with the original motion trajectory.
Returns:
{cc.EaseSineInOut}

            */
            reverse(): cc.EaseSineInOut;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Ease Sine Out.
Reference easeOutSine:
http://www.zhihu.com/question/21981571/answer/19925418

        */
        export class EaseSineOut extends cc.ActionEase {
            /**
            * Ease Sine Out.
            */
            constructor();
            /**
            * {cc.EaseSineOut}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.EaseSineOut}

            */
            clone(): cc.EaseSineOut;
            /**
            * &amp;lt;static&amp;gt;
{cc.EaseSineOut}
cc.EaseSineOut.create(action)
Creates an EaseSineOut action.
Reference easeOutSine:
http://www.zhihu.com/question/21981571/answer/19925418
//The old usage
cc.EaseSineOut.create(action);
//The new usage
action.easing(cc.easeSineOut());
Parameters:
{cc.ActionInterval} action
Deprecated:
since v3.0  Please use action.easing(cc.easeSineOut())
Returns:
{cc.EaseSineOut}

            */
            static create(action?: cc.ActionInterval): cc.EaseSineOut;
            /**
            * {cc.EaseSineIn}
reverse()
Create a cc.EaseSineIn action. Opposite with the original motion trajectory.
Returns:
{cc.EaseSineIn}

            */
            reverse(): cc.EaseSineIn;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.EditBox is a brief Class for edit box.
You can use this widget to gather small amounts of text from the user.

        */
        export class EditBox extends cc.ControlButton {
            /**
            * cc.EditBox is a brief Class for edit box.
            */
            constructor();
            /**
            * -  Delegate of edit box
            */
            delegate: Object;
            /**
            * -  Config font of edit box
            */
            font: string;
            /**
            * -  Config font color of edit box
            */
            fontColor: cc.Color;
            /**
            * -  Config font name of edit box
            */
            fontName: string;
            /**
            * -  Config font size of edit box
            */
            fontSize: number;
            /**
            * -  Input flag of edit box, one of the EditBoxInputFlag constants.
            */
            inputFlag: number;
            /**
            * -  Input mode of the edit box.
            */
            inputMode: number;
            /**
            * - Max length of the content string
            */
            maxLength: string;
            /**
            * - Place holder of edit box
            */
            placeHolder: string;
            /**
            * -  Config font of place holder
            */
            placeHolderFont: string;
            /**
            * -  Config font color of place holder
            */
            placeHolderFontColor: cc.Color;
            /**
            * -  Config font name of place holder
            */
            placeHolderFontName: string;
            /**
            * -  Config font size of place holder
            */
            placeHolderFontSize: number;
            /**
            * -  Return type of edit box, value should be one of the KeyboardReturnType constants.
            */
            returnType: number;
            /**
            * - Content string of edit box
            */
            string: string;
            /**
            * &amp;lt;static&amp;gt;
{cc.EditBox}
cc.EditBox.create(size, normal9SpriteBg, press9SpriteBg, disabled9SpriteBg)
create a edit box with size and background-color or
Parameters:
{cc.Size} size
{cc.Scale9Sprite} normal9SpriteBg
{cc.Scale9Sprite} press9SpriteBg
Optional
{cc.Scale9Sprite} disabled9SpriteBg
Optional
Deprecated:
since v3.0, please use new cc.EditBox(size, normal9SpriteBg, press9SpriteBg, disabled9SpriteBg) instead
Returns:
{cc.EditBox}

            */
            static create(size?: cc.Size, normal9SpriteBg?: cc.Scale9Sprite, press9SpriteBg?: cc.Scale9Sprite, disabled9SpriteBg?: cc.Scale9Sprite): cc.EditBox;
            /**
            * &amp;lt;static&amp;gt;
{cc.Rect}
cc.EditBox.getRect(node)
get the rect of a node in world coordinate frame
Parameters:
{cc.Node} node
Returns:
{cc.Rect}

            */
            static getRect(node?: cc.Node): cc.Rect;
        }
    }
declare module cc {
        /**
        * 
        */
        export class EditBoxDelegate extends cc.Class {
            /**
            * 
            */
            constructor();
        }
    }
declare module cc {
        /**
        * 
Base class of all kinds of events.

        */
        export class Event extends cc.Class {
            /**
            * Base class of all kinds of events.
            */
            constructor();
            /**
            * The type code of Acceleration event.
            */
            static ACCELERATION;
            /**
            * The type code of Custom event.
            */
            static CUSTOM;
            /**
            * The type code of Keyboard event.
            */
            static KEYBOARD;
            /**
            * The type code of Mouse event.
            */
            static MOUSE;
            /**
            * The type code of Touch event.
            */
            static TOUCH;
            /**
            * {cc.Node}
getCurrentTarget()
Gets current target of the event
note: It only be available when the event listener is associated with node.
It returns 0 when the listener is associated with fixed priority.
Returns:
{cc.Node} The target with which the event associates.

            */
            getCurrentTarget(): cc.Node;
            /**
            * {Number}
getType()
Gets the event type
Returns:
{Number}

            */
            getType(): number;
            /**
            * {boolean}
isStopped()
Checks whether the event has been stopped
Returns:
{boolean}

            */
            isStopped(): boolean;
            /**
            * stopPropagation()
Stops propagation for current event

            */
            stopPropagation();
        }
    }
declare module cc {
        /**
        * 
The Custom event

        */
        export class EventCustom extends cc.Event {
            /**
            * The Custom event
            */
            constructor();
            /**
            * {String}
getEventName()
Gets event name
Returns:
{String}

            */
            getEventName(): string;
            /**
            * {*}
getUserData()
Gets user data
Returns:
{*}

            */
            getUserData(): any;
            /**
            * setUserData(data)
Sets user data
Parameters:
{*} data

            */
            setUserData(data?: any);
        }
    }
declare module cc {
        /**
        * 
The widget focus event.

        */
        export class EventFocus extends cc.Event {
            /**
            * The widget focus event.
            */
            constructor();
            /**
            * ctor(widgetLoseFocus, widgetGetFocus)
Constructor function.
Parameters:
{ccui.Widget} widgetLoseFocus
{ccui.Widget} widgetGetFocus

            */
            ctor(widgetLoseFocus?: ccui.Widget, widgetGetFocus?: ccui.Widget);
        }
    }
declare module cc {
        /**
        * The base class of event listener.
If you need custom listener which with different callback, you need to inherit this class.
For instance, you could refer to EventListenerAcceleration, EventListenerKeyboard,
EventListenerTouchOneByOne, EventListenerCustom.

        */
        export class EventListener extends cc.Class {
            /**
            * 
The base class of event listener.
            */
            constructor();
            /**
            * The type code of acceleration event listener.
            */
            static ACCELERATION;
            /**
            * The type code of custom event listener.
            */
            static CUSTOM;
            /**
            * The type code of keyboard event listener.
            */
            static KEYBOARD;
            /**
            * The type code of mouse event listener.
            */
            static MOUSE;
            /**
            * The type code of all at once touch event listener.
            */
            static TOUCH_ALL_AT_ONCE;
            /**
            * The type code of one by one touch event listener.
            */
            static TOUCH_ONE_BY_ONE;
            /**
            * The type code of unknown event listener.
            */
            static UNKNOWN;
            /**
            * {boolean}
checkAvailable()
Checks whether the listener is available.
Returns:
{boolean}

            */
            checkAvailable(): boolean;
            /**
            * {cc.EventListener}
clone()
Clones the listener, its subclasses have to override this method.
Returns:
{cc.EventListener}

            */
            clone(): cc.EventListener;
            /**
            * &amp;lt;static&amp;gt;
{cc.EventListener}
cc.EventListener.create(argObj)
Create a EventListener object by json object
cc.EventListener.create({
event: cc.EventListener.TOUCH_ONE_BY_ONE,
swallowTouches: true,
onTouchBegan: function (touch, event) {
//do something
return true;
}
});
Parameters:
{object} argObj
a json object
Returns:
{cc.EventListener} todo: It should be the direct use new

            */
            static create(argObj?: any): cc.EventListener;
            /**
            * ctor(type, listenerID, callback)
Initializes event with type and callback function
Parameters:
{number} type
{string} listenerID
{function} callback

            */
            ctor(type?: number, listenerID?: string, callback?: any);
            /**
            * {boolean}
isEnabled()
Checks whether the listener is enabled
Returns:
{boolean}

            */
            isEnabled(): boolean;
            /**
            * release()
Currently JavaScript Bindings (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
This is a hack, and should be removed once JSB fixes the retain/release bug
You will need to retain an object if you created a listener and haven&#39;t added it any target node during the same frame.
Otherwise, JSB&#39;s native autorelease pool will consider this object a useless one and release it directly,
when you want to use it later, a &quot;Invalid Native Object&quot; error will be raised.
The retain function can increase a reference count for the native object to avoid it being released,
you need to manually invoke release function when you think this object is no longer needed, otherwise, there will be memory learks.
retain and release function call should be paired in developer&#39;s game code.
See:
cc.EventListener#retain

            */
            release();
            /**
            * retain()
Currently JavaScript Bindings (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
This is a hack, and should be removed once JSB fixes the retain/release bug
You will need to retain an object if you created a listener and haven&#39;t added it any target node during the same frame.
Otherwise, JSB&#39;s native autorelease pool will consider this object a useless one and release it directly,
when you want to use it later, a &quot;Invalid Native Object&quot; error will be raised.
The retain function can increase a reference count for the native object to avoid it being released,
you need to manually invoke release function when you think this object is no longer needed, otherwise, there will be memory learks.
retain and release function call should be paired in developer&#39;s game code.
See:
cc.EventListener#release

            */
            retain();
            /**
            * setEnabled(enabled)
Enables or disables the listener
Parameters:
{boolean} enabled

            */
            setEnabled(enabled?: boolean);
        }
    }
declare module cc {
        /**
        * cc.eventManager is a singleton object which manages event listener subscriptions and event dispatching.
The EventListener list is managed in such way so that event listeners can be added and removed
while events are being dispatched.

        */
        export class eventManager  {
            /**
            * 
cc.eventManager is a singleton object which manages event listener subscriptions and event dispatching.
            */
            constructor();
            /**
            * {cc.EventListener}
addCustomListener(eventName, callback)
Adds a Custom event listener. It will use a fixed priority of 1.
Parameters:
{string} eventName
{function} callback
Returns:
{cc.EventListener} the generated event. Needed in order to remove the event from the dispatcher

            */
            addCustomListener(eventName?: string, callback?: any): cc.EventListener;
            /**
            * {cc.EventListener}
addListener(listener, nodeOrPriority)
Adds a event listener for a specified event.
if the parameter &quot;nodeOrPriority&quot; is a node, it means to add a event listener for a specified event with the priority of scene graph.
if the parameter &quot;nodeOrPriority&quot; is a Number, it means to add a event listener for a specified event with the fixed priority.
Parameters:
{cc.EventListener|Object} listener
The listener of a specified event or a object of some event parameters.
{cc.Node|Number} nodeOrPriority
The priority of the listener is based on the draw order of this node or fixedPriority The fixed priority of the listener.
Returns:
{cc.EventListener} Return the listener. Needed in order to remove the event from the dispatcher.

            */
            addListener(listener?: any, nodeOrPriority?: any): cc.EventListener;
            /**
            * dispatchCustomEvent(eventName, optionalUserData)
Dispatches a Custom Event with a event name an optional user data
Parameters:
{string} eventName
{*} optionalUserData

            */
            dispatchCustomEvent(eventName?: string, optionalUserData?: any);
            /**
            * dispatchEvent(event)
Dispatches the event, also removes all EventListeners marked for deletion from the event dispatcher list.
Parameters:
{cc.Event} event

            */
            dispatchEvent(event?: cc.Event);
            /**
            * {boolean}
isEnabled()
Checks whether dispatching events is enabled
Returns:
{boolean}

            */
            isEnabled(): boolean;
            /**
            * pauseTarget(node, recursive)
Pauses all listeners which are associated the specified target.
Parameters:
{cc.Node} node
{Boolean} recursive
Optional, Default: false

            */
            pauseTarget(node?: cc.Node, recursive?: boolean);
            /**
            * removeAllListeners()
Removes all listeners

            */
            removeAllListeners();
            /**
            * removeCustomListeners(customEventName)
Removes all custom listeners with the same event name
Parameters:
{string} customEventName

            */
            removeCustomListeners(customEventName?: string);
            /**
            * removeListener(listener)
Remove a listener
Parameters:
{cc.EventListener} listener
an event listener or a registered node target

            */
            removeListener(listener?: cc.EventListener);
            /**
            * removeListeners(listenerType, recursive)
Removes all listeners with the same event listener type or removes all listeners of a node
Parameters:
{Number|cc.Node} listenerType
listenerType or a node
{Boolean} recursive
Optional, Default: false

            */
            removeListeners(listenerType?: any, recursive?: boolean);
            /**
            * resumeTarget(node, recursive)
Resumes all listeners which are associated the specified target.
Parameters:
{cc.Node} node
{Boolean} recursive
Optional, Default: false

            */
            resumeTarget(node?: cc.Node, recursive?: boolean);
            /**
            * setEnabled(enabled)
Whether to enable dispatching events
Parameters:
{boolean} enabled

            */
            setEnabled(enabled?: boolean);
            /**
            * setPriority(listener, fixedPriority)
Sets listener&#39;s priority with fixed value.
Parameters:
{cc.EventListener} listener
{Number} fixedPriority

            */
            setPriority(listener?: cc.EventListener, fixedPriority?: number);
        }
    }
declare module cc {
        /**
        * 
The mouse event

        */
        export class EventMouse extends cc.Event {
            /**
            * The mouse event
            */
            constructor();
            /**
            * The tag of Mouse button 4
            */
            static BUTTON_4;
            /**
            * The tag of Mouse button 5
            */
            static BUTTON_5;
            /**
            * The tag of Mouse button 6
            */
            static BUTTON_6;
            /**
            * The tag of Mouse button 7
            */
            static BUTTON_7;
            /**
            * The tag of Mouse button 8
            */
            static BUTTON_8;
            /**
            * The tag of Mouse left button
            */
            static BUTTON_LEFT;
            /**
            * The tag of Mouse middle button  (The right button number is 1 on browser)
            */
            static BUTTON_MIDDLE;
            /**
            * The tag of Mouse right button  (The right button number is 2 on browser)
            */
            static BUTTON_RIGHT;
            /**
            * The event type code of mouse down event.
            */
            static DOWN;
            /**
            * The event type code of mouse move event.
            */
            static MOVE;
            /**
            * The none event code of  mouse event.
            */
            static NONE;
            /**
            * The event type code of mouse scroll event.
            */
            static SCROLL;
            /**
            * The event type code of mouse up event.
            */
            static UP;
            /**
            * {number}
getButton()
Returns mouse button
Returns:
{number}

            */
            getButton(): number;
            /**
            * {cc.Point}
getDelta()
Returns the delta distance from the previous location to current location
Returns:
{cc.Point}

            */
            getDelta(): cc.Point;
            /**
            * {Number}
getDeltaX()
Returns the X axis delta distance from the previous location to current location
Returns:
{Number}

            */
            getDeltaX(): number;
            /**
            * {Number}
getDeltaY()
Returns the Y axis delta distance from the previous location to current location
Returns:
{Number}

            */
            getDeltaY(): number;
            /**
            * {cc.Point}
getLocation()
Returns cursor location
Returns:
{cc.Point} location

            */
            getLocation(): cc.Point;
            /**
            * {cc.Point}
getLocationInView()
Returns the current cursor location in screen coordinates
Returns:
{cc.Point}

            */
            getLocationInView(): cc.Point;
            /**
            * {number}
getLocationX()
Returns location X axis data
Returns:
{number}

            */
            getLocationX(): number;
            /**
            * {number}
getLocationY()
Returns location Y axis data
Returns:
{number}

            */
            getLocationY(): number;
            /**
            * {number}
getScrollX()
Returns the x axis scroll value
Returns:
{number}

            */
            getScrollX(): number;
            /**
            * {number}
getScrollY()
Returns the y axis scroll value
Returns:
{number}

            */
            getScrollY(): number;
            /**
            * setButton(button)
Sets mouse button
Parameters:
{number} button

            */
            setButton(button?: number);
            /**
            * setLocation(x, y)
Sets cursor location
Parameters:
{number} x
{number} y

            */
            setLocation(x?: number, y?: number);
            /**
            * setScrollData(scrollX, scrollY)
Sets scroll data
Parameters:
{number} scrollX
{number} scrollY

            */
            setScrollData(scrollX?: number, scrollY?: number);
        }
    }
declare module cc {
        /**
        * 
The touch event

        */
        export class EventTouch extends cc.Event {
            /**
            * The touch event
            */
            constructor();
            /**
            * The maximum touch numbers
            */
            static MAX_TOUCHES;
            /**
            * {number}
getEventCode()
Returns event code
Returns:
{number}

            */
            getEventCode(): number;
            /**
            * {Array}
getTouches()
Returns touches of event
Returns:
{Array}

            */
            getTouches(): Array<any>;
        }
    }
declare module cc {
        /**
        * 
Fades In an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from 0 to 255.
The &quot;reverse&quot; of this action is FadeOut

        */
        export class FadeIn extends cc.FadeTo {
            /**
            * Fades In an object that implements the cc.RGBAProtocol protocol.
            */
            constructor(duration?: number);
            /**
            * Please use cc.fadeIn instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FadeIn;
            /**
            * {cc.FadeIn}
clone()
returns a new clone of the action
Returns:
{cc.FadeIn}

            */
            clone(): cc.FadeIn;
            /**
            * ctor(duration)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
duration in seconds

            */
            ctor(duration?: number);
            /**
            * {cc.FadeOut}
reverse()
Returns a reversed action.
Returns:
{cc.FadeOut}

            */
            reverse(): cc.FadeOut;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
        }
    }
declare module cc {
        /**
        * 
Fades Out an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from 255 to 0.
The &quot;reverse&quot; of this action is FadeIn

        */
        export class FadeOut extends cc.FadeTo {
            /**
            * Fades Out an object that implements the cc.RGBAProtocol protocol.
            */
            constructor(duration?: number);
            /**
            * Please use cc.fadeOut instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FadeOut;
            /**
            * {cc.FadeOut}
clone()
returns a new clone of the action
Returns:
{cc.FadeOut}

            */
            clone(): cc.FadeOut;
            /**
            * ctor(duration)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
duration in seconds

            */
            ctor(duration?: number);
            /**
            * {cc.FadeIn}
reverse()
Returns a reversed action.
Returns:
{cc.FadeIn}

            */
            reverse(): cc.FadeIn;
        }
    }
declare module cc {
        /**
        * 
cc.FadeOutBLTiles action. Fades out the tiles in a Bottom-Left direction.
Reference the test cases (Effects Test)

        */
        export class FadeOutBLTiles extends cc.FadeOutTRTiles {
            /**
            * cc.FadeOutBLTiles action.
            */
            constructor();
            /**
            * Please use cc.fadeOutBLTiles instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FadeOutBLTiles;
            /**
            * testFunc(pos, time)
Test function
Parameters:
{cc.Size} pos
{Number} time

            */
            testFunc(pos?: cc.Size, time?: number);
        }
    }
declare module cc {
        /**
        * 
cc.FadeOutDownTiles action. Fades out the tiles in downwards direction.
Reference the test cases (Effects Test)

        */
        export class FadeOutDownTiles extends cc.FadeOutUpTiles {
            /**
            * cc.FadeOutDownTiles action.
            */
            constructor();
            /**
            * Please use cc.fadeOutDownTiles instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FadeOutDownTiles;
        }
    }
declare module cc {
        /**
        * 
cc.FadeOutTRTiles action. Fades out the tiles in a Top-Right direction.
Reference the test cases (Effects Test)

        */
        export class FadeOutTRTiles extends cc.TiledGrid3DAction {
            /**
            * cc.FadeOutTRTiles action.
            */
            constructor();
            /**
            * Please use cc.fadeOutTRTiles instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FadeOutTRTiles;
            /**
            * testFunc(pos, time)
Test function
Parameters:
{cc.Size} pos
{Number} time

            */
            testFunc(pos?: cc.Size, time?: number);
            /**
            * transformTile(pos, distance)
Transform tile
Parameters:
{cc.Point} pos
{Number} distance

            */
            transformTile(pos?: cc.Point, distance?: number);
            /**
            * turnOffTile(pos)
Turn Off Tile
Parameters:
{cc.Point} pos

            */
            turnOffTile(pos?: cc.Point);
            /**
            * turnOnTile(pos)
Turn on Tile
Parameters:
{cc.Point} pos

            */
            turnOnTile(pos?: cc.Point);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.FadeOutUpTiles action. Fades out the tiles in upwards direction.
Reference the test cases (Effects Test)

        */
        export class FadeOutUpTiles extends cc.FadeOutTRTiles {
            /**
            * cc.FadeOutUpTiles action.
            */
            constructor();
            /**
            * Please use cc.fadeOutUpTiles instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FadeOutUpTiles;
        }
    }
declare module cc {
        /**
        * 
Fades an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from the current value to a custom one.

        */
        export class FadeTo extends cc.ActionInterval {
            /**
            * Fades an object that implements the cc.RGBAProtocol protocol.
            */
            constructor(duration?: number, opacity?: number);
            /**
            * Please use cc.fadeTo instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FadeTo;
            /**
            * {cc.FadeTo}
clone()
returns a new clone of the action
Returns:
{cc.FadeTo}

            */
            clone(): cc.FadeTo;
            /**
            * ctor(duration, opacity)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
{Number} opacity
0-255, 0 is transparent

            */
            ctor(duration?: number, opacity?: number);
            /**
            * {Boolean}
initWithDuration(duration, opacity)
Initializes the action.
Parameters:
{Number} duration
duration in seconds
{Number} opacity
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, opacity?: number): boolean;
            /**
            * startWithTarget(target)
Start this action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(time)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} time
time in seconds

            */
            update(time?: number);
        }
    }
declare module cc {
        /**
        * 
Base class actions that do have a finite time duration.
Possible actions:
- An action with a duration of 0 seconds.
- An action with a duration of 35.5 seconds.

Infinite time actions are valid

        */
        export class FiniteTimeAction extends cc.Action {
            /**
            * Base class actions that do have a finite time duration.
            */
            constructor();
            /**
            * {cc.FiniteTimeAction}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.FiniteTimeAction}

            */
            clone(): cc.FiniteTimeAction;
            /**
            * ctor()
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Number}
getDuration()
get duration of the action. (seconds)
Returns:
{Number}

            */
            getDuration(): number;
            /**
            * {Null}
reverse()
Returns a reversed action.
For example:
- The action will be x coordinates of 0 move to 100.
- The reversed action will be x of 100 move to 0.
- Will be rewritten
Returns:
{Null}

            */
            reverse(): void;
            /**
            * setDuration(duration)
set duration of the action. (seconds)
Parameters:
{Number} duration

            */
            setDuration(duration?: number);
        }
    }
declare module cc {
        /**
        * 
Flips the sprite horizontally.

        */
        export class FlipX extends cc.ActionInstant {
            /**
            * Flips the sprite horizontally.
            */
            constructor(flip?: boolean);
            /**
            * Plese use cc.flipX instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FlipX;
            /**
            * {cc.FiniteTimeAction}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.FiniteTimeAction}

            */
            clone(): cc.FiniteTimeAction;
            /**
            * ctor(flip)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a FlipX action to flip or unflip the target.
Parameters:
{Boolean} flip
Indicate whether the target should be flipped or not

            */
            ctor(flip?: boolean);
            /**
            * {Boolean}
initWithFlipX(flip)
initializes the action with a set flipX.
Parameters:
{Boolean} flip
Returns:
{Boolean}

            */
            initWithFlipX(flip?: boolean): boolean;
            /**
            * {cc.FlipX}
reverse()
returns a reversed action.
Returns:
{cc.FlipX}

            */
            reverse(): cc.FlipX;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.FlipX3D action.
Flip around.
Reference the test cases (Effects Test)

        */
        export class FlipX3D extends cc.Grid3DAction {
            /**
            * cc.FlipX3D action.
            */
            constructor(duration?: number);
            /**
            * Please use cc.flipX3D instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FlipX3D;
            /**
            * ctor(duration)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a Flip X 3D action with duration.
Parameters:
{Number} duration

            */
            ctor(duration?: number);
            /**
            * {Boolean}
initWithDuration(duration)
initializes the action with duration
Parameters:
{Number} duration
Returns:
{Boolean}

            */
            initWithDuration(duration?: number): boolean;
            /**
            * {Boolean}
initWithSize(gridSize, duration)
initializes the action with gridSize and duration
Parameters:
{cc.Size} gridSize
{Number} duration
Returns:
{Boolean}

            */
            initWithSize(gridSize?: cc.Size, duration?: number): boolean;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Flips the sprite vertically

        */
        export class FlipY extends cc.ActionInstant {
            /**
            * Flips the sprite vertically
            */
            constructor(flip?: boolean);
            /**
            * Please use cc.flipY instead
Create a FlipY action to flip or unflip the target
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FlipY;
            /**
            * {cc.FlipY}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.FlipY}

            */
            clone(): cc.FlipY;
            /**
            * ctor(flip)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a FlipY action to flip or unflip the target.
Parameters:
{Boolean} flip

            */
            ctor(flip?: boolean);
            /**
            * {Boolean}
initWithFlipY(flip)
initializes the action with a set flipY.
Parameters:
{Boolean} flip
Returns:
{Boolean}

            */
            initWithFlipY(flip?: boolean): boolean;
            /**
            * {cc.FlipY}
reverse()
returns a reversed action.
Returns:
{cc.FlipY}

            */
            reverse(): cc.FlipY;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.FlipY3D action.
Upside down.
Reference the test cases (Effects Test)

        */
        export class FlipY3D extends cc.FlipX3D {
            /**
            * cc.FlipY3D action.
            */
            constructor(duration?: number);
            /**
            * Please use cc.flipY3D instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FlipY3D;
            /**
            * ctor(duration)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a flip Y 3d action with duration.
Parameters:
{Number} duration

            */
            ctor(duration?: number);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Follow is an action that &quot;follows&quot; a node.

        */
        export class Follow extends cc.Action {
            /**
            * cc.Follow is an action that &quot;follows&quot; a node.
            */
            constructor(followedNode?: cc.Node, rect?: cc.Rect);
            /**
            * - world bottomBoundary.
            */
            bottomBoundary: number;
            /**
            * Please use cc.follow instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):Follow;
            /**
            * - world leftBoundary.
            */
            leftBoundary: number;
            /**
            * - world rightBoundary.
            */
            rightBoundary: number;
            /**
            * - world topBoundary.
            */
            topBoundary: number;
            /**
            * {cc.Follow}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.Follow}

            */
            clone(): cc.Follow;
            /**
            * ctor(followedNode, rect)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates the action with a set boundary.
creates the action with no boundary set.
Parameters:
{cc.Node} followedNode
{cc.Rect} rect

            */
            ctor(followedNode?: cc.Node, rect?: cc.Rect);
            /**
            * {Boolean}
initWithTarget(followedNode, rect)
initializes the action with a set boundary.
Parameters:
{cc.Node} followedNode
{cc.Rect} rect
Optional
Returns:
{Boolean}

            */
            initWithTarget(followedNode?: cc.Node, rect?: cc.Rect): boolean;
            /**
            * {Boolean}
isBoundarySet()
Get whether camera should be limited to certain area.
Returns:
{Boolean}

            */
            isBoundarySet(): boolean;
            /**
            * {Boolean}
isDone()
Return true if the action has finished.
Returns:
{Boolean}

            */
            isDone(): boolean;
            /**
            * setBoudarySet(value)
alter behavior - turn on/off boundary.
Parameters:
{Boolean} value

            */
            setBoudarySet(value?: boolean);
            /**
            * step(dt)
called every frame with it&#39;s delta time.
DON&#39;T override unless you know what you are doing.
Parameters:
{Number} dt

            */
            step(dt?: number);
            /**
            * stop()
Stop the action.

            */
            stop();
        }
    }
declare module cc {
        /**
        * 
        */
        export class FontDefinition  {
            /**
            * 
            */
            constructor();
        }
    }
declare module cc {
        /**
        * 
An object to boot the game.

        */
        export class game  {
            /**
            * An object to boot the game.
            */
            constructor();
            /**
            * Config of game
            */
            config;
            /**
            * Key of config
            */
            CONFIG_KEY;
            /**
            * Callback when the scripts of engine have been load.
            */
            onStart;
            /**
            * Callback when game exits.
            */
            onStop;
            /**
            * prepare(cb)
Prepare game.
Parameters:
cb

            */
            prepare();
            /**
            * restart()
Restart game.

            */
            restart();
            /**
            * run(id)
Run game.
Parameters:
id

            */
            run();
            /**
            * setFrameRate(frameRate)
Set frameRate of game.
Parameters:
frameRate

            */
            setFrameRate();
        }
    }
declare module cc {
        /**
        * 
Class that implements a WebGL program

        */
        export class GLProgram extends cc.Class {
            /**
            * Class that implements a WebGL program
            */
            constructor();
            /**
            * addAttribute(attributeName, index)
It will add a new attribute to the shader
Parameters:
{String} attributeName
{Number} index

            */
            addAttribute(attributeName?: string, index?: number);
            /**
            * &amp;lt;static&amp;gt;
{cc.GLProgram}
cc.GLProgram.create(vShaderFileName, fShaderFileName)
Create a cc.GLProgram object
Parameters:
{String} vShaderFileName
{String} fShaderFileName
Deprecated:
since v3.0, please use new cc.GLProgram(vShaderFileName, fShaderFileName) instead
Returns:
{cc.GLProgram}

            */
            static create(vShaderFileName?: string, fShaderFileName?: string): cc.GLProgram;
            /**
            * {cc.GLProgram}
ctor(vShaderFileName, fShaderFileName, glContext)
Create a cc.GLProgram object
Parameters:
{String} vShaderFileName
{String} fShaderFileName
glContext
Returns:
{cc.GLProgram}

            */
            ctor(vShaderFileName?: string, fShaderFileName?: string): cc.GLProgram;
            /**
            * destroyProgram()
destroy program

            */
            destroyProgram();
            /**
            * {String}
fragmentShaderLog()
returns the fragmentShader error log
Returns:
{String}

            */
            fragmentShaderLog(): string;
            /**
            * {String}
getFragmentShaderLog()
returns the fragmentShader error log
Returns:
{String}

            */
            getFragmentShaderLog(): string;
            /**
            * {WebGLProgram}
getProgram()
get WebGLProgram object
Returns:
{WebGLProgram}

            */
            getProgram(): WebGLProgram;
            /**
            * {String}
getProgramLog()
returns the program error log
Returns:
{String}

            */
            getProgramLog(): string;
            /**
            * {Number}
getUniformLocationForName(name)
calls retrieves the named uniform location for this shader program.
Parameters:
{String} name
Returns:
{Number}

            */
            getUniformLocationForName(name?: string): number;
            /**
            * {WebGLUniformLocation}
getUniformMVPMatrix()
get uniform MVP matrix
Returns:
{WebGLUniformLocation}

            */
            getUniformMVPMatrix(): WebGLUniformLocation;
            /**
            * {WebGLUniformLocation}
getUniformSampler()
get uniform sampler
Returns:
{WebGLUniformLocation}

            */
            getUniformSampler(): WebGLUniformLocation;
            /**
            * {String}
getVertexShaderLog()
returns the vertexShader error log
Returns:
{String}

            */
            getVertexShaderLog(): string;
            /**
            * {Boolean}
init(vShaderFilename, fShaderFileName)
Initializes the CCGLProgram with a vertex and fragment with contents of filenames
Parameters:
{String} vShaderFilename
{String} fShaderFileName
Returns:
{Boolean}

            */
            init(vShaderFilename?: string, fShaderFileName?: string): boolean;
            /**
            * {Boolean}
initWithString(vertShaderStr, fragShaderStr)
Initializes the cc.GLProgram with a vertex and fragment with string
Parameters:
{String} vertShaderStr
{String} fragShaderStr
Returns:
{Boolean}

            */
            initWithString(vertShaderStr?: string, fragShaderStr?: string): boolean;
            /**
            * {Boolean}
initWithVertexShaderByteArray(vertShaderStr, fragShaderStr)
Initializes the cc.GLProgram with a vertex and fragment with string
Parameters:
{String} vertShaderStr
{String} fragShaderStr
Returns:
{Boolean}

            */
            initWithVertexShaderByteArray(vertShaderStr?: string, fragShaderStr?: string): boolean;
            /**
            * {Boolean}
initWithVertexShaderFilename(vShaderFilename, fShaderFileName)
Initializes the CCGLProgram with a vertex and fragment with contents of filenames
Parameters:
{String} vShaderFilename
{String} fShaderFileName
Returns:
{Boolean}

            */
            initWithVertexShaderFilename(vShaderFilename?: string, fShaderFileName?: string): boolean;
            /**
            * {Boolean}
link()
links the glProgram
Returns:
{Boolean}

            */
            link(): boolean;
            /**
            * {String}
programLog()
returns the program error log
Returns:
{String}

            */
            programLog(): string;
            /**
            * reset()
reload all shaders, this function is designed for android
when opengl context lost, so don&#39;t call it.

            */
            reset();
            /**
            * retain()
Currently JavaScript Bindings (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
This is a hack, and should be removed once JSB fixes the retain/release bug

            */
            retain();
            /**
            * setUniformForModelViewProjectionMatrix()
will update the MVP matrix on the MVP uniform if it is different than the previous call for this same shader program.

            */
            setUniformForModelViewProjectionMatrix();
            /**
            * setUniformLocationI32(location, i1)
calls glUniform1i only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Number} i1

            */
            setUniformLocationI32(location?: WebGLUniformLocation, i1?: number);
            /**
            * setUniformLocationWith1f(location, f1)
calls glUniform1f only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Number} f1

            */
            setUniformLocationWith1f(location?: WebGLUniformLocation, f1?: number);
            /**
            * setUniformLocationWith1i(location, i1)
calls glUniform1i only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Number} i1

            */
            setUniformLocationWith1i(location?: WebGLUniformLocation, i1?: number);
            /**
            * setUniformLocationWith2f(location, f1, f2)
calls glUniform2f only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Number} f1
{Number} f2

            */
            setUniformLocationWith2f(location?: WebGLUniformLocation, f1?: number, f2?: number);
            /**
            * setUniformLocationWith2fv(location, floatArray, numberOfArrays)
calls glUniform2fv only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Float32Array} floatArray
{Number} numberOfArrays

            */
            setUniformLocationWith2fv(location?: WebGLUniformLocation, floatArray?: Float32Array, numberOfArrays?: number);
            /**
            * setUniformLocationWith2i(location, i1, i2)
calls glUniform2i only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Number} i1
{Number} i2

            */
            setUniformLocationWith2i(location?: WebGLUniformLocation, i1?: number, i2?: number);
            /**
            * setUniformLocationWith2iv(location, intArray, numberOfArrays)
calls glUniform2iv only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Int32Array} intArray
{Number} numberOfArrays

            */
            setUniformLocationWith2iv(location?: WebGLUniformLocation, intArray?: Int32Array, numberOfArrays?: number);
            /**
            * setUniformLocationWith3f(location, f1, f2, f3)
calls glUniform3f only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Number} f1
{Number} f2
{Number} f3

            */
            setUniformLocationWith3f(location?: WebGLUniformLocation, f1?: number, f2?: number, f3?: number);
            /**
            * setUniformLocationWith3fv(location, floatArray, numberOfArrays)
calls glUniform3fv only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Float32Array} floatArray
{Number} numberOfArrays

            */
            setUniformLocationWith3fv(location?: WebGLUniformLocation, floatArray?: Float32Array, numberOfArrays?: number);
            /**
            * setUniformLocationWith3i(location, i1, i2, i3)
calls glUniform3i only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Number} i1
{Number} i2
{Number} i3

            */
            setUniformLocationWith3i(location?: WebGLUniformLocation, i1?: number, i2?: number, i3?: number);
            /**
            * setUniformLocationWith3iv(location, intArray, numberOfArrays)
calls glUniform3iv only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Int32Array} intArray
{Number} numberOfArrays

            */
            setUniformLocationWith3iv(location?: WebGLUniformLocation, intArray?: Int32Array, numberOfArrays?: number);
            /**
            * setUniformLocationWith4f(location, f1, f2, f3, f4)
calls glUniform4f only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Number} f1
{Number} f2
{Number} f3
{Number} f4

            */
            setUniformLocationWith4f(location?: WebGLUniformLocation, f1?: number, f2?: number, f3?: number, f4?: number);
            /**
            * setUniformLocationWith4fv(location, floatArray, numberOfArrays)
calls glUniform4fv only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Float32Array} floatArray
{Number} numberOfArrays

            */
            setUniformLocationWith4fv(location?: WebGLUniformLocation, floatArray?: Float32Array, numberOfArrays?: number);
            /**
            * setUniformLocationWith4i(location, i1, i2, i3, i4)
calls glUniform4i only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Number} i1
{Number} i2
{Number} i3
{Number} i4

            */
            setUniformLocationWith4i(location?: WebGLUniformLocation, i1?: number, i2?: number, i3?: number, i4?: number);
            /**
            * setUniformLocationWith4iv(location, intArray, numberOfArrays)
calls glUniform4iv only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Int32Array} intArray
{Number} numberOfArrays

            */
            setUniformLocationWith4iv(location?: WebGLUniformLocation, intArray?: Int32Array, numberOfArrays?: number);
            /**
            * setUniformLocationWithMatrix4fv(location, matrixArray, numberOfMatrices)
calls glUniformMatrix4fv only if the values are different than the previous call for this same shader program.
Parameters:
{WebGLUniformLocation} location
{Float32Array} matrixArray
{Number} numberOfMatrices

            */
            setUniformLocationWithMatrix4fv(location?: WebGLUniformLocation, matrixArray?: Float32Array, numberOfMatrices?: number);
            /**
            * setUniformsForBuiltins()
will update the builtin uniforms if they are different than the previous call for this same shader program.

            */
            setUniformsForBuiltins();
            /**
            * updateUniforms()
It will create 4 uniforms:
cc.UNIFORM_PMATRIX
cc.UNIFORM_MVMATRIX
cc.UNIFORM_MVPMATRIX
cc.UNIFORM_SAMPLER

            */
            updateUniforms();
            /**
            * use()
it will call glUseProgram()

            */
            use();
            /**
            * {String}
vertexShaderLog()
returns the vertexShader error log
Returns:
{String}

            */
            vertexShaderLog(): string;
        }
    }
declare module cc {
        /**
        * 
FBO class that grabs the the contents of the screen

        */
        export class Grabber extends cc.Class {
            /**
            * FBO class that grabs the the contents of the screen
            */
            constructor();
        }
    }
declare module cc {
        /**
        * 
cc.Grid3D is a 3D grid implementation. Each vertex has 3 dimensions: x,y,z

        */
        export class Grid3D extends cc.GridBase {
            /**
            * cc.Grid3D is a 3D grid implementation.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.Grid3D}
cc.Grid3D.create(gridSize, texture, flipped)
create one Grid3D object
Parameters:
{cc.Size} gridSize
{cc.Texture2D} texture
Optional
{Boolean} flipped
Optional
Returns:
{cc.Grid3D}

            */
            static create(gridSize?: cc.Size, texture?: cc.Texture2D, flipped?: boolean): cc.Grid3D;
            /**
            * ctor(gridSize, texture, flipped)
create one Grid3D object
Constructor of cc.Grid3D
Parameters:
{cc.Size} gridSize
{cc.Texture2D} texture
Optional
{Boolean} flipped
Optional

            */
            ctor(gridSize?: cc.Size, texture?: cc.Texture2D, flipped?: boolean);
            /**
            * {cc.Vertex3F}
originalVertex(pos)
returns the original (non-transformed) vertex at a given position
Parameters:
{cc.Point} pos
Returns:
{cc.Vertex3F}

            */
            originalVertex(pos?: cc.Point): cc.Vertex3F;
            /**
            * setVertex(pos, vertex)
sets a new vertex at a given position
Parameters:
{cc.Point} pos
{cc.Vertex3F} vertex

            */
            setVertex(pos?: cc.Point, vertex?: cc.Vertex3F);
            /**
            * {cc.Vertex3F}
vertex(pos)
returns the vertex at a given position
Parameters:
{cc.Point} pos
Returns:
{cc.Vertex3F}

            */
            vertex(pos?: cc.Point): cc.Vertex3F;
        }
    }
declare module cc {
        /**
        * 
Base class for cc.Grid3D actions.
Grid3D actions can modify a non-tiled grid.

        */
        export class Grid3DAction extends cc.GridAction {
            /**
            * Base class for cc.Grid3D actions.
            */
            constructor();
            /**
            * Please use cc.grid3DAction instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Grid3DAction;
            /**
            * {cc.Grid3D}
getGrid()
returns the grid
Returns:
{cc.Grid3D}

            */
            getGrid(): cc.Grid3D;
            /**
            * {cc.Vertex3F}
originalVertex(position)
returns the non-transformed vertex than belongs to certain position in the grid
Parameters:
{cc.Point} position
Returns:
{cc.Vertex3F}

            */
            originalVertex(position?: cc.Point): cc.Vertex3F;
            /**
            * setVertex(position, vertex)
sets a new vertex to a certain position of the grid
Parameters:
{cc.Point} position
{cc.Vertex3F} vertex

            */
            setVertex(position?: cc.Point, vertex?: cc.Vertex3F);
            /**
            * {cc.Vertex3F}
vertex(position)
returns the vertex than belongs to certain position in the grid
Parameters:
{cc.Point} position
Returns:
{cc.Vertex3F}

            */
            vertex(position?: cc.Point): cc.Vertex3F;
        }
    }
declare module cc {
        /**
        * 
Base class for Grid actions

        */
        export class GridAction extends cc.ActionInterval {
            /**
            * Base class for Grid actions
            */
            constructor(duration?: number, gridSize?: cc.Size);
            /**
            * Please use cc.gridAction instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.GridAction;
            /**
            * {cc.Action}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.Action}

            */
            clone(): cc.Action;
            /**
            * ctor(duration, gridSize)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
{cc.Size} gridSize

            */
            ctor(duration?: number, gridSize?: cc.Size);
            /**
            * {cc.GridBase}
getGrid()
Returns the grid.
Returns:
{cc.GridBase}

            */
            getGrid(): cc.GridBase;
            /**
            * {Boolean}
initWithDuration(duration, gridSize)
Initializes the action with size and duration.
Parameters:
{Number} duration
{cc.Size} gridSize
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size): boolean;
            /**
            * {cc.ReverseTime}
reverse()
Create a cc.ReverseTime action. Opposite with the original motion trajectory.
Returns:
{cc.ReverseTime}

            */
            reverse(): cc.ReverseTime;
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
        }
    }
declare module cc {
        /**
        * 
Base class for cc.Grid

        */
        export class GridBase extends cc.Class {
            /**
            * Base class for cc.Grid
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.GridBase}
cc.GridBase.create(gridSize, texture, flipped)
create one cc.GridBase Object
Parameters:
{cc.Size} gridSize
{cc.Texture2D} texture
Optional
{Boolean} flipped
Optional
Returns:
{cc.GridBase}

            */
            static create(gridSize?: cc.Size, texture?: cc.Texture2D, flipped?: boolean): cc.GridBase;
            /**
            * ctor(gridSize, texture, flipped)
create one cc.GridBase Object
Constructor of cc.GridBase
Parameters:
{cc.Size} gridSize
{cc.Texture2D} texture
Optional
{Boolean} flipped
Optional

            */
            ctor(gridSize?: cc.Size, texture?: cc.Texture2D, flipped?: boolean);
            /**
            * {cc.Size}
getGridSize()
get size of the grid
Returns:
{cc.Size}

            */
            getGridSize(): cc.Size;
            /**
            * {Number}
getReuseGrid()
get number of times that the grid will be reused
Returns:
{Number}

            */
            getReuseGrid(): number;
            /**
            * {cc.Point}
getStep()
get pixels between the grids
Returns:
{cc.Point}

            */
            getStep(): cc.Point;
            /**
            * {boolean}
initWithSize(gridSize, texture, flipped)
Parameters:
{cc.Size} gridSize
{cc.Texture2D} texture
Optional
{Boolean} flipped
Optional, Default: false
Returns:
{boolean}

            */
            initWithSize(gridSize?: cc.Size, texture?: cc.Texture2D, flipped?: boolean): boolean;
            /**
            * {Boolean}
isActive()
whether or not the grid is active
Returns:
{Boolean}

            */
            isActive(): boolean;
            /**
            * {Boolean}
isTextureFlipped()
get whether or not the texture is flipped
Returns:
{Boolean}

            */
            isTextureFlipped(): boolean;
            /**
            * setActive(active)
whether or not the grid is active
Parameters:
{Number} active

            */
            setActive(active?: number);
            /**
            * setGridSize(gridSize)
set size of the grid
Parameters:
{cc.Size} gridSize

            */
            setGridSize(gridSize?: cc.Size);
            /**
            * setReuseGrid(reuseGrid)
set number of times that the grid will be reused
Parameters:
reuseGrid

            */
            setReuseGrid();
            /**
            * setStep(step)
set pixels between the grids
Parameters:
{cc.Point} step

            */
            setStep(step?: cc.Point);
            /**
            * setTextureFlipped(flipped)
set whether or not the texture is flipped
Parameters:
{Boolean} flipped

            */
            setTextureFlipped(flipped?: boolean);
        }
    }
declare module cc {
        /**
        * 
        */
        export class HashElement extends cc.Class {
            /**
            * 
            */
            constructor();
            /**
            * ctor()
Constructor

            */
            ctor();
        }
    }
declare module cc {
        /**
        * 
Hide the node.

        */
        export class Hide extends cc.ActionInstant {
            /**
            * Hide the node.
            */
            constructor();
            /**
            * Hide the node.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Hide;
            /**
            * {cc.Hide}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.Hide}

            */
            clone(): cc.Hide;
            /**
            * {cc.Show}
reverse()
returns a reversed action.
For example:
- The action will be x coordinates of 0 move to 100.
- The reversed action will be x of 100 move to 0.
- Will be rewritten
Returns:
{cc.Show}

            */
            reverse(): cc.Show;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
TGA format

        */
        export class ImageTGA  {
            /**
            * TGA format
            */
            constructor(status?: number, type?: number, pixelDepth?: number, width?: number, height?: number, imageData?: Array<any>, flipped?: number);
        }
    }
declare module cc {
        /**
        * 
Input method editor delegate.

        */
        export class IMEDelegate extends cc.Class {
            /**
            * Input method editor delegate.
            */
            constructor();
            /**
            * {Boolean}
attachWithIME()
Remove delegate
Returns:
{Boolean}

            */
            attachWithIME(): boolean;
            /**
            * {Boolean}
canAttachWithIME()
Decide the delegate instance is ready for receive ime message or not.
Called by CCIMEDispatcher.
Returns:
{Boolean}

            */
            canAttachWithIME(): boolean;
            /**
            * {Boolean}
canDetachWithIME()
Decide the delegate instance can stop receive ime message or not.
Returns:
{Boolean}

            */
            canDetachWithIME(): boolean;
            /**
            * ctor()
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * deleteBackward()
Called by CCIMEDispatcher when user clicked the backward key.

            */
            deleteBackward();
            /**
            * {Boolean}
detachWithIME()
Detach with IME
Returns:
{Boolean}

            */
            detachWithIME(): boolean;
            /**
            * didAttachWithIME()
When the delegate detach with IME, this method call by CCIMEDispatcher.

            */
            didAttachWithIME();
            /**
            * didDetachWithIME()
When the delegate detach with IME, this method call by CCIMEDispatcher.

            */
            didDetachWithIME();
            /**
            * {String}
getContentText()
Called by CCIMEDispatcher for get text which delegate already has.
Returns:
{String}

            */
            getContentText(): string;
            /**
            * insertText(text, len)
Called by CCIMEDispatcher when some text input from IME.
Parameters:
text
len

            */
            insertText();
            /**
            * removeDelegate()
Remove delegate

            */
            removeDelegate();
        }
    }
declare module cc {
        /**
        * 
cc.imeDispatcher is a singleton object which manage input message dispatching.

        */
        export class imeDispatcher  {
            /**
            * cc.imeDispatcher is a singleton object which manage input message dispatching.
            */
            constructor();
            /**
            * addDelegate(delegate)
Add delegate to concern ime msg
//example
cc.imeDispatcher.addDelegate(this);
Parameters:
{cc.IMEDelegate} delegate

            */
            addDelegate(delegate?: cc.IMEDelegate);
            /**
            * {Boolean}
attachDelegateWithIME(delegate)
Attach the pDeleate with ime.
//example
var ret = cc.imeDispatcher.attachDelegateWithIME(this);
Parameters:
{cc.IMEDelegate} delegate
Returns:
{Boolean} If the old delegate can detattach with ime and the new delegate can attach with ime, return true, otherwise return false.

            */
            attachDelegateWithIME(delegate?: cc.IMEDelegate): boolean;
            /**
            * ctor()
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
detachDelegateWithIME(delegate)
Detach the pDeleate with ime.
//example
var ret = cc.imeDispatcher.detachDelegateWithIME(this);
Parameters:
{cc.IMEDelegate} delegate
Returns:
{Boolean} If the old delegate can detattach with ime and the new delegate can attach with ime, return true, otherwise return false.

            */
            detachDelegateWithIME(delegate?: cc.IMEDelegate): boolean;
            /**
            * dispatchDeleteBackward()
Dispatch the delete backward operation

            */
            dispatchDeleteBackward();
            /**
            * dispatchInsertText(text, len)
Dispatch the input text from ime
Parameters:
{String} text
{Number} len

            */
            dispatchInsertText(text?: string, len?: number);
            /**
            * dispatchKeyboardDidHide(info)
Dispatch keyboard notification
Parameters:
{cc.IMEKeyboardNotificationInfo} info

            */
            dispatchKeyboardDidHide(info?: cc.IMEKeyboardNotificationInfo);
            /**
            * dispatchKeyboardDidShow(info)
Dispatch keyboard notification
Parameters:
{cc.IMEKeyboardNotificationInfo} info

            */
            dispatchKeyboardDidShow(info?: cc.IMEKeyboardNotificationInfo);
            /**
            * dispatchKeyboardWillHide(info)
Dispatch keyboard notification
Parameters:
{cc.IMEKeyboardNotificationInfo} info

            */
            dispatchKeyboardWillHide(info?: cc.IMEKeyboardNotificationInfo);
            /**
            * dispatchKeyboardWillShow(info)
Dispatch keyboard notification
Parameters:
{cc.IMEKeyboardNotificationInfo} info

            */
            dispatchKeyboardWillShow(info?: cc.IMEKeyboardNotificationInfo);
            /**
            * {String}
getContentText()
Get the content text, which current CCIMEDelegate which attached with IME has.
Returns:
{String}

            */
            getContentText(): string;
            /**
            * processKeycode(keyCode)
Process keydown&#39;s keycode
//example
document.addEventListener(&quot;keydown&quot;, function (e) {
cc.imeDispatcher.processKeycode(e.keyCode);
});
Parameters:
{Number} keyCode

            */
            processKeycode(keyCode?: number);
            /**
            * removeDelegate(delegate)
Remove the delegate from the delegates who concern ime msg
//example
cc.imeDispatcher.removeDelegate(this);
Parameters:
{cc.IMEDelegate} delegate

            */
            removeDelegate(delegate?: cc.IMEDelegate);
        }
    }
declare module cc.IMEDispatcher {
        /**
        * 
Create the cc.IMEDispatcher.Imp Object.
This is the inner class...

        */
        export class Impl extends cc.Class {
            /**
            * Create the cc.IMEDispatcher.Imp Object.
            */
            constructor();
            /**
            * ctor()
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Number|Null}
findDelegate(delegate)
Find delegate
Parameters:
{cc.IMEDelegate} delegate
Returns:
{Number|Null}

            */
            findDelegate(delegate?: cc.IMEDelegate): any;
        }
    }
declare module cc {
        /**
        * This class manages all events of input. include: touch, mouse, accelerometer, keyboard

        */
        export class inputManager  {
            /**
            * 
This class manages all events of input.
            */
            constructor();
            /**
            * {Object}
getHTMLElementPosition(element)
Parameters:
{HTMLElement} element
Returns:
{Object}

            */
            getHTMLElementPosition(element?: HTMLElement): Object;
            /**
            * {cc.EventMouse}
getMouseEvent(location, pos, eventType)
Parameters:
{cc.Point} location
{cc.Point} pos
{Number} eventType
Returns:
{cc.EventMouse}

            */
            getMouseEvent(location?: cc.Point, pos?: cc.Point, eventType?: number): cc.EventMouse;
            /**
            * {cc.Point}
getPointByEvent(event, pos)
Parameters:
{Touch} event
{cc.Point} pos
Returns:
{cc.Point}

            */
            getPointByEvent(event?: Touch, pos?: cc.Point): cc.Point;
            /**
            * {cc.Touch}
getPreTouch(touch)
Parameters:
{cc.Touch} touch
Returns:
{cc.Touch}

            */
            getPreTouch(touch?: cc.Touch): cc.Touch;
            /**
            * {Array}
getSetOfTouchesEndOrCancel(touches)
Parameters:
{Array} touches
Returns:
{Array}

            */
            getSetOfTouchesEndOrCancel(touches?: Array<any>): Array<any>;
            /**
            * {cc.Touch}
getTouchByXY(tx, ty, pos)
Parameters:
{Number} tx
{Number} ty
{cc.Point} pos
Returns:
{cc.Touch}

            */
            getTouchByXY(tx?: number, ty?: number, pos?: cc.Point): cc.Touch;
            /**
            * {Array}
getTouchesByEvent(event, pos)
Parameters:
{Touch} event
{cc.Point} pos
Returns:
{Array}

            */
            getTouchesByEvent(event?: Touch, pos?: cc.Point): Array<any>;
            /**
            * handleTouchesBegin(touches)
Parameters:
{Array} touches

            */
            handleTouchesBegin(touches?: Array<any>);
            /**
            * handleTouchesCancel(touches)
Parameters:
{Array} touches

            */
            handleTouchesCancel(touches?: Array<any>);
            /**
            * handleTouchesEnd(touches)
Parameters:
{Array} touches

            */
            handleTouchesEnd(touches?: Array<any>);
            /**
            * handleTouchesMove(touches)
Parameters:
{Array} touches

            */
            handleTouchesMove(touches?: Array<any>);
            /**
            * registerSystemEvent(element)
Parameters:
{HTMLElement} element

            */
            registerSystemEvent(element?: HTMLElement);
            /**
            * setPreTouch(touch)
Parameters:
{cc.Touch} touch

            */
            setPreTouch(touch?: cc.Touch);
            /**
            * update(dt)
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
An Invocation class

        */
        export class Invocation extends cc.Class {
            /**
            * An Invocation class
            */
            constructor();
        }
    }
declare module cc {
        /**
        * 
Moves a cc.Node object simulating a parabolic jump movement by modifying it&#39;s position attribute.
Relative to its movement.

        */
        export class JumpBy extends cc.ActionInterval {
            /**
            * Moves a cc.Node object simulating a parabolic jump movement by modifying it&#39;s position attribute.
            */
            constructor(duration?: number, position?: any, y?: number, height?: number, jumps?: number);
            /**
            * Please use cc.jumpBy instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.JumpBy;
            /**
            * {cc.JumpBy}
clone()
returns a new clone of the action
Returns:
{cc.JumpBy}

            */
            clone(): cc.JumpBy;
            /**
            * ctor(duration, position, y, height, jumps)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
{cc.Point|Number} position
{Number} y
Optional
{Number} height
{Number} jumps

            */
            ctor(duration?: number, position?: any, y?: number, height?: number, jumps?: number);
            /**
            * {Boolean}
initWithDuration(duration, position, y, height, jumps)
Initializes the action.
actionBy.initWithDuration(2, cc.p(300, 0), 50, 4);
actionBy.initWithDuration(2, 300, 0, 50, 4);
Parameters:
{Number} duration
{cc.Point|Number} position
{Number} y
Optional
{Number} height
{Number} jumps
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, position?: any, y?: number, height?: number, jumps?: number): boolean;
            /**
            * {cc.JumpBy}
reverse()
Returns a reversed action.
Returns:
{cc.JumpBy}

            */
            reverse(): cc.JumpBy;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.JumpTiles3D action.  A sin function is executed to move the tiles across the Z axis.
Reference the test cases (Effects Test)

        */
        export class JumpTiles3D extends cc.TiledGrid3DAction {
            /**
            * cc.JumpTiles3D action.
            */
            constructor(duration?: number, gridSize?: cc.Size, numberOfJumps?: number, amplitude?: number);
            /**
            * Please use cc.jumpTiles3D instead
creates the action with the number of jumps, the sin amplitude, the grid size and the duration.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.JumpTiles3D;
            /**
            * ctor(duration, gridSize, numberOfJumps, amplitude)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates the action with the number of jumps, the sin amplitude, the grid size and the duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} numberOfJumps
{Number} amplitude

            */
            ctor(duration?: number, gridSize?: cc.Size, numberOfJumps?: number, amplitude?: number);
            /**
            * {Number}
getAmplitude()
get amplitude of the sin
Returns:
{Number}

            */
            getAmplitude(): number;
            /**
            * {Number}
getAmplitudeRate()
get amplitude rate
Returns:
{Number}

            */
            getAmplitudeRate(): number;
            /**
            * initWithDuration(duration, gridSize, numberOfJumps, amplitude)
initializes the action with the number of jumps, the sin amplitude, the grid size and the duration
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} numberOfJumps
{Number} amplitude

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, numberOfJumps?: number, amplitude?: number);
            /**
            * setAmplitude(amplitude)
set amplitude of the sin
Parameters:
{Number} amplitude

            */
            setAmplitude(amplitude?: number);
            /**
            * setAmplitudeRate(amplitudeRate)
set amplitude rate
Parameters:
amplitudeRate

            */
            setAmplitudeRate();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Moves a cc.Node object to a parabolic position simulating a jump movement by modifying it&#39;s position attribute.
Jump to the specified location.

        */
        export class JumpTo extends cc.JumpBy {
            /**
            * Moves a cc.Node object to a parabolic position simulating a jump movement by modifying it&#39;s position attribute.
            */
            constructor(duration?: number, position?: any, y?: number, height?: number, jumps?: number);
            /**
            * Please use cc.jumpTo instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.JumpTo;
            /**
            * {cc.JumpTo}
clone()
returns a new clone of the action
Returns:
{cc.JumpTo}

            */
            clone(): cc.JumpTo;
            /**
            * ctor(duration, position, y, height, jumps)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
{cc.Point|Number} position
{Number} y
Optional
{Number} height
{Number} jumps

            */
            ctor(duration?: number, position?: any, y?: number, height?: number, jumps?: number);
            /**
            * {Boolean}
initWithDuration(duration, position, y, height, jumps)
Initializes the action.
actionTo.initWithDuration(2, cc.p(300, 0), 50, 4);
actionTo.initWithDuration(2, 300, 0, 50, 4);
Parameters:
{Number} duration
{cc.Point|Number} position
{Number} y
Optional
{Number} height
{Number} jumps
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, position?: any, y?: number, height?: number, jumps?: number): boolean;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
        }
    }
declare module cc {
        /**
        * 
The Quaternion class

        */
        export class kmQuaternion  {
            /**
            * The Quaternion class
            */
            constructor(x?: number, y?: number, z?: number, w?: number);
        }
    }
declare module cc {
        /**
        * 
using image file to print text label on the screen, might be a bit slower than cc.Label, similar to cc.LabelBMFont

        */
        export class LabelAtlas extends cc.AtlasNode {
            /**
            * using image file to print text label on the screen, might be a bit slower than cc.Label, similar to cc.LabelBMFont
            */
            constructor(strText?: string, charMapFile?: string, itemWidth?: number, itemHeight?: number, startCharMap?: number);
            /**
            * - Content string of label
            */
            string: string;
            /**
            * addLoadedEventListener(callback, target)
Add texture loaded event listener.
Parameters:
{Function} callback
{cc.Node} target
Deprecated:
since 3.1, please use addEventListener instead

            */
            addLoadedEventListener(callback?: Function, target?: cc.Node);
            /**
            * &amp;lt;static&amp;gt;
{cc.LabelAtlas}
cc.LabelAtlas.create(strText, charMapFile, itemWidth, itemHeight, startCharMap)
Please use new cc.LabelAtlas instead.
Create a label atlas.
It accepts two groups of parameters:
a) string, fntFile
b) label, textureFilename, width, height, startChar
Parameters:
{String} strText
{String} charMapFile
charMapFile or fntFile
{Number} itemWidth
Optional, Default: 0
{Number} itemHeight
Optional, Default: 0
{Number} startCharMap
Optional, Default: &quot;&quot;
Deprecated:
since v3.0 please use new cc.LabelAtlas
Returns:
{cc.LabelAtlas} returns the LabelAtlas object on success

            */
            static create(strText?: string, charMapFile?: string, itemWidth?: number, itemHeight?: number, startCharMap?: number): cc.LabelAtlas;
            /**
            * ctor(strText, charMapFile, itemWidth, itemHeight, startCharMap)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a label atlas.
It accepts two groups of parameters:
a) string, fntFile
b) label, textureFilename, width, height, startChar
Parameters:
{String} strText
{String} charMapFile
charMapFile or fntFile
{Number} itemWidth
Optional, Default: 0
{Number} itemHeight
Optional, Default: 0
{Number} startCharMap
Optional, Default: &quot;&quot;

            */
            ctor(strText?: string, charMapFile?: string, itemWidth?: number, itemHeight?: number, startCharMap?: number);
            /**
            * {String}
getString()
return the text of this label
Returns:
{String}

            */
            getString(): string;
            /**
            * {Boolean}
initWithString(strText, charMapFile, itemWidth, itemHeight, startCharMap)
initializes the cc.LabelAtlas with a string, a char map file(the atlas),
the width and height of each element and the starting char of the atlas
It accepts two groups of parameters:
a) string, fntFile
b) label, textureFilename, width, height, startChar
Parameters:
{String} strText
{String|cc.Texture2D} charMapFile
charMapFile or fntFile or texture file
{Number} itemWidth
Optional, Default: 0
{Number} itemHeight
Optional, Default: 0
{Number} startCharMap
Optional, Default: &quot;&quot;
Returns:
{Boolean} returns true on success

            */
            initWithString(strText?: string, charMapFile?: any, itemWidth?: number, itemHeight?: number, startCharMap?: number): boolean;
            /**
            * setColor(color3)
Set the color.
Parameters:
{cc.Color} color3

            */
            setColor(color3?: cc.Color);
            /**
            * setString(label)
set the display string
Parameters:
{String} label

            */
            setString(label?: string);
            /**
            * {boolean}
textureLoaded()
Return  texture is loaded.
Returns:
{boolean}

            */
            textureLoaded(): boolean;
            /**
            * updateAtlasValues()
Atlas generation

            */
            updateAtlasValues();
        }
    }
declare module cc {
        /**
        * 
cc.LabelBMFont is a subclass of cc.SpriteBatchNode.

Features:
- Treats each character like a cc.Sprite. This means that each individual character can be:
- rotated
- scaled
- translated
- tinted
- change the opacity
- It can be used as part of a menu item.
- anchorPoint can be used to align the &quot;label&quot;
- Supports AngelCode text format

Limitations:
- All inner characters are using an anchorPoint of (0.5, 0.5) and it is not recommend to change it
because it might affect the rendering

cc.LabelBMFont implements the protocol cc.LabelProtocol, like cc.Label and cc.LabelAtlas.
cc.LabelBMFont has the flexibility of cc.Label, the speed of cc.LabelAtlas and all the features of cc.Sprite.
If in doubt, use cc.LabelBMFont instead of cc.LabelAtlas / cc.Label.

Supported editors:
http://glyphdesigner.71squared.com/ (Commercial, Mac OS X)
http://www.n4te.com/hiero/hiero.jnlp (Free, Java)
http://slick.cokeandcode.com/demos/hiero.jnlp (Free, Java)
http://www.angelcode.com/products/bmfont/ (Free, Windows only)

        */
        export class LabelBMFont extends cc.SpriteBatchNode {
            /**
            * cc.LabelBMFont is a subclass of cc.SpriteBatchNode.
            */
            constructor(str?: string, fntFile?: string, width?: number, alignment?: number, imageOffset?: cc.Point);
            /**
            * - Width of the bounding box of label, the real content width is limited by boundingWidth
            */
            boundingWidth: number;
            /**
            * - Content string of label
            */
            string: string;
            /**
            * - Horizontal Alignment of label, cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT
            */
            textAlign: number;
            /**
            * addLoadedEventListener(callback, target)
add texture loaded event listener.
Will execute the callback in the loaded.
Parameters:
{Function} callback
{Object} target
Deprecated:
since 3.1, please use addEventListener instead

            */
            addLoadedEventListener(callback?: Function, target?: Object);
            /**
            * &amp;lt;static&amp;gt;
{cc.LabelBMFont|Null}
cc.LabelBMFont.create(str, fntFile, width, alignment, imageOffset)
creates a bitmap font atlas with an initial string and the FNT file
Parameters:
{String} str
{String} fntFile
{Number} width
Optional, Default: -1
{Number} alignment
Optional, Default: cc.TEXT_ALIGNMENT_LEFT
{cc.Point} imageOffset
Optional, Default: cc.p(0,0)
Deprecated:
since v3.0 please use new cc.LabelBMFont
Returns:
{cc.LabelBMFont|Null}

            */
            static create(str?: string, fntFile?: string, width?: number, alignment?: number, imageOffset?: cc.Point): any;
            /**
            * createFontChars()
updates the font chars based on the string to render

            */
            createFontChars();
            /**
            * ctor(str, fntFile, width, alignment, imageOffset)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates a bitmap font atlas with an initial string and the FNT file.
Parameters:
{String} str
{String} fntFile
{Number} width
Optional, Default: -1
{Number} alignment
Optional, Default: cc.TEXT_ALIGNMENT_LEFT
{cc.Point} imageOffset
Optional, Default: cc.p(0,0)

            */
            ctor(str?: string, fntFile?: string, width?: number, alignment?: number, imageOffset?: cc.Point);
            /**
            * {String}
getFntFile()
Return the fnt file path.
Returns:
{String}

            */
            getFntFile(): string;
            /**
            * {String}
getString()
Gets the text of this label
Returns:
{String}

            */
            getString(): string;
            /**
            * init()
Initialization of the node, please do not call this function by yourself, you should pass the parameters to constructor to initialize it
.

            */
            init();
            /**
            * {Boolean}
initWithString(str, fntFile, width, alignment, imageOffset)
init a bitmap font atlas with an initial string and the FNT file
Parameters:
{String} str
{String} fntFile
{Number} width
Optional, Default: -1
{Number} alignment
Optional, Default: cc.TEXT_ALIGNMENT_LEFT
{cc.Point} imageOffset
Optional, Default: cc.p(0,0)
Returns:
{Boolean}

            */
            initWithString(str?: string, fntFile?: string, width?: number, alignment?: number, imageOffset?: cc.Point): boolean;
            /**
            * {Boolean}
isOpacityModifyRGB()
Conforms to cc.RGBAProtocol protocol.
Returns:
{Boolean}

            */
            isOpacityModifyRGB(): boolean;
            /**
            * setAlignment(alignment)
Set text alignment.
Parameters:
{Number} alignment

            */
            setAlignment(alignment?: number);
            /**
            * setAnchorPoint(point, y)
Set the AnchorPoint of the labelBMFont.
In order to change the location of label.
Parameters:
{cc.Point|Number} point
The anchor point of labelBMFont or The anchor point.x of labelBMFont.
{Number} y
Optional
The anchor point.y of labelBMFont.

            */
            setAnchorPoint(point?: any, y?: number);
            /**
            * setBoundingWidth(width)
Set the bounding width.
max with display width. The exceeding string will be wrapping.
Parameters:
{Number} width

            */
            setBoundingWidth(width?: number);
            /**
            * setCString(label)
Set the text.
Change this Label display string.
Parameters:
label
Deprecated:
since v3.0 please use .setString

            */
            setCString();
            /**
            * setFntFile(fntFile)
set fnt file path.
Change the fnt file path.
Parameters:
{String} fntFile

            */
            setFntFile(fntFile?: string);
            /**
            * setLineBreakWithoutSpace(breakWithoutSpace)
Set the param to change English word warp according to whether the space.
default is false.
Parameters:
{Boolean} breakWithoutSpace

            */
            setLineBreakWithoutSpace(breakWithoutSpace?: boolean);
            /**
            * setOpacityModifyRGB(opacityModifyRGB)
Set whether to support cc.RGBAProtocol protocol
Parameters:
{Boolean} opacityModifyRGB

            */
            setOpacityModifyRGB(opacityModifyRGB?: boolean);
            /**
            * setScale(scale, scaleY)
Set scale.
Input a number, will be decrease or increase the font size.
Parameters:
{Number} scale
{Number} scaleY
Optional, Default: null
default is scale

            */
            setScale(scale?: number, scaleY?: number);
            /**
            * setScaleX(scaleX)
Set scale of x.
Input a number, will be decrease or increase the font size.
Horizontal scale.
Parameters:
{Number} scaleX

            */
            setScaleX(scaleX?: number);
            /**
            * setScaleY(scaleY)
Set scale of x.
Input a number, will be decrease or increase the font size.
Longitudinal scale.
Parameters:
{Number} scaleY

            */
            setScaleY(scaleY?: number);
            /**
            * setString(newString, needUpdateLabel)
Set the text
Parameters:
{String} newString
{Boolean|null} needUpdateLabel

            */
            setString(newString?: string, needUpdateLabel?: any);
            /**
            * {boolean}
textureLoaded()
return  texture is loaded
Returns:
{boolean}

            */
            textureLoaded(): boolean;
            /**
            * updateLabel()
Update Label.
Update this Label display string and more...

            */
            updateLabel();
            /**
            * updateString(fromUpdate)
Update String.
Only update this label display string.
Parameters:
{Boolean} fromUpdate

            */
            updateString(fromUpdate?: boolean);
        }
    }
declare module cc {
        /**
        * 
cc.LabelTTF is a subclass of cc.TextureNode that knows how to render text labels with system font or a ttf font file
All features from cc.Sprite are valid in cc.LabelTTF
cc.LabelTTF objects are slow for js-binding on mobile devices.
Consider using cc.LabelAtlas or cc.LabelBMFont instead.
You can create a cc.LabelTTF from a font name, alignment, dimension and font size or a cc.FontDefinition object.

        */
        export class LabelTTF extends cc.Sprite {
            /**
            * cc.LabelTTF is a subclass of cc.TextureNode that knows how to render text labels with system font or a ttf font file
All features from cc.Sprite are valid in cc.LabelTTF
cc.LabelTTF objects are slow for js-binding on mobile devices.
            */
            constructor(text?: string, fontName?: any, fontSize?: number, dimensions?: cc.Size, hAlignment?: number, vAlignment?: number);
            /**
            * - Height of the bounding box of label, the real content height is limited by boundingHeight
            */
            boundingHeight: number;
            /**
            * - Width of the bounding box of label, the real content width is limited by boundingWidth
            */
            boundingWidth: number;
            /**
            * - The fill color
            */
            fillStyle: cc.Color;
            /**
            * - The label font with a style string: e.g.
            */
            font: string;
            /**
            * - Font name of label
            */
            fontName: string;
            /**
            * - Font size of label
            */
            fontSize: number;
            /**
            * - The line width for stroke
            */
            lineWidth: number;
            /**
            * - The blur size of shadow
            */
            shadowBlur: number;
            /**
            * - The x axis offset of shadow
            */
            shadowOffsetX: number;
            /**
            * - The y axis offset of shadow
            */
            shadowOffsetY: number;
            /**
            * - The opacity of shadow
            */
            shadowOpacity: number;
            /**
            * - Content string of label
            */
            string: string;
            /**
            * - The stroke color
            */
            strokeStyle: cc.Color;
            /**
            * - Horizontal Alignment of label: cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT
            */
            textAlign: number;
            /**
            * - Vertical Alignment of label: cc.VERTICAL_TEXT_ALIGNMENT_TOP|cc.VERTICAL_TEXT_ALIGNMENT_CENTER|cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM
            */
            verticalAlign: number;
            /**
            * &amp;lt;static&amp;gt;
{cc.LabelTTF|Null}
cc.LabelTTF.create(text, fontName, fontSize, dimensions, hAlignment, vAlignment)
creates a cc.LabelTTF from a font name, alignment, dimension and font size
Parameters:
{String} text
{String|cc.FontDefinition} fontName
Optional, Default: &quot;Arial&quot;
{Number} fontSize
Optional, Default: 16
{cc.Size} dimensions
Optional, Default: cc.size(0,0)
{Number} hAlignment
Optional, Default: cc.TEXT_ALIGNMENT_LEFT
{Number} vAlignment
Optional, Default: cc.VERTICAL_TEXT_ALIGNMENT_TOP
Deprecated:
since v3.0, please use the new construction instead
Returns:
{cc.LabelTTF|Null}
See:
cc.LabelTTF

            */
            static create(text?: string, fontName?: any, fontSize?: number, dimensions?: cc.Size, hAlignment?: number, vAlignment?: number): any;
            /**
            * &amp;lt;static&amp;gt;
cc.LabelTTF.createWithFontDefinition()
Deprecated:
since v3.0, please use the new construction instead

            */
            static createWithFontDefinition();
            /**
            * disableShadow()
Disable shadow rendering

            */
            disableShadow();
            /**
            * disableStroke()
Disable label stroke

            */
            disableStroke();
            /**
            * enableShadow(a, b, c, d)
Enable or disable shadow for the label
old:
labelttf.enableShadow(shadowOffsetX, shadowOffsetY, shadowOpacity, shadowBlur);
new:
labelttf.enableShadow(shadowColor, offset, blurRadius);
Parameters:
{cc.Color | Number} a
Color or The x axis offset of the shadow
{cc.Size | Number} b
Size or The y axis offset of the shadow
{Number} c
The blur size of the shadow or The opacity of the shadow (0 to 1)
{null | Number} d
Null or The blur size of the shadow

            */
            enableShadow(a?: any, b?: any, c?: number, d?: any);
            /**
            * enableStroke(strokeColor, strokeSize)
Enable label stroke with stroke parameters
Parameters:
{cc.Color} strokeColor
The color of stroke
{Number} strokeSize
The size of stroke

            */
            enableStroke(strokeColor?: cc.Color, strokeSize?: number);
            /**
            * {cc.Size}
getContentSize()
Returns the actual content size of the label, the content size is the real size that the label occupied while dimension is the outer bounding box of the label.
Returns:
{cc.Size} The content size

            */
            getContentSize(): cc.Size;
            /**
            * {cc.Size}
getDimensions()
Returns the dimensions of cc.LabelTTF, the dimension is the maximum size of the label, set it so that label will automatically change lines when necessary.
Returns:
{cc.Size}
See:
cc.LabelTTF#setDimensions, cc.LabelTTF#boundingWidth and cc.LabelTTF#boundingHeight

            */
            getDimensions(): cc.Size;
            /**
            * {String}
getFontName()
Returns font name of cc.LabelTTF
Returns:
{String}

            */
            getFontName(): string;
            /**
            * {Number}
getFontSize()
Returns font size of cc.LabelTTF
Returns:
{Number}

            */
            getFontSize(): number;
            /**
            * {cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT}
getHorizontalAlignment()
Returns Horizontal Alignment of cc.LabelTTF
Returns:
{cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT}

            */
            getHorizontalAlignment(): any;
            /**
            * {String}
getString()
Returns the text of the label
Returns:
{String}

            */
            getString(): string;
            /**
            * {cc.FontDefinition}
getTextDefinition()
Extract the text definition used by this label
Returns:
{cc.FontDefinition}

            */
            getTextDefinition(): cc.FontDefinition;
            /**
            * {cc.VERTICAL_TEXT_ALIGNMENT_TOP|cc.VERTICAL_TEXT_ALIGNMENT_CENTER|cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM}
getVerticalAlignment()
Returns Vertical Alignment of cc.LabelTTF
Returns:
{cc.VERTICAL_TEXT_ALIGNMENT_TOP|cc.VERTICAL_TEXT_ALIGNMENT_CENTER|cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM}

            */
            getVerticalAlignment(): any;
            /**
            * {Boolean}
initWithString(label, fontName, fontSize, dimensions, hAlignment, vAlignment)
Initializes the cc.LabelTTF with a font name, alignment, dimension and font size, do not call it by yourself,
you should pass the correct arguments in constructor to initialize the label.
Parameters:
{String} label
string
{String} fontName
{Number} fontSize
{cc.Size} dimensions
Optional
{Number} hAlignment
Optional
{Number} vAlignment
Optional
Returns:
{Boolean} return false on error

            */
            initWithString(label?: string, fontName?: string, fontSize?: number, dimensions?: cc.Size, hAlignment?: number, vAlignment?: number): boolean;
            /**
            * {Boolean}
initWithStringAndTextDefinition(text, textDefinition)
Initializes the CCLabelTTF with a font name, alignment, dimension and font size, do not call it by yourself, you should pass the correct arguments in constructor to initialize the label.
Parameters:
{String} text
{cc.FontDefinition} textDefinition
Returns:
{Boolean}

            */
            initWithStringAndTextDefinition(text?: string, textDefinition?: cc.FontDefinition): boolean;
            /**
            * setDimensions(dim, height)
Set Dimensions of cc.LabelTTF, the dimension is the maximum size of the label, set it so that label will automatically change lines when necessary.
Parameters:
{cc.Size|Number} dim
dimensions or width of dimensions
{Number} height
Optional
height of dimensions

            */
            setDimensions(dim?: any, height?: number);
            /**
            * setFontFillColor(fillColor)
Sets the text fill color
Parameters:
{cc.Color} fillColor
The fill color of the label

            */
            setFontFillColor(fillColor?: cc.Color);
            /**
            * setFontName(fontName)
Sets font name of cc.LabelTTF
Parameters:
{String} fontName

            */
            setFontName(fontName?: string);
            /**
            * setFontSize(fontSize)
Sets font size of cc.LabelTTF
Parameters:
{Number} fontSize

            */
            setFontSize(fontSize?: number);
            /**
            * setHorizontalAlignment(alignment)
Sets Horizontal Alignment of cc.LabelTTF
Parameters:
{cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT} alignment
Horizontal Alignment

            */
            setHorizontalAlignment(alignment?: any);
            /**
            * setString(text)
Changes the text content of the label
Parameters:
{String} text
Text content for the label

            */
            setString(text?: string);
            /**
            * setTextDefinition(theDefinition)
Sets the text definition used by this label
Parameters:
{cc.FontDefinition} theDefinition

            */
            setTextDefinition(theDefinition?: cc.FontDefinition);
            /**
            * setVerticalAlignment(verticalAlignment)
Sets Vertical Alignment of cc.LabelTTF
Parameters:
{cc.VERTICAL_TEXT_ALIGNMENT_TOP|cc.VERTICAL_TEXT_ALIGNMENT_CENTER|cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM} verticalAlignment

            */
            setVerticalAlignment(verticalAlignment?: any);
        }
    }
declare module cc {
        /**
        * 
cc.Layer is a subclass of cc.Node that implements the TouchEventsDelegate protocol.
All features from cc.Node are valid, plus the bake feature: Baked layer can cache a static layer to improve performance

        */
        export class Layer extends cc.Node {
            /**
            * cc.Layer is a subclass of cc.Node that implements the TouchEventsDelegate protocol.
            */
            constructor();
            /**
            * bake()
Sets the layer to cache all of children to a bake sprite, and draw itself by bake sprite. recommend using it in UI.
This is useful only in html5 engine
See:
cc.Layer#unbake

            */
            bake();
            /**
            * &amp;lt;static&amp;gt;
{cc.Layer|Null}
cc.Layer.create()
Creates a layer
Deprecated:
since v3.0, please use the new construction instead
Returns:
{cc.Layer|Null}
See:
cc.Layer

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): Layer;
            /**
            * ctor()
Constructor of cc.Layer, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * init()
Initialization of the layer, please do not call this function by yourself, you should pass the parameters to constructor to initialize a layer

            */
            init();
            /**
            * {boolean}
isBaked()
Determines if the layer is baked.
Returns:
{boolean}
See:
cc.Layer#bake and cc.Layer#unbake

            */
            isBaked(): boolean;
            /**
            * unbake()
Cancel the layer to cache all of children to a bake sprite.
This is useful only in html5 engine
See:
cc.Layer#bake

            */
            unbake();
        }
    }
declare module cc {
        /**
        * CCLayerColor is a subclass of CCLayer that implements the CCRGBAProtocol protocol.
All features from CCLayer are valid, plus the following new features:
- opacity
- RGB colors

        */
        export class LayerColor extends cc.Layer {
            /**
            * 
CCLayerColor is a subclass of CCLayer that implements the CCRGBAProtocol protocol.
            */
            constructor(color?: cc.Color, width?: number, height?: number);
            /**
            * changeHeight(h)
change height in Points
Parameters:
{Number} h
height
Deprecated:
since v3.0 please use setContentSize instead
See:
cc.Node#setContentSize

            */
            changeHeight(h?: number);
            /**
            * changeWidth(w)
Changes width in Points
Parameters:
{Number} w
width
Deprecated:
since v3.0 please use setContentSize instead
See:
cc.Node#setContentSize

            */
            changeWidth(w?: number);
            /**
            * changeWidthAndHeight(w, h)
Changes width and height
Parameters:
{Number} w
width
{Number} h
height
Deprecated:
since v3.0 please use setContentSize instead
See:
cc.Node#setContentSize

            */
            changeWidthAndHeight(w?: number, h?: number);
            /**
            * &amp;lt;static&amp;gt;
{cc.LayerColor}
cc.LayerColor.create(color, width, height)
Creates a cc.Layer with color, width and height in Points
Parameters:
{cc.Color} color
{Number|Null} width
Optional
{Number|Null} height
Optional
Deprecated:
since v3.0 please use the new construction instead
Returns:
{cc.LayerColor}
See:
cc.LayerColor

            */
            static create(color?: cc.Color, width?: any, height?: any): cc.LayerColor;
            /**
            * ctor(color, width, height)
Constructor of cc.LayerColor
Parameters:
{cc.Color} color
Optional
{Number} width
Optional
{Number} height
Optional

            */
            ctor(color?: cc.Color, width?: number, height?: number);
            /**
            * {cc.BlendFunc}
getBlendFunc()
Returns the blend function
Returns:
{cc.BlendFunc}

            */
            getBlendFunc(): cc.BlendFunc;
            /**
            * {Boolean}
init(color, width, height)
Initialization of the layer, please do not call this function by yourself, you should pass the parameters to constructor to initialize a layer
Parameters:
{cc.Color} color
Optional
{Number} width
Optional
{Number} height
Optional
Returns:
{Boolean}

            */
            init(color?: cc.Color, width?: number, height?: number): boolean;
            /**
            * setBlendFunc(src, dst)
Sets the blend func, you can pass either a cc.BlendFunc object or source and destination value separately
Parameters:
{Number|cc.BlendFunc} src
{Number} dst
Optional

            */
            setBlendFunc(src?: any, dst?: number);
        }
    }
declare module cc {
        /**
        * CCLayerGradient is a subclass of cc.LayerColor that draws gradients across the background.

All features from cc.LayerColor are valid, plus the following new features:
direction
final color
interpolation mode

Color is interpolated between the startColor and endColor along the given
vector (starting at the origin, ending at the terminus).  If no vector is
supplied, it defaults to (0, -1) -- a fade from top to bottom.

If &#39;compressedInterpolation&#39; is disabled, you will not see either the start or end color for
non-cardinal vectors; a smooth gradient implying both end points will be still
be drawn, however.

If &#39;compressedInterpolation&#39; is enabled (default mode) you will see both the start and end colors of the gradient.

        */
        export class LayerGradient extends cc.LayerColor {
            /**
            * 
CCLayerGradient is a subclass of cc.LayerColor that draws gradients across the background.
            */
            constructor(start?: cc.Color, end?: cc.Color, v?: cc.Point);
            /**
            * - Indicate whether or not the interpolation will be compressed
            */
            compresseInterpolation: number;
            /**
            * - End color of the color gradient
            */
            endColor: cc.Color;
            /**
            * - End opacity of the color gradient
            */
            endOpacity: number;
            /**
            * - Start color of the color gradient
            */
            startColor: cc.Color;
            /**
            * - Start opacity of the color gradient
            */
            startOpacity: number;
            /**
            * - Direction vector of the color gradient
            */
            vector: number;
            /**
            * &amp;lt;static&amp;gt;
{cc.LayerGradient}
cc.LayerGradient.create(start, end, v)
Creates a gradient layer
Parameters:
{cc.Color} start
starting color
{cc.Color} end
ending color
{cc.Point|Null} v
Deprecated:
since v3.0, please use the new construction instead
Returns:
{cc.LayerGradient}
See:
cc.layerGradient

            */
            static create(start?: cc.Color, end?: cc.Color, v?: any): cc.LayerGradient;
            /**
            * ctor(start, end, v)
Constructor of cc.LayerGradient
Parameters:
{cc.Color} start
{cc.Color} end
{cc.Point} v
Optional, Default: cc.p(0, -1)

            */
            ctor(start?: cc.Color, end?: cc.Color, v?: cc.Point);
            /**
            * {cc.Color}
getEndColor()
Returns the end color
Returns:
{cc.Color}

            */
            getEndColor(): cc.Color;
            /**
            * {Number}
getEndOpacity()
Returns the end gradient opacity
Returns:
{Number}

            */
            getEndOpacity(): number;
            /**
            * {cc.Color}
getStartColor()
Returns the starting color
Returns:
{cc.Color}

            */
            getStartColor(): cc.Color;
            /**
            * {Number}
getStartOpacity()
Returns the starting gradient opacity
Returns:
{Number}

            */
            getStartOpacity(): number;
            /**
            * {cc.Point}
getVector()
Returns the direction vector of the gradient
Returns:
{cc.Point}

            */
            getVector(): cc.Point;
            /**
            * {Boolean}
init(start, end, v)
Initialization of the layer, please do not call this function by yourself, you should pass the parameters to constructor to initialize a layer
Parameters:
{cc.Color} start
starting color
{cc.Color} end
{cc.Point|Null} v
Returns:
{Boolean}

            */
            init(start?: cc.Color, end?: cc.Color, v?: any): boolean;
            /**
            * {Boolean}
isCompressedInterpolation()
Returns whether compressed interpolation is enabled
Returns:
{Boolean}

            */
            isCompressedInterpolation(): boolean;
            /**
            * setCompressedInterpolation(compress)
Sets whether compressed interpolation is enabled
Parameters:
{Boolean} compress

            */
            setCompressedInterpolation(compress?: boolean);
            /**
            * setContentSize(size, height)
Sets the untransformed size of the LayerGradient.
Parameters:
{cc.Size|Number} size
The untransformed size of the LayerGradient or The untransformed size&#39;s width of the LayerGradient.
{Number} height
Optional
The untransformed size&#39;s height of the LayerGradient.

            */
            setContentSize(size?: any, height?: number);
            /**
            * setEndColor(color)
Sets the end gradient color
// Example
myGradientLayer.setEndColor(cc.color(255,0,0));
//set the ending gradient to red
Parameters:
{cc.Color} color

            */
            setEndColor(color?: cc.Color);
            /**
            * setEndOpacity(o)
Sets the end gradient opacity
Parameters:
{Number} o

            */
            setEndOpacity(o?: number);
            /**
            * setStartColor(color)
Sets the starting color
// Example
myGradientLayer.setStartColor(cc.color(255,0,0));
//set the starting gradient to red
Parameters:
{cc.Color} color

            */
            setStartColor(color?: cc.Color);
            /**
            * setStartOpacity(o)
Sets starting gradient opacity
Parameters:
{Number} o
from 0 to 255, 0 is transparent

            */
            setStartOpacity(o?: number);
            /**
            * setVector(Var)
Sets the direction vector of the gradient
Parameters:
{cc.Point} Var

            */
            setVector(Var?: cc.Point);
        }
    }
declare module cc {
        /**
        * 
CCMultipleLayer is a CCLayer with the ability to multiplex it&#39;s children.
Features:
- It supports one or more children
- Only one children will be active a time

        */
        export class LayerMultiplex extends cc.Layer {
            /**
            * CCMultipleLayer is a CCLayer with the ability to multiplex it&#39;s children.
            */
            constructor(layers?: Array<any>);
            /**
            * addLayer(layer)
Add a layer to the multiplex layers list
Parameters:
{cc.Layer} layer

            */
            addLayer(layer?: cc.Layer);
            /**
            * &amp;lt;static&amp;gt;
{cc.LayerMultiplex|Null}
cc.LayerMultiplex.create()
Creates a cc.LayerMultiplex with one or more layers using a variable argument list.
Deprecated:
since v3.0, please use new construction instead
Returns:
{cc.LayerMultiplex|Null}
See:
cc.LayerMultiplex

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): LayerMultiplex;
            /**
            * ctor(layers)
Constructor of cc.LayerMultiplex
Parameters:
{Array} layers
an array of cc.Layer

            */
            ctor(layers?: Array<any>);
            /**
            * {Boolean}
initWithLayers(layers)
Initialization of the layer multiplex, please do not call this function by yourself, you should pass the parameters to constructor to initialize a layer multiplex
Parameters:
{Array} layers
an array of cc.Layer
Returns:
{Boolean}

            */
            initWithLayers(layers?: Array<any>): boolean;
            /**
            * switchTo(n)
Switches to a certain layer indexed by n.
The current (old) layer will be removed from it&#39;s parent with &#39;cleanup:YES&#39;.
Parameters:
{Number} n
the layer index to switch to

            */
            switchTo(n?: number);
            /**
            * switchToAndReleaseMe(n)
Release the current layer and switches to another layer indexed by n.
The current (old) layer will be removed from it&#39;s parent with &#39;cleanup:YES&#39;.
Parameters:
{Number} n
the layer index to switch to

            */
            switchToAndReleaseMe(n?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Lens3D action.
Upside down.
Reference the test cases (Effects Test)

        */
        export class Lens3D extends cc.Grid3DAction {
            /**
            * cc.Lens3D action.
            */
            constructor(duration?: number, gridSize?: cc.Size, position?: cc.Point, radius?: number);
            /**
            * Please use cc.lens3D instead
creates a lens 3d action with center position, radius
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Lens3D;
            /**
            * ctor(duration, gridSize, position, radius)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates a lens 3d action with center position, radius.
Parameters:
{Number} duration
{cc.Size} gridSize
{cc.Point} position
{Number} radius

            */
            ctor(duration?: number, gridSize?: cc.Size, position?: cc.Point, radius?: number);
            /**
            * {Number}
getLensEffect()
Get lens center position
Returns:
{Number}

            */
            getLensEffect(): number;
            /**
            * {cc.Point}
getPosition()
get Position
Returns:
{cc.Point}

            */
            getPosition(): cc.Point;
            /**
            * {Boolean}
initWithDuration(duration, gridSize, position, radius)
initializes the action with center position, radius, a grid size and duration
Parameters:
{Number} duration
{cc.Size} gridSize
{cc.Point} position
{Number} radius
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, position?: cc.Point, radius?: number): boolean;
            /**
            * setConcave(concave)
Set whether lens is concave
Parameters:
{Boolean} concave

            */
            setConcave(concave?: boolean);
            /**
            * setLensEffect(lensEffect)
Set lens center position
Parameters:
{Number} lensEffect

            */
            setLensEffect(lensEffect?: number);
            /**
            * setPosition(position)
set Position
Parameters:
{cc.Point} position

            */
            setPosition(position?: cc.Point);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Liquid action.
Reference the test cases (Effects Test)

        */
        export class Liquid extends cc.Grid3DAction {
            /**
            * cc.Liquid action.
            */
            constructor(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number);
            /**
            * Please use cc.liquid instead
creates the action with amplitude, a grid and duration
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Liquid;
            /**
            * ctor(duration, gridSize, waves, amplitude)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a liquid action with amplitude, a grid and duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} waves
{Number} amplitude

            */
            ctor(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number);
            /**
            * {Number}
getAmplitude()
get amplitude
Returns:
{Number}

            */
            getAmplitude(): number;
            /**
            * {Number}
getAmplitudeRate()
get amplitude rate
Returns:
{Number}

            */
            getAmplitudeRate(): number;
            /**
            * {Boolean}
initWithDuration(duration, gridSize, waves, amplitude)
initializes the action with amplitude, a grid and duration
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} waves
{Number} amplitude
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number): boolean;
            /**
            * setAmplitude(amplitude)
set amplitude
Parameters:
{Number} amplitude

            */
            setAmplitude(amplitude?: number);
            /**
            * setAmplitudeRate(amplitudeRate)
set amplitude rate
Parameters:
{Number} amplitudeRate

            */
            setAmplitudeRate(amplitudeRate?: number);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Loader for resource loading process. It&#39;s a singleton object.

        */
        export class loader  {
            /**
            * Loader for resource loading process.
            */
            constructor();
            /**
            * {*}
getRes(url)
Get resource data by url.
Parameters:
url
Returns:
{*}

            */
            getRes(): any;
            /**
            * {*}
getUrl(basePath, url)
Get url with basePath.
Parameters:
{string} basePath
{string} url
Optional
Returns:
{*}

            */
            getUrl(basePath?: string, url?: string): any;
            /**
            * {XMLHttpRequest}
getXMLHttpRequest()
Get XMLHttpRequest.
Returns:
{XMLHttpRequest}

            */
            getXMLHttpRequest(): XMLHttpRequest;
            /**
            * {cc.AsyncPool}
load(resources, option, loadCallback)
Load resources then call the callback.
Parameters:
{string} resources
{function} option
Optional
callback or trigger
{function|Object} loadCallback
Optional
Returns:
{cc.AsyncPool}

            */
            load(resources?: string, option?: any, loadCallback?: any): cc.AsyncPool;
            /**
            * loadAliases(url, callback)
Loads alias map from the contents of a filename.
Parameters:
{String} url
The plist file name.
{Function} callback
Optional

            */
            loadAliases(url?: string, callback?: Function);
            /**
            * {Image}
loadImg(url, option, callback)
Load a single image.
Parameters:
{!string} url
{object} option
Optional
{function} callback
Returns:
{Image}

            */
            loadImg(url?: string, option?: any, callback?: any): any;
            /**
            * {*}
loadJs(baseDir, jsList, cb)
Load js files.
If the third parameter doesn&#39;t exist, then the baseDir turns to be &quot;&quot;.
Parameters:
{string} baseDir
Optional
The pre path for jsList or the list of js path.
{array} jsList
List of js path.
{function} cb
Optional
Callback function
Returns:
{*}

            */
            loadJs(baseDir?: string, jsList?: Array<any>, cb?: any): any;
            /**
            * loadJson(url, cb)
Load a single resource as json.
Parameters:
{string} url
{function} cb
Optional
arguments are : err, json

            */
            loadJson(url?: string, cb?: any);
            /**
            * loadJsWithImg(baseDir, jsList, cb)
Load js width loading image.
Parameters:
{string} baseDir
Optional
{array} jsList
{function} cb
Optional

            */
            loadJsWithImg(baseDir?: string, jsList?: Array<any>, cb?: any);
            /**
            * loadTxt(url, cb)
Load a single resource as txt.
Parameters:
{string} url
{function} cb
Optional
arguments are : err, txt

            */
            loadTxt(url?: string, cb?: any);
            /**
            * register(extNames, loader)
Register a resource loader into loader.
Parameters:
{string} extNames
{function} loader

            */
            register(extNames?: string, loader?: any);
            /**
            * release(url)
Release the cache of resource by url.
Parameters:
url

            */
            release();
            /**
            * releaseAll()
Resource cache of all resources.

            */
            releaseAll();
        }
    }
declare module cc {
        /**
        * 
Features and Limitation:
- You can add MenuItem objects in runtime using addChild:
- But the only accepted children are MenuItem objects

        */
        export class Menu extends cc.Layer {
            /**
            * Features and Limitation:
- You can add MenuItem objects in runtime using addChild:
- But the only accepted children are MenuItem objects
            */
            constructor(menuItems);
            /**
            * addChild(child, zOrder, tag)
add a child for  cc.Menu
Parameters:
{cc.Node} child
{Number|Null} zOrder
Optional
zOrder for the child
{Number|Null} tag
Optional
tag for the child

            */
            addChild(child?: cc.Node, zOrder?: any, tag?: any);
            /**
            * alignItemsHorizontally()
align items horizontally with default padding

            */
            alignItemsHorizontally();
            /**
            * alignItemsHorizontallyWithPadding(padding)
align items horizontally with specified padding
Parameters:
{Number} padding

            */
            alignItemsHorizontallyWithPadding(padding?: number);
            /**
            * alignItemsInColumns()
align items in columns
// Example
menu.alignItemsInColumns(3,2,3)// this will create 3 columns, with 3 items for first column, 2 items for second and 3 for third

menu.alignItemsInColumns(3,3)//this creates 2 columns, each have 3 items

            */
            alignItemsInColumns();
            /**
            * alignItemsInRows()
align menu items in rows
// Example
menu.alignItemsInRows(5,3)//this will align items to 2 rows, first row with 5 items, second row with 3

menu.alignItemsInRows(4,4,4,4)//this creates 4 rows each have 4 items
Parameters:
{Number}

            */
            alignItemsInRows();
            /**
            * alignItemsVertically()
align items vertically with default padding

            */
            alignItemsVertically();
            /**
            * alignItemsVerticallyWithPadding(padding)
align items vertically with specified padding
Parameters:
{Number} padding

            */
            alignItemsVerticallyWithPadding(padding?: number);
            /**
            * &amp;lt;static&amp;gt;
{cc.Menu}
cc.Menu.create(menuItems)
create a new menu
Parameters:
{...cc.MenuItem|null} menuItems
todo: need to use new
Deprecated:
since v3.0, please use new cc.Menu(menuitem1, menuitem2, menuitem3) to create a new menu
Returns:
{cc.Menu}

            */
            static create(menuItems?: any): cc.Menu;
            /**
            * ctor(menuItems)
Constructor of cc.Menu override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{...cc.MenuItem|null} menuItems

            */
            ctor(menuItems?: any);
            /**
            * {Boolean}
initWithArray(arrayOfItems)
initializes a cc.Menu with a Array of cc.MenuItem objects
Parameters:
{Array} arrayOfItems
array Of cc.MenuItem Items
Returns:
{Boolean}

            */
            initWithArray(arrayOfItems?: Array<any>): boolean;
            /**
            * {Boolean}
initWithItems(args)
initializes a cc.Menu with it&#39;s items
Parameters:
{Array} args
Returns:
{Boolean}

            */
            initWithItems(args?: Array<any>): boolean;
            /**
            * {Boolean}
isEnabled()
return whether or not the menu will receive events
Returns:
{Boolean}

            */
            isEnabled(): boolean;
            /**
            * {boolean}
isOpacityModifyRGB()
only use for jsbinding
Returns:
{boolean}

            */
            isOpacityModifyRGB(): boolean;
            /**
            * onEnter()
Event callback that is invoked every time when CCMenu enters the &#39;stage&#39;.
If the CCMenu enters the &#39;stage&#39; with a transition, this event is called when the transition starts.
During onEnter you can&#39;t access a &quot;sister/brother&quot; node.
If you override onEnter, you must call its parent&#39;s onEnter function with this._super().

            */
            onEnter();
            /**
            * onExit()
callback that is called every time the cc.Menu leaves the &#39;stage&#39;.
If the cc.Menu leaves the &#39;stage&#39; with a transition, this callback is called when the transition finishes.
During onExit you can&#39;t access a sibling node.
If you override onExit, you shall call its parent&#39;s onExit with this._super().

            */
            onExit();
            /**
            * removeChild(child, cleanup)
remove a child from cc.Menu
Parameters:
{cc.Node} child
the child you want to remove
{boolean} cleanup
whether to cleanup

            */
            removeChild(child?: cc.Node, cleanup?: boolean);
            /**
            * setEnabled(enabled)
set whether or not the menu will receive events
Parameters:
{Boolean} enabled

            */
            setEnabled(enabled?: boolean);
            /**
            * setOpacityModifyRGB(value)
only use for jsbinding
Parameters:
value

            */
            setOpacityModifyRGB();
        }
    }
declare module cc {
        /**
        * 
Subclass cc.MenuItem (or any subclass) to create your custom cc.MenuItem objects.

        */
        export class MenuItem extends cc.Node {
            /**
            * Subclass cc.MenuItem (or any subclass) to create your custom cc.MenuItem objects.
            */
            constructor(callback?: any, target?: cc.Node);
            /**
            * activate()
call the selector with target

            */
            activate();
            /**
            * &amp;lt;static&amp;gt;
{cc.MenuItem}
cc.MenuItem.create(callback, target)
creates an empty menu item with target and callback
Not recommended to use the base class, should use more defined menu item classes
Parameters:
{function|String} callback
callback
{cc.Node} target
Deprecated:
since v3.0, please use new cc.MenuItem(callback,target) instead
Returns:
{cc.MenuItem}

            */
            static create(callback?: any, target?: cc.Node): cc.MenuItem;
            /**
            * ctor(callback, target)
Constructor of cc.MenuItem
Parameters:
{function|String} callback
{cc.Node} target

            */
            ctor(callback?: any, target?: cc.Node);
            /**
            * {Boolean}
initWithCallback(callback, target)
initializes a cc.MenuItem with callback
Parameters:
{function|String} callback
{cc.Node} target
Returns:
{Boolean}

            */
            initWithCallback(callback?: any, target?: cc.Node): boolean;
            /**
            * {Boolean}
isEnabled()
return whether MenuItem is Enabled
Returns:
{Boolean}

            */
            isEnabled(): boolean;
            /**
            * {boolean}
isOpacityModifyRGB()
only use for jsbinding
Returns:
{boolean}

            */
            isOpacityModifyRGB(): boolean;
            /**
            * {Boolean}
isSelected()
return whether MenuItem is selected
Returns:
{Boolean}

            */
            isSelected(): boolean;
            /**
            * {cc.Rect}
rect()
return rect value of cc.MenuItem
Returns:
{cc.Rect}

            */
            rect(): cc.Rect;
            /**
            * selected()
set the cc.MenuItem selected same as setIsSelected(true)

            */
            selected();
            /**
            * setCallback(callback, target)
set the callback to the menu item
Parameters:
{function|String} callback
{cc.Node} target

            */
            setCallback(callback?: any, target?: cc.Node);
            /**
            * setEnabled(enable)
set enable value of MenuItem
Parameters:
{Boolean} enable

            */
            setEnabled(enable?: boolean);
            /**
            * setOpacityModifyRGB(value)
only use for jsbinding
Parameters:
value

            */
            setOpacityModifyRGB();
            /**
            * setTarget(selector, rec)
set the target/selector of the menu item
Parameters:
{function|String} selector
{cc.Node} rec
Deprecated:
since v3.0

            */
            setTarget(selector?: any, rec?: cc.Node);
            /**
            * unselected()
set the cc.MenuItem unselected same as setIsSelected(false)

            */
            unselected();
        }
    }
declare module cc {
        /**
        * 
Helper class that creates a MenuItemLabel class with a LabelAtlas

        */
        export class MenuItemAtlasFont extends cc.MenuItemLabel {
            /**
            * Helper class that creates a MenuItemLabel class with a LabelAtlas
            */
            constructor(value?: string, charMapFile?: string, itemWidth?: number, itemHeight?: number, startCharMap?: string, callback?: any, target?: any);
            /**
            * &amp;lt;static&amp;gt;
{cc.MenuItemAtlasFont}
cc.MenuItemAtlasFont.create(value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target)
create menu item from string with font
Parameters:
{String} value
the text to display
{String} charMapFile
the character map file
{Number} itemWidth
{Number} itemHeight
{String} startCharMap
a single character
{function|String|Null} callback
Optional, Default: null
{cc.Node|Null} target
Optional
Deprecated:
since v3.0 ,please use new cc.MenuItemAtlasFont() instead.
Returns:
{cc.MenuItemAtlasFont}

            */
            static create(value?: string, charMapFile?: string, itemWidth?: number, itemHeight?: number, startCharMap?: string, callback?: any, target?: any): cc.MenuItemAtlasFont;
            /**
            * ctor(value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target)
the contructor of cc.MenuItemAtlasFont
Parameters:
{String} value
{String} charMapFile
{Number} itemWidth
{Number} itemHeight
{String} startCharMap
a single character
{function|String|Null} callback
{cc.Node|Null} target

            */
            ctor(value?: string, charMapFile?: string, itemWidth?: number, itemHeight?: number, startCharMap?: string, callback?: any, target?: any);
            /**
            * {Boolean}
initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target)
initializes a cc.MenuItemAtlasFont with string
Parameters:
{String} value
{String} charMapFile
{Number} itemWidth
{Number} itemHeight
{String} startCharMap
a single character
{function|String|Null} callback
{cc.Node|Null} target
Returns:
{Boolean}

            */
            initWithString(value?: string, charMapFile?: string, itemWidth?: number, itemHeight?: number, startCharMap?: string, callback?: any, target?: any): boolean;
        }
    }
declare module cc {
        /**
        * 
Helper class that creates a CCMenuItemLabel class with a Label

        */
        export class MenuItemFont extends cc.MenuItemLabel {
            /**
            * Helper class that creates a CCMenuItemLabel class with a Label
            */
            constructor(value?: string, callback?: any, target?: cc.Node);
            /**
            * - Font name of font item
            */
            fontName: string;
            /**
            * - Font size of font item
            */
            fontSize: number;
            /**
            * &amp;lt;static&amp;gt;
{cc.MenuItemFont}
cc.MenuItemFont.create(value, callback, target)
create a menu item from string
Parameters:
{String} value
the text to display
{String|function|Null} callback
the callback to run, either in function name or pass in the actual function
{cc.Node|Null} target
the target to run callback
Deprecated:
since v3.0, please use new construction instead
Returns:
{cc.MenuItemFont}

            */
            static create(value?: string, callback?: any, target?: any): cc.MenuItemFont;
            /**
            * ctor(value, callback, target)
Constructor of cc.MenuItemFont
Parameters:
{String} value
text for the menu item
{function|String} callback
{cc.Node} target

            */
            ctor(value?: string, callback?: any, target?: cc.Node);
            /**
            * &amp;lt;static&amp;gt;
{String}
cc.MenuItemFont.fontName()
a shared function to get the font name for menuitem font
Returns:
{String}

            */
            static fontName(): string;
            /**
            * &amp;lt;static&amp;gt;
{Number}
cc.MenuItemFont.fontSize()
a shared function to get the font size for menuitem font
Returns:
{Number}

            */
            static fontSize(): number;
            /**
            * {String}
getFontName()
return the font name for cc.MenuItemFont
Returns:
{String}

            */
            getFontName(): string;
            /**
            * {Number}
getFontSize()
return the font size of cc.MenuItemFont
Returns:
{Number}

            */
            getFontSize(): number;
            /**
            * {Boolean}
initWithString(value, callback, target)
initializes cc.MenuItemFont with  string
Parameters:
{String} value
text for the menu item
{function|String} callback
{cc.Node} target
Returns:
{Boolean}

            */
            initWithString(value?: string, callback?: any, target?: cc.Node): boolean;
            /**
            * setFontName(name)
set the font name for cc.MenuItemFont
Parameters:
{String} name

            */
            setFontName(name?: string);
            /**
            * &amp;lt;static&amp;gt;
cc.MenuItemFont.setFontName(name)
a shared function to set the fontsize for menuitem font
Parameters:
name

            */
            static setFontName();
            /**
            * &amp;lt;static&amp;gt;
cc.MenuItemFont.setFontSize(fontSize)
a shared function to set the fontSize for menuitem font
Parameters:
{Number} fontSize

            */
            static setFontSize(fontSize?: number);
            /**
            * setFontSize(s)
set the font size for cc.MenuItemFont
Parameters:
{Number} s

            */
            setFontSize(s?: number);
        }
    }
declare module cc {
        /**
        * 
cc.MenuItemImage accepts images as items.
The images has 3 different states:
- unselected image
- selected image
- disabled image

For best results try that all images are of the same size

        */
        export class MenuItemImage extends cc.MenuItemSprite {
            /**
            * cc.MenuItemImage accepts images as items.
            */
            constructor(normalImage?: any, selectedImage?: any, disabledImage?: any, callback?: any, target?: any);
            /**
            * &amp;lt;static&amp;gt;
{cc.MenuItemImage}
cc.MenuItemImage.create(normalImage, selectedImage, three, four, five)
creates a new menu item image
Parameters:
{String} normalImage
file name for normal state
{String} selectedImage
image for selected state
{String|cc.Node} three
Disabled image OR callback function
{String|function|Null} four
Optional
callback function, either name in string or pass the whole function OR the target
{cc.Node|String|function|Null} five
Optional
cc.Node target to run callback when clicked
Deprecated:
since v3.0, please use new cc.MenuItemImage(normalImage, selectedImage, three, four, five) instead.
Returns:
{cc.MenuItemImage}

            */
            static create(normalImage?: string, selectedImage?: string, three?: any, four?: any, five?: any): cc.MenuItemImage;
            /**
            * ctor(normalImage, selectedImage, disabledImage, callback, target)
Constructor of cc.MenuItemImage
Parameters:
{string|null} normalImage
{string|null} selectedImage
{string|null} disabledImage
{function|string|null} callback
{cc.Node|null} target

            */
            ctor(normalImage?: any, selectedImage?: any, disabledImage?: any, callback?: any, target?: any);
            /**
            * {boolean}
initWithNormalImage(normalImage, selectedImage, disabledImage, callback, target)
initializes a cc.MenuItemImage
Parameters:
{string|null} normalImage
{string|null} selectedImage
{string|null} disabledImage
{function|string|null} callback
{cc.Node|null} target
Returns:
{boolean}

            */
            initWithNormalImage(normalImage?: any, selectedImage?: any, disabledImage?: any, callback?: any, target?: any): boolean;
            /**
            * setDisabledSpriteFrame(frame)
sets the sprite frame for the disabled image
Parameters:
{cc.SpriteFrame} frame

            */
            setDisabledSpriteFrame(frame?: cc.SpriteFrame);
            /**
            * setNormalSpriteFrame(frame)
sets the sprite frame for the normal image
Parameters:
{cc.SpriteFrame} frame

            */
            setNormalSpriteFrame(frame?: cc.SpriteFrame);
            /**
            * setSelectedSpriteFrame(frame)
sets the sprite frame for the selected image
Parameters:
{cc.SpriteFrame} frame

            */
            setSelectedSpriteFrame(frame?: cc.SpriteFrame);
        }
    }
declare module cc {
        /**
        * 
Any cc.Node that supports the cc.LabelProtocol protocol can be added.
Supported nodes:
- cc.BitmapFontAtlas
- cc.LabelAtlas
- cc.LabelTTF

        */
        export class MenuItemLabel extends cc.MenuItem {
            /**
            * Any cc.Node that supports the cc.LabelProtocol protocol can be added.
            */
            constructor(label?: cc.Node, selector?: any, target?: cc.Node);
            /**
            * - Color of label when it&#39;s disabled
            */
            disabledColor: cc.Color;
            /**
            * - Label of label item
            */
            label: cc.Node;
            /**
            * - Content string of label item
            */
            string: string;
            /**
            * activate()
activate the menu item

            */
            activate();
            /**
            * &amp;lt;static&amp;gt;
{cc.MenuItemLabel}
cc.MenuItemLabel.create(label, selector, target)
Parameters:
{cc.Node} label
{function|String|Null} selector
Optional
{cc.Node|Null} target
Optional
Deprecated:
since v3.0 ,please use new cc.MenuItemLabel(label,selector,target) instead
Returns:
{cc.MenuItemLabel}

            */
            static create(label?: cc.Node, selector?: any, target?: any): cc.MenuItemLabel;
            /**
            * ctor(label, selector, target)
Constructor of cc.MenuItemLabel
Parameters:
{cc.Node} label
{function|String} selector
{cc.Node} target

            */
            ctor(label?: cc.Node, selector?: any, target?: cc.Node);
            /**
            * {cc.Color}
getColor()
return the color of cc.MenuItemLabel
Returns:
{cc.Color}

            */
            getColor(): cc.Color;
            /**
            * {cc.Color}
getDisabledColor()
return the disable color for this cc.MenuItemLabel
Returns:
{cc.Color}

            */
            getDisabledColor(): cc.Color;
            /**
            * {cc.Node}
getLabel()
return label of cc.MenuItemLabel
Returns:
{cc.Node}

            */
            getLabel(): cc.Node;
            /**
            * {Number}
getOpacity()
return the opacity of cc.MenuItemLabel
Returns:
{Number}

            */
            getOpacity(): number;
            /**
            * {*|string|_p.string|ret.string|q.string|String}
getString()
return the string of cc.MenuItemLabel
Returns:
{*|string|_p.string|ret.string|q.string|String}

            */
            getString(): any;
            /**
            * {Boolean}
initWithLabel(label, selector, target)
initializes a cc.MenuItemLabel with a label
Parameters:
{cc.Node} label
{function|String} selector
{cc.Node} target
Returns:
{Boolean}

            */
            initWithLabel(label?: cc.Node, selector?: any, target?: cc.Node): boolean;
            /**
            * selected()
menu item is selected (runs callback)

            */
            selected();
            /**
            * setColor(color)
set the opacity for cc.MenuItemLabel
Parameters:
{cc.Color} color

            */
            setColor(color?: cc.Color);
            /**
            * setDisabledColor(color)
set the disable color for this cc.MenuItemLabel
Parameters:
{cc.Color} color

            */
            setDisabledColor(color?: cc.Color);
            /**
            * setEnabled(enabled)
set enable value to cc.MenuItemLabel
Parameters:
{Boolean} enabled

            */
            setEnabled(enabled?: boolean);
            /**
            * setLabel(label)
set a label for cc.MenuItemLabel
Parameters:
{cc.Node} label

            */
            setLabel(label?: cc.Node);
            /**
            * setOpacity(opacity)
set opacity for cc.MenuItemLabel
Parameters:
{Number} opacity
from 0-255

            */
            setOpacity(opacity?: number);
            /**
            * setString(label)
set the string for  cc.MenuItemLabel
Parameters:
{String} label

            */
            setString(label?: string);
            /**
            * unselected()
menu item goes back to unselected state

            */
            unselected();
        }
    }
declare module cc {
        /**
        * 
CCMenuItemSprite accepts CCNode objects as items.
The images has 3 different states:
- unselected image
- selected image
- disabled image

        */
        export class MenuItemSprite extends cc.MenuItem {
            /**
            * CCMenuItemSprite accepts CCNode objects as items.
            */
            constructor(normalSprite?: any, selectedSprite?: any, three?: any, four?: any, five?: any);
            /**
            * - Sprite in disabled state
            */
            disabledImage: cc.Sprite;
            /**
            * - Sprite in normal state
            */
            normalImage: cc.Sprite;
            /**
            * - Sprite in selected state
            */
            selectedImage: cc.Sprite;
            /**
            * &amp;lt;static&amp;gt;
{cc.MenuItemSprite}
cc.MenuItemSprite.create(normalSprite, selectedSprite, three, four, five)
create a menu item from sprite
Parameters:
{Image} normalSprite
normal state image
{Image|Null} selectedSprite
selected state image
{Image|cc.Node|Null} three
disabled state image OR target node
{String|function|cc.Node|Null} four
callback function name in string or actual function, OR target Node
{String|function|Null} five
callback function name in string or actual function
Deprecated:
since v3.0 please use new cc.MenuItemSprite(normalSprite, selectedSprite, three, four, five) instead
Returns:
{cc.MenuItemSprite}

            */
            static create(normalSprite?: any, selectedSprite?: any, three?: any, four?: any, five?: any): cc.MenuItemSprite;
            /**
            * ctor(normalSprite, selectedSprite, three, four, five)
Constructor of cc.MenuItemSprite
Parameters:
{Image|Null} normalSprite
normal state image
{Image|Null} selectedSprite
selected state image
{Image|cc.Node|Null} three
disabled state image OR target node
{String|function|cc.Node|Null} four
callback function name in string or actual function, OR target Node
{String|function|Null} five
callback function name in string or actual function

            */
            ctor(normalSprite?: any, selectedSprite?: any, three?: any, four?: any, five?: any);
            /**
            * {cc.Color}
getColor()
return the color of cc.MenuItemSprite
Returns:
{cc.Color}

            */
            getColor(): cc.Color;
            /**
            * {cc.Sprite}
getDisabledImage()
return the disabled status of cc.MenuItemSprite
Returns:
{cc.Sprite}

            */
            getDisabledImage(): cc.Sprite;
            /**
            * {cc.Sprite}
getNormalImage()
return the normal status image(cc.Sprite)
Returns:
{cc.Sprite}

            */
            getNormalImage(): cc.Sprite;
            /**
            * {Number}
getOpacity()
return the opacity of cc.MenuItemSprite
Returns:
{Number} opacity from 0 - 255

            */
            getOpacity(): number;
            /**
            * {cc.Sprite}
getSelectedImage()
return the selected status image(cc.Sprite) of cc.MenuItemSprite
Returns:
{cc.Sprite}

            */
            getSelectedImage(): cc.Sprite;
            /**
            * {Boolean}
initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, callback, target)
initializes cc.MenuItemSprite with a cc.Sprite
Parameters:
{cc.Node} normalSprite
{cc.Node} selectedSprite
{cc.Node} disabledSprite
{function|String} callback
{cc.Node} target
Returns:
{Boolean}

            */
            initWithNormalSprite(normalSprite?: cc.Node, selectedSprite?: cc.Node, disabledSprite?: cc.Node, callback?: any, target?: cc.Node): boolean;
            /**
            * selected()
menu item is selected (runs callback)

            */
            selected();
            /**
            * setColor(color)
set the color for cc.MenuItemSprite
Parameters:
{cc.Color} color

            */
            setColor(color?: cc.Color);
            /**
            * setDisabledImage(disabledImage)
set the disabled status image(cc.Sprite)
Parameters:
{cc.Sprite} disabledImage

            */
            setDisabledImage(disabledImage?: cc.Sprite);
            /**
            * setEnabled(bEnabled)
set cc.MenuItemSprite  enable to receive the touch event
Parameters:
{Boolean} bEnabled

            */
            setEnabled(bEnabled?: boolean);
            /**
            * setNormalImage(normalImage)
set the normal status image(cc.Sprite)
Parameters:
{cc.Sprite} normalImage

            */
            setNormalImage(normalImage?: cc.Sprite);
            /**
            * setOpacity(opacity)
set the opacity for cc.MenuItemSprite
Parameters:
{Number} opacity
0 - 255

            */
            setOpacity(opacity?: number);
            /**
            * setSelectedImage(selectedImage)
set the selected status image(cc.Sprite)
Parameters:
{cc.Sprite} selectedImage

            */
            setSelectedImage(selectedImage?: cc.Sprite);
            /**
            * unselected()
menu item goes back to unselected state

            */
            unselected();
        }
    }
declare module cc {
        /**
        * 
A simple container class that &quot;toggles&quot; it&#39;s inner items
The inner items can be any MenuItem

        */
        export class MenuItemToggle extends cc.MenuItem {
            /**
            * A simple container class that &quot;toggles&quot; it&#39;s inner items
The inner items can be any MenuItem
            */
            constructor();
            /**
            * - Index of selected sub item
            */
            selectedIndex: number;
            /**
            * - Sub items
            */
            subItems: Array<any>;
            /**
            * activate()
activate the menu item

            */
            activate();
            /**
            * addSubItem(item)
add the subitem for cc.MenuItemToggle
Parameters:
{cc.MenuItem} item

            */
            addSubItem(item?: cc.MenuItem);
            /**
            * &amp;lt;static&amp;gt;
{cc.MenuItemToggle}
cc.MenuItemToggle.create()
create a simple container class that &quot;toggles&quot; it&#39;s inner items
The inner items can be any MenuItem
Deprecated:
since v3.0 please use new cc.MenuItemToggle(params) instead
Returns:
{cc.MenuItemToggle}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.MenuItemToggle;
            /**
            * ctor()
Constructor of cc.MenuItemToggle

            */
            ctor();
            /**
            * {cc.Color}
getColor()
return the color of cc.MenuItemToggle
Returns:
{cc.Color}

            */
            getColor(): cc.Color;
            /**
            * {Number}
getOpacity()
return the opacity of cc.MenuItemToggle
Returns:
{Number}

            */
            getOpacity(): number;
            /**
            * {Number}
getSelectedIndex()
return the index of selected
Returns:
{Number}

            */
            getSelectedIndex(): number;
            /**
            * {Array}
getSubItems()
similar to get children,return the sumItem array.
Returns:
{Array}

            */
            getSubItems(): Array<any>;
            /**
            * {Boolean}
initWithItems(args[last-1], args[last])
initializes a cc.MenuItemToggle with items
Parameters:
{cc.MenuItem} args[0...last-2]
the rest in the array are cc.MenuItems
{function|String} args[last-1]
the second item in the args array is the callback
{cc.Node} args[last]
the first item in the args array is a target
Returns:
{Boolean}

            */
            initWithItems(args?, args_last?): boolean;
            /**
            * onEnter()
*
Event callback that is invoked every time when cc.MenuItemToggle enters the &#39;stage&#39;.
If the cc.MenuItemToggle enters the &#39;stage&#39; with a transition, this event is called when the transition starts.
During onEnter you can&#39;t access a &quot;sister/brother&quot; node.
If you override onEnter, you must call its parent&#39;s onEnter function with this._super().

            */
            onEnter();
            /**
            * selected()
menu item is selected (runs callback)

            */
            selected();
            /**
            * {cc.MenuItem}
selectedItem()
returns the selected item
Returns:
{cc.MenuItem}

            */
            selectedItem(): cc.MenuItem;
            /**
            * setColor(Color)
set the color for cc.MenuItemToggle
Parameters:
{cc.Color} Color

            */
            setColor(Color?: cc.Color);
            /**
            * setEnabled(enabled)
set the enable status for cc.MenuItemToggle
Parameters:
{Boolean} enabled

            */
            setEnabled(enabled?: boolean);
            /**
            * setOpacity(opacity)
set the opacity for cc.MenuItemToggle
Parameters:
{Number} opacity

            */
            setOpacity(opacity?: number);
            /**
            * setSelectedIndex(SelectedIndex)
set the seleceted index for cc.MenuItemToggle
Parameters:
{Number} SelectedIndex

            */
            setSelectedIndex(SelectedIndex?: number);
            /**
            * setSubItems(subItems)
set the subitem for cc.MenuItemToggle
Parameters:
{cc.MenuItem} subItems

            */
            setSubItems(subItems?: cc.MenuItem);
            /**
            * unselected()
menu item goes back to unselected state

            */
            unselected();
        }
    }
declare module cc {
        /**
        * 
MenuPassive: The menu passive ui component

        */
        export class MenuPassive extends cc.Layer {
            /**
            * MenuPassive: The menu passive ui component
            */
            constructor();
            /**
            * alignItemsHorizontally()
align items horizontally

            */
            alignItemsHorizontally();
            /**
            * alignItemsHorizontallyWithPadding(padding)
align items horizontally with padding
Parameters:
padding
Since:
v0.7.2

            */
            alignItemsHorizontallyWithPadding();
            /**
            * alignItemsInColumns(columns)
align items in rows of columns
Parameters:
columns

            */
            alignItemsInColumns();
            /**
            * alignItemsInRows(rows)
align items in columns of rows
Parameters:
rows

            */
            alignItemsInRows();
            /**
            * alignItemsVertically()
align items vertically

            */
            alignItemsVertically();
            /**
            * alignItemsVerticallyWithPadding(padding)
align items vertically with padding
Parameters:
padding
Since:
v0.7.2

            */
            alignItemsVerticallyWithPadding();
            /**
            * &amp;lt;static&amp;gt;
cc.MenuPassive.create(item)
creates an empty CCMenu
Parameters:
item

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): MenuPassive;
            /**
            * &amp;lt;static&amp;gt;
cc.MenuPassive.createWithItem(item)
creates a CCMenu with it&#39;s item, then use addChild() to add
other items. It is used for script, it can&#39;t init with undetermined
number of variables.
Parameters:
item

            */
            static createWithItem();
            /**
            * getColor()
Color: conforms with CCRGBAProtocol protocol

            */
            getColor();
            /**
            * getOpacity()
Opacity: conforms with CCRGBAProtocol protocol

            */
            getOpacity();
            /**
            * initWithItems(item, args)
initializes a CCMenu with it&#39;s items
Parameters:
item
args

            */
            initWithItems();
        }
    }
declare module cc {
        /**
        * 
cc.MotionStreak manages a Ribbon based on it&#39;s motion in absolute space.
You construct it with a fadeTime, minimum segment size, texture path, texture
length and color. The fadeTime controls how long it takes each vertex in
the streak to fade out, the minimum segment size it how many pixels the
streak will move before adding a new ribbon segment, and the texture
length is the how many pixels the texture is stretched across. The texture
is vertically aligned along the streak segment.

        */
        export class MotionStreak extends cc.Node {
            /**
            * cc.MotionStreak manages a Ribbon based on it&#39;s motion in absolute space.
            */
            constructor();
            /**
            * - Indicate whether use fast mode.
            */
            fastMode: boolean;
            /**
            * - Indicate whether starting position initialized.
            */
            startingPositionInitialized: boolean;
            /**
            * - Texture used for the motion streak.
            */
            texture: cc.Texture2D;
            /**
            * &amp;lt;static&amp;gt;
{cc.MotionStreak}
cc.MotionStreak.create(fade, minSeg, stroke, color, texture)
Please use new cc.MotionStreak instead.
Creates and initializes a motion streak with fade in seconds, minimum segments, stroke&#39;s width, color, texture filename or texture
//example
new cc.MotionStreak(2, 3, 32, cc.color.GREEN, s_streak);
Parameters:
{Number} fade
time to fade
{Number} minSeg
minimum segment size
{Number} stroke
stroke&#39;s width
{Number} color
{string|cc.Texture2D} texture
texture filename or texture
Deprecated:
since v3.0 please use new cc.MotionStreak instead.
Returns:
{cc.MotionStreak}

            */
            static create(fade?: number, minSeg?: number, stroke?: number, color?: number, texture?: any): cc.MotionStreak;
            /**
            * ctor(fade, minSeg, stroke, color, texture)
creates and initializes a motion streak with fade in seconds, minimum segments, stroke&#39;s width, color, texture filename or texture
Constructor of cc.MotionStreak
Parameters:
{Number} fade
time to fade
{Number} minSeg
minimum segment size
{Number} stroke
stroke&#39;s width
{Number} color
{string|cc.Texture2D} texture
texture filename or texture

            */
            ctor(fade?: number, minSeg?: number, stroke?: number, color?: number, texture?: any);
            /**
            * {cc.BlendFunc}
getBlendFunc()
Gets the blend func.
Returns:
{cc.BlendFunc}

            */
            getBlendFunc(): cc.BlendFunc;
            /**
            * {number}
getOpacity()
Gets opacity.
Returns:
{number}

            */
            getOpacity(): number;
            /**
            * {Number}
getPositionX()
Gets the position.x
Returns:
{Number}

            */
            getPositionX(): number;
            /**
            * {Number}
getPositionY()
Gets the position.y
Returns:
{Number}

            */
            getPositionY(): number;
            /**
            * {cc.Texture2D}
getTexture()
Gets the texture.
Returns:
{cc.Texture2D}

            */
            getTexture(): cc.Texture2D;
            /**
            * {Boolean}
initWithFade(fade, minSeg, stroke, color, texture)
initializes a motion streak with fade in seconds, minimum segments, stroke&#39;s width, color and texture filename or texture
Parameters:
{Number} fade
time to fade
{Number} minSeg
minimum segment size
{Number} stroke
stroke&#39;s width
{Number} color
{string|cc.Texture2D} texture
texture filename or texture
Returns:
{Boolean}

            */
            initWithFade(fade?: number, minSeg?: number, stroke?: number, color?: number, texture?: any): boolean;
            /**
            * {boolean}
isFastMode()
Checking fast mode.
Returns:
{boolean}

            */
            isFastMode(): boolean;
            /**
            * {boolean}
isOpacityModifyRGB()
Checking OpacityModifyRGB.
Returns:
{boolean}

            */
            isOpacityModifyRGB(): boolean;
            /**
            * {boolean}
isStartingPositionInitialized()
Checking starting position initialized.
Returns:
{boolean}

            */
            isStartingPositionInitialized(): boolean;
            /**
            * reset()
Remove all living segments of the ribbon

            */
            reset();
            /**
            * setBlendFunc(src, dst)
Set the blend func.
Parameters:
{Number} src
{Number} dst

            */
            setBlendFunc(src?: number, dst?: number);
            /**
            * setFastMode(fastMode)
set fast mode
Parameters:
{Boolean} fastMode

            */
            setFastMode(fastMode?: boolean);
            /**
            * setOpacity(opacity)
Set opacity.
Parameters:
opacity

            */
            setOpacity();
            /**
            * setOpacityModifyRGB(value)
set opacity modify RGB.
Parameters:
value

            */
            setOpacityModifyRGB();
            /**
            * setPosition(position, yValue)
Set the position.
Parameters:
{cc.Point|Number} position
{Number} yValue
Optional, Default: undefined
If not exists, the first parameter must be cc.Point.

            */
            setPosition(position?: any, yValue?: number);
            /**
            * setPositionX(x)
Set the position.x
Parameters:
{Number} x

            */
            setPositionX(x?: number);
            /**
            * setPositionY(y)
Set the position.y
Parameters:
{Number} y

            */
            setPositionY(y?: number);
            /**
            * setStartingPositionInitialized(startingPositionInitialized)
Set Starting Position Initialized.
Parameters:
{Boolean} startingPositionInitialized

            */
            setStartingPositionInitialized(startingPositionInitialized?: boolean);
            /**
            * setTexture(texture)
Set the texture.
Parameters:
{cc.Texture2D} texture

            */
            setTexture(texture?: cc.Texture2D);
            /**
            * tintWithColor(color)
color used for the tint
Parameters:
{cc.Color} color

            */
            tintWithColor(color?: cc.Color);
            /**
            * update(delta)
schedules the &quot;update&quot; method.
It will use the order number 0. This method will be called every frame.
Scheduled methods with a lower order value will be called before the ones that have a higher order value.
Only one &quot;update&quot; method could be scheduled per node.
Parameters:
{Number} delta

            */
            update(delta?: number);
        }
    }
declare module cc {
        /**
        * Moves a CCNode object x,y pixels by modifying it&#39;s position attribute.
x and y are relative to the position of the object.
Several CCMoveBy actions can be concurrently called, and the resulting
movement will be the sum of individual movements.

        */
        export class MoveBy extends cc.ActionInterval {
            /**
            * 
Moves a CCNode object x,y pixels by modifying it&#39;s position attribute.
            */
            constructor(duration?: number, deltaPos?: any, deltaY?: number);
            /**
            * Please use cc.moveBy instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.MoveBy;
            /**
            * {cc.MoveBy}
clone()
returns a new clone of the action
Returns:
{cc.MoveBy}

            */
            clone(): cc.MoveBy;
            /**
            * ctor(duration, deltaPos, deltaY)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
duration in seconds
{cc.Point|Number} deltaPos
{Number} deltaY
Optional

            */
            ctor(duration?: number, deltaPos?: any, deltaY?: number);
            /**
            * {Boolean}
initWithDuration(duration, position, y)
Initializes the action.
Parameters:
{Number} duration
duration in seconds
{cc.Point} position
{Number} y
Optional
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, position?: cc.Point, y?: number): boolean;
            /**
            * {cc.MoveBy}
reverse()
MoveTo reverse is not implemented
Returns:
{cc.MoveBy}

            */
            reverse(): cc.MoveBy;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Moves a CCNode object to the position x,y. x and y are absolute coordinates by modifying it&#39;s position attribute.
Several CCMoveTo actions can be concurrently called, and the resulting
movement will be the sum of individual movements.

        */
        export class MoveTo extends cc.MoveBy {
            /**
            * Moves a CCNode object to the position x,y.
            */
            constructor(duration?: number, position?: any, y?: number);
            /**
            * Please use cc.moveTo instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.MoveBy;
            /**
            * {cc.MoveTo}
clone()
returns a new clone of the action
Returns:
{cc.MoveTo}

            */
            clone(): cc.MoveTo;
            /**
            * ctor(duration, position, y)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
duration in seconds
{cc.Point|Number} position
{Number} y

            */
            ctor(duration?: number, position?: any, y?: number);
            /**
            * {Boolean}
initWithDuration(duration, position, y)
Initializes the action.
Parameters:
{Number} duration
duration in seconds
{cc.Point} position
{Number} y
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, position?: cc.Point, y?: number): boolean;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
        }
    }
declare module cc {
        /**
        * 
cc.Node is the root class of all node. Anything that gets drawn or contains things that get drawn is a cc.Node.
The most popular cc.Nodes are: cc.Scene, cc.Layer, cc.Sprite, cc.Menu.

The main features of a cc.Node are:
- They can contain other cc.Node nodes (addChild, getChildByTag, removeChild, etc)
- They can schedule periodic callback (schedule, unschedule, etc)
- They can execute actions (runAction, stopAction, etc)

Some cc.Node nodes provide extra functionality for them or their children.

Subclassing a cc.Node usually means (one/all) of:
- overriding constructor function &quot;ctor&quot; to initialize resources and schedule callbacks
- create callbacks to handle the advancement of time

Features of cc.Node:
- position
- scale (x, y)
- rotation (in degrees, clockwise)
- anchor point
- size
- color
- opacity
- visible
- z-order
- WebGL z position

Default values:
- rotation: 0
- position: (x=0,y=0)
- scale: (x=1,y=1)
- contentSize: (x=0,y=0)
- anchorPoint: (x=0,y=0)
- color: (r=255,g=255,b=255)
- opacity: 255

Limitations:
- A cc.Node is a &quot;void&quot; object. It doesn&#39;t have a texture

Order in transformations with grid disabled
-# The node will be translated (position)
-# The node will be rotated (rotation)
-# The node will be scaled (scale)

Order in transformations with grid enabled
-# The node will be translated (position)
-# The node will be rotated (rotation)
-# The node will be scaled (scale)
-# The grid will capture the screen
-# The node will be moved according to the camera values (camera)
-# The grid will render the captured screen

        */
        export class Node extends cc.Class {
            /**
            * cc.Node is the root class of all node.
            */
            constructor();
            /**
            * - The CCActionManager object that is used by all actions.
            */
            actionManager: cc.ActionManager;
            /**
            * - Anchor point&#39;s position on x axis
            */
            anchorX: number;
            /**
            * - Anchor point&#39;s position on y axis
            */
            anchorY: number;
            /**
            * - The arrival order, indicates which children is added previously
            */
            arrivalOrder: number;
            /**
            * - Indicate whether node&#39;s color value affect its child nodes, default value is false
            */
            cascadeColor: boolean;
            /**
            * - Indicate whether node&#39;s opacity value affect its child nodes, default value is false
            */
            cascadeOpacity: boolean;
            /**
            * -  All children nodes
            */
            children: Array<any>;
            /**
            * -  Number of children
            */
            childrenCount: number;
            /**
            * - Color of node, default value is white: (255, 255, 255)
            */
            color: cc.Color;
            /**
            * - The state of OpenGL server side
            */
            glServerState: number;
            /**
            * - grid object that is used when applying effects
            */
            grid: cc.GridBase;
            /**
            * - Height of node
            */
            height: number;
            /**
            * - Indicate whether ignore the anchor point property for positioning
            */
            ignoreAnchor: boolean;
            /**
            * - Opacity of node, default value is 255
            */
            opacity: number;
            /**
            * - Indicate whether opacity affect the color value, default value is false
            */
            opacityModifyRGB: boolean;
            /**
            * - Parent node
            */
            parent: cc.Node;
            /**
            * - Rotation of node
            */
            rotation: number;
            /**
            * - Rotation on x axis
            */
            rotationX: number;
            /**
            * - Rotation on y axis
            */
            rotationY: number;
            /**
            * -  Indicate whether node is running or not
            */
            running: boolean;
            /**
            * - Scale of node
            */
            scale: number;
            /**
            * - Scale on x axis
            */
            scaleX: number;
            /**
            * - Scale on y axis
            */
            scaleY: number;
            /**
            * - cc.Scheduler used to schedule all &quot;updates&quot; and timers.
            */
            scheduler: cc.Scheduler;
            /**
            * - The shader program currently used for this node
            */
            shaderProgram: cc.GLProgram;
            /**
            * - Skew x
            */
            skewX: number;
            /**
            * - Skew y
            */
            skewY: number;
            /**
            * - Tag of node
            */
            tag: number;
            /**
            * - Custom user data
            */
            userData: Object;
            /**
            * - User assigned CCObject, similar to userData, but instead of holding a void* it holds an id
            */
            userObject: Object;
            /**
            * - WebGL Z vertex of this node, z order works OK if all the nodes uses the same openGL Z vertex
            */
            vertexZ: number;
            /**
            * - Indicate whether node is visible or not
            */
            visible: boolean;
            /**
            * - Width of node
            */
            width: number;
            /**
            * - x axis position of node
            */
            x: number;
            /**
            * - y axis position of node
            */
            y: number;
            /**
            * - Z order in depth which stands for the drawing order
            */
            zIndex: number;
            /**
            * addChild(child, localZOrder, tag)
&quot;add&quot; logic MUST only be in this method

If the child is added to a &#39;running&#39; node, then &#39;onEnter&#39; and &#39;onEnterTransitionDidFinish&#39; will be called immediately.
Parameters:
{cc.Node} child
A child node
{Number} localZOrder
Optional
Z order for drawing priority. Please refer to setZOrder(int)
{Number} tag
Optional
A integer to identify the node easily. Please refer to setTag(int)

            */
            addChild(child?: cc.Node, localZOrder?: number, tag?: number);
            /**
            * addComponent(component)
Adds a component to the node&#39;s component container.
Parameters:
{cc.Component} component

            */
            addComponent(component?: cc.Component);
            /**
            * attr(attrs)
Properties configuration function
All properties in attrs will be set to the node,
when the setter of the node is available,
the property will be set via setter function.
Parameters:
{Object} attrs
Properties to be set to node

            */
            attr(attrs?: Object);
            /**
            * {cc.Rect}
boundingBox()
Returns a &quot;local&quot; axis aligned bounding box of the node.
Deprecated:
since v3.0, please use getBoundingBox instead
Returns:
{cc.Rect}

            */
            boundingBox(): cc.Rect;
            /**
            * cleanup()
Stops all running actions and schedulers

            */
            cleanup();
            /**
            * {cc.Point}
convertToNodeSpace(worldPoint)
Converts a Point to node (local) space coordinates. The result is in Points.
Parameters:
{cc.Point} worldPoint
Returns:
{cc.Point}

            */
            convertToNodeSpace(worldPoint?: cc.Point): cc.Point;
            /**
            * {cc.Point}
convertToNodeSpaceAR(worldPoint)
Converts a Point to node (local) space coordinates. The result is in Points.
treating the returned/received node point as anchor relative.
Parameters:
{cc.Point} worldPoint
Returns:
{cc.Point}

            */
            convertToNodeSpaceAR(worldPoint?: cc.Point): cc.Point;
            /**
            * {cc.Point}
convertTouchToNodeSpace(touch)
convenience methods which take a cc.Touch instead of cc.Point
Parameters:
{cc.Touch} touch
The touch object
Returns:
{cc.Point}

            */
            convertTouchToNodeSpace(touch?: cc.Touch): cc.Point;
            /**
            * {cc.Point}
convertTouchToNodeSpaceAR(touch)
converts a cc.Touch (world coordinates) into a local coordinate. This method is AR (Anchor Relative).
Parameters:
{cc.Touch} touch
The touch object
Returns:
{cc.Point}

            */
            convertTouchToNodeSpaceAR(touch?: cc.Touch): cc.Point;
            /**
            * {cc.Point}
convertToWorldSpace(nodePoint)
Converts a Point to world space coordinates. The result is in Points.
Parameters:
{cc.Point} nodePoint
Returns:
{cc.Point}

            */
            convertToWorldSpace(nodePoint?: cc.Point): cc.Point;
            /**
            * {cc.Point}
convertToWorldSpaceAR(nodePoint)
Converts a local Point to world space coordinates.The result is in Points.
treating the returned/received node point as anchor relative.
Parameters:
{cc.Point} nodePoint
Returns:
{cc.Point}

            */
            convertToWorldSpaceAR(nodePoint?: cc.Point): cc.Point;
            /**
            * &amp;lt;static&amp;gt;
{cc.Node}
cc.Node.create()
Allocates and initializes a node.
Deprecated:
since v3.0, please use new construction instead.
Returns:
{cc.Node}
See:
cc.Node

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.Node;
            /**
            * ctor()
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * draw(ctx)
Render function using the canvas 2d context or WebGL context, internal usage only, please do not call this function
Parameters:
{CanvasRenderingContext2D | WebGLRenderingContext} ctx
The render context

            */
            draw(ctx?: any);
            /**
            * {cc.Action}
getActionByTag(tag)
Returns an action from the running action list by its tag.
Parameters:
{Number} tag
Returns:
{cc.Action} The action object with the given tag.
See:
cc.Node#getTag and cc.Node#setTag

            */
            getActionByTag(tag?: number): cc.Action;
            /**
            * {cc.ActionManager}
getActionManager()
Returns the CCActionManager object that is used by all actions.
(IMPORTANT: If you set a new cc.ActionManager, then previously created actions are going to be removed.)
Returns:
{cc.ActionManager} A CCActionManager object.
See:
cc.Node#setActionManager

            */
            getActionManager(): cc.ActionManager;
            /**
            * {cc.Point}
getAnchorPoint()
Returns a copy of the anchor point.
Anchor point is the point around which all transformations and positioning manipulations take place.
It&#39;s like a pin in the node where it is &quot;attached&quot; to its parent.
The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner.
But you can use values higher than (1,1) and lower than (0,0) too.
The default anchor point is (0.5,0.5), so it starts at the center of the node.
Returns:
{cc.Point} The anchor point of node.

            */
            getAnchorPoint(): cc.Point;
            /**
            * {cc.Point}
getAnchorPointInPoints()
Returns a copy of the anchor point in absolute pixels.
you can only read it. If you wish to modify it, use setAnchorPoint
Returns:
{cc.Point} The anchor point in absolute pixels.
See:
cc.Node#getAnchorPoint

            */
            getAnchorPointInPoints(): cc.Point;
            /**
            * {cc.Rect}
getBoundingBox()
Returns a &quot;local&quot; axis aligned bounding box of the node.
The returned box is relative only to its parent.
Returns:
{cc.Rect} The calculated bounding box of the node

            */
            getBoundingBox(): cc.Rect;
            /**
            * {cc.Rect}
getBoundingBoxToWorld()
Returns a &quot;world&quot; axis aligned bounding box of the node.
Returns:
{cc.Rect}

            */
            getBoundingBoxToWorld(): cc.Rect;
            /**
            * {cc.Camera}
getCamera()
Returns a camera object that lets you move the node using a gluLookAt
var camera = node.getCamera();
camera.setEye(0, 0, 415/2);
camera.setCenter(0, 0, 0);
Deprecated:
since v3.0, no alternative function
Returns:
{cc.Camera} A CCCamera object that lets you move the node using a gluLookAt

            */
            getCamera(): any;
            /**
            * {cc.Node}
getChildByName(name)
Returns a child from the container given its name
Parameters:
{String} name
A name to find the child node.
Returns:
{cc.Node} a CCNode object whose name equals to the input parameter

            */
            getChildByName(name?: string): cc.Node;
            /**
            * {cc.Node}
getChildByTag(aTag)
Returns a child from the container given its tag
Parameters:
{Number} aTag
An identifier to find the child node.
Returns:
{cc.Node} a CCNode object whose tag equals to the input parameter

            */
            getChildByTag(aTag?: number): cc.Node;
            /**
            * {Array}
getChildren()
Returns an array of all children
Composing a &quot;tree&quot; structure is a very important feature of CCNode
//This sample code traverses all children nodes, and set their position to (0,0)
var allChildren = parent.getChildren();
for(var i = 0; i
Returns:
{Array} An array of children

            */
            getChildren(): Array<any>;
            /**
            * {Number}
getChildrenCount()
Returns the amount of children.
Returns:
{Number} The amount of children.

            */
            getChildrenCount(): number;
            /**
            * {cc.Color}
getColor()
Returns the color of Node
Returns:
{cc.Color}

            */
            getColor(): cc.Color;
            /**
            * {cc.Component}
getComponent(name)
Returns a component identified by the name given.
Parameters:
{String} name
The name to search for
Returns:
{cc.Component} The component found

            */
            getComponent(name?: string): cc.Component;
            /**
            * {cc.Size}
getContentSize()
Returns a copy the untransformed size of the node.
The contentSize remains the same no matter the node is scaled or rotated.
All nodes has a size. Layer and Scene has the same size of the screen by default.
Returns:
{cc.Size} The untransformed size of the node.

            */
            getContentSize(): cc.Size;
            /**
            * {cc.Color}
getDisplayedColor()
Returns the displayed color of Node,
the difference between displayed color and color is that displayed color is calculated based on color and parent node&#39;s color when cascade color enabled.
Returns:
{cc.Color}

            */
            getDisplayedColor(): cc.Color;
            /**
            * {number}
getDisplayedOpacity()
Returns the displayed opacity of Node,
the difference between displayed opacity and opacity is that displayed opacity is calculated based on opacity and parent node&#39;s opacity when cascade opacity enabled.
Returns:
{number} displayed opacity

            */
            getDisplayedOpacity(): number;
            /**
            * {number}
getGlobalZOrder()
Return the Node&#39;s Global Z Order.
Returns:
{number} The node&#39;s global Z order

            */
            getGlobalZOrder(): number;
            /**
            * {Number}
getGLServerState()
Returns the state of OpenGL server side.
Deprecated:
since v3.0, no need anymore
Returns:
{Number} The state of OpenGL server side.

            */
            getGLServerState(): number;
            /**
            * {cc.GridBase}
getGrid()
Returns a grid object that is used when applying effects.
This function have been deprecated, please use cc.NodeGrid to run grid actions
Deprecated:
since v3.0, no alternative function
Returns:
{cc.GridBase} A CCGrid object that is used when applying effects

            */
            getGrid(): cc.GridBase;
            /**
            * {Number}
getLocalZOrder()
Returns the local Z order of this node.
Returns:
{Number} The local (relative to its siblings) Z order.

            */
            getLocalZOrder(): number;
            /**
            * {string}
getName()
Returns a string that is used to identify the node.
Returns:
{string} A string that identifies the node.

            */
            getName(): string;
            /**
            * {cc.AffineTransform}
getNodeToParentTransform()
Returns the matrix that transform the node&#39;s (local) space coordinates into the parent&#39;s space coordinates.
The matrix is in Pixels.
Returns:
{cc.AffineTransform} The affine transform object

            */
            getNodeToParentTransform(): cc.AffineTransform;
            /**
            * {cc.AffineTransform}
getNodeToWorldTransform()
Returns the world affine transform matrix. The matrix is in Pixels.
Returns:
{cc.AffineTransform}

            */
            getNodeToWorldTransform(): cc.AffineTransform;
            /**
            * {cc.Point}
getNormalizedPosition()
returns the normalized position
Returns:
{cc.Point}

            */
            getNormalizedPosition(): cc.Point;
            /**
            * {Number}
getNumberOfRunningActions()
Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays).
Composable actions are counted as 1 action. Example:
If you are running 1 Sequence of 7 actions, it will return 1.
If you are running 7 Sequences of 2 actions, it will return 7.
Returns:
{Number} The number of actions that are running plus the ones that are schedule to run

            */
            getNumberOfRunningActions(): number;
            /**
            * {number}
getOpacity()
Returns the opacity of Node
Returns:
{number} opacity

            */
            getOpacity(): number;
            /**
            * {Number}
getOrderOfArrival()
Returns the arrival order, indicates which children should be added previously.
Returns:
{Number} The arrival order.

            */
            getOrderOfArrival(): number;
            /**
            * {cc.Node}
getParent()
Returns a reference to the parent node
Returns:
{cc.Node} A reference to the parent node

            */
            getParent(): cc.Node;
            /**
            * {cc.AffineTransform}
getParentToNodeTransform()
Returns the matrix that transform parent&#39;s space coordinates to the node&#39;s (local) space coordinates.
The matrix is in Pixels.
Returns:
{cc.AffineTransform}

            */
            getParentToNodeTransform(): cc.AffineTransform;
            /**
            * {cc.Point}
getPosition()
Returns a copy of the position (x,y) of the node in cocos2d coordinates. (0,0) is the left-bottom corner.
Returns:
{cc.Point} The position (x,y) of the node in OpenGL coordinates

            */
            getPosition(): cc.Point;
            /**
            * {Number}
getPositionX()
Returns the x axis position of the node in cocos2d coordinates.
Returns:
{Number}

            */
            getPositionX(): number;
            /**
            * {Number}
getPositionY()
Returns the y axis position of the node in cocos2d coordinates.
Returns:
{Number}

            */
            getPositionY(): number;
            /**
            * {Number}
getRotation()
Returns the rotation (angle) of the node in degrees. 0 is the default rotation angle. Positive values rotate node clockwise.
Returns:
{Number} The rotation of the node in degrees.

            */
            getRotation(): number;
            /**
            * {Number}
getRotationX()
Returns the X axis rotation (angle) which represent a horizontal rotational skew of the node in degrees.
0 is the default rotation angle. Positive values rotate node clockwise
(support only in WebGL rendering mode)
Returns:
{Number} The X rotation in degrees.

            */
            getRotationX(): number;
            /**
            * {Number}
getRotationY()
Returns the Y axis rotation (angle) which represent a vertical rotational skew of the node in degrees.
0 is the default rotation angle. Positive values rotate node clockwise
(support only in WebGL rendering mode)
Returns:
{Number} The Y rotation in degrees.

            */
            getRotationY(): number;
            /**
            * {Number}
getScale()
Returns the scale factor of the node.
Returns:
{Number} The scale factor

            */
            getScale(): number;
            /**
            * {Number}
getScaleX()
Returns the scale factor on X axis of this node
Returns:
{Number} The scale factor on X axis.

            */
            getScaleX(): number;
            /**
            * {Number}
getScaleY()
Returns the scale factor on Y axis of this node
Returns:
{Number} The scale factor on Y axis.

            */
            getScaleY(): number;
            /**
            * {cc.Scheduler}
getScheduler()
Returns the cc.Scheduler object used to schedule all &quot;updates&quot; and timers.
Returns:
{cc.Scheduler} A CCScheduler object.

            */
            getScheduler(): cc.Scheduler;
            /**
            * {cc.GLProgram}
getShaderProgram()
Return the shader program currently used for this node
Returns:
{cc.GLProgram} The shader program currently used for this node

            */
            getShaderProgram(): cc.GLProgram;
            /**
            * {Number}
getSkewX()
Returns the skew degrees in X
The X skew angle of the node in degrees.
This angle describes the shear distortion in the X direction.
Thus, it is the angle between the Y axis and the left edge of the shape
The default skewX angle is 0. Positive values distort the node in a CW direction.
Returns:
{Number} The X skew angle of the node in degrees.

            */
            getSkewX(): number;
            /**
            * {Number}
getSkewY()
Returns the skew degrees in Y
The Y skew angle of the node in degrees.
This angle describes the shear distortion in the Y direction.
Thus, it is the angle between the X axis and the bottom edge of the shape
The default skewY angle is 0. Positive values distort the node in a CCW direction.
Returns:
{Number} The Y skew angle of the node in degrees.

            */
            getSkewY(): number;
            /**
            * {Number}
getTag()
Returns a tag that is used to identify the node easily.
//You can set tags to node then identify them easily.
// set tags
node1.setTag(TAG_PLAYER);
node2.setTag(TAG_MONSTER);
node3.setTag(TAG_BOSS);
parent.addChild(node1);
parent.addChild(node2);
parent.addChild(node3);
// identify by tags
var allChildren = parent.getChildren();
for(var i = 0; i
Returns:
{Number} An integer that identifies the node.

            */
            getTag(): number;
            /**
            * {object}
getUserData()
Returns a custom user data pointer
You can set everything in UserData pointer, a data block, a structure or an object.
Returns:
{object} A custom user data pointer

            */
            getUserData(): any;
            /**
            * {object}
getUserObject()
Returns a user assigned cocos2d object.
Similar to userData, but instead of holding all kinds of data it can only hold a cocos2d object
Returns:
{object} A user assigned CCObject

            */
            getUserObject(): any;
            /**
            * {Number}
getVertexZ()
Returns WebGL Z vertex of this node.
Returns:
{Number} WebGL Z vertex of this node

            */
            getVertexZ(): number;
            /**
            * {cc.AffineTransform}
getWorldToNodeTransform()
Returns the inverse world affine transform matrix. The matrix is in Pixels.
Returns:
{cc.AffineTransform}

            */
            getWorldToNodeTransform(): cc.AffineTransform;
            /**
            * {Number}
getZOrder()
Returns z order of this node
Deprecated:
since 3.0, please use getLocalZOrder instead
Returns:
{Number}

            */
            getZOrder(): number;
            /**
            * ignoreAnchorPointForPosition(newValue)
Sets whether the anchor point will be ignored when you position this node.
When anchor point ignored, position will be calculated based on the origin point (0, 0) in parent&#39;s coordinates.
This is an internal method, only used by CCLayer and CCScene. Don&#39;t call it outside framework.
The default value is false, while in CCLayer and CCScene are true
Parameters:
{Boolean} newValue
true if anchor point will be ignored when you position this node

            */
            ignoreAnchorPointForPosition(newValue?: boolean);
            /**
            * {boolean}
init()
Initializes the instance of cc.Node
Returns:
{boolean} Whether the initialization was successful.

            */
            init(): boolean;
            /**
            * {boolean}
isCascadeColorEnabled()
Returns whether node&#39;s color value affect its child nodes.
Returns:
{boolean}

            */
            isCascadeColorEnabled(): boolean;
            /**
            * {boolean}
isCascadeOpacityEnabled()
Returns whether node&#39;s opacity value affect its child nodes.
Returns:
{boolean}

            */
            isCascadeOpacityEnabled(): boolean;
            /**
            * {Boolean}
isIgnoreAnchorPointForPosition()
Returns whether the anchor point will be ignored when you position this node.
When anchor point ignored, position will be calculated based on the origin point (0, 0) in parent&#39;s coordinates.
Returns:
{Boolean} true if the anchor point will be ignored when you position this node.
See:
cc.Node#ignoreAnchorPointForPosition

            */
            isIgnoreAnchorPointForPosition(): boolean;
            /**
            * {Boolean}
isOpacityModifyRGB()
Get whether color should be changed with the opacity value
Returns:
{Boolean}

            */
            isOpacityModifyRGB(): boolean;
            /**
            * {Boolean}
isRunning()
Returns whether or not the node accepts event callbacks.
Running means the node accept event callbacks like onEnter(), onExit(), update()
Returns:
{Boolean} Whether or not the node is running.

            */
            isRunning(): boolean;
            /**
            * {Boolean}
isVisible()
Returns if the node is visible
Returns:
{Boolean} true if the node is visible, false if the node is hidden.
See:
cc.Node#setVisible

            */
            isVisible(): boolean;
            /**
            * {cc.AffineTransform}
nodeToParentTransform()
Returns the matrix that transform the node&#39;s (local) space coordinates into the parent&#39;s space coordinates.
The matrix is in Pixels.
Deprecated:
since v3.0, please use getNodeToParentTransform instead
Returns:
{cc.AffineTransform}

            */
            nodeToParentTransform(): cc.AffineTransform;
            /**
            * nodeToWorldTransform()
Deprecated:
since v3.0, please use getNodeToWorldTransform instead

            */
            nodeToWorldTransform();
            /**
            * onEnter()
Event callback that is invoked every time when CCNode enters the &#39;stage&#39;.
If the CCNode enters the &#39;stage&#39; with a transition, this event is called when the transition starts.
During onEnter you can&#39;t access a &quot;sister/brother&quot; node.
If you override onEnter, you must call its parent&#39;s onEnter function with this._super().

            */
            onEnter();
            /**
            * onEnterTransitionDidFinish()
Event callback that is invoked when the CCNode enters in the &#39;stage&#39;.
If the CCNode enters the &#39;stage&#39; with a transition, this event is called when the transition finishes.
If you override onEnterTransitionDidFinish, you shall call its parent&#39;s onEnterTransitionDidFinish with this._super()

            */
            onEnterTransitionDidFinish();
            /**
            * onExit()
callback that is called every time the cc.Node leaves the &#39;stage&#39;.
If the cc.Node leaves the &#39;stage&#39; with a transition, this callback is called when the transition finishes.
During onExit you can&#39;t access a sibling node.
If you override onExit, you shall call its parent&#39;s onExit with this._super().

            */
            onExit();
            /**
            * onExitTransitionDidStart()
callback that is called every time the cc.Node leaves the &#39;stage&#39;.
If the cc.Node leaves the &#39;stage&#39; with a transition, this callback is called when the transition starts.
If you override onExitTransitionDidStart, you shall call its parent&#39;s onExitTransitionDidStart with this._super()

            */
            onExitTransitionDidStart();
            /**
            * parentToNodeTransform()
Deprecated:
since v3.0, please use getParentToNodeTransform instead

            */
            parentToNodeTransform();
            /**
            * pause()
Pauses all scheduled selectors and actions.
This method is called internally by onExit

            */
            pause();
            /**
            * pauseSchedulerAndActions()
Pauses all scheduled selectors and actions.
This method is called internally by onExit
Deprecated:
since v3.0, please use pause instead

            */
            pauseSchedulerAndActions();
            /**
            * release()
Currently JavaScript Bindings (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
This is a hack, and should be removed once JSB fixes the retain/release bug
You will need to retain an object if you created an engine object and haven&#39;t added it into the scene graph during the same frame.
Otherwise, JSB&#39;s native autorelease pool will consider this object a useless one and release it directly,
when you want to use it later, a &quot;Invalid Native Object&quot; error will be raised.
The retain function can increase a reference count for the native object to avoid it being released,
you need to manually invoke release function when you think this object is no longer needed, otherwise, there will be memory learks.
retain and release function call should be paired in developer&#39;s game code.
See:
cc.Node#retain

            */
            release();
            /**
            * removeAllChildren(cleanup)
Removes all children from the container and do a cleanup all running actions depending on the cleanup parameter.
If the cleanup parameter is not passed, it will force a cleanup.
Parameters:
{Boolean} cleanup
Optional, Default: true
true if all running actions on all children nodes should be cleanup, false otherwise.

            */
            removeAllChildren(cleanup?: boolean);
            /**
            * removeAllChildrenWithCleanup(cleanup)
Removes all children from the container and do a cleanup all running actions depending on the cleanup parameter.
Parameters:
{Boolean} cleanup
Optional, Default: true

            */
            removeAllChildrenWithCleanup(cleanup?: boolean);
            /**
            * removeAllComponents()
Removes all components of cc.Node, it called when cc.Node is exiting from stage.

            */
            removeAllComponents();
            /**
            * removeChild(child, cleanup)
Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter.
If the cleanup parameter is not passed, it will force a cleanup.
&quot;remove&quot; logic MUST only be on this method
If a class wants to extend the &#39;removeChild&#39; behavior it only needs
to override this method
Parameters:
{cc.Node} child
The child node which will be removed.
{Boolean} cleanup
Optional, Default: true
true if all running actions and callbacks on the child node will be cleanup, false otherwise.

            */
            removeChild(child?: cc.Node, cleanup?: boolean);
            /**
            * removeChildByTag(tag, cleanup)
Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter.
If the cleanup parameter is not passed, it will force a cleanup.
Parameters:
{Number} tag
An integer number that identifies a child node
{Boolean} cleanup
Optional, Default: true
true if all running actions and callbacks on the child node will be cleanup, false otherwise.
See:
cc.Node#removeChildByTag

            */
            removeChildByTag(tag?: number, cleanup?: boolean);
            /**
            * removeComponent(component)
Removes a component identified by the given name or removes the component object given
Parameters:
{String|cc.Component} component

            */
            removeComponent(component?: any);
            /**
            * removeFromParent(cleanup)
Remove itself from its parent node. If cleanup is true, then also remove all actions and callbacks.
If the cleanup parameter is not passed, it will force a cleanup.
If the node orphan, then nothing happens.
Parameters:
{Boolean} cleanup
Optional, Default: true
true if all actions and callbacks on this node should be removed, false otherwise.
See:
cc.Node#removeFromParentAndCleanup

            */
            removeFromParent(cleanup?: boolean);
            /**
            * removeFromParentAndCleanup(cleanup)
Removes this node itself from its parent node.
If the node orphan, then nothing happens.
Parameters:
{Boolean} cleanup
Optional, Default: true
true if all actions and callbacks on this node should be removed, false otherwise.
Deprecated:
since v3.0, please use removeFromParent() instead

            */
            removeFromParentAndCleanup(cleanup?: boolean);
            /**
            * reorderChild(child, zOrder)
Reorders a child according to a new z value.
The child MUST be already added.
Parameters:
{cc.Node} child
An already added child node. It MUST be already added.
{Number} zOrder
Z order for drawing priority. Please refer to setZOrder(int)

            */
            reorderChild(child?: cc.Node, zOrder?: number);
            /**
            * resume()
Resumes all scheduled selectors and actions.
This method is called internally by onEnter

            */
            resume();
            /**
            * resumeSchedulerAndActions()
Resumes all scheduled selectors and actions.
This method is called internally by onEnter
Deprecated:
since v3.0, please use resume() instead

            */
            resumeSchedulerAndActions();
            /**
            * retain()
Currently JavaScript Bindings (JSB), in some cases, needs to use retain and release. This is a bug in JSB,
and the ugly workaround is to use retain/release. So, these 2 methods were added to be compatible with JSB.
This is a hack, and should be removed once JSB fixes the retain/release bug
You will need to retain an object if you created an engine object and haven&#39;t added it into the scene graph during the same frame.
Otherwise, JSB&#39;s native autorelease pool will consider this object a useless one and release it directly,
when you want to use it later, a &quot;Invalid Native Object&quot; error will be raised.
The retain function can increase a reference count for the native object to avoid it being released,
you need to manually invoke release function when you think this object is no longer needed, otherwise, there will be memory learks.
retain and release function call should be paired in developer&#39;s game code.
See:
cc.Node#release

            */
            retain();
            /**
            * {cc.Action}
runAction(action)
Executes an action, and returns the action that is executed.
The node becomes the action&#39;s target. Refer to cc.Action&#39;s getTarget()
Parameters:
{cc.Action} action
Returns:
{cc.Action} An Action pointer

            */
            runAction(action?: cc.Action): cc.Action;
            /**
            * schedule(callback_fn, interval, repeat, delay)
Schedules a custom selector.
If the selector is already scheduled, then the interval parameter will be updated without scheduling it again.
Parameters:
{function} callback_fn
A function wrapped as a selector
{Number} interval
Tick interval in seconds. 0 means tick every frame. If interval = 0, it&#39;s recommended to use scheduleUpdate() instead.
{Number} repeat
The selector will be executed (repeat + 1) times, you can use kCCRepeatForever for tick infinitely.
{Number} delay
The amount of time that the first tick will wait before execution.

            */
            schedule(callback_fn?: any, interval?: number, repeat?: number, delay?: number);
            /**
            * scheduleOnce(callback_fn, delay)
Schedules a callback function that runs only once, with a delay of 0 or larger
Parameters:
{function} callback_fn
A function wrapped as a selector
{Number} delay
The amount of time that the first tick will wait before execution.
See:
cc.Node#schedule

            */
            scheduleOnce(callback_fn?: any, delay?: number);
            /**
            * scheduleUpdate()
schedules the &quot;update&quot; method.
It will use the order number 0. This method will be called every frame.
Scheduled methods with a lower order value will be called before the ones that have a higher order value.
Only one &quot;update&quot; method could be scheduled per node.

            */
            scheduleUpdate();
            /**
            * scheduleUpdateWithPriority(priority)
schedules the &quot;update&quot; callback function with a custom priority.
This callback function will be called every frame.
Scheduled callback functions with a lower priority will be called before the ones that have a higher value.
Only one &quot;update&quot; callback function could be scheduled per node (You can&#39;t have 2 &#39;update&#39; callback functions).
Parameters:
{Number} priority

            */
            scheduleUpdateWithPriority(priority?: number);
            /**
            * setActionManager(actionManager)
Sets the cc.ActionManager object that is used by all actions.
Parameters:
{cc.ActionManager} actionManager
A CCActionManager object that is used by all actions.

            */
            setActionManager(actionManager?: cc.ActionManager);
            /**
            * setAdditionalTransform(additionalTransform)
Sets the additional transform.
The additional transform will be concatenated at the end of getNodeToParentTransform.
It could be used to simulate `parent-child` relationship between two nodes (e.g. one is in BatchNode, another isn&#39;t).
// create a batchNode
var batch = new cc.SpriteBatchNode(&quot;Icon-114.png&quot;);
this.addChild(batch);

// create two sprites, spriteA will be added to batchNode, they are using different textures.
var spriteA = new cc.Sprite(batch-&gt;getTexture());
var spriteB = new cc.Sprite(&quot;Icon-72.png&quot;);

batch.addChild(spriteA);

// We can&#39;t make spriteB as spriteA&#39;s child since they use different textures. So just add it to layer.
// But we want to simulate `parent-child` relationship for these two node.
this.addChild(spriteB);

//position
spriteA.setPosition(ccp(200, 200));

// Gets the spriteA&#39;s transform.
var t = spriteA.getNodeToParentTransform();

// Sets the additional transform to spriteB, spriteB&#39;s position will based on its pseudo parent i.e. spriteA.
spriteB.setAdditionalTransform(t);

//scale
spriteA.setScale(2);

// Gets the spriteA&#39;s transform.
t = spriteA.getNodeToParentTransform();

// Sets the additional transform to spriteB, spriteB&#39;s scale will based on its pseudo parent i.e. spriteA.
spriteB.setAdditionalTransform(t);

//rotation
spriteA.setRotation(20);

// Gets the spriteA&#39;s transform.
t = spriteA.getNodeToParentTransform();

// Sets the additional transform to spriteB, spriteB&#39;s rotation will based on its pseudo parent i.e. spriteA.
spriteB.setAdditionalTransform(t);
Parameters:
{cc.AffineTransform} additionalTransform
The additional transform

            */
            setAdditionalTransform(additionalTransform?: cc.AffineTransform);
            /**
            * setAnchorPoint(point, y)
Sets the anchor point in percent.
anchor point is the point around which all transformations and positioning manipulations take place.
It&#39;s like a pin in the node where it is &quot;attached&quot; to its parent.
The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner.
But you can use values higher than (1,1) and lower than (0,0) too.
The default anchor point is (0.5,0.5), so it starts at the center of the node.
Parameters:
{cc.Point|Number} point
The anchor point of node or The x axis anchor of node.
{Number} y
Optional
The y axis anchor of node.

            */
            setAnchorPoint(point?: any, y?: number);
            /**
            * setCascadeColorEnabled(cascadeColorEnabled)
Enable or disable cascade color, if cascade enabled, child nodes&#39; opacity will be the cascade value of parent color and its own color.
Parameters:
{boolean} cascadeColorEnabled

            */
            setCascadeColorEnabled(cascadeColorEnabled?: boolean);
            /**
            * setCascadeOpacityEnabled(cascadeOpacityEnabled)
Enable or disable cascade opacity, if cascade enabled, child nodes&#39; opacity will be the multiplication of parent opacity and its own opacity.
Parameters:
{boolean} cascadeOpacityEnabled

            */
            setCascadeOpacityEnabled(cascadeOpacityEnabled?: boolean);
            /**
            * setColor(color)
Sets the color of Node.
When color doesn&#39;t include opacity value like cc.color(128,128,128), this function only change the color.
When color include opacity like cc.color(128,128,128,100), then this function will change the color and the opacity.
Parameters:
{cc.Color} color
The new color given

            */
            setColor(color?: cc.Color);
            /**
            * setContentSize(size, height)
Sets the untransformed size of the node.
The contentSize remains the same no matter the node is scaled or rotated.
All nodes has a size. Layer and Scene has the same size of the screen.
Parameters:
{cc.Size|Number} size
The untransformed size of the node or The untransformed size&#39;s width of the node.
{Number} height
Optional
The untransformed size&#39;s height of the node.

            */
            setContentSize(size?: any, height?: number);
            /**
            * setGlobalZOrder(globalZOrder)
Defines the oder in which the nodes are renderer.
Nodes that have a Global Z Order lower, are renderer first.
In case two or more nodes have the same Global Z Order, the oder is not guaranteed.
The only exception if the Nodes have a Global Z Order == 0. In that case, the Scene Graph order is used.
By default, all nodes have a Global Z Order = 0. That means that by default, the Scene Graph order is used to render the nodes.
Global Z Order is useful when you need to render nodes in an order different than the Scene Graph order.
Limitations: Global Z Order can&#39;t be used used by Nodes that have SpriteBatchNode as one of their ancestors.
And if ClippingNode is one of the ancestors, then &quot;global Z order&quot; will be relative to the ClippingNode.
Parameters:
{Number} globalZOrder

            */
            setGlobalZOrder(globalZOrder?: number);
            /**
            * setGLServerState(state)
Sets the state of OpenGL server side.
Parameters:
{Number} state
The state of OpenGL server side.
Deprecated:
since v3.0, no need anymore

            */
            setGLServerState(state?: number);
            /**
            * setGrid(grid)
Changes a grid object that is used when applying effects
This function have been deprecated, please use cc.NodeGrid to run grid actions
Parameters:
{cc.GridBase} grid
A CCGrid object that is used when applying effects
Deprecated:
since v3.0, no alternative function

            */
            setGrid(grid?: cc.GridBase);
            /**
            * setLocalZOrder(localZOrder)
LocalZOrder is the &#39;key&#39; used to sort the node relative to its siblings.
The Node&#39;s parent will sort all its children based ont the LocalZOrder value.
If two nodes have the same LocalZOrder, then the node that was added first to the children&#39;s array
will be in front of the other node in the array.

Also, the Scene Graph is traversed using the &quot;In-Order&quot; tree traversal algorithm ( http://en.wikipedia.org/wiki/Tree_traversal#In-order )

And Nodes that have LocalZOder values
While Nodes with LocalZOder &gt;=0 are the &quot;right&quot; subtree.
Parameters:
{Number} localZOrder

            */
            setLocalZOrder(localZOrder?: number);
            /**
            * setName(name)
Changes the name that is used to identify the node easily.
Parameters:
{String} name

            */
            setName(name?: string);
            /**
            * setNormalizedPosition(posOrX, y)
Sets the position (x,y) using values between 0 and 1.
The positions in pixels is calculated like the following:
_position = _normalizedPosition * parent.getContentSize()
Parameters:
{cc.Point|Number} posOrX
{Number} y
Optional

            */
            setNormalizedPosition(posOrX?: any, y?: number);
            /**
            * setOpacity(opacity)
Sets the opacity of Node
Parameters:
{Number} opacity

            */
            setOpacity(opacity?: number);
            /**
            * setOpacityModifyRGB(opacityValue)
Set whether color should be changed with the opacity value,
useless in cc.Node, but this function is override in some class to have such behavior.
Parameters:
{Boolean} opacityValue

            */
            setOpacityModifyRGB(opacityValue?: boolean);
            /**
            * setOrderOfArrival(Var)
Sets the arrival order when this node has a same ZOrder with other children.
A node which called addChild subsequently will take a larger arrival order,
If two children have the same Z order, the child with larger arrival order will be drawn later.
Parameters:
{Number} Var
The arrival order.

            */
            setOrderOfArrival(Var?: number);
            /**
            * setParent(parent)
Sets the parent node
Parameters:
{cc.Node} parent
A reference to the parent node

            */
            setParent(parent?: cc.Node);
            /**
            * setPosition(newPosOrxValue, yValue)
Changes the position (x,y) of the node in cocos2d coordinates.
The original point (0,0) is at the left-bottom corner of screen.
Usually we use cc.p(x,y) to compose CCPoint object.
and Passing two numbers (x,y) is more efficient than passing CCPoint object.
var size = cc.winSize;
node.setPosition(size.width/2, size.height/2);
Parameters:
{cc.Point|Number} newPosOrxValue
The position (x,y) of the node in coordinates or the X coordinate for position
{Number} yValue
Optional
Y coordinate for position

            */
            setPosition(newPosOrxValue?: any, yValue?: number);
            /**
            * setPositionX(x)
Sets the x axis position of the node in cocos2d coordinates.
Parameters:
{Number} x
The new position in x axis

            */
            setPositionX(x?: number);
            /**
            * setPositionY(y)
Sets the y axis position of the node in cocos2d coordinates.
Parameters:
{Number} y
The new position in y axis

            */
            setPositionY(y?: number);
            /**
            * setRotation(newRotation)
Sets the rotation (angle) of the node in degrees.
0 is the default rotation angle.
Positive values rotate node clockwise, and negative values for anti-clockwise.
Parameters:
{Number} newRotation
The rotation of the node in degrees.

            */
            setRotation(newRotation?: number);
            /**
            * setRotationX(rotationX)
Sets the X rotation (angle) of the node in degrees which performs a horizontal rotational skew.
(support only in WebGL rendering mode)
0 is the default rotation angle.
Positive values rotate node clockwise, and negative values for anti-clockwise.
Parameters:
{Number} rotationX
The X rotation in degrees which performs a horizontal rotational skew.

            */
            setRotationX(rotationX?: number);
            /**
            * setRotationY(rotationY)
Sets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.
(support only in WebGL rendering mode)
0 is the default rotation angle.
Positive values rotate node clockwise, and negative values for anti-clockwise.
Parameters:
rotationY
The Y rotation in degrees.

            */
            setRotationY();
            /**
            * setScale(scale, scaleY)
Sets the scale factor of the node. 1.0 is the default scale factor. This function can modify the X and Y scale at the same time.
Parameters:
{Number} scale
or scaleX value
{Number} scaleY
Optional

            */
            setScale(scale?: number, scaleY?: number);
            /**
            * setScaleX(newScaleX)
Changes the scale factor on X axis of this node
The default value is 1.0 if you haven&#39;t changed it before
Parameters:
{Number} newScaleX
The scale factor on X axis.

            */
            setScaleX(newScaleX?: number);
            /**
            * setScaleY(newScaleY)
Changes the scale factor on Y axis of this node
The Default value is 1.0 if you haven&#39;t changed it before.
Parameters:
{Number} newScaleY
The scale factor on Y axis.

            */
            setScaleY(newScaleY?: number);
            /**
            * setScheduler(scheduler)
Sets a CCScheduler object that is used to schedule all &quot;updates&quot; and timers.
IMPORTANT: If you set a new cc.Scheduler, then previously created timers/update are going to be removed.
Parameters:
scheduler
A cc.Scheduler object that is used to schedule all &quot;update&quot; and timers.

            */
            setScheduler();
            /**
            * setShaderProgram(newShaderProgram)
Sets the shader program for this node

Since v2.0, each rendering node must set its shader program.
It should be set in initialize phase.
node.setGLProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
Parameters:
{cc.GLProgram} newShaderProgram
The shader program which fetches from CCShaderCache.

            */
            setShaderProgram(newShaderProgram?: cc.GLProgram);
            /**
            * setSkewX(newSkewX)
Changes the X skew angle of the node in degrees.

This angle describes the shear distortion in the X direction.
Thus, it is the angle between the Y axis and the left edge of the shape
The default skewX angle is 0. Positive values distort the node in a CW direction.
Parameters:
{Number} newSkewX
The X skew angle of the node in degrees.

            */
            setSkewX(newSkewX?: number);
            /**
            * setSkewY(newSkewY)
Changes the Y skew angle of the node in degrees.
This angle describes the shear distortion in the Y direction.
Thus, it is the angle between the X axis and the bottom edge of the shape
The default skewY angle is 0. Positive values distort the node in a CCW direction.
Parameters:
{Number} newSkewY
The Y skew angle of the node in degrees.

            */
            setSkewY(newSkewY?: number);
            /**
            * setTag(tag)
Changes the tag that is used to identify the node easily.
Please refer to getTag for the sample code.
Parameters:
{Number} tag
A integer that identifies the node.
See:
cc.Node#getTag

            */
            setTag(tag?: number);
            /**
            * setUserData(Var)
Sets a custom user data reference
You can set everything in UserData reference, a data block, a structure or an object, etc.
Parameters:
{object} Var
A custom user data

            */
            setUserData(Var?: any);
            /**
            * setUserObject(newValue)
Sets a user assigned cocos2d object
Similar to UserData, but instead of holding all kinds of data it can only hold a cocos2d object
In JSB, the UserObject will be retained once in this method, and the previous UserObject (if existed) will be release.
The UserObject will be released in CCNode&#39;s destruction.
Parameters:
{object} newValue
A user cocos2d object

            */
            setUserObject(newValue?: any);
            /**
            * setVertexZ(Var)
Sets the real WebGL Z vertex.
Differences between openGL Z vertex and cocos2d Z order:
- WebGL Z modifies the Z vertex, and not the Z order in the relation between parent-children
- WebGL Z might require to set 2D projection
- cocos2d Z order works OK if all the nodes uses the same WebGL Z vertex. eg: vertexZ = 0
Parameters:
{Number} Var

            */
            setVertexZ(Var?: number);
            /**
            * setVisible(visible)
Sets whether the node is visible
The default value is true
Parameters:
{Boolean} visible
Pass true to make the node visible, false to hide the node.

            */
            setVisible(visible?: boolean);
            /**
            * setZOrder(z)
Sets the Z order which stands for the drawing order, and reorder this node in its parent&#39;s children array.
The Z order of node is relative to its &quot;brothers&quot;: children of the same parent.
It&#39;s nothing to do with OpenGL&#39;s z vertex. This one only affects the draw order of nodes in cocos2d.
The larger number it is, the later this node will be drawn in each message loop.
Please refer to setVertexZ(float) for the difference.
Parameters:
{Number} z
Z order of this node.
Deprecated:
since 3.0, please use setLocalZOrder instead

            */
            setZOrder(z?: number);
            /**
            * sortAllChildren()
Sorts the children array once before drawing, instead of every time when a child is added or reordered.
This approach can improves the performance massively.

            */
            sortAllChildren();
            /**
            * stopAction(action)
Stops and removes an action from the running action list.
Parameters:
{cc.Action} action
An action object to be removed.

            */
            stopAction(action?: cc.Action);
            /**
            * stopActionByTag(tag)
Removes an action from the running action list by its tag.
Parameters:
{Number} tag
A tag that indicates the action to be removed.

            */
            stopActionByTag(tag?: number);
            /**
            * stopAllActions()
Stops and removes all actions from the running action list .

            */
            stopAllActions();
            /**
            * transform(parentCmd, recursive)
Performs view-matrix transformation based on position, scale, rotation and other attributes.
Parameters:
{cc.Node.RenderCmd} parentCmd
parent&#39;s render command
{boolean} recursive
whether call its children&#39;s transform

            */
            transform(parentCmd?: any, recursive?: boolean);
            /**
            * unschedule(callback_fn)
unschedules a custom callback function.
Parameters:
{function} callback_fn
A function wrapped as a selector
See:
cc.Node#schedule

            */
            unschedule(callback_fn?: any);
            /**
            * unscheduleAllCallbacks()
unschedule all scheduled callback functions: custom callback functions, and the &#39;update&#39; callback function.
Actions are not affected by this method.

            */
            unscheduleAllCallbacks();
            /**
            * unscheduleUpdate()
Unschedules the &quot;update&quot; method.
See:
cc.Node#scheduleUpdate

            */
            unscheduleUpdate();
            /**
            * update(dt)
Update will be called automatically every frame if &quot;scheduleUpdate&quot; is called when the node is &quot;live&quot;.
The default behavior is to invoke the visit function of node&#39;s componentContainer.
Override me to implement your own update logic.
Parameters:
{Number} dt
Delta time since last update

            */
            update(dt?: number);
            /**
            * updateDisplayedColor(parentColor)
Update the displayed color of Node
Parameters:
{cc.Color} parentColor

            */
            updateDisplayedColor(parentColor?: cc.Color);
            /**
            * updateDisplayedOpacity(parentOpacity)
Update displayed opacity
Parameters:
{Number} parentOpacity

            */
            updateDisplayedOpacity(parentOpacity?: number);
            /**
            * updateTransform()
Calls children&#39;s updateTransform() method recursively.
This method is moved from CCSprite, so it&#39;s no longer specific to CCSprite.
As the result, you apply CCSpriteBatchNode&#39;s optimization on your customed CCNode.
e.g., batchNode-&gt;addChild(myCustomNode), while you can only addChild(sprite) before.

            */
            updateTransform();
            /**
            * visit(parentCmd)
Recursive method that visit its children and draw them
Parameters:
{cc.Node.RenderCmd} parentCmd

            */
            visit(parentCmd?: any);
            /**
            * worldToNodeTransform()
Deprecated:
since v3.0, please use getWorldToNodeTransform instead

            */
            worldToNodeTransform();
        }
    }
declare module cc {
        /**
        * This action simulates a page turn from the bottom right hand corner of the screen.
It&#39;s not much use by itself but is used by the PageTurnTransition.
Based on an original paper by L Hong et al.
http://www.parc.com/publication/1638/turning-pages-of-3d-electronic-books.html

        */
        export class PageTurn3D extends cc.Grid3DAction {
            /**
            * 
This action simulates a page turn from the bottom right hand corner of the screen.
            */
            constructor();
            /**
            * Please use cc.pageTurn3D instead
create PageTurn3D action
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.PageTurn3D;
            /**
            * update(time)
Update each tick
Time is the percentage of the way through the duration
Parameters:
time

            */
            update();
        }
    }
declare module cc {
        /**
        * 
cc.ParallaxNode: A node that simulates a parallax scroller
The children will be moved faster / slower than the parent according the the parallax ratio.

        */
        export class ParallaxNode extends cc.Node {
            /**
            * cc.ParallaxNode: A node that simulates a parallax scroller
The children will be moved faster / slower than the parent according the the parallax ratio.
            */
            constructor();
            /**
            * - Parallax nodes array
            */
            parallaxArray: Array<any>;
            /**
            * addChild(child, z, ratio, offset)
Adds a child to the container with a z-order, a parallax ratio and a position offset
It returns self, so you can chain several addChilds.
//example
voidNode.addChild(background, -1, cc.p(0.4, 0.5), cc.p(0,0));
Parameters:
{cc.Node} child
{Number} z
{cc.Point} ratio
{cc.Point} offset

            */
            addChild(child?: cc.Node, z?: number, ratio?: cc.Point, offset?: cc.Point);
            /**
            * &amp;lt;static&amp;gt;
{cc.ParallaxNode}
cc.ParallaxNode.create()
Create new parallax node.
//example
var voidNode = new cc.ParallaxNode();
Deprecated:
since v3.0 please use new cc.ParallaxNode() instead.
Returns:
{cc.ParallaxNode}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParallaxNode;
            /**
            * ctor()
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Array}
getParallaxArray()
Gets the parallax array.
Returns:
{Array}

            */
            getParallaxArray(): Array<any>;
            /**
            * removeAllChildren(cleanup)
Remove all children with cleanup
Parameters:
{Boolean} cleanup

            */
            removeAllChildren(cleanup?: boolean);
            /**
            * removeChild(child, cleanup)
Remove Child
//example
voidNode.removeChild(background,true);
Parameters:
{cc.Node} child
{Boolean} cleanup

            */
            removeChild(child?: cc.Node, cleanup?: boolean);
            /**
            * setParallaxArray(value)
Set parallax array.
Parameters:
{Array} value

            */
            setParallaxArray(value?: Array<any>);
        }
    }
declare module cc {
        /**
        * 
Structure that contains the values of each particle

        */
        export class Particle  {
            /**
            * Structure that contains the values of each particle
            */
            constructor(pos?: cc.Point, startPos?: cc.Point, color?: cc.Color, deltaColor?: cc.Color, size?: cc.Size, deltaSize?: cc.Size, rotation?: number, deltaRotation?: number, timeToLive?: number, atlasIndex?: number, modeA?: cc.Particle.ModeA, modeB?: cc.Particle.ModeA);
            /**
            * Array of Point instances used to optimize particle updates
            */
            static TemporaryPoints;
        }
    }
declare module cc.Particle {
        /**
        * 
Mode A: gravity, direction, radial accel, tangential accel

        */
        export class ModeA  {
            /**
            * Mode A: gravity, direction, radial accel, tangential accel
            */
            constructor(dir?: cc.Point, radialAccel?: number, tangentialAccel?: number);
        }
    }
declare module cc.Particle {
        /**
        * 
Mode B: radius mode

        */
        export class ModeB  {
            /**
            * Mode B: radius mode
            */
            constructor(angle?: number, degreesPerSecond?: number, radius?: number, deltaRadius?: number);
        }
    }
declare module cc {
        /**
        * cc.ParticleBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL call
(often known as &quot;batch draw&quot;).

A cc.ParticleBatchNode can reference one and only one texture (one image file, one texture atlas).
Only the cc.ParticleSystems that are contained in that texture can be added to the cc.SpriteBatchNode.
All cc.ParticleSystems added to a cc.SpriteBatchNode are drawn in one OpenGL ES draw call.
If the cc.ParticleSystems are not added to a cc.ParticleBatchNode then an OpenGL ES draw call will be needed for each one, which is less efficient.

Limitations:
- At the moment only cc.ParticleSystem is supported
- All systems need to be drawn with the same parameters, blend function, aliasing, texture

Most efficient usage
- Initialize the ParticleBatchNode with the texture and enough capacity for all the particle systems
- Initialize all particle systems and add them as child to the batch node

        */
        export class ParticleBatchNode extends cc.ParticleSystem {
            /**
            * 
cc.ParticleBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL call
(often known as &quot;batch draw&quot;).
            */
            constructor(fileImage?: any, capacity?: number);
            /**
            * - The used texture
            */
            texture: any;
            /**
            * - The texture atlas used for drawing the quads
            */
            textureAtlas: cc.TextureAtlas;
            /**
            * addChild(child, zOrder, tag)
Add a child into the cc.ParticleBatchNode
Parameters:
{cc.ParticleSystem} child
{Number} zOrder
{Number} tag

            */
            addChild(child?: cc.ParticleSystem, zOrder?: number, tag?: number);
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleBatchNode}
cc.ParticleBatchNode.create(fileImage, capacity)
initializes the particle system with the name of a file on disk (for a list of supported formats look at the cc.Texture2D class), a capacity of particles
Parameters:
{String|cc.Texture2D} fileImage
{Number} capacity
Deprecated:
since v3.0 please use new cc.ParticleBatchNode(filename, capacity) instead.
Returns:
{cc.ParticleBatchNode}

            */
            static create(fileImage?: any, capacity?: number): cc.ParticleBatchNode;
            /**
            * ctor(fileImage, capacity)
initializes the particle system with the name of a file on disk (for a list of supported formats look at the cc.Texture2D class), a capacity of particles
Constructor of cc.ParticleBatchNode
1.
//Create a cc.ParticleBatchNode with image path  and capacity
var particleBatchNode = new cc.ParticleBatchNode(&quot;res/grossini_dance.png&quot;,30);

2.
//Create a cc.ParticleBatchNode with a texture and capacity
var texture = cc.TextureCache.getInstance().addImage(&quot;res/grossini_dance.png&quot;);
var particleBatchNode = new cc.ParticleBatchNode(texture, 30);
Parameters:
{String|cc.Texture2D} fileImage
{Number} capacity

            */
            ctor(fileImage?: any, capacity?: number);
            /**
            * disableParticle(particleIndex)
disables a particle by inserting a 0&#39;d quad into the texture atlas
Parameters:
{Number} particleIndex

            */
            disableParticle(particleIndex?: number);
            /**
            * {cc.BlendFunc}
getBlendFunc()
returns the blending function used for the texture
Returns:
{cc.BlendFunc}

            */
            getBlendFunc(): cc.BlendFunc;
            /**
            * {cc.Texture2D}
getTexture()
returns the used texture
Returns:
{cc.Texture2D}

            */
            getTexture(): cc.Texture2D;
            /**
            * {cc.TextureAtlas}
getTextureAtlas()
return the texture atlas used for drawing the quads
Returns:
{cc.TextureAtlas}

            */
            getTextureAtlas(): cc.TextureAtlas;
            /**
            * {Boolean}
init(fileImage, capacity)
initializes the particle system with the name of a file on disk (for a list of supported formats look at the cc.Texture2D class), a capacity of particles
Parameters:
{String} fileImage
{Number} capacity
Returns:
{Boolean}

            */
            init(fileImage?: string, capacity?: number): boolean;
            /**
            * {Boolean}
initWithFile(fileImage, capacity)
initializes the particle system with the name of a file on disk (for a list of supported formats look at the cc.Texture2D class), a capacity of particles
Parameters:
{String} fileImage
{Number} capacity
Returns:
{Boolean}

            */
            initWithFile(fileImage?: string, capacity?: number): boolean;
            /**
            * {Boolean}
initWithTexture(texture, capacity)
initializes the particle system with cc.Texture2D, a capacity of particles
Parameters:
{cc.Texture2D|HTMLImageElement|HTMLCanvasElement} texture
{Number} capacity
Returns:
{Boolean}

            */
            initWithTexture(texture?: any, capacity?: number): boolean;
            /**
            * insertChild(pSystem, index)
Inserts a child into the cc.ParticleBatchNode
Parameters:
{cc.ParticleSystem} pSystem
{Number} index

            */
            insertChild(pSystem?: cc.ParticleSystem, index?: number);
            /**
            * removeAllChildren(doCleanup)
Parameters:
{Boolean} doCleanup

            */
            removeAllChildren(doCleanup?: boolean);
            /**
            * removeChild(child, cleanup)
Parameters:
{cc.ParticleSystem} child
{Boolean} cleanup

            */
            removeChild(child?: cc.ParticleSystem, cleanup?: boolean);
            /**
            * removeChildAtIndex(index, doCleanup)
Parameters:
{Number} index
{Boolean} doCleanup

            */
            removeChildAtIndex(index?: number, doCleanup?: boolean);
            /**
            * reorderChild(child, zOrder)
Reorder will be done in this function, no &quot;lazy&quot; reorder to particles
Parameters:
{cc.ParticleSystem} child
{Number} zOrder

            */
            reorderChild(child?: cc.ParticleSystem, zOrder?: number);
            /**
            * setBlendFunc(src, dst)
set the blending function used for the texture
Parameters:
{Number|Object} src
{Number} dst

            */
            setBlendFunc(src?: any, dst?: number);
            /**
            * setTexture(texture)
sets a new texture. it will be retained
Parameters:
{cc.Texture2D} texture

            */
            setTexture(texture?: cc.Texture2D);
            /**
            * setTextureAtlas(textureAtlas)
set the texture atlas used for drawing the quads
Parameters:
{cc.TextureAtlas} textureAtlas

            */
            setTextureAtlas(textureAtlas?: cc.TextureAtlas);
        }
    }
declare module cc {
        /**
        * 
An explosion particle system

        */
        export class ParticleExplosion extends cc.ParticleSystem {
            /**
            * An explosion particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleExplosion}
cc.ParticleExplosion.create()
Create an explosion particle system
Deprecated:
since v3.0 please use new cc.ParticleExplosion() instead.
Returns:
{cc.ParticleExplosion}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleExplosion;
            /**
            * ctor()
The cc.ParticleExplosion&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleExplosion()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize an explosion particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A fire particle system

        */
        export class ParticleFire extends cc.ParticleSystem {
            /**
            * A fire particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleFire}
cc.ParticleFire.create()
Create a fire particle system
Deprecated:
since v3.0 please use new cc.ParticleFire() instead
Returns:
{cc.ParticleFire}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleFire;
            /**
            * ctor()
The cc.ParticleFire&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleFire()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize a fire particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A fireworks particle system

        */
        export class ParticleFireworks extends cc.ParticleSystem {
            /**
            * A fireworks particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleFireworks}
cc.ParticleFireworks.create()
Create a fireworks particle system
Deprecated:
since v3.0 please use new cc.ParticleFireworks() instead.
Returns:
{cc.ParticleFireworks}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleFireworks;
            /**
            * ctor()
The cc.ParticleFireworks&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleFireworks()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize a fireworks particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A flower particle system

        */
        export class ParticleFlower extends cc.ParticleSystem {
            /**
            * A flower particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleFlower}
cc.ParticleFlower.create()
Create a flower particle system
Deprecated:
since v3.0 please use new cc.ParticleFlower() instead.
Returns:
{cc.ParticleFlower}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleFlower;
            /**
            * ctor()
The cc.ParticleFlower&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleFlower()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize a flower particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A galaxy particle system

        */
        export class ParticleGalaxy extends cc.ParticleSystem {
            /**
            * A galaxy particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleGalaxy}
cc.ParticleGalaxy.create()
Create a galaxy particle system
Deprecated:
since v3.0 please use new cc.OarticleGalaxy() instead.
Returns:
{cc.ParticleGalaxy}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleGalaxy;
            /**
            * ctor()
The cc.ParticleGalaxy&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleGalaxy()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize a galaxy particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A meteor particle system

        */
        export class ParticleMeteor extends cc.ParticleSystem {
            /**
            * A meteor particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleMeteor}
cc.ParticleMeteor.create()
Create a meteor particle system
Deprecated:
since v3.0 please use new cc.ParticleMeteor() instead.
Returns:
{cc.ParticleMeteor}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleMeteor;
            /**
            * ctor()
The cc.ParticleMeteor&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleMeteor()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize a meteor particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A rain particle system

        */
        export class ParticleRain extends cc.ParticleSystem {
            /**
            * A rain particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleRain}
cc.ParticleRain.create()
Create a rain particle system
Deprecated:
since v3.0 please use cc.ParticleRain() instead.
Returns:
{cc.ParticleRain}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleRain;
            /**
            * ctor()
The cc.ParticleRain&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleRain()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize a rain particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A smoke particle system

        */
        export class ParticleSmoke extends cc.ParticleSystem {
            /**
            * A smoke particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleSmoke}
cc.ParticleSmoke.create()
Create a smoke particle system
Deprecated:
since v3.0 please use new cc.ParticleSmoke() instead.
Returns:
{cc.ParticleSmoke}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleSmoke;
            /**
            * ctor()
The cc.ParticleSmoke&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleSmoke()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize a smoke particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A snow particle system

        */
        export class ParticleSnow extends cc.ParticleSystem {
            /**
            * A snow particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleSnow}
cc.ParticleSnow.create()
Create a snow particle system
Deprecated:
since v3.0 please use new cc.ParticleSnow() instead.
Returns:
{cc.ParticleSnow}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleSnow;
            /**
            * ctor()
The cc.ParticleSnow&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleSnow()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize a snow particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A spiral particle system

        */
        export class ParticleSpiral extends cc.ParticleSystem {
            /**
            * A spiral particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleSpiral}
cc.ParticleSpiral.create()
Create a spiral particle system
Deprecated:
since v3.0 please use new cc.ParticleSpiral() instead.
Returns:
{cc.ParticleSpiral}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleSpiral;
            /**
            * ctor()
The cc.ParticleSpiral&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleSpiral()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize a spiral particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A sun particle system

        */
        export class ParticleSun extends cc.ParticleSystem {
            /**
            * A sun particle system
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleSun}
cc.ParticleSun.create()
Create a sun particle system
Deprecated:
since v3.0 please use new cc.ParticleSun() instead.
Returns:
{cc.ParticleSun}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.ParticleSun;
            /**
            * ctor()
The cc.ParticleSun&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.ParticleSun()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
initialize a sun particle system with number Of Particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
        }
    }
declare module cc {
        /**
        * Particle System base class.
Attributes of a Particle System:
- emmision rate of the particles
- Gravity Mode (Mode A):
- gravity
- direction
- speed +-  variance
- tangential acceleration +- variance
- radial acceleration +- variance
- Radius Mode (Mode B):
- startRadius +- variance
- endRadius +- variance
- rotate +- variance
- Properties common to all modes:
- life +- life variance
- start spin +- variance
- end spin +- variance
- start size +- variance
- end size +- variance
- start color +- variance
- end color +- variance
- life +- variance
- blending function
- texture
cocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).
&#39;Radius Mode&#39; in Particle Designer uses a fixed emit rate of 30 hz. Since that can&#39;t be guarateed in cocos2d,
cocos2d uses a another approach, but the results are almost identical.
cocos2d supports all the variables used by Particle Designer plus a bit more:
- spinning particles (supported when using ParticleSystem)
- tangential acceleration (Gravity mode)
- radial acceleration (Gravity mode)
- radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only)
It is possible to customize any of the above mentioned properties in runtime. Example:

        */
        export class ParticleSystem extends cc.Node {
            /**
            * 
Particle System base class.
            */
            constructor();
            /**
            * -  Indicate whether the particle system is activated.
            */
            active: boolean;
            /**
            * - Angle of each particle setter.
            */
            angle: number;
            /**
            * - Variation of angle of each particle setter.
            */
            angleVar: number;
            /**
            * - Index of system in batch node array.
            */
            atlasIndex: number;
            /**
            * - Indicate whether the node will be auto-removed when it has no particles left.
            */
            autoRemoveOnFinish: boolean;
            /**
            * Ball Shape for ShapeMode of Particle
            */
            static BALL_SHAPE: number;
            /**
            * - Weak reference to the sprite batch node.
            */
            batchNode: cc.SpriteBatchNode;
            /**
            * - How many seconds the emitter wil run.
            */
            duration: number;
            /**
            * The Particle emitter lives forever
            */
            static DURATION_INFINITY: number;
            /**
            * - Emission rate of the particles.
            */
            emissionRate: number;
            /**
            * - Emitter modes: CCParticleSystem.MODE_GRAVITY: uses gravity, speed, radial and tangential acceleration; CCParticleSystem.MODE_RADIUS: uses radius movement + rotation.
            */
            emitterMode: number;
            /**
            * - Ending color of each particle.
            */
            endColor: cc.Color;
            /**
            * - Variation of the end color.
            */
            endColorVar: cc.Color;
            /**
            * - Ending radius of the particles.
            */
            endRadius: number;
            /**
            * - Variation of the ending radius.
            */
            endRadiusVar: number;
            /**
            * - End size in pixels of each particle.
            */
            endSize: number;
            /**
            * - Variation of end size in pixels.
            */
            endSizeVar: number;
            /**
            * - End angle of each particle.
            */
            endSpin: number;
            /**
            * - Variation of end angle.
            */
            endSpinVar: number;
            /**
            * - Gravity of the emitter.
            */
            gravity: cc.Point;
            /**
            * - Life of each particle setter.
            */
            life: number;
            /**
            * - Variation of life.
            */
            lifeVar: number;
            /**
            * Gravity mode (A mode)
            */
            static MODE_GRAVITY: number;
            /**
            * Radius mode (B mode)
            */
            static MODE_RADIUS: number;
            /**
            * - Indicate whether the alpha value modify color.
            */
            opacityModifyRGB: boolean;
            /**
            * - Current quantity of particles that are being simulated.
            */
            particleCount: number;
            /**
            * - Particles movement type: cc.ParticleSystem.TYPE_FREE | cc.ParticleSystem.TYPE_GROUPED.
            */
            positionType: number;
            /**
            * - Variation of source position.
            */
            posVar: cc.Point;
            /**
            * - Number of degress to rotate a particle around the source pos per second.
            */
            rotatePerS: number;
            /**
            * - Variation of the degress to rotate a particle around the source pos per second.
            */
            rotatePerSVar: number;
            /**
            * - Indicate whether the rotation of each particle equals to its direction.
            */
            rotationIsDir: boolean;
            /**
            * Shape Mode of Particle Draw
            */
            static SHAPE_MODE: number;
            /**
            * - ShapeType of ParticleSystem : cc.ParticleSystem.BALL_SHAPE | cc.ParticleSystem.STAR_SHAPE.
            */
            shapeType: number;
            /**
            * - Source position of the emitter.
            */
            sourcePos: cc.Point;
            /**
            * - Speed of the emitter.
            */
            speed: cc.Point;
            /**
            * - Variation of the speed.
            */
            speedVar: cc.Point;
            /**
            * Star Shape for ShapeMode of Particle
            */
            static STAR_SHAPE: number;
            /**
            * The starting radius of the particle is equal to the ending radius
            */
            static START_RADIUS_EQUAL_TO_END_RADIUS: number;
            /**
            * The starting size of the particle is equal to the ending size
            */
            static START_SIZE_EQUAL_TO_END_SIZE: number;
            /**
            * - Start color of each particle.
            */
            startColor: cc.Color;
            /**
            * - Variation of the start color.
            */
            startColorVar: cc.Color;
            /**
            * - Starting radius of the particles.
            */
            startRadius: number;
            /**
            * - Variation of the starting radius.
            */
            startRadiusVar: number;
            /**
            * - Start size in pixels of each particle.
            */
            startSize: number;
            /**
            * - Variation of start size in pixels.
            */
            startSizeVar: number;
            /**
            * - Start angle of each particle.
            */
            startSpin: number;
            /**
            * - Variation of start angle.
            */
            startSpinVar: number;
            /**
            * - Tangential acceleration of each particle.
            */
            tangentialAccel: number;
            /**
            * - Variation of the tangential acceleration.
            */
            tangentialAccelVar: number;
            /**
            * - Texture of Particle System.
            */
            texture: cc.Texture2D;
            /**
            * Texture Mode of Particle Draw
            */
            static TEXTURE_MODE: number;
            /**
            * - Maximum particles of the system.
            */
            totalParticles: number;
            /**
            * Living particles are attached to the world and are unaffected by emitter repositioning.
            */
            static TYPE_FREE: number;
            /**
            * Living particles are attached to the emitter and are translated along with it.
            */
            static TYPE_GROUPED: number;
            /**
            * Living particles are attached to the world but will follow the emitter repositioning.
            */
            static TYPE_RELATIVE: number;
            /**
            * {Boolean}
addParticle()
Add a particle to the emitter
Returns:
{Boolean}

            */
            addParticle(): boolean;
            /**
            * {cc.ParticleSystem}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.ParticleSystem}

            */
            clone(): cc.ParticleSystem;
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleSystem}
cc.ParticleSystem.create(plistFile)
return the string found by key in dict.
This plist files can be create manually or with Particle Designer:
http://particledesigner.71squared.com/
Parameters:
{String|Number} plistFile
Deprecated:
since v3.0 please use new cc.ParticleSysytem(plistFile) instead.
Returns:
{cc.ParticleSystem}

            */
            static create(plistFile?: any): cc.ParticleSystem;
            /**
            * &amp;lt;static&amp;gt;
{cc.ParticleSystem}
cc.ParticleSystem.createWithTotalParticles(plistFile)
return the string found by key in dict.
This plist files can be create manually or with Particle Designer:
http://particledesigner.71squared.com/
Parameters:
{String|Number} plistFile
Deprecated:
since v3.0 please use new cc.ParticleSysytem(plistFile) instead.
Returns:
{cc.ParticleSystem}

            */
            static createWithTotalParticles(plistFile?: any): cc.ParticleSystem;
            /**
            * ctor(plistFile)
return the string found by key in dict.
This plist files can be create manually or with Particle Designer:
http://particledesigner.71squared.com/

Constructor of cc.ParticleSystem
Parameters:
{String|Number} plistFile

            */
            ctor(plistFile?: any);
            /**
            * destroyParticleSystem()
Unschedules the &quot;update&quot; method.
See:
scheduleUpdate();

            */
            destroyParticleSystem();
            /**
            * {Number}
getAngle()
Return angle of each particle
Returns:
{Number}

            */
            getAngle(): number;
            /**
            * {Number}
getAngleVar()
Return angle variance of each particle
Returns:
{Number}

            */
            getAngleVar(): number;
            /**
            * {Number}
getAtlasIndex()
return index of system in batch node array
Returns:
{Number}

            */
            getAtlasIndex(): number;
            /**
            * {cc.ParticleBatchNode}
getBatchNode()
return weak reference to the cc.SpriteBatchNode that renders the cc.Sprite
Returns:
{cc.ParticleBatchNode}

            */
            getBatchNode(): cc.ParticleBatchNode;
            /**
            * {cc.BlendFunc}
getBlendFunc()
get BlendFunc of Particle System
Returns:
{cc.BlendFunc}

            */
            getBlendFunc(): cc.BlendFunc;
            /**
            * {cc.Rect}
getBoundingBoxToWorld()
return bounding box of particle system in world space
Returns:
{cc.Rect}

            */
            getBoundingBoxToWorld(): cc.Rect;
            /**
            * {Number}
getDrawMode()
Return DrawMode of ParticleSystem   (Canvas Mode only)
Returns:
{Number}

            */
            getDrawMode(): number;
            /**
            * {Number}
getDuration()
How many seconds the emitter wil run. -1 means &#39;forever&#39;
Returns:
{Number}

            */
            getDuration(): number;
            /**
            * {Number}
getEmissionRate()
get emission rate of the particles
Returns:
{Number}

            */
            getEmissionRate(): number;
            /**
            * {Number}
getEmitterMode()
return kind of emitter modes
Returns:
{Number}

            */
            getEmitterMode(): number;
            /**
            * {cc.Color}
getEndColor()
get end color and end color variation of each particle
Returns:
{cc.Color}

            */
            getEndColor(): cc.Color;
            /**
            * {cc.Color}
getEndColorVar()
get end color variance of each particle
Returns:
{cc.Color}

            */
            getEndColorVar(): cc.Color;
            /**
            * {Number}
getEndRadius()
Return ending radius of the particles. Only available in &#39;Radius&#39; mode.
Returns:
{Number}

            */
            getEndRadius(): number;
            /**
            * {Number}
getEndRadiusVar()
Return ending radius variance of the particles. Only available in &#39;Radius&#39; mode.
Returns:
{Number}

            */
            getEndRadiusVar(): number;
            /**
            * {Number}
getEndSize()
get end size in pixels of each particle
Returns:
{Number}

            */
            getEndSize(): number;
            /**
            * {Number}
getEndSizeVar()
get end size variance in pixels of each particle
Returns:
{Number}

            */
            getEndSizeVar(): number;
            /**
            * {Number}
getEndSpin()
get end angle of each particle
Returns:
{Number}

            */
            getEndSpin(): number;
            /**
            * {Number}
getEndSpinVar()
get end angle variance of each particle
Returns:
{Number}

            */
            getEndSpinVar(): number;
            /**
            * {cc.Point}
getGravity()
Return Gravity of emitter
Returns:
{cc.Point}

            */
            getGravity(): cc.Point;
            /**
            * {Number}
getLife()
Return life of each particle
Returns:
{Number}

            */
            getLife(): number;
            /**
            * {Number}
getLifeVar()
Return life variance of each particle
Returns:
{Number}

            */
            getLifeVar(): number;
            /**
            * {Number}
getParticleCount()
Quantity of particles that are being simulated at the moment
Returns:
{Number}

            */
            getParticleCount(): number;
            /**
            * {Number}
getPositionType()
get particles movement type: Free or Grouped
Returns:
{Number}

            */
            getPositionType(): number;
            /**
            * {cc.Point | Object}
getPosVar()
Return Position variance of the emitter
Returns:
{cc.Point | Object}

            */
            getPosVar(): any;
            /**
            * {Number}
getRadialAccel()
Return radial acceleration of each particle. Only available in &#39;Gravity&#39; mode.
Returns:
{Number}

            */
            getRadialAccel(): number;
            /**
            * {Number}
getRadialAccelVar()
Return radial acceleration variance of each particle. Only available in &#39;Gravity&#39; mode.
Returns:
{Number}

            */
            getRadialAccelVar(): number;
            /**
            * {Number}
getRotatePerSecond()
get Number of degress to rotate a particle around the source pos per second. Only available in &#39;Radius&#39; mode.
Returns:
{Number}

            */
            getRotatePerSecond(): number;
            /**
            * {Number}
getRotatePerSecondVar()
Return Variance in degrees for rotatePerSecond. Only available in &#39;Radius&#39; mode.
Returns:
{Number}

            */
            getRotatePerSecondVar(): number;
            /**
            * {boolean}
getRotationIsDir()
get the rotation of each particle to its direction Only available in &#39;Gravity&#39; mode.
Returns:
{boolean}

            */
            getRotationIsDir(): boolean;
            /**
            * {Number}
getShapeType()
Return ShapeType of ParticleSystem  (Canvas Mode only)
Returns:
{Number}

            */
            getShapeType(): number;
            /**
            * {cc.Point | Object}
getSourcePosition()
Return sourcePosition of the emitter
Returns:
{cc.Point | Object}

            */
            getSourcePosition(): any;
            /**
            * {Number}
getSpeed()
Return Speed of each particle
Returns:
{Number}

            */
            getSpeed(): number;
            /**
            * {Number}
getSpeedVar()
return speed variance of each particle. Only available in &#39;Gravity&#39; mode.
Returns:
{Number}

            */
            getSpeedVar(): number;
            /**
            * {cc.Color}
getStartColor()
set start color of each particle
Returns:
{cc.Color}

            */
            getStartColor(): cc.Color;
            /**
            * {cc.Color}
getStartColorVar()
get start color variance of each particle
Returns:
{cc.Color}

            */
            getStartColorVar(): cc.Color;
            /**
            * {Number}
getStartRadius()
Return starting radius of the particles. Only available in &#39;Radius&#39; mode.
Returns:
{Number}

            */
            getStartRadius(): number;
            /**
            * {Number}
getStartRadiusVar()
Return starting radius variance of the particles. Only available in &#39;Radius&#39; mode.
Returns:
{Number}

            */
            getStartRadiusVar(): number;
            /**
            * {Number}
getStartSize()
get start size in pixels of each particle
Returns:
{Number}

            */
            getStartSize(): number;
            /**
            * {Number}
getStartSizeVar()
get size variance in pixels of each particle
Returns:
{Number}

            */
            getStartSizeVar(): number;
            /**
            * {Number}
getStartSpin()
get initial angle of each particle
Returns:
{Number}

            */
            getStartSpin(): number;
            /**
            * {Number}
getStartSpinVar()
get initial angle variance of each particle
Returns:
{Number}

            */
            getStartSpinVar(): number;
            /**
            * {Number}
getTangentialAccel()
Return tangential acceleration of each particle. Only available in &#39;Gravity&#39; mode.
Returns:
{Number}

            */
            getTangentialAccel(): number;
            /**
            * {Number}
getTangentialAccelVar()
Return tangential acceleration variance of each particle. Only available in &#39;Gravity&#39; mode.
Returns:
{Number}

            */
            getTangentialAccelVar(): number;
            /**
            * {cc.Texture2D}
getTexture()
get Texture of Particle System
Returns:
{cc.Texture2D}

            */
            getTexture(): cc.Texture2D;
            /**
            * {Number}
getTotalParticles()
get maximum particles of the system
Returns:
{Number}

            */
            getTotalParticles(): number;
            /**
            * ignoreColor(ignore)
This is a hack function for performance, it&#39;s only available on Canvas mode.
It&#39;s very expensive to change color on Canvas mode, so if set it to true, particle system will ignore the changing color operation.
Parameters:
{boolean} ignore

            */
            ignoreColor(ignore?: boolean);
            /**
            * init()
initializes a cc.ParticleSystem

            */
            init();
            /**
            * initParticle(particle)
Initializes a particle
Parameters:
{cc.Particle} particle

            */
            initParticle(particle?: cc.Particle);
            /**
            * initTexCoordsWithRect(pointRect)
initializes the texture with a rectangle measured Points
pointRect should be in Texture coordinates, not pixel coordinates
Parameters:
{cc.Rect} pointRect

            */
            initTexCoordsWithRect(pointRect?: cc.Rect);
            /**
            * {Boolean}
initWithDictionary(dictionary, dirname)
initializes a particle system from a NSDictionary and the path from where to load the png
Parameters:
{object} dictionary
{String} dirname
Returns:
{Boolean}

            */
            initWithDictionary(dictionary?: any, dirname?: string): boolean;
            /**
            * {boolean}
initWithFile(plistFile)
initializes a CCParticleSystem from a plist file.
This plist files can be creted manually or with Particle Designer:
http://particledesigner.71squared.com/
Parameters:
{String} plistFile
Returns:
{boolean}

            */
            initWithFile(plistFile?: string): boolean;
            /**
            * {Boolean}
initWithTotalParticles(numberOfParticles)
Initializes a system with a fixed number of particles
Parameters:
{Number} numberOfParticles
Returns:
{Boolean}

            */
            initWithTotalParticles(numberOfParticles?: number): boolean;
            /**
            * {Boolean}
isActive()
Return ParticleSystem is active
Returns:
{Boolean}

            */
            isActive(): boolean;
            /**
            * {Boolean}
isAutoRemoveOnFinish()
return whether or not the node will be auto-removed when it has no particles left.
By default it is false.
Returns:
{Boolean}

            */
            isAutoRemoveOnFinish(): boolean;
            /**
            * {Boolean}
isBlendAdditive()
whether or not the particles are using blend additive.
If enabled, the following blending function will be used.
source blend function = GL_SRC_ALPHA;
dest blend function = GL_ONE;
Returns:
{Boolean}

            */
            isBlendAdditive(): boolean;
            /**
            * {Boolean}
isFull()
whether or not the system is full
Returns:
{Boolean}

            */
            isFull(): boolean;
            /**
            * {Boolean}
isOpacityModifyRGB()
does the alpha value modify color getter
Returns:
{Boolean}

            */
            isOpacityModifyRGB(): boolean;
            /**
            * listenBackToForeground(obj)
listen the event that coming to foreground on Android  (An empty function for native)
Parameters:
{cc.Class} obj

            */
            listenBackToForeground(obj?: cc.Class);
            /**
            * postStep()
should be overridden by subclasses

            */
            postStep();
            /**
            * resetSystem()
Kill all living particles.

            */
            resetSystem();
            /**
            * setAngle(angle)
angle of each particle setter
Parameters:
{Number} angle

            */
            setAngle(angle?: number);
            /**
            * setAngleVar(angleVar)
angle variance of each particle setter
Parameters:
angleVar

            */
            setAngleVar();
            /**
            * setAtlasIndex(atlasIndex)
set index of system in batch node array
Parameters:
{Number} atlasIndex

            */
            setAtlasIndex(atlasIndex?: number);
            /**
            * setAutoRemoveOnFinish(isAutoRemoveOnFinish)
set whether or not the node will be auto-removed when it has no particles left.
By default it is false.
Parameters:
{Boolean} isAutoRemoveOnFinish

            */
            setAutoRemoveOnFinish(isAutoRemoveOnFinish?: boolean);
            /**
            * setBatchNode(batchNode)
set weak reference to the cc.SpriteBatchNode that renders the cc.Sprite
Parameters:
{cc.ParticleBatchNode} batchNode

            */
            setBatchNode(batchNode?: cc.ParticleBatchNode);
            /**
            * setBlendAdditive(isBlendAdditive)
whether or not the particles are using blend additive.
If enabled, the following blending function will be used.
Parameters:
{Boolean} isBlendAdditive

            */
            setBlendAdditive(isBlendAdditive?: boolean);
            /**
            * setBlendFunc(src, dst)
set BlendFunc of Particle System
Parameters:
{Number} src
{Number} dst

            */
            setBlendFunc(src?: number, dst?: number);
            /**
            * setDisplayFrame(spriteFrame)
Sets a new CCSpriteFrame as particle.
WARNING: this method is experimental. Use setTextureWithRect instead.
Parameters:
{cc.SpriteFrame} spriteFrame

            */
            setDisplayFrame(spriteFrame?: cc.SpriteFrame);
            /**
            * setDrawMode(drawMode)
DrawMode of ParticleSystem setter   (Canvas Mode only)
Parameters:
{Number} drawMode

            */
            setDrawMode(drawMode?: number);
            /**
            * setDuration(duration)
set run seconds of the emitter
Parameters:
{Number} duration

            */
            setDuration(duration?: number);
            /**
            * setEmissionRate(emissionRate)
set emission rate of the particles
Parameters:
{Number} emissionRate

            */
            setEmissionRate(emissionRate?: number);
            /**
            * setEmitterMode(emitterMode)
Switch between different kind of emitter modes:
- CCParticleSystem.MODE_GRAVITY: uses gravity, speed, radial and tangential acceleration
- CCParticleSystem.MODE_RADIUS: uses radius movement + rotation
Parameters:
{Number} emitterMode

            */
            setEmitterMode(emitterMode?: number);
            /**
            * setEndColor(endColor)
set end color and end color variation of each particle
Parameters:
{cc.Color} endColor

            */
            setEndColor(endColor?: cc.Color);
            /**
            * setEndColorVar(endColorVar)
set end color variance of each particle
Parameters:
{cc.Color} endColorVar

            */
            setEndColorVar(endColorVar?: cc.Color);
            /**
            * setEndRadius(endRadius)
ending radius of the particles setter. Only available in &#39;Radius&#39; mode.
Parameters:
{Number} endRadius

            */
            setEndRadius(endRadius?: number);
            /**
            * setEndRadiusVar(endRadiusVar)
ending radius variance of the particles setter. Only available in &#39;Radius&#39; mode.
Parameters:
endRadiusVar

            */
            setEndRadiusVar();
            /**
            * setEndSize(endSize)
set end size in pixels of each particle
Parameters:
endSize

            */
            setEndSize();
            /**
            * setEndSizeVar(endSizeVar)
set end size variance in pixels of each particle
Parameters:
{Number} endSizeVar

            */
            setEndSizeVar(endSizeVar?: number);
            /**
            * setEndSpin(endSpin)
set end angle of each particle
Parameters:
{Number} endSpin

            */
            setEndSpin(endSpin?: number);
            /**
            * setEndSpinVar(endSpinVar)
set end angle variance of each particle
Parameters:
{Number} endSpinVar

            */
            setEndSpinVar(endSpinVar?: number);
            /**
            * setGravity(gravity)
Gravity of emitter setter
Parameters:
{cc.Point} gravity

            */
            setGravity(gravity?: cc.Point);
            /**
            * setLife(life)
life of each particle setter
Parameters:
{Number} life

            */
            setLife(life?: number);
            /**
            * setLifeVar(lifeVar)
life variance of each particle setter
Parameters:
{Number} lifeVar

            */
            setLifeVar(lifeVar?: number);
            /**
            * setOpacityModifyRGB(newValue)
does the alpha value modify color setter
Parameters:
newValue

            */
            setOpacityModifyRGB();
            /**
            * setParticleCount(particleCount)
Quantity of particles setter
Parameters:
{Number} particleCount

            */
            setParticleCount(particleCount?: number);
            /**
            * setPositionType(positionType)
set particles movement type: Free or Grouped
Parameters:
{Number} positionType

            */
            setPositionType(positionType?: number);
            /**
            * setPosVar(posVar)
Position variance of the emitter setter
Parameters:
{cc.Point} posVar

            */
            setPosVar(posVar?: cc.Point);
            /**
            * setRadialAccel(radialAccel)
radial acceleration of each particle setter. Only available in &#39;Gravity&#39; mode.
Parameters:
{Number} radialAccel

            */
            setRadialAccel(radialAccel?: number);
            /**
            * setRadialAccelVar(radialAccelVar)
radial acceleration variance of each particle setter. Only available in &#39;Gravity&#39; mode.
Parameters:
{Number} radialAccelVar

            */
            setRadialAccelVar(radialAccelVar?: number);
            /**
            * setRotatePerSecond(degrees)
set Number of degress to rotate a particle around the source pos per second. Only available in &#39;Radius&#39; mode.
Parameters:
{Number} degrees

            */
            setRotatePerSecond(degrees?: number);
            /**
            * setRotatePerSecondVar(degrees)
Variance in degrees for rotatePerSecond setter. Only available in &#39;Radius&#39; mode.
Parameters:
degrees

            */
            setRotatePerSecondVar();
            /**
            * setRotationIsDir(t)
set the rotation of each particle to its direction Only available in &#39;Gravity&#39; mode.
Parameters:
{boolean} t

            */
            setRotationIsDir(t?: boolean);
            /**
            * setShapeType(shapeType)
ShapeType of ParticleSystem setter  (Canvas Mode only)
Parameters:
{Number} shapeType

            */
            setShapeType(shapeType?: number);
            /**
            * setSourcePosition(sourcePosition)
sourcePosition of the emitter setter
Parameters:
sourcePosition

            */
            setSourcePosition();
            /**
            * setSpeed(speed)
Speed of each particle setter
Parameters:
{Number} speed

            */
            setSpeed(speed?: number);
            /**
            * setSpeedVar(speedVar)
speed variance of each particle setter. Only available in &#39;Gravity&#39; mode.
Parameters:
{Number} speedVar

            */
            setSpeedVar(speedVar?: number);
            /**
            * setStartColor(startColor)
get start color of each particle
Parameters:
{cc.Color} startColor

            */
            setStartColor(startColor?: cc.Color);
            /**
            * setStartColorVar(startColorVar)
set start color variance of each particle
Parameters:
{cc.Color} startColorVar

            */
            setStartColorVar(startColorVar?: cc.Color);
            /**
            * setStartRadius(startRadius)
starting radius of the particles setter. Only available in &#39;Radius&#39; mode.
Parameters:
{Number} startRadius

            */
            setStartRadius(startRadius?: number);
            /**
            * setStartRadiusVar(startRadiusVar)
starting radius variance of the particles setter. Only available in &#39;Radius&#39; mode.
Parameters:
{Number} startRadiusVar

            */
            setStartRadiusVar(startRadiusVar?: number);
            /**
            * setStartSize(startSize)
set start size in pixels of each particle
Parameters:
{Number} startSize

            */
            setStartSize(startSize?: number);
            /**
            * setStartSizeVar(startSizeVar)
set size variance in pixels of each particle
Parameters:
{Number} startSizeVar

            */
            setStartSizeVar(startSizeVar?: number);
            /**
            * setStartSpin(startSpin)
set initial angle of each particle
Parameters:
{Number} startSpin

            */
            setStartSpin(startSpin?: number);
            /**
            * setStartSpinVar(startSpinVar)
set initial angle variance of each particle
Parameters:
{Number} startSpinVar

            */
            setStartSpinVar(startSpinVar?: number);
            /**
            * setTangentialAccel(tangentialAccel)
Tangential acceleration of each particle setter. Only available in &#39;Gravity&#39; mode.
Parameters:
{Number} tangentialAccel

            */
            setTangentialAccel(tangentialAccel?: number);
            /**
            * setTangentialAccelVar(tangentialAccelVar)
tangential acceleration variance of each particle setter. Only available in &#39;Gravity&#39; mode.
Parameters:
{Number} tangentialAccelVar

            */
            setTangentialAccelVar(tangentialAccelVar?: number);
            /**
            * setTexture(texture)
set Texture of Particle System
Parameters:
{cc.Texture2D} texture

            */
            setTexture(texture?: cc.Texture2D);
            /**
            * setTextureWithRect(texture, rect)
Sets a new texture with a rect. The rect is in Points.
Parameters:
{cc.Texture2D} texture
{cc.Rect} rect

            */
            setTextureWithRect(texture?: cc.Texture2D, rect?: cc.Rect);
            /**
            * setTotalParticles(tp)
set maximum particles of the system
Parameters:
{Number} tp
totalParticles

            */
            setTotalParticles(tp?: number);
            /**
            * stopSystem()
stop emitting particles. Running particles will continue to run until they die

            */
            stopSystem();
            /**
            * update(dt)
update emitter&#39;s status
Parameters:
{Number} dt
delta time

            */
            update(dt?: number);
            /**
            * updateQuadWithParticle(particle, newPosition)
should be overridden by subclasses
Parameters:
{cc.Particle} particle
{cc.Point} newPosition

            */
            updateQuadWithParticle(particle?: cc.Particle, newPosition?: cc.Point);
            /**
            * updateWithNoTime()
update emitter&#39;s status (dt = 0)

            */
            updateWithNoTime();
        }
    }
declare module cc.ParticleSystem {
        /**
        * 
Mode A:Gravity + Tangential Accel + Radial Accel

        */
        export class ModeA  {
            /**
            * Mode A:Gravity + Tangential Accel + Radial Accel
            */
            constructor(gravity?: cc.Point, speed?: number, speedVar?: number, tangentialAccel?: number, tangentialAccelVar?: number, radialAccel?: number, radialAccelVar?: number, rotationIsDir?: boolean);
            /**
            * Gravity value.
            */
            gravity;
            /**
            * radial acceleration of each particle.
            */
            radialAccel;
            /**
            * radial acceleration variance of each particle.
            */
            radialAccelVar;
            /**
            * set the rotation of each particle to its direction Only available in &#39;Gravity&#39; mode.
            */
            rotationIsDir;
            /**
            * speed of each particle.
            */
            speed;
            /**
            * speed variance of each particle.
            */
            speedVar;
            /**
            * tangential acceleration of each particle.
            */
            tangentialAccel;
            /**
            * tangential acceleration variance of each particle.
            */
            tangentialAccelVar;
        }
    }
declare module cc.ParticleSystem {
        /**
        * 
Mode B: circular movement (gravity, radial accel and tangential accel don&#39;t are not used in this mode)

        */
        export class ModeB  {
            /**
            * Mode B: circular movement (gravity, radial accel and tangential accel don&#39;t are not used in this mode)
            */
            constructor(startRadius?: number, startRadiusVar?: number, endRadius?: number, endRadiusVar?: number, rotatePerSecond?: number, rotatePerSecondVar?: number);
            /**
            * The ending radius of the particles.
            */
            endRadius;
            /**
            * The ending radius variance of the particles.
            */
            endRadiusVar;
            /**
            * Number of degress to rotate a particle around the source pos per second.
            */
            rotatePerSecond;
            /**
            * Variance in degrees for rotatePerSecond.
            */
            rotatePerSecondVar;
            /**
            * The starting radius of the particles.
            */
            startRadius;
            /**
            * The starting radius variance of the particles.
            */
            startRadiusVar;
        }
    }
declare module cc {
        /**
        * 
        */
        export class path  {
            /**
            * 
            */
            constructor();
            /**
            * {*}
basename(pathStr, extname)
Get the file name of a file path.
cc.path.basename(&quot;a/b.png&quot;);//--&gt;&quot;b.png&quot;
cc.path.basename(&quot;a/b.png?a=1&amp;b=2&quot;);//--&gt;&quot;b.png&quot;
cc.path.basename(&quot;a/b.png&quot;, &quot;.png&quot;);//--&gt;&quot;b&quot;
cc.path.basename(&quot;a/b.png?a=1&amp;b=2&quot;, &quot;.png&quot;);//--&gt;&quot;b&quot;
cc.path.basename(&quot;a/b.png&quot;, &quot;.txt&quot;);//--&gt;&quot;b.png&quot;
Parameters:
{string} pathStr
{string} extname
Optional
Returns:
{*}

            */
            basename(pathStr?: string, extname?: string): any;
            /**
            * {string}
changeBasename(pathStr, basename, isSameExt)
Change file name of a file path.
cc.path.changeBasename(&quot;a/b/c.plist&quot;, &quot;b.plist&quot;);//--&gt;&quot;a/b/b.plist&quot;
cc.path.changeBasename(&quot;a/b/c.plist?a=1&amp;b=2&quot;, &quot;b.plist&quot;);//--&gt;&quot;a/b/b.plist?a=1&amp;b=2&quot;
cc.path.changeBasename(&quot;a/b/c.plist&quot;, &quot;.png&quot;);//--&gt;&quot;a/b/c.png&quot;
cc.path.changeBasename(&quot;a/b/c.plist&quot;, &quot;b&quot;);//--&gt;&quot;a/b/b&quot;
cc.path.changeBasename(&quot;a/b/c.plist&quot;, &quot;b&quot;, true);//--&gt;&quot;a/b/b.plist&quot;
Parameters:
{String} pathStr
{String} basename
{Boolean} isSameExt
Optional
Returns:
{string}

            */
            changeBasename(pathStr?: string, basename?: string, isSameExt?: boolean): string;
            /**
            * {string}
changeExtname(pathStr, extname)
Change extname of a file path.
cc.path.changeExtname(&quot;a/b.png&quot;, &quot;.plist&quot;);//--&gt;&quot;a/b.plist&quot;
cc.path.changeExtname(&quot;a/b.png?a=1&amp;b=2&quot;, &quot;.plist&quot;);//--&gt;&quot;a/b.plist?a=1&amp;b=2&quot;
Parameters:
{string} pathStr
{string} extname
Optional
Returns:
{string}

            */
            changeExtname(pathStr?: string, extname?: string): string;
            /**
            * {*}
dirname(pathStr)
Get dirname of a file path.
unix
cc.path.driname(&quot;a/b/c.png&quot;);//--&gt;&quot;a/b&quot;
cc.path.driname(&quot;a/b/c.png?a=1&amp;b=2&quot;);//--&gt;&quot;a/b&quot;
cc.path.dirname(&quot;a/b/&quot;);//--&gt;&quot;a/b&quot;
cc.path.dirname(&quot;c.png&quot;);//--&gt;&quot;&quot;
windows
cc.path.driname(&quot;a\\b\\c.png&quot;);//--&gt;&quot;a\b&quot;
cc.path.driname(&quot;a\\b\\c.png?a=1&amp;b=2&quot;);//--&gt;&quot;a\b&quot;
Parameters:
{string} pathStr
Returns:
{*}

            */
            dirname(pathStr?: string): any;
            /**
            * {*}
extname(pathStr)
Get the ext name of a path.
cc.path.extname(&quot;a/b.png&quot;);//--&gt;&quot;.png&quot;
cc.path.extname(&quot;a/b.png?a=1&amp;b=2&quot;);//--&gt;&quot;.png&quot;
cc.path.extname(&quot;a/b&quot;);//--&gt;null
cc.path.extname(&quot;a/b?a=1&amp;b=2&quot;);//--&gt;null
Parameters:
{string} pathStr
Returns:
{*}

            */
            extname(pathStr?: string): any;
            /**
            * {string}
join()
Join strings to be a path.
cc.path.join(&quot;a&quot;, &quot;b.png&quot;);//--&gt;&quot;a/b.png&quot;
cc.path.join(&quot;a&quot;, &quot;b&quot;, &quot;c.png&quot;);//--&gt;&quot;a/b/c.png&quot;
cc.path.join(&quot;a&quot;, &quot;b&quot;);//--&gt;&quot;a/b&quot;
cc.path.join(&quot;a&quot;, &quot;b&quot;, &quot;/&quot;);//--&gt;&quot;a/b/&quot;
cc.path.join(&quot;a&quot;, &quot;b/&quot;, &quot;/&quot;);//--&gt;&quot;a/b/&quot;
Returns:
{string}

            */
            join(): string;
            /**
            * {string}
mainFileName(fileName)
Get the main name of a file name
Parameters:
{string} fileName
Returns:
{string}

            */
            mainFileName(fileName?: string): string;
        }
    }
declare module cc {
        /**
        * 
Places the node in a certain position

        */
        export class Place extends cc.ActionInstant {
            /**
            * Places the node in a certain position
            */
            constructor(pos?: any, y?: number);
            /**
            * Please use cc.place instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Place;
            /**
            * {cc.Place}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.Place}

            */
            clone(): cc.Place;
            /**
            * ctor(pos, y)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates a Place action with a position.
Parameters:
{cc.Point|Number} pos
{Number} y
Optional

            */
            ctor(pos?: any, y?: number);
            /**
            * {Boolean}
initWithPosition(x, y)
Initializes a Place action with a position
Parameters:
{number} x
{number} y
Returns:
{Boolean}

            */
            initWithPosition(x?: number, y?: number): boolean;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.plistParser is a singleton object for parsing plist files

        */
        export class plistParser  {
            /**
            * cc.plistParser is a singleton object for parsing plist files
            */
            constructor();
            /**
            * {*}
parse(xmlTxt)
parse a xml string as plist object.
Parameters:
{String} xmlTxt
plist xml contents
Returns:
{*} plist object

            */
            parse(xmlTxt?: string): any;
        }
    }
declare module cc {
        /**
        * 
cc.Point is the class for point object, please do not use its constructor to create points, use cc.p() alias function instead.

        */
        export class Point  {
            /**
            * cc.Point is the class for point object, please do not use its constructor to create points, use cc.p() alias function instead.
            */
            constructor(x?: number, y?: number);
        }
    }
declare module cc {
        /**
        * 
Parallax Object.
Parallax required attributes are stored.

        */
        export class PointObject extends cc.Class {
            /**
            * Parallax Object.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.PointObject}
cc.PointObject.create(ratio, offset)
Create a object to stored parallax data.
Parameters:
{cc.Point} ratio
{cc.Point} offset
Deprecated:
since v3.0 please use new cc.PointObject() instead.
Returns:
{cc.PointObject}

            */
            static create(ratio?: cc.Point, offset?: cc.Point): cc.PointObject;
            /**
            * {cc.Node}
getChild()
Gets the child.
Returns:
{cc.Node}

            */
            getChild(): cc.Node;
            /**
            * {cc.Point}
getOffset()
Gets the offset.
Returns:
{cc.Point}

            */
            getOffset(): cc.Point;
            /**
            * {cc.Point}
getRatio()
Gets the ratio.
Returns:
{cc.Point} Not point, this is ratio.

            */
            getRatio(): cc.Point;
            /**
            * {Boolean}
initWithCCPoint(ratio, offset)
initializes cc.PointObject
Parameters:
{cc.Point} ratio
Not point, this is a ratio.
{cc.Point} offset
Returns:
{Boolean}

            */
            initWithCCPoint(ratio?: cc.Point, offset?: cc.Point): boolean;
            /**
            * setChild(value)
Set the child.
Parameters:
{cc.Node} value

            */
            setChild(value?: cc.Node);
            /**
            * setOffset(value)
Set the offset.
Parameters:
{cc.Point} value

            */
            setOffset(value?: cc.Point);
            /**
            * setRatio(value)
Set the ratio.
Parameters:
{cc.Point} value

            */
            setRatio(value?: cc.Point);
        }
    }
declare module cc {
        /**
        * cc.pool is a singleton object serves as an object cache pool.
It can helps you to improve your game performance for objects which need frequent release and recreate operations
Some common use case is :
1. Bullets in game (die very soon, massive creation and recreation, no side effect on other objects)
2. Blocks in candy crash (massive creation and recreation)
etc...

        */
        export class pool  {
            /**
            * 
cc.pool is a singleton object serves as an object cache pool.
            */
            constructor();
            /**
            * drainAllPools()
remove all objs in pool and reset the pool

            */
            drainAllPools();
            /**
            * {*}
getFromPool(args)
Get the obj from pool
Parameters:
args
Returns:
{*} call the reuse function an return the obj

            */
            getFromPool(): any;
            /**
            * {boolean}
hasObject(objClass)
Check if this kind of obj has already in pool
Parameters:
objClass
Returns:
{boolean} if this kind of obj is already in pool return true,else return false;

            */
            hasObject(): boolean;
            /**
            * putInPool(obj)
Put the obj in pool
Parameters:
obj

            */
            putInPool();
            /**
            * removeObject(obj)
Remove the obj if you want to delete it;
Parameters:
obj

            */
            removeObject();
        }
    }
declare module cc {
        /**
        * 
Progress from a percentage to another percentage

        */
        export class ProgressFromTo extends cc.ActionInterval {
            /**
            * Progress from a percentage to another percentage
            */
            constructor(duration?: number, fromPercentage?: number, toPercentage?: number);
            /**
            * Creates and initializes the action with a duration, a &quot;from&quot; percentage and a &quot;to&quot; percentage
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ProgressFromTo;
            /**
            * {cc.ProgressFromTo}
clone()
return a new cc.ProgressTo, all the configuration is the same as the original
Returns:
{cc.ProgressFromTo}

            */
            clone(): cc.ProgressFromTo;
            /**
            * ctor(duration, fromPercentage, toPercentage)
Creates and initializes the action with a duration, a &quot;from&quot; percentage and a &quot;to&quot; percentage
Constructor of cc.ProgressFromTo
Parameters:
{Number} duration
duration in seconds
{Number} fromPercentage
{Number} toPercentage

            */
            ctor(duration?: number, fromPercentage?: number, toPercentage?: number);
            /**
            * {Boolean}
initWithDuration(duration, fromPercentage, toPercentage)
Initializes the action with a duration, a &quot;from&quot; percentage and a &quot;to&quot; percentage
Parameters:
{Number} duration
duration in seconds
{Number} fromPercentage
{Number} toPercentage
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, fromPercentage?: number, toPercentage?: number): boolean;
            /**
            * {cc.ActionInterval}
reverse()
Returns:
{cc.ActionInterval}

            */
            reverse(): cc.ActionInterval;
            /**
            * startWithTarget(target)
start with a target
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(time)
Parameters:
{Number} time
time in seconds

            */
            update(time?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Progresstimer is a subclass of cc.Node.
It renders the inner sprite according to the percentage.
The progress can be Radial, Horizontal or vertical.

        */
        export class ProgressTimer extends cc.Node {
            /**
            * cc.Progresstimer is a subclass of cc.Node.
            */
            constructor();
            /**
            * - This allows the bar type to move the component at a specific rate.
            */
            barChangeRate: cc.Point;
            /**
            * - Midpoint is used to modify the progress start position.
            */
            midPoint: cc.Point;
            /**
            * - Percentage to change progress, from 0 to 100.
            */
            percentage: number;
            /**
            * - Indicate whether the direction is reversed.
            */
            reverseDir: boolean;
            /**
            * - The sprite to show the progress percentage.
            */
            sprite: cc.Sprite;
            /**
            * 
            */
            static TEXTURE_COORDS: number;
            /**
            * 
            */
            static TEXTURE_COORDS_COUNT: number;
            /**
            * - Type of the progress timer: cc.ProgressTimer.TYPE_RADIAL|cc.ProgressTimer.TYPE_BAR.
            */
            type: any;
            /**
            * Bar
            */
            static TYPE_BAR: number;
            /**
            * Radial Counter-Clockwise
            */
            static TYPE_RADIAL: number;
            /**
            * &amp;lt;static&amp;gt;
{cc.ProgressTimer}
cc.ProgressTimer.create(sprite)
create a progress timer object with image file name that renders the inner sprite according to the percentage
Parameters:
{cc.Sprite} sprite
Deprecated:
since v3.0,please use new cc.ProgressTimer(sprite) instead.
Returns:
{cc.ProgressTimer}

            */
            static create(sprite?: cc.Sprite): cc.ProgressTimer;
            /**
            * ctor(sprite)
constructor of cc.cc.ProgressTimer
Parameters:
{cc.Sprite} sprite

            */
            ctor(sprite?: cc.Sprite);
            /**
            * {cc.Point}
getBarChangeRate()
This allows the bar type to move the component at a specific rate
Set the component to 0 to make sure it stays at 100%.
For example you want a left to right bar but not have the height stay 100%
Set the rate to be cc.p(0,1); and set the midpoint to = cc.p(0,.5f);
Returns:
{cc.Point}

            */
            getBarChangeRate(): cc.Point;
            /**
            * {cc.Color}
getColor()
return color of sprite
Returns:
{cc.Color}

            */
            getColor(): cc.Color;
            /**
            * {cc.Point}
getMidpoint()
Midpoint is used to modify the progress start position.
If you&#39;re using radials type then the midpoint changes the center point
If you&#39;re using bar type the the midpoint changes the bar growth
it expands from the center but clamps to the sprites edge so:
you want a left to right then set the midpoint all the way to cc.p(0,y)
you want a right to left then set the midpoint all the way to cc.p(1,y)
you want a bottom to top then set the midpoint all the way to cc.p(x,0)
you want a top to bottom then set the midpoint all the way to cc.p(x,1)
Returns:
{cc.Point}

            */
            getMidpoint(): cc.Point;
            /**
            * {Number}
getOpacity()
return Opacity of sprite
Returns:
{Number}

            */
            getOpacity(): number;
            /**
            * {Number}
getPercentage()
Percentages are from 0 to 100
Returns:
{Number}

            */
            getPercentage(): number;
            /**
            * {cc.Sprite}
getSprite()
The image to show the progress percentage, retain
Returns:
{cc.Sprite}

            */
            getSprite(): cc.Sprite;
            /**
            * {cc.ProgressTimer.TYPE_RADIAL|cc.ProgressTimer.TYPE_BAR}
getType()
Change the percentage to change progress
Returns:
{cc.ProgressTimer.TYPE_RADIAL|cc.ProgressTimer.TYPE_BAR}

            */
            getType(): any;
            /**
            * {Boolean}
initWithSprite(sprite)
Initializes a progress timer with the sprite as the shape the timer goes through
Parameters:
{cc.Sprite} sprite
Returns:
{Boolean}

            */
            initWithSprite(sprite?: cc.Sprite): boolean;
            /**
            * {boolean}
isOpacityModifyRGB()
only use for jsbinding
Returns:
{boolean}

            */
            isOpacityModifyRGB(): boolean;
            /**
            * {boolean}
isReverseDirection()
return if reverse direction
Returns:
{boolean}

            */
            isReverseDirection(): boolean;
            /**
            * setBarChangeRate(barChangeRate)
Parameters:
{cc.Point} barChangeRate

            */
            setBarChangeRate(barChangeRate?: cc.Point);
            /**
            * setColor(color)
set color of sprite
Parameters:
{cc.Color} color

            */
            setColor(color?: cc.Color);
            /**
            * setMidpoint(mpoint)
Midpoint setter
Parameters:
{cc.Point} mpoint

            */
            setMidpoint(mpoint?: cc.Point);
            /**
            * setOpacity(opacity)
set opacity of sprite
Parameters:
{Number} opacity

            */
            setOpacity(opacity?: number);
            /**
            * setOpacityModifyRGB(bValue)
only use for jsbinding
Parameters:
bValue

            */
            setOpacityModifyRGB();
            /**
            * setPercentage(percentage)
from 0-100
Parameters:
{Number} percentage

            */
            setPercentage(percentage?: number);
            /**
            * setReverseDirection(reverse)
Reverse Progress setter
Parameters:
{Boolean} reverse

            */
            setReverseDirection(reverse?: boolean);
            /**
            * setReverseProgress(reverse)
set reverse cc.ProgressTimer
Parameters:
{Boolean} reverse

            */
            setReverseProgress(reverse?: boolean);
            /**
            * setSprite(sprite)
set sprite for cc.ProgressTimer
Parameters:
{cc.Sprite} sprite

            */
            setSprite(sprite?: cc.Sprite);
            /**
            * setType(type)
set Progress type of cc.ProgressTimer
Parameters:
{cc.ProgressTimer.TYPE_RADIAL|cc.ProgressTimer.TYPE_BAR} type

            */
            setType(type?: any);
        }
    }
declare module cc {
        /**
        * 
Progress to percentage

        */
        export class ProgressTo extends cc.ActionInterval {
            /**
            * Progress to percentage
            */
            constructor(duration?: number, percent?: number);
            /**
            * Please use cc.progressTo instead
Creates and initializes with a duration and a percent
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ProgressTo;
            /**
            * {cc.ProgressTo}
clone()
return a new cc.ProgressTo, all the configuration is the same as the original
Returns:
{cc.ProgressTo}

            */
            clone(): cc.ProgressTo;
            /**
            * ctor(duration, percent)
Creates a ProgressTo action with a duration and a percent
Constructor of cc.ProgressTo
Parameters:
{Number} duration
duration in seconds
{Number} percent

            */
            ctor(duration?: number, percent?: number);
            /**
            * {Boolean}
initWithDuration(duration, percent)
Initializes with a duration and a percent
Parameters:
{Number} duration
duration in seconds
{Number} percent
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, percent?: number): boolean;
            /**
            * {null}
reverse()
reverse hasn&#39;t been supported
Returns:
{null}

            */
            reverse(): void;
            /**
            * startWithTarget(target)
start with a target
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(time)
custom update
Parameters:
{Number} time
time in seconds

            */
            update(time?: number);
        }
    }
declare module cc {
        /**
        * 
A class inhert from cc.Node, use for saving some protected children in other list.

        */
        export class ProtectedNode extends cc.Node {
            /**
            * A class inhert from cc.Node, use for saving some protected children in other list.
            */
            constructor();
            /**
            * addProtectedChild(child, localZOrder, tag)
Adds a child to the container with z order and tag
If the child is added to a &#39;running&#39; node, then &#39;onEnter&#39; and &#39;onEnterTransitionDidFinish&#39; will be called immediately.
Parameters:
{cc.Node} child
A child node
{Number} localZOrder
Optional
Z order for drawing priority. Please refer to `setLocalZOrder(int)`
{Number} tag
Optional
An integer to identify the node easily. Please refer to `setTag(int)`

            */
            addProtectedChild(child?: cc.Node, localZOrder?: number, tag?: number);
            /**
            * cleanup()
Stops itself and its children and protected children&#39;s all running actions and schedulers

            */
            cleanup();
            /**
            * &amp;lt;static&amp;gt;
cc.ProtectedNode.create()
create a cc.ProtectedNode object;
Deprecated:
since v3.0, please use new cc.ProtectedNode() instead.
Returns:
cc.ProtectedNode

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ProtectedNode;
            /**
            * ctor()
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {cc.Node}
getProtectedChildByTag(tag)
Gets a child from the container with its tag
Parameters:
{Number} tag
An identifier to find the child node.
Returns:
{cc.Node} a Node object whose tag equals to the input parameter

            */
            getProtectedChildByTag(tag?: number): cc.Node;
            /**
            * onEnter()
Calls its parent&#39;s onEnter and calls its protected children&#39;s onEnter

            */
            onEnter();
            /**
            * onEnterTransitionDidFinish()
Event callback that is invoked when the Node enters in the &#39;stage&#39;.
If the Node enters the &#39;stage&#39; with a transition, this event is called when the transition finishes.
If you override onEnterTransitionDidFinish, you shall call its parent&#39;s one, e.g. Node::onEnterTransitionDidFinish()

            */
            onEnterTransitionDidFinish();
            /**
            * onExit()
Calls its parent&#39;s onExit and calls its protected children&#39;s onExit

            */
            onExit();
            /**
            * onExitTransitionDidStart()
Event callback that is called every time the Node leaves the &#39;stage&#39;.
If the Node leaves the &#39;stage&#39; with a transition, this callback is called when the transition starts.

            */
            onExitTransitionDidStart();
            /**
            * removeAllProtectedChildren()
Removes all children from the container with a cleanup.
See:
cc.ProtectedNode#removeAllProtectedChildrenWithCleanup

            */
            removeAllProtectedChildren();
            /**
            * removeAllProtectedChildrenWithCleanup(cleanup)
Removes all children from the container, and do a cleanup to all running actions depending on the cleanup parameter.
Parameters:
{Boolean} cleanup
Optional, Default: true
true if all running actions on all children nodes should be cleanup, false otherwise.

            */
            removeAllProtectedChildrenWithCleanup(cleanup?: boolean);
            /**
            * removeProtectedChild(child, cleanup)
Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter.
Parameters:
{cc.Node} child
The child node which will be removed.
{Boolean} cleanup
Optional, Default: true
true if all running actions and callbacks on the child node will be cleanup, false otherwise.

            */
            removeProtectedChild(child?: cc.Node, cleanup?: boolean);
            /**
            * removeProtectedChildByTag(tag, cleanup)
Removes a child from the container by tag value.
It will also cleanup all running actions depending on the cleanup parameter
Parameters:
{Number} tag
{Boolean} cleanup
Optional, Default: true

            */
            removeProtectedChildByTag(tag?: number, cleanup?: boolean);
            /**
            * reorderProtectedChild(child, localZOrder)
Reorders a child according to a new z value.
Parameters:
{cc.Node} child
An already added child node. It MUST be already added.
{Number} localZOrder
Z order for drawing priority. Please refer to setLocalZOrder(int)

            */
            reorderProtectedChild(child?: cc.Node, localZOrder?: number);
            /**
            * sortAllProtectedChildren()
Sorts the children array once before drawing, instead of every time when a child is added or reordered.
This approach can improves the performance massively.

            */
            sortAllProtectedChildren();
            /**
            * visit(ctx)
transforms and draws itself, and visit its children and protected children.
Parameters:
{CanvasRenderingContext2D|WebGLRenderingContext} ctx
context of renderer

            */
            visit(ctx?: any);
        }
    }
declare module cc {
        /**
        * 
cc.Rect is the class for rect object, please do not use its constructor to create rects, use cc.rect() alias function instead.

        */
        export class Rect  {
            /**
            * cc.Rect is the class for rect object, please do not use its constructor to create rects, use cc.rect() alias function instead.
            */
            constructor(width?: number, height?: number);
        }
    }
declare module cc {
        /**
        * 
Delete self in the next frame.

        */
        export class RemoveSelf extends cc.ActionInstant {
            /**
            * Delete self in the next frame.
            */
            constructor(isNeedCleanUp?: boolean);
            /**
            * Please use cc.removeSelf instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.RemoveSelf;
        }
    }
declare module cc {
        /**
        * 
cc.RenderTexture is a generic rendering target. To render things into it,
simply construct a render target, call begin on it, call visit on any cocos
scenes or objects to render them, and call end. For convenience, render texture
adds a sprite as it&#39;s display child with the results, so you can simply add
the render texture to your scene and treat it like any other CocosNode.
There are also functions for saving the render texture to disk in PNG or JPG format.

        */
        export class RenderTexture extends cc.Node {
            /**
            * cc.RenderTexture is a generic rendering target.
            */
            constructor();
            /**
            * - Indicate auto draw mode activate or not.
            */
            autoDraw: boolean;
            /**
            * - Clear color value, valid only when &quot;autoDraw&quot; is true.
            */
            clearColorVal: cc.Color;
            /**
            * - Clear depth value.
            */
            clearDepthVal: number;
            /**
            * - Code for &quot;auto&quot; update.
            */
            clearFlags: cc.Sprite;
            /**
            * - Clear stencil value.
            */
            clearStencilVal: number;
            /**
            * - The sprite.
            */
            sprite: cc.Sprite;
            /**
            * begin()
starts grabbing

            */
            begin();
            /**
            * beginWithClear(r, g, b, a, depthValue, stencilValue)
starts rendering to the texture while clearing the texture first.
This is more efficient then calling -clear first and then -begin
Parameters:
{Number} r
red 0-255
{Number} g
green 0-255
{Number} b
blue 0-255
{Number} a
alpha 0-255 0 is transparent
{Number} depthValue
Optional
{Number} stencilValue
Optional

            */
            beginWithClear(r?: number, g?: number, b?: number, a?: number, depthValue?: number, stencilValue?: number);
            /**
            * cleanup()
Clear RenderTexture.

            */
            cleanup();
            /**
            * clear(r, g, b, a)
clears the texture with a color
Parameters:
{Number|cc.Rect} r
red 0-1
{Number} g
green 0-1
{Number} b
blue 0-1
{Number} a
alpha 0-1

            */
            clear(r?: any, g?: number, b?: number, a?: number);
            /**
            * clearDepth(depthValue)
clears the texture with a specified depth value
Parameters:
{Number} depthValue

            */
            clearDepth(depthValue?: number);
            /**
            * clearRect(x, y, width, height)
clears the texture with rect.
Parameters:
{number} x
{number} y
{number} width
{number} height

            */
            clearRect(x?: number, y?: number, width?: number, height?: number);
            /**
            * clearStencil(stencilValue)
clears the texture with a specified stencil value
Parameters:
{Number} stencilValue

            */
            clearStencil(stencilValue?: number);
            /**
            * &amp;lt;static&amp;gt;
{cc.RenderTexture}
cc.RenderTexture.create(width, height, format, depthStencilFormat)
creates a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid
Parameters:
{Number} width
{Number} height
{cc.IMAGE_FORMAT_JPEG|cc.IMAGE_FORMAT_PNG|cc.IMAGE_FORMAT_RAWDATA} format
{Number} depthStencilFormat
Deprecated:
since v3.0 please use new cc.RenderTexture() instead.
Returns:
{cc.RenderTexture}

            */
            static create(width?: number, height?: number, format?: any, depthStencilFormat?: number): cc.RenderTexture;
            /**
            * ctor(width, height, format, depthStencilFormat)
creates a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid
Constructor of cc.RenderTexture for Canvas
// Example
var rt = new cc.RenderTexture(width, height, format, depthStencilFormat)
Parameters:
{Number} width
{Number} height
{cc.IMAGE_FORMAT_JPEG|cc.IMAGE_FORMAT_PNG|cc.IMAGE_FORMAT_RAWDATA} format
{Number} depthStencilFormat

            */
            ctor(width?: number, height?: number, format?: any, depthStencilFormat?: number);
            /**
            * end()
ends grabbing

            */
            end();
            /**
            * {cc.Color}
getClearColor()
Clear color value. Valid only when &quot;autoDraw&quot; is true.
Returns:
{cc.Color}

            */
            getClearColor(): cc.Color;
            /**
            * {Number}
getClearDepth()
Value for clearDepth. Valid only when autoDraw is true.
Returns:
{Number}

            */
            getClearDepth(): number;
            /**
            * {Number}
getClearFlags()
Valid flags: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT. They can be OR&#39;ed. Valid when &quot;autoDraw is YES.
Returns:
{Number}

            */
            getClearFlags(): number;
            /**
            * {Number}
getClearStencil()
Value for clear Stencil. Valid only when autoDraw is true
Returns:
{Number}

            */
            getClearStencil(): number;
            /**
            * {cc.Sprite}
getSprite()
Gets the sprite
Returns:
{cc.Sprite}

            */
            getSprite(): cc.Sprite;
            /**
            * {Boolean}
initWithWidthAndHeight(width, height, format, depthStencilFormat)
Initializes the instance of cc.RenderTexture
Parameters:
{Number} width
{Number} height
{cc.IMAGE_FORMAT_JPEG|cc.IMAGE_FORMAT_PNG|cc.IMAGE_FORMAT_RAWDATA} format
Optional
{Number} depthStencilFormat
Optional
Returns:
{Boolean}

            */
            initWithWidthAndHeight(width?: number, height?: number, format?: any, depthStencilFormat?: number): boolean;
            /**
            * {Boolean}
isAutoDraw()
When enabled, it will render its children into the texture automatically. Disabled by default for compatiblity reasons.
Will be enabled in the future.
Returns:
{Boolean}

            */
            isAutoDraw(): boolean;
            /**
            * listenToBackground(obj)
Listen &quot;come to background&quot; message, and save render texture. It only has effect on Android.
Parameters:
{cc.Class} obj

            */
            listenToBackground(obj?: cc.Class);
            /**
            * listenToForeground(obj)
Listen &quot;come to foreground&quot; message and restore the frame buffer object. It only has effect on Android.
Parameters:
{cc.Class} obj

            */
            listenToForeground(obj?: cc.Class);
            /**
            * {*}
newCCImage(flipImage)
creates a new CCImage from with the texture&#39;s data. Caller is responsible for releasing it by calling delete.
Parameters:
flipImage
Returns:
{*}

            */
            newCCImage(): any;
            /**
            * saveToFile(filePath, format)
saves the texture into a file using JPEG format. The file will be saved in the Documents folder.
Returns YES if the operation is successful.
(doesn&#39;t support in HTML5)
Parameters:
{Number} filePath
{Number} format

            */
            saveToFile(filePath?: number, format?: number);
            /**
            * {Boolean}
setAutoDraw(autoDraw)
When enabled, it will render its children into the texture automatically. Disabled by default for compatiblity reasons.
Will be enabled in the future.
Parameters:
autoDraw
Returns:
{Boolean}

            */
            setAutoDraw(): boolean;
            /**
            * setClearColor(clearColor)
Set the clear color value. Valid only when &quot;autoDraw&quot; is true.
Parameters:
{cc.Color} clearColor
The clear color

            */
            setClearColor(clearColor?: cc.Color);
            /**
            * setClearDepth(clearDepth)
Set value for clearDepth. Valid only when autoDraw is true.
Parameters:
{Number} clearDepth

            */
            setClearDepth(clearDepth?: number);
            /**
            * setClearFlags(clearFlags)
Set the clearFlags
Parameters:
{Number} clearFlags

            */
            setClearFlags(clearFlags?: number);
            /**
            * {Number}
setClearStencil(clearStencil)
Set value for clear Stencil. Valid only when autoDraw is true
Parameters:
clearStencil
Returns:
{Number}

            */
            setClearStencil(): number;
            /**
            * setSprite(sprite)
Set the sprite
Parameters:
{cc.Sprite} sprite

            */
            setSprite(sprite?: cc.Sprite);
        }
    }
declare module cc {
        /**
        * 
Repeats an action a number of times.
To repeat an action forever use the CCRepeatForever action.

        */
        export class Repeat extends cc.ActionInterval {
            /**
            * Repeats an action a number of times.
            */
            constructor(action?: cc.FiniteTimeAction, times?: number);
            /**
            * Please use cc.repeat instead
Creates a Repeat action.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Repeat;
            /**
            * {cc.Repeat}
clone()
returns a new clone of the action
Returns:
{cc.Repeat}

            */
            clone(): cc.Repeat;
            /**
            * ctor(action, times)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates a Repeat action. Times is an unsigned integer between 1 and pow(2,30).
Parameters:
{cc.FiniteTimeAction} action
{Number} times

            */
            ctor(action?: cc.FiniteTimeAction, times?: number);
            /**
            * {cc.FiniteTimeAction}
getInnerAction()
Get inner Action.
Returns:
{cc.FiniteTimeAction}

            */
            getInnerAction(): cc.FiniteTimeAction;
            /**
            * {Boolean}
initWithAction(action, times)
Parameters:
{cc.FiniteTimeAction} action
{Number} times
Returns:
{Boolean}

            */
            initWithAction(action?: cc.FiniteTimeAction, times?: number): boolean;
            /**
            * {Boolean}
isDone()
Return true if the action has finished.
Returns:
{Boolean}

            */
            isDone(): boolean;
            /**
            * {cc.Repeat}
reverse()
returns a reversed action.
Returns:
{cc.Repeat}

            */
            reverse(): cc.Repeat;
            /**
            * setInnerAction(action)
Set inner Action.
Parameters:
{cc.FiniteTimeAction} action

            */
            setInnerAction(action?: cc.FiniteTimeAction);
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * stop()
stop the action

            */
            stop();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Repeats an action for ever.
To repeat the an action for a limited number of times use the Repeat action.

        */
        export class RepeatForever extends cc.ActionInterval {
            /**
            * Repeats an action for ever.
            */
            constructor(action?: cc.FiniteTimeAction);
            /**
            * Please use cc.repeatForever instead
Create a acton which repeat forever
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.RepeatForever;
            /**
            * {cc.RepeatForever}
clone()
returns a new clone of the action
Returns:
{cc.RepeatForever}

            */
            clone(): cc.RepeatForever;
            /**
            * ctor(action)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a acton which repeat forever.
Parameters:
{cc.FiniteTimeAction} action

            */
            ctor(action?: cc.FiniteTimeAction);
            /**
            * {cc.ActionInterval}
getInnerAction()
Get inner action.
Returns:
{cc.ActionInterval}

            */
            getInnerAction(): cc.ActionInterval;
            /**
            * {Boolean}
initWithAction(action)
Parameters:
{cc.ActionInterval} action
Returns:
{Boolean}

            */
            initWithAction(action?: cc.ActionInterval): boolean;
            /**
            * {Boolean}
isDone()
Return true if the action has finished.
Returns:
{Boolean}

            */
            isDone(): boolean;
            /**
            * {cc.RepeatForever}
reverse()
Returns a reversed action.
Returns:
{cc.RepeatForever}

            */
            reverse(): cc.RepeatForever;
            /**
            * setInnerAction(action)
Set inner action.
Parameters:
{cc.ActionInterval} action

            */
            setInnerAction(action?: cc.ActionInterval);
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * step(dt)
called every frame with it&#39;s delta time.
DON&#39;T override unless you know what you are doing.
Parameters:
dt
delta time in seconds

            */
            step();
        }
    }
declare module cc {
        /**
        * 
cc.ResolutionPolicy class is the root strategy class of scale strategy,
its main task is to maintain the compatibility with Cocos2d-x

        */
        export class ResolutionPolicy extends cc.Class {
            /**
            * cc.ResolutionPolicy class is the root strategy class of scale strategy,
its main task is to maintain the compatibility with Cocos2d-x
            */
            constructor(containerStg?: cc.ContainerStrategy, contentStg?: cc.ContentStrategy);
            /**
            * 
            */
            EXACT_FIT: number;
            /**
            * 
            */
            FIXED_HEIGHT: number;
            /**
            * 
            */
            FIXED_WIDTH: number;
            /**
            * 
            */
            NO_BORDER: number;
            /**
            * 
            */
            SHOW_ALL: number;
            /**
            * 
            */
            UNKNOWN: number;
            /**
            * {object}
apply(view, designedResolution)
Function to apply this resolution policy
The return value is {scale: [scaleX, scaleY], viewport: {cc.Rect}},
The target view can then apply these value to itself, it&#39;s preferred not to modify directly its private variables
Parameters:
{cc.view} view
The target view
{cc.Size} designedResolution
The user defined design resolution
Returns:
{object} An object contains the scale X/Y values and the viewport rect

            */
            apply(view?: cc.view, designedResolution?: cc.Size): any;
            /**
            * ctor(containerStg, contentStg)
Constructor of cc.ResolutionPolicy
Parameters:
{cc.ContainerStrategy} containerStg
{cc.ContentStrategy} contentStg

            */
            ctor(containerStg?: cc.ContainerStrategy, contentStg?: cc.ContentStrategy);
            /**
            * postApply(view)
Manipulation after appyling the strategy
Parameters:
{cc.view} view
The target view

            */
            postApply(view?: cc.view);
            /**
            * preApply(view)
Manipulation before applying the resolution policy
Parameters:
{cc.view} view
The target view

            */
            preApply(view?: cc.view);
            /**
            * setContainerStrategy(containerStg)
Setup the container&#39;s scale strategy
Parameters:
{cc.ContainerStrategy} containerStg

            */
            setContainerStrategy(containerStg?: cc.ContainerStrategy);
            /**
            * setContentStrategy(contentStg)
Setup the content&#39;s scale strategy
Parameters:
{cc.ContentStrategy} contentStg

            */
            setContentStrategy(contentStg?: cc.ContentStrategy);
        }
    }
declare module cc {
        /**
        * 
cc.ReuseGrid action

        */
        export class ReuseGrid extends cc.ActionInstant {
            /**
            * cc.ReuseGrid action
            */
            constructor(times?: number);
            /**
            * Please use cc.reuseGrid instead
creates an action with the number of times that the current grid will be reused
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ReuseGrid;
            /**
            * ctor(times)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} times

            */
            ctor(times?: number);
            /**
            * {Boolean}
initWithTimes(times)
initializes an action with the number of times that the current grid will be reused
Parameters:
{Number} times
Returns:
{Boolean}

            */
            initWithTimes(times?: number): boolean;
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
        }
    }
declare module cc {
        /**
        * Executes an action in reverse order, from time=duration to time=0

        */
        export class ReverseTime extends cc.ActionInterval {
            /**
            * 
Executes an action in reverse order, from time=duration to time=0
            */
            constructor(action?: cc.FiniteTimeAction);
            /**
            * Please use cc.reverseTime instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ReverseTime;
            /**
            * {cc.ReverseTime}
clone()
returns a new clone of the action
Returns:
{cc.ReverseTime}

            */
            clone(): cc.ReverseTime;
            /**
            * ctor(action)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{cc.FiniteTimeAction} action

            */
            ctor(action?: cc.FiniteTimeAction);
            /**
            * {Boolean}
initWithAction(action)
Parameters:
{cc.FiniteTimeAction} action
Returns:
{Boolean}

            */
            initWithAction(action?: cc.FiniteTimeAction): boolean;
            /**
            * {cc.ActionInterval}
reverse()
Returns a reversed action.
Returns:
{cc.ActionInterval}

            */
            reverse(): cc.ActionInterval;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * stop()
Stop the action

            */
            stop();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt
time in seconds

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
An RGBA color class, its value present as percent

        */
        export class RGBA  {
            /**
            * An RGBA color class, its value present as percent
            */
            constructor(r?: number, g?: number, b?: number, a?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Ripple3D action.
Reference the test cases (Effects Test)

        */
        export class Ripple3D extends cc.Grid3DAction {
            /**
            * cc.Ripple3D action.
            */
            constructor(duration?: number, gridSize?: cc.Size, position?: cc.Point, radius?: number, waves?: number, amplitude?: number);
            /**
            * Please use cc.ripple3D instead
creates a ripple 3d action with radius, number of waves, amplitude
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Ripple3D;
            /**
            * ctor(duration, gridSize, position, radius, waves, amplitude)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates a ripple 3d action with radius, number of waves, amplitude.
Parameters:
{Number} duration
{cc.Size} gridSize
{cc.Point} position
{Number} radius
{Number} waves
{Number} amplitude

            */
            ctor(duration?: number, gridSize?: cc.Size, position?: cc.Point, radius?: number, waves?: number, amplitude?: number);
            /**
            * {Number}
getAmplitude()
get Amplitude
Returns:
{Number}

            */
            getAmplitude(): number;
            /**
            * {*}
getAmplitudeRate()
get Amplitude rate
Returns:
{*}

            */
            getAmplitudeRate(): any;
            /**
            * {cc.Point}
getPosition()
get center position
Returns:
{cc.Point}

            */
            getPosition(): cc.Point;
            /**
            * {Boolean}
initWithDuration(duration, gridSize, position, radius, waves, amplitude)
initializes the action with radius, number of waves, amplitude, a grid size and duration
Parameters:
{Number} duration
{cc.Size} gridSize
{cc.Point} position
{Number} radius
{Number} waves
{Number} amplitude
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, position?: cc.Point, radius?: number, waves?: number, amplitude?: number): boolean;
            /**
            * setAmplitude(amplitude)
set Amplitude
Parameters:
{Number} amplitude

            */
            setAmplitude(amplitude?: number);
            /**
            * setAmplitudeRate(amplitudeRate)
get amplitude rate
Parameters:
{Number} amplitudeRate

            */
            setAmplitudeRate(amplitudeRate?: number);
            /**
            * setPosition(position)
set center position
Parameters:
{cc.Point} position

            */
            setPosition(position?: cc.Point);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Rotates a cc.Node object clockwise a number of degrees by modifying it&#39;s rotation attribute.
Relative to its properties to modify.

        */
        export class RotateBy extends cc.ActionInterval {
            /**
            * Rotates a cc.Node object clockwise a number of degrees by modifying it&#39;s rotation attribute.
            */
            constructor(duration?: number, deltaAngleX?: number, deltaAngleY?: number);
            /**
            * Please use cc.rotateBy instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.RotateBy;
            /**
            * {cc.RotateBy}
clone()
returns a new clone of the action
Returns:
{cc.RotateBy}

            */
            clone(): cc.RotateBy;
            /**
            * ctor(duration, deltaAngleX, deltaAngleY)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
duration in seconds
{Number} deltaAngleX
deltaAngleX in degrees
{Number} deltaAngleY
Optional
deltaAngleY in degrees

            */
            ctor(duration?: number, deltaAngleX?: number, deltaAngleY?: number);
            /**
            * {Boolean}
initWithDuration(duration, deltaAngleX, deltaAngleY)
Initializes the action.
Parameters:
{Number} duration
duration in seconds
{Number} deltaAngleX
deltaAngleX in degrees
{Number} deltaAngleY
Optional
deltaAngleY in degrees
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, deltaAngleX?: number, deltaAngleY?: number): boolean;
            /**
            * {cc.RotateBy}
reverse()
Returns a reversed action.
Returns:
{cc.RotateBy}

            */
            reverse(): cc.RotateBy;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Rotates a cc.Node object to a certain angle by modifying it&#39;s.
rotation attribute.
The direction will be decided by the shortest angle.

        */
        export class RotateTo extends cc.ActionInterval {
            /**
            * Rotates a cc.Node object to a certain angle by modifying it&#39;s.
            */
            constructor(duration?: number, deltaAngleX?: number, deltaAngleY?: number);
            /**
            * Please use cc.rotateTo instead
Creates a RotateTo action with separate rotation angles.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.RotateTo;
            /**
            * {cc.RotateTo}
clone()
returns a new clone of the action
Returns:
{cc.RotateTo}

            */
            clone(): cc.RotateTo;
            /**
            * ctor(duration, deltaAngleX, deltaAngleY)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates a RotateTo action with x and y rotation angles.
Parameters:
{Number} duration
duration in seconds
{Number} deltaAngleX
deltaAngleX in degrees.
{Number} deltaAngleY
Optional
deltaAngleY in degrees.

            */
            ctor(duration?: number, deltaAngleX?: number, deltaAngleY?: number);
            /**
            * {Boolean}
initWithDuration(duration, deltaAngleX, deltaAngleY)
Initializes the action.
Parameters:
{Number} duration
{Number} deltaAngleX
{Number} deltaAngleY
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, deltaAngleX?: number, deltaAngleY?: number): boolean;
            /**
            * reverse()
RotateTo reverse not implemented.
Will be overridden.

            */
            reverse();
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
A SAX Parser

        */
        export class saxParser extends cc.Class {
            /**
            * A SAX Parser
            */
            constructor();
            /**
            * ctor()
Constructor of cc.SAXParser

            */
            ctor();
            /**
            * {Document}
parse(xmlTxt)
Parameters:
{String} xmlTxt
Returns:
{Document}

            */
            parse(xmlTxt?: string): Document;
        }
    }
declare module cc {
        /**
        * 
A 9-slice sprite for cocos2d.

9-slice scaling allows you to specify how scaling is applied
to specific areas of a sprite. With 9-slice scaling (3x3 grid),
you can ensure that the sprite does not become distorted when
scaled.

        */
        export class Scale9Sprite extends cc.Node {
            /**
            * A 9-slice sprite for cocos2d.
            */
            constructor();
            /**
            * - The cap insets of the 9-slice sprite
            */
            capInsets: cc.Rect;
            /**
            * - The bottom inset of the 9-slice sprite
            */
            insetBottom: number;
            /**
            * - The left inset of the 9-slice sprite
            */
            insetLeft: number;
            /**
            * - The right inset of the 9-slice sprite
            */
            insetRight: number;
            /**
            * - The top inset of the 9-slice sprite
            */
            insetTop: number;
            /**
            * - The preferred size of the 9-slice sprite
            */
            preferredSize: cc.Size;
            /**
            * addLoadedEventListener(callback, target)
add texture loaded event listener
Parameters:
{Function} callback
{Object} target
Deprecated:
since 3.1, please use addEventListener instead

            */
            addLoadedEventListener(callback?: Function, target?: Object);
            /**
            * &amp;lt;static&amp;gt;
{cc.Scale9Sprite}
cc.Scale9Sprite.create(file, rect, capInsets)
Creates a 9-slice sprite with a texture file, a delimitation zone and
with the specified cap insets.
Parameters:
{String|cc.SpriteFrame} file
file name of texture or a cc.Sprite object
{cc.Rect} rect
the rect of the texture
{cc.Rect} capInsets
the cap insets of cc.Scale9Sprite
Returns:
{cc.Scale9Sprite}

            */
            static create(file?: any, rect?: cc.Rect, capInsets?: cc.Rect): cc.Scale9Sprite;
            /**
            * &amp;lt;static&amp;gt;
{cc.Scale9Sprite}
cc.Scale9Sprite.createWithSpriteFrame(spriteFrame, capInsets)
Parameters:
spriteFrame
capInsets
Returns:
{cc.Scale9Sprite}

            */
            static createWithSpriteFrame(): cc.Scale9Sprite;
            /**
            * &amp;lt;static&amp;gt;
{cc.Scale9Sprite}
cc.Scale9Sprite.createWithSpriteFrameName(spriteFrameName, capInsets)
Parameters:
spriteFrameName
capInsets
Returns:
{cc.Scale9Sprite}

            */
            static createWithSpriteFrameName(): cc.Scale9Sprite;
            /**
            * {Scale9Sprite}
ctor(file, rect, capInsets)
Constructor function. override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{string|cc.SpriteFrame} file
file name of texture or a SpriteFrame
{cc.Rect} rect
{cc.Rect} capInsets
Returns:
{Scale9Sprite}

            */
            ctor(file?: any, rect?: cc.Rect, capInsets?: cc.Rect): Scale9Sprite;
            /**
            * {number}
getInsetBottom()
Gets the bottom side inset
Returns:
{number}

            */
            getInsetBottom(): number;
            /**
            * {number}
getInsetLeft()
Gets the left side inset
Returns:
{number}

            */
            getInsetLeft(): number;
            /**
            * {number}
getInsetRight()
Gets the right side inset
Returns:
{number}

            */
            getInsetRight(): number;
            /**
            * {number}
getInsetTop()
Gets the top side inset
Returns:
{number}

            */
            getInsetTop(): number;
            /**
            * getOriginalSize()
Original sprite&#39;s size.

            */
            getOriginalSize();
            /**
            * {boolean}
init()
Initializes a cc.Scale9Sprite. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * {boolean}
initWithBatchNode(batchNode, rect, rotated, capInsets)
Initializes a 9-slice sprite with a SpriteBatchNode.
Parameters:
{cc.SpriteBatchNode} batchNode
{cc.Rect} rect
{boolean|cc.Rect} rotated
{cc.Rect} capInsets
Optional
Returns:
{boolean}

            */
            initWithBatchNode(batchNode?: cc.SpriteBatchNode, rect?: cc.Rect, rotated?: any, capInsets?: cc.Rect): boolean;
            /**
            * initWithFile(file, rect, capInsets)
Initializes a 9-slice sprite with a texture file, a delimitation zone and
with the specified cap insets.
Once the sprite is created, you can then call its &quot;setContentSize:&quot; method
to resize the sprite will all it&#39;s 9-slice goodness intact.
It respects the anchorPoint too.
Parameters:
{String} file
The name of the texture file.
{cc.Rect} rect
The rectangle that describes the sub-part of the texture that
is the whole image. If the shape is the whole texture, set this to the texture&#39;s full rect.
{cc.Rect} capInsets
The values to use for the cap insets.

            */
            initWithFile(file?: string, rect?: cc.Rect, capInsets?: cc.Rect);
            /**
            * initWithSpriteFrame(spriteFrame, capInsets)
Initializes a 9-slice sprite with an sprite frame and with the specified
cap insets.
Once the sprite is created, you can then call its &quot;setContentSize:&quot; method
to resize the sprite will all it&#39;s 9-slice goodness interact.
It respects the anchorPoint too.
Parameters:
spriteFrame
The sprite frame object.
capInsets
The values to use for the cap insets.

            */
            initWithSpriteFrame();
            /**
            * initWithSpriteFrameName(spriteFrameName, capInsets)
Initializes a 9-slice sprite with an sprite frame name and with the specified
cap insets.
Once the sprite is created, you can then call its &quot;setContentSize:&quot; method
to resize the sprite will all it&#39;s 9-slice goodness interact.
It respects the anchorPoint too.
Parameters:
spriteFrameName
The sprite frame name.
capInsets
The values to use for the cap insets.

            */
            initWithSpriteFrameName();
            /**
            * isOpacityModifyRGB()
returns whether or not the opacity will be applied using glColor(R,G,B,opacity) or glColor(opacity, opacity, opacity, opacity);
Since:
v0.8

            */
            isOpacityModifyRGB();
            /**
            * resizableSpriteWithCapInsets(capInsets)
Creates and returns a new sprite object with the specified cap insets.
You use this method to add cap insets to a sprite or to change the existing
cap insets of a sprite. In both cases, you get back a new image and the
original sprite remains untouched.
Parameters:
{cc.Rect} capInsets
The values to use for the cap insets.

            */
            resizableSpriteWithCapInsets(capInsets?: cc.Rect);
            /**
            * setColor(color)
Color: conforms to CCRGBAProtocol protocol
Parameters:
color

            */
            setColor();
            /**
            * setContentSize(size, height)
Sets the untransformed size of the Scale9Sprite.
Parameters:
{cc.Size|Number} size
The untransformed size of the Scale9Sprite or The untransformed size&#39;s width of the Scale9Sprite.
{Number} height
Optional
The untransformed size&#39;s height of the Scale9Sprite.

            */
            setContentSize(size?: any, height?: number);
            /**
            * setInsetBottom(insetBottom)
Sets the bottom side inset
Parameters:
{number} insetBottom

            */
            setInsetBottom(insetBottom?: number);
            /**
            * setInsetLeft(insetLeft)
Sets the left side inset
Parameters:
{Number} insetLeft

            */
            setInsetLeft(insetLeft?: number);
            /**
            * setInsetRight(insetRight)
Sets the right side inset
Parameters:
{Number} insetRight

            */
            setInsetRight(insetRight?: number);
            /**
            * setInsetTop(insetTop)
Sets the top side inset
Parameters:
{Number} insetTop

            */
            setInsetTop(insetTop?: number);
            /**
            * setOpacity(opacity)
Opacity: conforms to CCRGBAProtocol protocol
Parameters:
opacity

            */
            setOpacity();
            /**
            * setOpacityModifyRGB(value)
sets the premultipliedAlphaOpacity property.
If set to NO then opacity will be applied as: glColor(R,G,B,opacity);
If set to YES then opacity will be applied as: glColor(opacity, opacity, opacity, opacity );
Textures with premultiplied alpha will have this property by default on YES. Otherwise the default value is NO
Parameters:
value
Since:
v0.8

            */
            setOpacityModifyRGB();
            /**
            * setSpriteFrame(spriteFrame)
set the sprite frame of cc.Scale9Sprite
Parameters:
{cc.SpriteFrame} spriteFrame

            */
            setSpriteFrame(spriteFrame?: cc.SpriteFrame);
            /**
            * {boolean}
textureLoaded()
return  texture is loaded
Returns:
{boolean}

            */
            textureLoaded(): boolean;
            /**
            * {boolean}
updateWithBatchNode(batchNode, originalRect, rotated, capInsets)
Update the scale9Sprite with a SpriteBatchNode.
Parameters:
{cc.SpriteBatchNode} batchNode
{cc.Rect} originalRect
{boolean} rotated
{cc.Rect} capInsets
Returns:
{boolean}

            */
            updateWithBatchNode(batchNode?: cc.SpriteBatchNode, originalRect?: cc.Rect, rotated?: boolean, capInsets?: cc.Rect): boolean;
        }
    }
declare module cc {
        /**
        * 
Scales a cc.Node object a zoom factor by modifying it&#39;s scale attribute.
Relative to its changes.

        */
        export class ScaleBy extends cc.ScaleTo {
            /**
            * Scales a cc.Node object a zoom factor by modifying it&#39;s scale attribute.
            */
            constructor();
            /**
            * Please use cc.scaleBy instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ScaleBy;
            /**
            * {cc.ScaleBy}
clone()
returns a new clone of the action
Returns:
{cc.ScaleBy}

            */
            clone(): cc.ScaleBy;
            /**
            * {cc.ScaleBy}
reverse()
Returns a reversed action.
Returns:
{cc.ScaleBy}

            */
            reverse(): cc.ScaleBy;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
        }
    }
declare module cc {
        /**
        * 
Scales a cc.Node object to a zoom factor by modifying it&#39;s scale attribute.

        */
        export class ScaleTo extends cc.ActionInterval {
            /**
            * Scales a cc.Node object to a zoom factor by modifying it&#39;s scale attribute.
            */
            constructor(duration?: number, sx?: number, sy?: number);
            /**
            * Please use cc.scaleTo instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ScaleTo;
            /**
            * {cc.ScaleTo}
clone()
returns a new clone of the action
Returns:
{cc.ScaleTo}

            */
            clone(): cc.ScaleTo;
            /**
            * ctor(duration, sx, sy)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
{Number} sx
scale parameter in X
{Number} sy
Optional
scale parameter in Y, if Null equal to sx

            */
            ctor(duration?: number, sx?: number, sy?: number);
            /**
            * {Boolean}
initWithDuration(duration, sx, sy)
Initializes the action.
Parameters:
{Number} duration
{Number} sx
{Number} sy
Optional
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, sx?: number, sy?: number): boolean;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Scene is a subclass of cc.Node that is used only as an abstract concept.
cc.Scene an cc.Node are almost identical with the difference that cc.Scene has it&#39;s
anchor point (by default) at the center of the screen.

For the moment cc.Scene has no other logic than that, but in future releases it might have
additional logic.

It is a good practice to use and cc.Scene as the parent of all your nodes.

        */
        export class Scene extends cc.Node {
            /**
            * cc.Scene is a subclass of cc.Node that is used only as an abstract concept.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.Scene}
cc.Scene.create()
creates a scene
Deprecated:
since v3.0,please use new cc.Scene() instead.
Returns:
{cc.Scene}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): cc.Scene;
        }
    }
declare module cc {
        /**
        * Scheduler is responsible of triggering the scheduled callbacks.
You should not use NSTimer. Instead use this class.
There are 2 different types of callbacks (selectors):
- update callback: the &#39;update&#39; callback will be called every frame. You can customize the priority.
- custom callback: A custom callback will be called every frame, or with a custom interval of time
The &#39;custom selectors&#39; should be avoided when possible. It is faster, and consumes less memory to use the &#39;update callback&#39;. *

        */
        export class Scheduler extends cc.Class {
            /**
            * 
Scheduler is responsible of triggering the scheduled callbacks.
            */
            constructor();
            /**
            * Priority level reserved for system services.
            */
            static PRIORITY_SYSTEM: number;
            /**
            * {Number}
getTimeScale()
Returns time scale of scheduler
Returns:
{Number}

            */
            getTimeScale(): number;
            /**
            * {Boolean}
isTargetPaused(target)
Returns whether or not the target is paused
Parameters:
{cc.Class} target
Returns:
{Boolean}

            */
            isTargetPaused(target?: cc.Class): boolean;
            /**
            * pauseAllTargets()
Pause all selectors from all targets.
You should NEVER call this method, unless you know what you are doing.

            */
            pauseAllTargets();
            /**
            * pauseAllTargetsWithMinPriority(minPriority)
Pause all selectors from all targets with a minimum priority.
You should only call this with kCCPriorityNonSystemMin or higher.
Parameters:
{Number} minPriority

            */
            pauseAllTargetsWithMinPriority(minPriority?: number);
            /**
            * pauseTarget(target)
Pauses the target.
All scheduled selectors/update for a given target won&#39;t be &#39;ticked&#39; until the target is resumed.
If the target is not present, nothing happens.
Parameters:
{cc.Class} target

            */
            pauseTarget(target?: cc.Class);
            /**
            * resumeTarget(target)
Resumes the target.
The &#39;target&#39; will be unpaused, so all schedule selectors/update will be &#39;ticked&#39; again.
If the target is not present, nothing happens.
Parameters:
{cc.Class} target

            */
            resumeTarget(target?: cc.Class);
            /**
            * resumeTargets(targetsToResume)
Resume selectors on a set of targets.
This can be useful for undoing a call to pauseAllCallbacks.
Parameters:
{Array} targetsToResume

            */
            resumeTargets(targetsToResume?: Array<any>);
            /**
            * scheduleCallbackForTarget(target, callback_fn, interval, repeat, delay, paused)
The scheduled method will be called every &#39;interval&#39; seconds.
If paused is YES, then it won&#39;t be called until it is resumed.
If &#39;interval&#39; is 0, it will be called every frame, but if so, it recommended to use &#39;scheduleUpdateForTarget:&#39; instead.
If the callback function is already scheduled, then only the interval parameter will be updated without re-scheduling it again.
repeat let the action be repeated repeat + 1 times, use cc.REPEAT_FOREVER to let the action run continuously
delay is the amount of time the action will wait before it&#39;ll start
//register a schedule to scheduler
cc.director.getScheduler().scheduleCallbackForTarget(this, function, interval, repeat, delay, !this._isRunning );
Parameters:
{cc.Class} target
{function} callback_fn
{Number} interval
{Number} repeat
{Number} delay
{Boolean} paused

            */
            scheduleCallbackForTarget(target?: cc.Class, callback_fn?: any, interval?: number, repeat?: number, delay?: number, paused?: boolean);
            /**
            * scheduleUpdateForTarget(target, priority, paused)
Schedules the &#39;update&#39; callback_fn for a given target with a given priority.
The &#39;update&#39; callback_fn will be called every frame.
The lower the priority, the earlier it is called.
//register this object to scheduler
cc.director.getScheduler().scheduleUpdateForTarget(this, priority, !this._isRunning );
Parameters:
{cc.Class} target
{Number} priority
{Boolean} paused

            */
            scheduleUpdateForTarget(target?: cc.Class, priority?: number, paused?: boolean);
            /**
            * setTimeScale(timeScale)
Modifies the time of all scheduled callbacks.
You can use this property to create a &#39;slow motion&#39; or &#39;fast forward&#39; effect.
Default is 1.0. To create a &#39;slow motion&#39; effect, use values below 1.0.
To create a &#39;fast forward&#39; effect, use values higher than 1.0.
Parameters:
{Number} timeScale

            */
            setTimeScale(timeScale?: number);
            /**
            * unscheduleAllCallbacks()
Unschedules all function callbacks from all targets.
You should NEVER call this method, unless you know what you are doing.

            */
            unscheduleAllCallbacks();
            /**
            * unscheduleAllCallbacksForTarget(target)
Unschedules all function callbacks for a given target. This also includes the &quot;update&quot; callback function.
Parameters:
{cc.Class} target

            */
            unscheduleAllCallbacksForTarget(target?: cc.Class);
            /**
            * unscheduleAllCallbacksWithMinPriority(minPriority)
Unschedules all function callbacks from all targets with a minimum priority.
You should only call this with kCCPriorityNonSystemMin or higher.
Parameters:
{Number} minPriority

            */
            unscheduleAllCallbacksWithMinPriority(minPriority?: number);
            /**
            * unscheduleCallbackForTarget(target, callback_fn)
Unschedule a callback function for a given target.
If you want to unschedule the &quot;update&quot;, use unscheudleUpdateForTarget.
//unschedule a callback of target
cc.director.getScheduler().unscheduleCallbackForTarget(function, this);
Parameters:
{cc.Class} target
{function} callback_fn

            */
            unscheduleCallbackForTarget(target?: cc.Class, callback_fn?: any);
            /**
            * unscheduleUpdateForTarget(target)
Unschedules the update callback function for a given target
//unschedules the &quot;update&quot; method.
cc.director.getScheduler().unscheduleUpdateForTarget(this);
Parameters:
{cc.Class} target

            */
            unscheduleUpdateForTarget(target?: cc.Class);
            /**
            * update(dt)
&#39;update&#39; the scheduler. (You should NEVER call this method, unless you know what you are doing.)
Parameters:
{Number} dt
delta time

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
The fullscreen API provides an easy way for web content to be presented using the user&#39;s entire screen.
It&#39;s invalid on safari, QQbrowser and android browser

        */
        export class screen  {
            /**
            * The fullscreen API provides an easy way for web content to be presented using the user&#39;s entire screen.
            */
            constructor();
            /**
            * autoFullScreen(element, onFullScreenChange)
Automatically request full screen with a touch/click event
Parameters:
{Element} element
{Function} onFullScreenChange

            */
            autoFullScreen(element?: Element, onFullScreenChange?: Function);
            /**
            * {Boolean}
exitFullScreen()
exit the full mode.
Returns:
{Boolean}

            */
            exitFullScreen(): boolean;
            /**
            * {Boolean}
fullScreen()
return true if it&#39;s full now.
Returns:
{Boolean}

            */
            fullScreen(): boolean;
            /**
            * init()
initialize

            */
            init();
            /**
            * requestFullScreen(element, onFullScreenChange)
change the screen to full mode.
Parameters:
{Element} element
{Function} onFullScreenChange

            */
            requestFullScreen(element?: Element, onFullScreenChange?: Function);
        }
    }
declare module cc {
        /**
        * 
ScrollView support for cocos2d -x.
It provides scroll view functionalities to cocos2d projects natively.

        */
        export class ScrollView extends cc.Layer {
            /**
            * ScrollView support for cocos2d -x.
            */
            constructor();
            /**
            * - Indicate whether the scroll view is bounceable
            */
            bounceable: boolean;
            /**
            * - Indicate whether the scroll view clips its children
            */
            clippingToBounds: boolean;
            /**
            * - The inside container of the scroll view
            */
            container: cc.Layer;
            /**
            * - The inside container of the scroll view
            */
            delegate: cc.ScrollViewDelegate;
            /**
            * - The direction allowed to scroll: cc.SCROLLVIEW_DIRECTION_BOTH by default, or cc.SCROLLVIEW_DIRECTION_NONE | cc.SCROLLVIEW_DIRECTION_HORIZONTAL | cc.SCROLLVIEW_DIRECTION_VERTICAL
            */
            direction: number;
            /**
            * -  The current container&#39;s maximum offset
            */
            maxOffset: cc.Point;
            /**
            * -  The current container&#39;s minimum offset
            */
            minOffset: cc.Point;
            /**
            * - The size of the scroll view
            */
            viewSize: cc.Size;
            /**
            * &amp;lt;static&amp;gt;
{cc.ScrollView}
cc.ScrollView.create(size, container)
Returns an autoreleased scroll view object.
Parameters:
{cc.Size} size
view size
{cc.Node} container
parent object
Returns:
{cc.ScrollView} scroll view object

            */
            static create(size?: cc.Size, container?: cc.Node): cc.ScrollView;
            /**
            * {ScrollView}
ctor(size, container)
Parameters:
size
container
Returns:
{ScrollView}

            */
            ctor(): ScrollView;
            /**
            * getDirection()
direction allowed to scroll. CCScrollViewDirectionBoth by default.

            */
            getDirection();
            /**
            * getViewSize()
size to clip. CCNode boundingBox uses contentSize directly.
It&#39;s semantically different what it actually means to common scroll views.
Hence, this scroll view will use a separate size property.

            */
            getViewSize();
            /**
            * {Boolean}
initWithViewSize(size, container)
initialized whether success or fail
Parameters:
{cc.Size} size
{cc.Node} container
Returns:
{Boolean}

            */
            initWithViewSize(size?: cc.Size, container?: cc.Node): boolean;
            /**
            * isClippingToBounds()
Determines whether it clips its children or not.

            */
            isClippingToBounds();
            /**
            * {Boolean}
isNodeVisible(node)
Determines if a given node&#39;s bounding box is in visible bounds
Parameters:
{cc.Node} node
Returns:
{Boolean} YES if it is in visible bounds

            */
            isNodeVisible(node?: cc.Node): boolean;
            /**
            * {cc.Point}
maxContainerOffset()
Returns the current container&#39;s maximum offset. You may want this while you animate scrolling by yourself
Returns:
{cc.Point} Returns the current container&#39;s maximum offset.

            */
            maxContainerOffset(): cc.Point;
            /**
            * {cc.Point}
minContainerOffset()
Returns the current container&#39;s minimum offset. You may want this while you animate scrolling by yourself
Returns:
{cc.Point} Returns the current container&#39;s minimum offset.

            */
            minContainerOffset(): cc.Point;
            /**
            * onTouchBegan(touch, event)
override functions
Parameters:
touch
event

            */
            onTouchBegan();
            /**
            * pause(sender)
Provided to make scroll view compatible with SWLayer&#39;s pause method
Parameters:
sender

            */
            pause();
            /**
            * resume(sender)
Provided to make scroll view compatible with SWLayer&#39;s resume method
Parameters:
sender

            */
            resume();
            /**
            * setContentOffset(offset, animated)
Sets a new content offset. It ignores max/min offset. It just sets what&#39;s given. (just like UIKit&#39;s UIScrollView)
Parameters:
{cc.Point} offset
new offset
{Number} animated
Optional
If true, the view will scroll to the new offset

            */
            setContentOffset(offset?: cc.Point, animated?: number);
            /**
            * setContentOffsetInDuration(offset, dt)
Sets a new content offset. It ignores max/min offset. It just sets what&#39;s given. (just like UIKit&#39;s UIScrollView)
You can override the animation duration with this method.
Parameters:
{cc.Point} offset
new offset
{Number} dt
animation duration

            */
            setContentOffsetInDuration(offset?: cc.Point, dt?: number);
            /**
            * setZoomScale(scale, animated)
Sets a new scale and does that for a predefined duration.
Parameters:
{Number} scale
a new scale vale
{Boolean} animated
Optional, Default: null
if YES, scaling is animated

            */
            setZoomScale(scale?: number, animated?: boolean);
            /**
            * setZoomScaleInDuration(s, dt)
Sets a new scale for container in a given duration.
Parameters:
{Number} s
a new scale value
{Number} dt
animation duration

            */
            setZoomScaleInDuration(s?: number, dt?: number);
        }
    }
declare module cc {
        /**
        * 
Runs actions sequentially, one after another.

        */
        export class Sequence extends cc.ActionInterval {
            /**
            * Runs actions sequentially, one after another.
            */
            constructor(tempArray?: any);
            /**
            * Please use cc.sequence instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Sequence;
            /**
            * {cc.Sequence}
clone()
returns a new clone of the action
Returns:
{cc.Sequence}

            */
            clone(): cc.Sequence;
            /**
            * ctor(tempArray)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create an array of sequenceable actions.
Parameters:
{Array|cc.FiniteTimeAction} tempArray

            */
            ctor(tempArray?: any);
            /**
            * {Boolean}
initWithTwoActions(actionOne, actionTwo)
Initializes the action
Parameters:
{cc.FiniteTimeAction} actionOne
{cc.FiniteTimeAction} actionTwo
Returns:
{Boolean}

            */
            initWithTwoActions(actionOne?: cc.FiniteTimeAction, actionTwo?: cc.FiniteTimeAction): boolean;
            /**
            * {cc.Sequence}
reverse()
Returns a reversed action.
Returns:
{cc.Sequence}

            */
            reverse(): cc.Sequence;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * stop()
stop the action.

            */
            stop();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.shaderCache is a singleton object that stores manages GL shaders

        */
        export class shaderCache  {
            /**
            * cc.shaderCache is a singleton object that stores manages GL shaders
            */
            constructor();
            /**
            * 
            */
            TYPE_MAX;
            /**
            * 
            */
            TYPE_POSITION_COLOR;
            /**
            * 
            */
            TYPE_POSITION_LENGTH_TEXTURECOLOR;
            /**
            * 
            */
            TYPE_POSITION_TEXTURE;
            /**
            * 
            */
            TYPE_POSITION_TEXTURE_A8COLOR;
            /**
            * 
            */
            TYPE_POSITION_TEXTURE_UCOLOR;
            /**
            * 
            */
            TYPE_POSITION_TEXTURECOLOR;
            /**
            * 
            */
            TYPE_POSITION_TEXTURECOLOR_ALPHATEST;
            /**
            * 
            */
            TYPE_POSITION_UCOLOR;
            /**
            * addProgram(program, key)
adds a CCGLProgram to the cache for a given name
Parameters:
{cc.GLProgram} program
{String} key

            */
            addProgram(program?: cc.GLProgram, key?: string);
            /**
            * {cc.GLProgram}
getProgram(shaderName)
returns a GL program for a shader name
Parameters:
{String} shaderName
Returns:
{cc.GLProgram}

            */
            getProgram(shaderName?: string): cc.GLProgram;
            /**
            * loadDefaultShaders()
loads the default shaders

            */
            loadDefaultShaders();
            /**
            * programForKey(key)
returns a GL program for a given key
Parameters:
{String} key

            */
            programForKey(key?: string);
            /**
            * reloadDefaultShaders()
reload the default shaders

            */
            reloadDefaultShaders();
        }
    }
declare module cc {
        /**
        * 
cc.Shaky3D action.
Reference the test cases (Effects Test)

        */
        export class Shaky3D extends cc.Grid3DAction {
            /**
            * cc.Shaky3D action.
            */
            constructor(duration?: number, gridSize?: cc.Size, range?: number, shakeZ?: boolean);
            /**
            * Please use cc.shaky3D instead
creates the action with a range, shake Z vertices, a grid and duration
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Shaky3D;
            /**
            * ctor(duration, gridSize, range, shakeZ)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a shaky3d action with a range, shake Z vertices.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} range
{Boolean} shakeZ

            */
            ctor(duration?: number, gridSize?: cc.Size, range?: number, shakeZ?: boolean);
            /**
            * {Boolean}
initWithDuration(duration, gridSize, range, shakeZ)
initializes the action with a range, shake Z vertices, a grid and duration
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} range
{Boolean} shakeZ
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, range?: number, shakeZ?: boolean): boolean;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.ShakyTiles3D action.
Reference the test cases (Effects Test)

        */
        export class ShakyTiles3D extends cc.TiledGrid3DAction {
            /**
            * cc.ShakyTiles3D action.
            */
            constructor(duration?: number, gridSize?: cc.Size, range?: number, shakeZ?: boolean);
            /**
            * Please use cc.shakyTiles3D instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ShakyTiles3D;
            /**
            * ctor(duration, gridSize, range, shakeZ)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates the action with a range, whether or not to shake Z vertices, a grid size, and duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} range
{Boolean} shakeZ

            */
            ctor(duration?: number, gridSize?: cc.Size, range?: number, shakeZ?: boolean);
            /**
            * {Boolean}
initWithDuration(duration, gridSize, range, shakeZ)
Initializes the action with a range, whether or not to shake Z vertices, a grid size, and duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} range
{Boolean} shakeZ
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, range?: number, shakeZ?: boolean): boolean;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.ShatteredTiles3D action.
Reference the test cases (Effects Test)

        */
        export class ShatteredTiles3D extends cc.TiledGrid3DAction {
            /**
            * cc.ShatteredTiles3D action.
            */
            constructor(duration?: number, gridSize?: cc.Size, range?: number, shatterZ?: boolean);
            /**
            * Please use cc.shatteredTiles3D instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ShatteredTiles3D;
            /**
            * ctor(duration, gridSize, range, shatterZ)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates the action with a range, whether of not to shatter Z vertices, a grid size and duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} range
{Boolean} shatterZ

            */
            ctor(duration?: number, gridSize?: cc.Size, range?: number, shatterZ?: boolean);
            /**
            * {Boolean}
initWithDuration(duration, gridSize, range, shatterZ)
Initializes the action with a range, whether or not to shatter Z vertices, a grid size and duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} range
{Boolean} shatterZ
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, range?: number, shatterZ?: boolean): boolean;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Show the node.

        */
        export class Show extends cc.ActionInstant {
            /**
            * Show the node.
            */
            constructor();
            /**
            * Show the Node.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Show;
            /**
            * {cc.FiniteTimeAction}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.FiniteTimeAction}

            */
            clone(): cc.FiniteTimeAction;
            /**
            * {cc.Hide}
reverse()
returns a reversed action.
For example:
- The action will be x coordinates of 0 move to 100.
- The reversed action will be x of 100 move to 0.
- Will be rewritten
Returns:
{cc.Hide}

            */
            reverse(): cc.Hide;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.ShuffleTiles action, Shuffle the tiles in random order.
Reference the test cases (Effects Test)

        */
        export class ShuffleTiles extends cc.TiledGrid3DAction {
            /**
            * cc.ShuffleTiles action, Shuffle the tiles in random order.
            */
            constructor(duration?: number, gridSize?: cc.Size, seed?: number);
            /**
            * Please use cc.shuffleTiles instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ShuffleTiles;
            /**
            * ctor(duration, gridSize, seed)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates the action with a random seed, the grid size and the duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} seed

            */
            ctor(duration?: number, gridSize?: cc.Size, seed?: number);
            /**
            * getDelta(pos)
Get Delta
Parameters:
{cc.Size} pos

            */
            getDelta(pos?: cc.Size);
            /**
            * {Boolean}
initWithDuration(duration, gridSize, seed)
Initializes the action with a random seed, the grid size and the duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} seed
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, seed?: number): boolean;
            /**
            * placeTile(pos, tile)
Place Tile
Parameters:
{cc.Point} pos
{cc.Tile} tile

            */
            placeTile(pos?: cc.Point, tile?: cc.Tile);
            /**
            * shuffle(array, len)
Shuffle
Parameters:
{Array} array
{Number} len

            */
            shuffle(array?: Array<any>, len?: number);
            /**
            * startWithTarget(target)
Start with target
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Size is the class for size object, please do not use its constructor to create sizes, use cc.size() alias function instead.

        */
        export class Size  {
            /**
            * cc.Size is the class for size object, please do not use its constructor to create sizes, use cc.size() alias function instead.
            */
            constructor(width?: number, height?: number);
        }
    }
declare module cc {
        /**
        * 
Skews a cc.Node object by skewX and skewY degrees.
Relative to its attribute modification.

        */
        export class SkewBy extends cc.SkewTo {
            /**
            * Skews a cc.Node object by skewX and skewY degrees.
            */
            constructor(t?: number, sx?: number, sy?: number);
            /**
            * Please use cc.skewBy instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.SkewBy;
            /**
            * {cc.SkewBy}
clone()
returns a new clone of the action
Returns:
{cc.SkewBy}

            */
            clone(): cc.SkewBy;
            /**
            * ctor(t, sx, sy)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} t
time in seconds
{Number} sx
skew in degrees for X axis
{Number} sy
skew in degrees for Y axis

            */
            ctor(t?: number, sx?: number, sy?: number);
            /**
            * {Boolean}
initWithDuration(t, deltaSkewX, deltaSkewY)
Initializes the action.
Parameters:
{Number} t
time in seconds
{Number} deltaSkewX
skew in degrees for X axis
{Number} deltaSkewY
skew in degrees for Y axis
Returns:
{Boolean}

            */
            initWithDuration(t?: number, deltaSkewX?: number, deltaSkewY?: number): boolean;
            /**
            * {cc.SkewBy}
reverse()
Returns a reversed action.
Returns:
{cc.SkewBy}

            */
            reverse(): cc.SkewBy;
            /**
            * startWithTarget(target)
Start the action width target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
        }
    }
declare module cc {
        /**
        * 
Skews a cc.Node object to given angles by modifying it&#39;s skewX and skewY attributes

        */
        export class SkewTo extends cc.ActionInterval {
            /**
            * Skews a cc.Node object to given angles by modifying it&#39;s skewX and skewY attributes
            */
            constructor(t?: number, sx?: number, sy?: number);
            /**
            * Please use cc.skewTo instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.SkewTo;
            /**
            * {cc.SkewTo}
clone()
returns a new clone of the action
Returns:
{cc.SkewTo}

            */
            clone(): cc.SkewTo;
            /**
            * ctor(t, sx, sy)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} t
time in seconds
{Number} sx
{Number} sy

            */
            ctor(t?: number, sx?: number, sy?: number);
            /**
            * {Boolean}
initWithDuration(t, sx, sy)
Initializes the action.
Parameters:
{Number} t
time in seconds
{Number} sx
{Number} sy
Returns:
{Boolean}

            */
            initWithDuration(t?: number, sx?: number, sy?: number): boolean;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
The sortable object interface

        */
        export class SortableObject extends cc.Class {
            /**
            * The sortable object interface
            */
            constructor();
        }
    }
declare module cc {
        /**
        * 
The SortedObject class

        */
        export class SortedObject extends cc.SortableObject {
            /**
            * The SortedObject class
            */
            constructor();
        }
    }
declare module cc {
        /**
        * 
The Spacer class

        */
        export class Spacer extends cc.Layer {
            /**
            * The Spacer class
            */
            constructor();
        }
    }
declare module cc {
        /**
        * 
Spawn a new action immediately

        */
        export class Spawn extends cc.ActionInterval {
            /**
            * Spawn a new action immediately
            */
            constructor();
            /**
            * Please use cc.spawn instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.FiniteTimeAction;
            /**
            * {cc.Spawn}
clone()
returns a new clone of the action
Returns:
{cc.Spawn}

            */
            clone(): cc.Spawn;
            /**
            * ctor(tempArray)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Array|cc.FiniteTimeAction} tempArray

            */
            ctor(tempArray?: any);
            /**
            * {Boolean}
initWithTwoActions(action1, action2)
initializes the Spawn action with the 2 actions to spawn
Parameters:
{cc.FiniteTimeAction} action1
{cc.FiniteTimeAction} action2
Returns:
{Boolean}

            */
            initWithTwoActions(action1?: cc.FiniteTimeAction, action2?: cc.FiniteTimeAction): boolean;
            /**
            * {cc.Spawn}
reverse()
Returns a reversed action.
Returns:
{cc.Spawn}

            */
            reverse(): cc.Spawn;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * stop()
Stop the action

            */
            stop();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Changes the speed of an action, making it take longer (speed &gt; 1)
or less (speed
Useful to simulate &#39;slow motion&#39; or &#39;fast forward&#39; effect.

        */
        export class Speed extends cc.Action {
            /**
            * Changes the speed of an action, making it take longer (speed &gt; 1)
or less (speed
            */
            constructor(action?: cc.ActionInterval, speed?: number);
            /**
            * Please use cc.speed instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Speed;
            /**
            * {cc.Speed}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.Speed}

            */
            clone(): cc.Speed;
            /**
            * ctor(action, speed)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{cc.ActionInterval} action
{Number} speed

            */
            ctor(action?: cc.ActionInterval, speed?: number);
            /**
            * {cc.ActionInterval}
getInnerAction()
Get inner Action.
Returns:
{cc.ActionInterval}

            */
            getInnerAction(): cc.ActionInterval;
            /**
            * {Number}
getSpeed()
Gets the current running speed.
Will get a percentage number, compared to the original speed.
Returns:
{Number}

            */
            getSpeed(): number;
            /**
            * {Boolean}
initWithAction(action, speed)
initializes the action.
Parameters:
{cc.ActionInterval} action
{Number} speed
Returns:
{Boolean}

            */
            initWithAction(action?: cc.ActionInterval, speed?: number): boolean;
            /**
            * {Boolean}
isDone()
return true if the action has finished.
Returns:
{Boolean}

            */
            isDone(): boolean;
            /**
            * {cc.Speed}
reverse()
returns a reversed action.
For example:
- The action will be x coordinates of 0 move to 100.
- The reversed action will be x of 100 move to 0.
- Will be rewritten
Returns:
{cc.Speed}

            */
            reverse(): cc.Speed;
            /**
            * setInnerAction(action)
Set inner Action.
Parameters:
{cc.ActionInterval} action

            */
            setInnerAction(action?: cc.ActionInterval);
            /**
            * setSpeed(speed)
alter the speed of the inner function in runtime.
Parameters:
{Number} speed

            */
            setSpeed(speed?: number);
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * step(dt)
called every frame with it&#39;s delta time.
DON&#39;T override unless you know what you are doing.
Parameters:
{Number} dt

            */
            step(dt?: number);
            /**
            * stop()
Stop the action.

            */
            stop();
        }
    }
declare module cc {
        /**
        * 
cc.SplitCols action.
Reference the test cases (Effects Test)

        */
        export class SplitCols extends cc.TiledGrid3DAction {
            /**
            * cc.SplitCols action.
            */
            constructor(duration?: number, cols?: number);
            /**
            * Please use cc.splitCols instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.SplitCols;
            /**
            * ctor(duration, cols)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates the action with the number of columns to split and the duration.
Parameters:
{Number} duration
{Number} cols

            */
            ctor(duration?: number, cols?: number);
            /**
            * {Boolean}
initWithDuration(duration, cols)
initializes the action with the number of columns to split and the duration
Parameters:
{Number} duration
{Number} cols
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, cols?: number): boolean;
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.SplitRows action.
Reference the test cases (Effects Test)

        */
        export class SplitRows extends cc.TiledGrid3DAction {
            /**
            * cc.SplitRows action.
            */
            constructor(duration?: number, rows?: number);
            /**
            * Please use cc.splitRows instead
creates the action with the number of rows to split and the duration.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.SplitRows;
            /**
            * ctor(duration, rows)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates the action with the number of rows to split and the duration.
Parameters:
{Number} duration
{Number} rows

            */
            ctor(duration?: number, rows?: number);
            /**
            * {Boolean}
initWithDuration(duration, rows)
initializes the action with the number of rows to split and the duration
Parameters:
{Number} duration
{Number} rows
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, rows?: number): boolean;
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) )

cc.Sprite can be created with an image, or with a sub-rectangle of an image.

If the parent or any of its ancestors is a cc.SpriteBatchNode then the following features/limitations are valid
- Features when the parent is a cc.BatchNode:
- MUCH faster rendering, specially if the cc.SpriteBatchNode has many children. All the children will be drawn in a single batch.

- Limitations
- Camera is not supported yet (eg: CCOrbitCamera action doesn&#39;t work)
- GridBase actions are not supported (eg: CCLens, CCRipple, CCTwirl)
- The Alias/Antialias property belongs to CCSpriteBatchNode, so you can&#39;t individually set the aliased property.
- The Blending function property belongs to CCSpriteBatchNode, so you can&#39;t individually set the blending function property.
- Parallax scroller is not supported, but can be simulated with a &quot;proxy&quot; sprite.

If the parent is an standard cc.Node, then cc.Sprite behaves like any other cc.Node:
- It supports blending functions
- It supports aliasing / antialiasing
- But the rendering will be slower: 1 draw per children.

The default anchorPoint in cc.Sprite is (0.5, 0.5).

        */
        export class Sprite extends cc.Node {
            /**
            * cc.Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) )

cc.Sprite can be created with an image, or with a sub-rectangle of an image.
            */
            constructor(fileName?: any, rect?: cc.Rect, rotated?: boolean);
            /**
            * - The index used on the TextureAtlas.
            */
            atlasIndex: number;
            /**
            * - The batch node object if this sprite is rendered by cc.SpriteBatchNode.
            */
            batchNode: cc.SpriteBatchNode;
            /**
            * - Indicates whether the sprite needs to be updated.
            */
            dirty: boolean;
            /**
            * - Indicates whether or not the sprite is flipped on x axis.
            */
            flippedX: boolean;
            /**
            * - Indicates whether or not the sprite is flipped on y axis.
            */
            flippedY: boolean;
            /**
            * cc.Sprite invalid index on the cc.SpriteBatchNode
            */
            static INDEX_NOT_INITIALIZED;
            /**
            * -  The offset position on x axis of the sprite in texture.
            */
            offsetX: number;
            /**
            * -  The offset position on x axis of the sprite in texture.
            */
            offsetY: number;
            /**
            * -  The quad (tex coords, vertex coords and color) information.
            */
            quad: cc.V3F_C4B_T2F_Quad;
            /**
            * - Texture used to render the sprite.
            */
            texture: cc.Texture2D;
            /**
            * - The weak reference of the cc.TextureAtlas when the sprite is rendered using via cc.SpriteBatchNode.
            */
            textureAtlas: cc.TextureAtlas;
            /**
            * -  Indicate whether the texture rectangle is rotated.
            */
            textureRectRotated: boolean;
            /**
            * addChild(child, localZOrder, tag)
Add child to sprite (override cc.Node)
Parameters:
{cc.Sprite} child
{Number} localZOrder
child&#39;s zOrder
{String} tag
Optional
child&#39;s tag

            */
            addChild(child?: cc.Sprite, localZOrder?: number, tag?: string);
            /**
            * addLoadedEventListener(callback, target)
Add a event listener for texture loaded event.
Parameters:
{Function} callback
{Object} target
Deprecated:
since 3.1, please use addEventListener instead

            */
            addLoadedEventListener(callback?: Function, target?: Object);
            /**
            * &amp;lt;static&amp;gt;
{cc.Sprite}
cc.Sprite.create(fileName, rect, rotated)
Create a sprite with image path or frame name or texture or spriteFrame.
Parameters:
{String|cc.SpriteFrame|HTMLImageElement|cc.Texture2D} fileName
The string which indicates a path to image file, e.g., &quot;scene1/monster.png&quot;.
{cc.Rect} rect
Only the contents inside rect of pszFileName&#39;s texture will be applied for this sprite.
{Boolean} rotated
Optional
Whether or not the texture rectangle is rotated.
Deprecated:
since v3.0, please use new construction instead
Returns:
{cc.Sprite} A valid sprite object
See:
cc.Sprite

            */
            static create(fileName?: any, rect?: cc.Rect, rotated?: boolean): cc.Sprite;
            /**
            * &amp;lt;static&amp;gt;
cc.Sprite.createWithSpriteFrame()
Deprecated:
since v3.0, please use new construction instead
See:
cc.Sprite

            */
            static createWithSpriteFrame();
            /**
            * &amp;lt;static&amp;gt;
cc.Sprite.createWithSpriteFrameName()
Deprecated:
since v3.0, please use new construction instead
See:
cc.Sprite

            */
            static createWithSpriteFrameName();
            /**
            * &amp;lt;static&amp;gt;
cc.Sprite.createWithTexture()
Deprecated:
since v3.0, please use new construction instead
See:
cc.Sprite

            */
            static createWithTexture();
            /**
            * {cc.SpriteFrame}
displayFrame()
Returns the current displayed frame.
Returns:
{cc.SpriteFrame}

            */
            displayFrame(): cc.SpriteFrame;
            /**
            * {Number}
getAtlasIndex()
Returns the index used on the TextureAtlas.
Returns:
{Number}

            */
            getAtlasIndex(): number;
            /**
            * {cc.SpriteBatchNode|null}
getBatchNode()
Returns the batch node object if this sprite is rendered by cc.SpriteBatchNode
Returns:
{cc.SpriteBatchNode|null} The cc.SpriteBatchNode object if this sprite is rendered by cc.SpriteBatchNode, null if the sprite isn&#39;t used batch node.

            */
            getBatchNode(): any;
            /**
            * {cc.BlendFunc}
getBlendFunc()
Returns the blend function
Returns:
{cc.BlendFunc}

            */
            getBlendFunc(): cc.BlendFunc;
            /**
            * {cc.Point}
getOffsetPosition()
Returns the offset position of the sprite. Calculated automatically by editors like Zwoptex.
Returns:
{cc.Point}

            */
            getOffsetPosition(): cc.Point;
            /**
            * {cc.V3F_C4B_T2F_Quad|null}
getQuad()
Returns the quad (tex coords, vertex coords and color) information.
Returns:
{cc.V3F_C4B_T2F_Quad|null} Returns a cc.V3F_C4B_T2F_Quad object when render mode is WebGL, returns null when render mode is Canvas.

            */
            getQuad(): any;
            /**
            * {cc.Texture2D}
getTexture()
Returns the texture of the sprite node
Returns:
{cc.Texture2D}

            */
            getTexture(): cc.Texture2D;
            /**
            * {cc.TextureAtlas}
getTextureAtlas()
Returns the weak reference of the cc.TextureAtlas when the sprite is rendered using via cc.SpriteBatchNode
Returns:
{cc.TextureAtlas}

            */
            getTextureAtlas(): cc.TextureAtlas;
            /**
            * {cc.Rect}
getTextureRect()
Returns the rect of the cc.Sprite in points
Returns:
{cc.Rect}

            */
            getTextureRect(): cc.Rect;
            /**
            * ignoreAnchorPointForPosition(relative)
Sets whether ignore anchor point for positioning
Parameters:
{Boolean} relative

            */
            ignoreAnchorPointForPosition(relative?: boolean);
            /**
            * {Boolean}
init()
Initializes an empty sprite with nothing init.
Please pass parameters to the constructor to initialize the sprite, do not call this function yourself.
Returns:
{Boolean}

            */
            init(): boolean;
            /**
            * {Boolean}
initWithFile(filename, rect)
Initializes a sprite with an image filename.

This method will find pszFilename from local file system, load its content to CCTexture2D,
then use CCTexture2D to create a sprite.
After initialization, the rect used will be the size of the image. The offset will be (0,0).
Please pass parameters to the constructor to initialize the sprite, do not call this function yourself.
Parameters:
{String} filename
The path to an image file in local file system
{cc.Rect} rect
The rectangle assigned the content area from texture.
Returns:
{Boolean} true if the sprite is initialized properly, false otherwise.

            */
            initWithFile(filename?: string, rect?: cc.Rect): boolean;
            /**
            * {Boolean}
initWithSpriteFrame(spriteFrame)
Initializes a sprite with a SpriteFrame. The texture and rect in SpriteFrame will be applied on this sprite.
Please pass parameters to the constructor to initialize the sprite, do not call this function yourself,
Parameters:
{cc.SpriteFrame} spriteFrame
A CCSpriteFrame object. It should includes a valid texture and a rect
Returns:
{Boolean} true if the sprite is initialized properly, false otherwise.

            */
            initWithSpriteFrame(spriteFrame?: cc.SpriteFrame): boolean;
            /**
            * {Boolean}
initWithSpriteFrameName(spriteFrameName)
Initializes a sprite with a sprite frame name.
A cc.SpriteFrame will be fetched from the cc.SpriteFrameCache by name.
If the cc.SpriteFrame doesn&#39;t exist it will raise an exception.
Please pass parameters to the constructor to initialize the sprite, do not call this function yourself.
var sprite = new cc.Sprite();
sprite.initWithSpriteFrameName(&quot;grossini_dance_01.png&quot;);
Parameters:
{String} spriteFrameName
A key string that can fected a valid cc.SpriteFrame from cc.SpriteFrameCache
Returns:
{Boolean} true if the sprite is initialized properly, false otherwise.

            */
            initWithSpriteFrameName(spriteFrameName?: string): boolean;
            /**
            * {Boolean}
initWithTexture(texture, rect, rotated)
Initializes a sprite with a texture and a rect in points, optionally rotated.
After initialization, the rect used will be the size of the texture, and the offset will be (0,0).
Please pass parameters to the constructor to initialize the sprite, do not call this function yourself.
Parameters:
{cc.Texture2D|HTMLImageElement|HTMLCanvasElement} texture
A pointer to an existing CCTexture2D object. You can use a CCTexture2D object for many sprites.
{cc.Rect} rect
Optional
Only the contents inside rect of this texture will be applied for this sprite.
{Boolean} rotated
Optional
Whether or not the texture rectangle is rotated.
Returns:
{Boolean} true if the sprite is initialized properly, false otherwise.

            */
            initWithTexture(texture?: any, rect?: cc.Rect, rotated?: boolean): boolean;
            /**
            * {Boolean}
isDirty()
Returns whether or not the Sprite needs to be updated in the Atlas
Returns:
{Boolean} True if the sprite needs to be updated in the Atlas, false otherwise.

            */
            isDirty(): boolean;
            /**
            * {Boolean}
isFlippedX()
Returns the flag which indicates whether the sprite is flipped horizontally or not.
It only flips the texture of the sprite, and not the texture of the sprite&#39;s children.
Also, flipping the texture doesn&#39;t alter the anchorPoint.
If you want to flip the anchorPoint too, and/or to flip the children too use:
sprite.setScaleX(sprite.getScaleX() * -1);
Returns:
{Boolean} true if the sprite is flipped horizontally, false otherwise.

            */
            isFlippedX(): boolean;
            /**
            * {Boolean}
isFlippedY()
Return the flag which indicates whether the sprite is flipped vertically or not.
It only flips the texture of the sprite, and not the texture of the sprite&#39;s children.
Also, flipping the texture doesn&#39;t alter the anchorPoint.
If you want to flip the anchorPoint too, and/or to flip the children too use:
sprite.setScaleY(sprite.getScaleY() * -1);
Returns:
{Boolean} true if the sprite is flipped vertically, false otherwise.

            */
            isFlippedY(): boolean;
            /**
            * {Boolean}
isFrameDisplayed(frame)
Returns whether or not a cc.SpriteFrame is being displayed
Parameters:
{cc.SpriteFrame} frame
Returns:
{Boolean}

            */
            isFrameDisplayed(frame?: cc.SpriteFrame): boolean;
            /**
            * {Boolean}
isOpacityModifyRGB()
Returns whether opacity modify color or not.
Returns:
{Boolean}

            */
            isOpacityModifyRGB(): boolean;
            /**
            * {Boolean}
isTextureRectRotated()
Returns whether or not the texture rectangle is rotated.
Returns:
{Boolean}

            */
            isTextureRectRotated(): boolean;
            /**
            * removeAllChildren(cleanup)
Removes all children from the container.
Parameters:
cleanup
whether or not cleanup all running actions

            */
            removeAllChildren();
            /**
            * removeChild(child, cleanup)
Removes a child from the sprite.
Parameters:
child
cleanup
whether or not cleanup all running actions

            */
            removeChild();
            /**
            * reorderChild(child, zOrder)
Reorders a child according to a new z value.  (override cc.Node )
Parameters:
{cc.Node} child
{Number} zOrder

            */
            reorderChild(child?: cc.Node, zOrder?: number);
            /**
            * setAtlasIndex(atlasIndex)
Sets the index used on the TextureAtlas.
Parameters:
{Number} atlasIndex

            */
            setAtlasIndex(atlasIndex?: number);
            /**
            * setBatchNode(spriteBatchNode)
Sets the batch node to sprite
var batch = new cc.SpriteBatchNode(&quot;Images/grossini_dance_atlas.png&quot;, 15);
var sprite = new cc.Sprite(batch.texture, cc.rect(0, 0, 57, 57));
batch.addChild(sprite);
layer.addChild(batch);
Parameters:
{cc.SpriteBatchNode|null} spriteBatchNode

            */
            setBatchNode(spriteBatchNode?: any);
            /**
            * setBlendFunc(src, dst)
conforms to cc.TextureProtocol protocol
Parameters:
{Number|cc.BlendFunc} src
{Number} dst

            */
            setBlendFunc(src?: any, dst?: number);
            /**
            * setDirty(bDirty)
Makes the sprite to be updated in the Atlas.
Parameters:
{Boolean} bDirty

            */
            setDirty(bDirty?: boolean);
            /**
            * setDisplayFrame(newFrame)
Sets a new display frame to the sprite.
Parameters:
{cc.SpriteFrame|String} newFrame

            */
            setDisplayFrame(newFrame?: any);
            /**
            * setDisplayFrameWithAnimationName(animationName, frameIndex)
Changes the display frame with animation name and index.
The animation name will be get from the CCAnimationCache
Parameters:
{String} animationName
{Number} frameIndex

            */
            setDisplayFrameWithAnimationName(animationName?: string, frameIndex?: number);
            /**
            * setFlippedX(flippedX)
Sets whether the sprite should be flipped horizontally or not.
Parameters:
{Boolean} flippedX
true if the sprite should be flipped horizontally, false otherwise.

            */
            setFlippedX(flippedX?: boolean);
            /**
            * setFlippedY(flippedY)
Sets whether the sprite should be flipped vertically or not.
Parameters:
{Boolean} flippedY
true if the sprite should be flipped vertically, false otherwise.

            */
            setFlippedY(flippedY?: boolean);
            /**
            * setOpacityModifyRGB(modify)
Sets whether opacity modify color or not.
Parameters:
{Boolean} modify

            */
            setOpacityModifyRGB(modify?: boolean);
            /**
            * setSpriteFrame(newFrame)
Sets a new sprite frame to the sprite.
Parameters:
{cc.SpriteFrame|String} newFrame

            */
            setSpriteFrame(newFrame?: any);
            /**
            * setTexture(texture)
Sets the texture of sprite
Parameters:
{cc.Texture2D|String} texture

            */
            setTexture(texture?: any);
            /**
            * setTextureAtlas(textureAtlas)
Sets the weak reference of the cc.TextureAtlas when the sprite is rendered using via cc.SpriteBatchNode
Parameters:
{cc.TextureAtlas} textureAtlas

            */
            setTextureAtlas(textureAtlas?: cc.TextureAtlas);
            /**
            * setTextureRect(rect, rotated, untrimmedSize, needConvert)
Updates the texture rect of the CCSprite in points.
Parameters:
{cc.Rect} rect
a rect of texture
{Boolean} rotated
Optional
Whether or not the texture is rotated
{cc.Size} untrimmedSize
Optional
The original pixels size of the texture
needConvert

            */
            setTextureRect(rect?: cc.Rect, rotated?: boolean, untrimmedSize?: cc.Size);
            /**
            * setVertexRect(rect)
set the vertex rect.
It will be called internally by setTextureRect.
Useful if you want to create 2x images from SD images in Retina Display.
Do not call it manually. Use setTextureRect instead.
(override this method to generate &quot;double scale&quot; sprites)
Parameters:
{cc.Rect} rect

            */
            setVertexRect(rect?: cc.Rect);
            /**
            * setVisible(visible)
Sets whether the sprite is visible or not.
Parameters:
{Boolean} visible

            */
            setVisible(visible?: boolean);
            /**
            * sortAllChildren()
Sort all children of this sprite node.

            */
            sortAllChildren();
            /**
            * {boolean}
textureLoaded()
Returns whether the texture have been loaded
Returns:
{boolean}

            */
            textureLoaded(): boolean;
            /**
            * updateTransform()
Updates the quad according the the rotation, position, scale values.

            */
            updateTransform();
            /**
            * useBatchNode(batchNode)
Tell the sprite to use batch node render.
Parameters:
{cc.SpriteBatchNode} batchNode

            */
            useBatchNode(batchNode?: cc.SpriteBatchNode);
        }
    }
declare module cc {
        /**
        * A cc.SpriteBatchNode can reference one and only one texture (one image file, one texture atlas).
Only the cc.Sprites that are contained in that texture can be added to the cc.SpriteBatchNode.
All cc.Sprites added to a cc.SpriteBatchNode are drawn in one WebGL draw call.
If the cc.Sprites are not added to a cc.SpriteBatchNode then an WebGL draw call will be needed for each one, which is less efficient.
Limitations:
- The only object that is accepted as child (or grandchild, grand-grandchild, etc...) is cc.Sprite or any subclass of cc.Sprite.
eg: particles, labels and layer can&#39;t be added to a cc.SpriteBatchNode.
- Either all its children are Aliased or Antialiased. It can&#39;t be a mix.
This is because &quot;alias&quot; is a property of the texture, and all the sprites share the same texture.

        */
        export class SpriteBatchNode extends cc.Node {
            /**
            * 
A cc.SpriteBatchNode can reference one and only one texture (one image file, one texture atlas).
            */
            constructor(fileImage?: any, capacity?: number);
            /**
            * 
            */
            static DEFAULT_CAPACITY: number;
            /**
            * -  Descendants of sprite batch node
            */
            descendants: Array<any>;
            /**
            * - The texture atlas
            */
            textureAtlas: cc.TextureAtlas;
            /**
            * addChild(child, zOrder, tag)
Add child to the sprite batch node (override addChild of cc.Node)
Parameters:
{cc.Sprite} child
{Number} zOrder
Optional
{Number} tag
Optional

            */
            addChild(child?: cc.Sprite, zOrder?: number, tag?: number);
            /**
            * {cc.SpriteBatchNode}
addSpriteWithoutQuad(child, z, aTag)
This is the opposite of &quot;addQuadFromSprite.
It add the sprite to the children and descendants array, but it doesn&#39;t update add it to the texture atlas
Parameters:
{cc.Sprite} child
{Number} z
zOrder
{Number} aTag
Returns:
{cc.SpriteBatchNode}

            */
            addSpriteWithoutQuad(child?: cc.Sprite, z?: number, aTag?: number): cc.SpriteBatchNode;
            /**
            * appendChild(sprite)
Add child at the end, faster than insert child
Parameters:
{cc.Sprite} sprite

            */
            appendChild(sprite?: cc.Sprite);
            /**
            * {Number}
atlasIndexForChild(sprite, nZ)
Returns atlas index for child
Parameters:
{cc.Sprite} sprite
{Number} nZ
Returns:
{Number}

            */
            atlasIndexForChild(sprite?: cc.Sprite, nZ?: number): number;
            /**
            * &amp;lt;static&amp;gt;
{cc.SpriteBatchNode}
cc.SpriteBatchNode.create(fileImage, capacity)
creates a cc.SpriteBatchNodeCanvas with a file image (.png, .jpg etc) with a default capacity of 29 children.
The capacity will be increased in 33% in runtime if it run out of space.
The file will be loaded using the TextureMgr.
Parameters:
{String|cc.Texture2D} fileImage
{Number} capacity
Deprecated:
since v3.0, please use new construction instead
Returns:
{cc.SpriteBatchNode}
See:
cc.SpriteBatchNode

            */
            static create(fileImage?: any, capacity?: number): cc.SpriteBatchNode;
            /**
            * &amp;lt;static&amp;gt;
cc.SpriteBatchNode.createWithTexture()
Deprecated:
since v3.0, please use new construction instead
See:
cc.SpriteBatchNode

            */
            static createWithTexture();
            /**
            * {cc.BlendFunc}
getBlendFunc()
Returns the blending function used for the texture
Returns:
{cc.BlendFunc}

            */
            getBlendFunc(): cc.BlendFunc;
            /**
            * {Array}
getDescendants()
Return Descendants of cc.SpriteBatchNode
Returns:
{Array}

            */
            getDescendants(): Array<any>;
            /**
            * {cc.Texture2D}
getTexture()
Returns texture of the sprite batch node
Returns:
{cc.Texture2D}

            */
            getTexture(): cc.Texture2D;
            /**
            * {cc.TextureAtlas}
getTextureAtlas()
Return TextureAtlas of cc.SpriteBatchNode
Returns:
{cc.TextureAtlas}

            */
            getTextureAtlas(): cc.TextureAtlas;
            /**
            * {Number}
highestAtlasIndexInChild(sprite)
Returns highest atlas index in child
Parameters:
{cc.Sprite} sprite
Returns:
{Number}

            */
            highestAtlasIndexInChild(sprite?: cc.Sprite): number;
            /**
            * increaseAtlasCapacity()
Increase Atlas Capacity

            */
            increaseAtlasCapacity();
            /**
            * {Boolean}
init(fileImage, capacity)
initializes a cc.SpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and a capacity of children.
The capacity will be increased in 33% in runtime if it run out of space.
The file will be loaded using the TextureMgr.
Please pass parameters to constructor to initialize the sprite batch node, do not call this function yourself.
Parameters:
{String} fileImage
{Number} capacity
Returns:
{Boolean}

            */
            init(fileImage?: string, capacity?: number): boolean;
            /**
            * {Boolean}
initWithFile(fileImage, capacity)
Initializes a cc.SpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and a capacity of children.
The capacity will be increased in 33% in runtime if it run out of space.
The file will be loaded using the TextureMgr.
Please pass parameters to constructor to initialize the sprite batch node, do not call this function yourself.
Parameters:
{String} fileImage
{Number} capacity
Returns:
{Boolean}

            */
            initWithFile(fileImage?: string, capacity?: number): boolean;
            /**
            * {Boolean}
initWithTexture(tex, capacity)
Initializes a cc.SpriteBatchNode with a texture2d and capacity of children.
The capacity will be increased in 33% in runtime if it run out of space.
Please pass parameters to constructor to initialize the sprite batch node, do not call this function yourself.
Parameters:
{cc.Texture2D} tex
{Number} capacity
Optional
Returns:
{Boolean}

            */
            initWithTexture(tex?: cc.Texture2D, capacity?: number): boolean;
            /**
            * insertChild(sprite, index)
Insert a child
Parameters:
{cc.Sprite} sprite
The child sprite
{Number} index
The insert index

            */
            insertChild(sprite?: cc.Sprite, index?: number);
            /**
            * insertQuadFromSprite(sprite, index)
Inserts a quad at a certain index into the texture atlas. The cc.Sprite won&#39;t be added into the children array.
This method should be called only when you are dealing with very big AtlasSprite and when most of the cc.Sprite won&#39;t be updated.
For example: a tile map (cc.TMXMap) or a label with lots of characters (cc.LabelBMFont)
Parameters:
{cc.Sprite} sprite
{Number} index

            */
            insertQuadFromSprite(sprite?: cc.Sprite, index?: number);
            /**
            * {Number}
lowestAtlasIndexInChild(sprite)
Returns lowest atlas index in child
Parameters:
{cc.Sprite} sprite
Returns:
{Number}

            */
            lowestAtlasIndexInChild(sprite?: cc.Sprite): number;
            /**
            * {Number}
rebuildIndexInOrder(pobParent, index)
Rebuild index in order for child
Parameters:
{cc.Sprite} pobParent
{Number} index
Returns:
{Number}

            */
            rebuildIndexInOrder(pobParent?: cc.Sprite, index?: number): number;
            /**
            * removeAllChildren(cleanup)
Removes all children from the container and do a cleanup all running actions depending on the cleanup parameter.
(override removeAllChildren of cc.Node)
Parameters:
{Boolean} cleanup

            */
            removeAllChildren(cleanup?: boolean);
            /**
            * removeChild(child, cleanup)
Removes a child from cc.SpriteBatchNode (override removeChild of cc.Node)
Parameters:
{cc.Sprite} child
{Boolean} cleanup

            */
            removeChild(child?: cc.Sprite, cleanup?: boolean);
            /**
            * removeChildAtIndex(index, doCleanup)
Removes a child given a certain index. It will also cleanup the running actions depending on the cleanup parameter.
Parameters:
{Number} index
{Boolean} doCleanup

            */
            removeChildAtIndex(index?: number, doCleanup?: boolean);
            /**
            * removeSpriteFromAtlas(sprite)
Removes sprite from TextureAtlas
Parameters:
{cc.Sprite} sprite

            */
            removeSpriteFromAtlas(sprite?: cc.Sprite);
            /**
            * reorderBatch(reorder)
Sprites use this to start sortChildren, don&#39;t call this manually
Parameters:
{Boolean} reorder

            */
            reorderBatch(reorder?: boolean);
            /**
            * reorderChild(child, zOrder)
Reorder children (override reorderChild of cc.Node)
Parameters:
{cc.Sprite} child
{Number} zOrder

            */
            reorderChild(child?: cc.Sprite, zOrder?: number);
            /**
            * setBlendFunc(src, dst)
Sets the source and destination blending function for the texture
Parameters:
{Number | cc.BlendFunc} src
{Number} dst

            */
            setBlendFunc(src?: any, dst?: number);
            /**
            * setTexture(texture)
Sets the texture of the sprite batch node.
Parameters:
{cc.Texture2D} texture

            */
            setTexture(texture?: cc.Texture2D);
            /**
            * setTextureAtlas(textureAtlas)
TextureAtlas of cc.SpriteBatchNode setter
Parameters:
{cc.TextureAtlas} textureAtlas

            */
            setTextureAtlas(textureAtlas?: cc.TextureAtlas);
            /**
            * sortAllChildren()
Sort all children nodes (override draw of cc.Node)

            */
            sortAllChildren();
            /**
            * updateQuadFromSprite(sprite, index)
Updates a quad at a certain index into the texture atlas. The CCSprite won&#39;t be added into the children array.
This method should be called only when you are dealing with very big AtlasSrite and when most of the cc.Sprite won&#39;t be updated.
For example: a tile map (cc.TMXMap) or a label with lots of characters (BitmapFontAtlas)
Parameters:
{cc.Sprite} sprite
{Number} index

            */
            updateQuadFromSprite(sprite?: cc.Sprite, index?: number);
        }
    }
declare module cc {
        /**
        * A cc.SpriteFrame has:
- texture: A cc.Texture2D that will be used by the cc.Sprite
- rectangle: A rectangle of the texture
You can modify the frame of a cc.Sprite by doing:

        */
        export class SpriteFrame extends cc.Class {
            /**
            * 
A cc.SpriteFrame has:
- texture: A cc.Texture2D that will be used by the cc.Sprite
- rectangle: A rectangle of the texture
You can modify the frame of a cc.Sprite by doing:

            */
            constructor(filename?: any, rect?: cc.Rect, rotated?: boolean, offset?: cc.Point, originalSize?: cc.Size);
            /**
            * addLoadedEventListener(callback, target)
Add a event listener for texture loaded event.
Parameters:
{Function} callback
{Object} target
Deprecated:
since 3.1, please use addEventListener instead

            */
            addLoadedEventListener(callback?: Function, target?: Object);
            /**
            * {SpriteFrame}
clone()
Clone the sprite frame
Returns:
{SpriteFrame}

            */
            clone(): SpriteFrame;
            /**
            * {cc.SpriteFrame}
copy()
Copy the sprite frame
Returns:
{cc.SpriteFrame}

            */
            copy(): cc.SpriteFrame;
            /**
            * {cc.SpriteFrame}
copyWithZone()
Copy the sprite frame
Returns:
{cc.SpriteFrame}

            */
            copyWithZone(): cc.SpriteFrame;
            /**
            * &amp;lt;static&amp;gt;
{cc.SpriteFrame}
cc.SpriteFrame.create(filename, rect, rotated, offset, originalSize)
Create a cc.SpriteFrame with a texture filename, rect, rotated, offset and originalSize in pixels.
The originalSize is the size in pixels of the frame before being trimmed.
Parameters:
{String|cc.Texture2D} filename
{cc.Rect} rect
if parameters&#39; length equal 2, rect in points, else rect in pixels
{Boolean} rotated
{cc.Point} offset
{cc.Size} originalSize
Deprecated:
since v3.0, please use new construction instead
Returns:
{cc.SpriteFrame}
See:
cc.SpriteFrame

            */
            static create(filename?: any, rect?: cc.Rect, rotated?: boolean, offset?: cc.Point, originalSize?: cc.Size): cc.SpriteFrame;
            /**
            * &amp;lt;static&amp;gt;
cc.SpriteFrame.createWithTexture()
Deprecated:
since v3.0, please use new construction instead
See:
cc.SpriteFrame

            */
            static createWithTexture();
            /**
            * {cc.Point}
getOffset()
Returns the offset of the frame in the texture
Returns:
{cc.Point}

            */
            getOffset(): cc.Point;
            /**
            * {cc.Point}
getOffsetInPixels()
Returns the offset of the sprite frame in the texture in pixel
Returns:
{cc.Point}

            */
            getOffsetInPixels(): cc.Point;
            /**
            * {cc.Size}
getOriginalSize()
Returns the original size of the trimmed image
Returns:
{cc.Size}

            */
            getOriginalSize(): cc.Size;
            /**
            * {cc.Size}
getOriginalSizeInPixels()
Returns the original size of the trimmed image
Returns:
{cc.Size}

            */
            getOriginalSizeInPixels(): cc.Size;
            /**
            * {cc.Rect}
getRect()
Returns the rect of the sprite frame in the texture
Returns:
{cc.Rect}

            */
            getRect(): cc.Rect;
            /**
            * {cc.Rect}
getRectInPixels()
Gets the rect of the frame in the texture
Returns:
{cc.Rect}

            */
            getRectInPixels(): cc.Rect;
            /**
            * {cc.Texture2D}
getTexture()
Returns the texture of the frame
Returns:
{cc.Texture2D}

            */
            getTexture(): cc.Texture2D;
            /**
            * {Boolean}
initWithTexture(texture, rect, rotated, offset, originalSize)
Initializes SpriteFrame with Texture, rect, rotated, offset and originalSize in pixels.
Please pass parameters to the constructor to initialize the sprite, do not call this function yourself.
Parameters:
{String|cc.Texture2D} texture
{cc.Rect} rect
if parameters&#39; length equal 2, rect in points, else rect in pixels
{Boolean} rotated
Optional, Default: false
{cc.Point} offset
Optional, Default: cc.p(0,0)
{cc.Size} originalSize
Optional, Default: rect.size
Returns:
{Boolean}

            */
            initWithTexture(texture?: any, rect?: cc.Rect, rotated?: boolean, offset?: cc.Point, originalSize?: cc.Size): boolean;
            /**
            * {Boolean}
isRotated()
Returns whether the sprite frame is rotated in the texture.
Returns:
{Boolean}

            */
            isRotated(): boolean;
            /**
            * setOffset(offsets)
Sets the offset of the frame in the texture
Parameters:
{cc.Point} offsets

            */
            setOffset(offsets?: cc.Point);
            /**
            * setOffsetInPixels(offsetInPixels)
Sets the offset of the sprite frame in the texture in pixel
Parameters:
{cc.Point} offsetInPixels

            */
            setOffsetInPixels(offsetInPixels?: cc.Point);
            /**
            * setOriginalSize(sizeInPixels)
Sets the original size of the trimmed image
Parameters:
{cc.Size} sizeInPixels

            */
            setOriginalSize(sizeInPixels?: cc.Size);
            /**
            * setOriginalSizeInPixels(sizeInPixels)
Sets the original size of the trimmed image
Parameters:
{cc.Size} sizeInPixels

            */
            setOriginalSizeInPixels(sizeInPixels?: cc.Size);
            /**
            * setRect(rect)
Sets the rect of the sprite frame in the texture
Parameters:
{cc.Rect} rect

            */
            setRect(rect?: cc.Rect);
            /**
            * setRectInPixels(rectInPixels)
Sets the rect of the frame in the texture
Parameters:
{cc.Rect} rectInPixels

            */
            setRectInPixels(rectInPixels?: cc.Rect);
            /**
            * setRotated(bRotated)
Set whether the sprite frame is rotated in the texture.
Parameters:
{Boolean} bRotated

            */
            setRotated(bRotated?: boolean);
            /**
            * setTexture(texture)
Sets the texture of the frame, the texture is retained automatically
Parameters:
{cc.Texture2D} texture

            */
            setTexture(texture?: cc.Texture2D);
            /**
            * {boolean}
textureLoaded()
Returns whether the texture have been loaded
Returns:
{boolean}

            */
            textureLoaded(): boolean;
        }
    }
declare module cc {
        /**
        * cc.spriteFrameCache is a singleton that handles the loading of the sprite frames. It saves in a cache the sprite frames.

example
// add SpriteFrames to spriteFrameCache With File
cc.spriteFrameCache.addSpriteFrames(s_grossiniPlist);

        */
        export class spriteFrameCache  {
            /**
            * 
cc.spriteFrameCache is a singleton that handles the loading of the sprite frames.
            */
            constructor();
            /**
            * addSpriteFrame(frame, frameName)
Adds an sprite frame with a given name.
If the name already exists, then the contents of the old name will be replaced with the new one.
Parameters:
{cc.SpriteFrame} frame
{String} frameName

            */
            addSpriteFrame(frame?: cc.SpriteFrame, frameName?: string);
            /**
            * addSpriteFrames(url, texture)
Adds multiple Sprite Frames from a plist or json file.
A texture will be loaded automatically. The texture name will composed by replacing the .plist or .json suffix with .png
If you want to use another texture, you should use the addSpriteFrames:texture method.
// add SpriteFrames to SpriteFrameCache With File
cc.spriteFrameCache.addSpriteFrames(s_grossiniPlist);
cc.spriteFrameCache.addSpriteFrames(s_grossiniJson);
Parameters:
{String} url
file path
{HTMLImageElement|cc.Texture2D|string} texture

            */
            addSpriteFrames(url?: string, texture?: any);
            /**
            * {cc.SpriteFrame}
getSpriteFrame(name)
Returns an Sprite Frame that was previously added.
If the name is not found it will return nil.
You should retain the returned copy if you are going to use it.
//get a SpriteFrame by name
var frame = cc.spriteFrameCache.getSpriteFrame(&quot;grossini_dance_01.png&quot;);
Parameters:
{String} name
name of SpriteFrame
Returns:
{cc.SpriteFrame}

            */
            getSpriteFrame(name?: string): cc.SpriteFrame;
            /**
            * removeSpriteFrameByName(name)
Deletes an sprite frame from the sprite frame cache.
Parameters:
{String} name

            */
            removeSpriteFrameByName(name?: string);
            /**
            * removeSpriteFrames()
Purges the dictionary of loaded sprite frames.
Call this method if you receive the &quot;Memory Warning&quot;.
In the short term: it will free some resources preventing your app from being killed.
In the medium term: it will allocate more resources.
In the long term: it will be the same.

            */
            removeSpriteFrames();
            /**
            * removeSpriteFramesFromFile(url)
Removes multiple Sprite Frames from a plist file.
Sprite Frames stored in this file will be removed.
It is convinient to call this method when a specific texture needs to be removed.
Parameters:
{String} url
Plist filename

            */
            removeSpriteFramesFromFile(url?: string);
            /**
            * removeSpriteFramesFromTexture(texture)
Removes all Sprite Frames associated with the specified textures.
It is convenient to call this method when a specific texture needs to be removed.
Parameters:
{HTMLImageElement|HTMLCanvasElement|cc.Texture2D} texture

            */
            removeSpriteFramesFromTexture(texture?: any);
        }
    }
declare module cc {
        /**
        * cc.StopGrid action.

        */
        export class StopGrid extends cc.ActionInstant {
            /**
            * 
cc.StopGrid action.
            */
            constructor();
            /**
            * Please use cc.stopGrid instead
Allocates and initializes the action
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.StopGrid;
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
        }
    }
declare module cc {
        /**
        * 
        */
        export class sys  {
            /**
            * 
            */
            static ANDROID;
            /**
            * 
            */
            static BLACKBERRY;
            /**
            * Indicate the running browser type
            */
            static browserType;
            /**
            * 
            */
            static DESKTOP_BROWSER;
            /**
            * 
            */
            static EMSCRIPTEN;
            /**
            * 
            */
            static IPAD;
            /**
            * 
            */
            static IPHONE;
            /**
            * Indicate whether system is mobile system
            */
            static isMobile;
            /**
            * Is native ? This is set to be true in jsb auto.
            */
            static isNative;
            /**
            * Indicate the current language of the running system
            */
            static language;
            /**
            * Arabic language code
            */
            static LANGUAGE_ARABIC;
            /**
            * Chinese language code
            */
            static LANGUAGE_CHINESE;
            /**
            * Spanish language code
            */
            static LANGUAGE_DUTCH;
            /**
            * English language code
            */
            static LANGUAGE_ENGLISH;
            /**
            * French language code
            */
            static LANGUAGE_FRENCH;
            /**
            * German language code
            */
            static LANGUAGE_GERMAN;
            /**
            * Hungarian language code
            */
            static LANGUAGE_HUNGARIAN;
            /**
            * Italian language code
            */
            static LANGUAGE_ITALIAN;
            /**
            * Japanese language code
            */
            static LANGUAGE_JAPANESE;
            /**
            * Korean language code
            */
            static LANGUAGE_KOREAN;
            /**
            * Norwegian language code
            */
            static LANGUAGE_NORWEGIAN;
            /**
            * Polish language code
            */
            static LANGUAGE_POLISH;
            /**
            * Portuguese language code
            */
            static LANGUAGE_PORTUGUESE;
            /**
            * Russian language code
            */
            static LANGUAGE_RUSSIAN;
            /**
            * Spanish language code
            */
            static LANGUAGE_SPANISH;
            /**
            * 
            */
            static LINUX;
            /**
            * cc.sys.localStorage is a local storage component.
            */
            static localStorage;
            /**
            * 
            */
            static MACOS;
            /**
            * 
            */
            static MOBILE_BROWSER;
            /**
            * 
            */
            static NACL;
            /**
            * Indicate the running os name
            */
            static os;
            /**
            * 
            */
            static OS_ANDROID;
            /**
            * 
            */
            static OS_IOS;
            /**
            * 
            */
            static OS_LINUX;
            /**
            * 
            */
            static OS_OSX;
            /**
            * 
            */
            static OS_UNIX;
            /**
            * 
            */
            static OS_UNKNOWN;
            /**
            * 
            */
            static OS_WINDOWS;
            /**
            * Indicate the running platform
            */
            static platform;
            /**
            * 
            */
            static TIZEN;
            /**
            * 
            */
            static WINDOWS;
            /**
            * 
            */
            static WINRT;
            /**
            * 
            */
            static WP8;
            /**
            * &amp;lt;static&amp;gt;
cc.sys.cleanScript(jsfile)
Clean a script in the JS VM, only available in JSB
Parameters:
{String} jsfile

            */
            static cleanScript(jsfile?: string);
            /**
            * &amp;lt;static&amp;gt;
cc.sys.dump()
Dump system informations

            */
            static dump();
            /**
            * &amp;lt;static&amp;gt;
cc.sys.dumpRoot()
Dumps rooted objects, only available in JSB

            */
            static dumpRoot();
            /**
            * &amp;lt;static&amp;gt;
cc.sys.garbageCollect()
Forces the garbage collection, only available in JSB

            */
            static garbageCollect();
            /**
            * &amp;lt;static&amp;gt;
cc.sys.restartVM()
Restart the JS VM, only available in JSB

            */
            static restartVM();
        }
    }
declare module cc {
        /**
        * 
UITableView counterpart for cocos2d for iphone.
this is a very basic, minimal implementation to bring UITableView-like component into cocos2d world.

        */
        export class TableView extends cc.ScrollView {
            /**
            * UITableView counterpart for cocos2d for iphone.
            */
            constructor();
            /**
            * - The data source of the table view
            */
            dataSource: cc.TableViewDataSource;
            /**
            * - The event delegate of the table view
            */
            delegate: cc.TableViewDelegate;
            /**
            * - The index to determine how cell is ordered and filled in the view
            */
            verticalFillOrder: number;
            /**
            * {cc.TableViewCell}
cellAtIndex(idx)
Returns an existing cell at a given index. Returns nil if a cell is nonexistent at the moment of query.
Parameters:
idx
index
Returns:
{cc.TableViewCell} a cell at a given index

            */
            cellAtIndex(): cc.TableViewCell;
            /**
            * &amp;lt;static&amp;gt;
{cc.TableView}
cc.TableView.create(dataSource, size, container)
An initialized table view object
Parameters:
{cc.TableViewDataSource} dataSource
data source;
{cc.Size} size
view size
{cc.Node} container
Optional
parent object for cells
Returns:
{cc.TableView} table view

            */
            static create(dataSource?: cc.TableViewDataSource, size?: cc.Size, container?: cc.Node): cc.TableView;
            /**
            * ctor(dataSource, size, container)
The
Parameters:
dataSource
size
container

            */
            ctor();
            /**
            * {TableViewCell}
dequeueCell()
Dequeues a free cell if available. nil if not.
Returns:
{TableViewCell} free cell

            */
            dequeueCell(): TableViewCell;
            /**
            * getDataSource()
data source

            */
            getDataSource();
            /**
            * getDelegate()
delegate

            */
            getDelegate();
            /**
            * insertCellAtIndex(idx)
Inserts a new cell at a given index
Parameters:
idx
location to insert

            */
            insertCellAtIndex();
            /**
            * reloadData()
reloads data from data source.  the view will be refreshed.

            */
            reloadData();
            /**
            * removeCellAtIndex(idx)
Removes a cell at a given index
Parameters:
idx
index to find a cell

            */
            removeCellAtIndex();
            /**
            * setVerticalFillOrder(fillOrder)
determines how cell is ordered and filled in the view.
Parameters:
fillOrder

            */
            setVerticalFillOrder();
            /**
            * updateCellAtIndex(idx)
Updates the content of the cell at a given index.
Parameters:
idx
index to find a cell

            */
            updateCellAtIndex();
        }
    }
declare module cc {
        /**
        * 
Abstract class for SWTableView cell node

        */
        export class TableViewCell extends cc.Node {
            /**
            * Abstract class for SWTableView cell node
            */
            constructor();
            /**
            * - The index used internally by SWTableView and its subclasses
            */
            objectId: number;
            /**
            * getIdx()
The index used internally by SWTableView and its subclasses

            */
            getIdx();
            /**
            * reset()
Cleans up any resources linked to this cell and resets idx property.

            */
            reset();
        }
    }
declare module cc {
        /**
        * Overrides the target of an action so that it always runs on the target
specified at action creation rather than the one specified by runAction.

        */
        export class TargetedAction extends cc.ActionInterval {
            /**
            * 
Overrides the target of an action so that it always runs on the target
specified at action creation rather than the one specified by runAction.
            */
            constructor(target?: cc.Node, action?: cc.FiniteTimeAction);
            /**
            * Please use cc.targetedAction instead
Create an action with the specified action and forced target
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.TargetedAction;
            /**
            * {cc.TargetedAction}
clone()
returns a new clone of the action
Returns:
{cc.TargetedAction}

            */
            clone(): cc.TargetedAction;
            /**
            * ctor(target, action)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create an action with the specified action and forced target.
Parameters:
{cc.Node} target
{cc.FiniteTimeAction} action

            */
            ctor(target?: cc.Node, action?: cc.FiniteTimeAction);
            /**
            * {cc.Node}
getForcedTarget()
return the target that the action will be forced to run with
Returns:
{cc.Node}

            */
            getForcedTarget(): cc.Node;
            /**
            * {Boolean}
initWithTarget(target, action)
Init an action with the specified action and forced target
Parameters:
{cc.Node} target
{cc.FiniteTimeAction} action
Returns:
{Boolean}

            */
            initWithTarget(target?: cc.Node, action?: cc.FiniteTimeAction): boolean;
            /**
            * setForcedTarget(forcedTarget)
set the target that the action will be forced to run with
Parameters:
{cc.Node} forcedTarget

            */
            setForcedTarget(forcedTarget?: cc.Node);
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * stop()
stop the action

            */
            stop();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
        */
        export class Tex2F  {
            /**
            * 
            */
            constructor(u1?: number, v1?: number);
        }
    }
declare module cc {
        /**
        * 
Text field delegate

        */
        export class TextFieldDelegate extends cc.Class {
            /**
            * Text field delegate
            */
            constructor();
            /**
            * {Boolean}
onDraw(sender)
If doesn&#39;t want draw sender as default, return true.
Parameters:
{cc.TextFieldTTF} sender
Returns:
{Boolean}

            */
            onDraw(sender?: cc.TextFieldTTF): boolean;
            /**
            * {Boolean}
onTextFieldAttachWithIME(sender)
If the sender doesn&#39;t want to attach with IME, return true;
Parameters:
{cc.TextFieldTTF} sender
Returns:
{Boolean}

            */
            onTextFieldAttachWithIME(sender?: cc.TextFieldTTF): boolean;
            /**
            * {Boolean}
onTextFieldDeleteBackward(sender, delText, len)
If the sender doesn&#39;t want to delete the delText, return true;
Parameters:
{cc.TextFieldTTF} sender
{String} delText
{Number} len
Returns:
{Boolean}

            */
            onTextFieldDeleteBackward(sender?: cc.TextFieldTTF, delText?: string, len?: number): boolean;
            /**
            * {Boolean}
onTextFieldDetachWithIME(sender)
If the sender doesn&#39;t want to detach with IME, return true;
Parameters:
{cc.TextFieldTTF} sender
Returns:
{Boolean}

            */
            onTextFieldDetachWithIME(sender?: cc.TextFieldTTF): boolean;
            /**
            * {Boolean}
onTextFieldInsertText(sender, text, len)
If the sender doesn&#39;t want to insert the text, return true;
Parameters:
{cc.TextFieldTTF} sender
{String} text
{Number} len
Returns:
{Boolean}

            */
            onTextFieldInsertText(sender?: cc.TextFieldTTF, text?: string, len?: number): boolean;
        }
    }
declare module cc {
        /**
        * 
A simple text input field with TTF font.

        */
        export class TextFieldTTF extends cc.LabelTTF {
            /**
            * A simple text input field with TTF font.
            */
            constructor(placeholder?: string, dimensions?: cc.Size, alignment?: number, fontName?: string, fontSize?: number);
            /**
            * -  Characators count
            */
            charCount: number;
            /**
            * 
            */
            colorSpaceHolder: cc.Color;
            /**
            * - Delegate
            */
            delegate: cc.Node;
            /**
            * - Place holder for the field
            */
            placeHolder: string;
            /**
            * {Boolean}
attachWithIME()
Open keyboard and receive input text.
Returns:
{Boolean}

            */
            attachWithIME(): boolean;
            /**
            * {Boolean}
canAttachWithIME()
Return whether to allow attach with IME.
Returns:
{Boolean}

            */
            canAttachWithIME(): boolean;
            /**
            * {Boolean}
canDetachWithIME()
Return whether to allow detach with IME.
Returns:
{Boolean}

            */
            canDetachWithIME(): boolean;
            /**
            * &amp;lt;static&amp;gt;
{cc.TextFieldTTF|Null}
cc.TextFieldTTF.create(placeholder, dimensions, alignment, fontName, fontSize)
Please use new TextFieldTTF instead.
Creates a cc.TextFieldTTF from a fontName, alignment, dimension and font size.
Parameters:
{String} placeholder
{cc.Size} dimensions
{Number} alignment
{String} fontName
{Number} fontSize
Deprecated:
since v3.0 Please use new TextFieldTTF instead.
Returns:
{cc.TextFieldTTF|Null}

            */
            static create(placeholder?: string, dimensions?: cc.Size, alignment?: number, fontName?: string, fontSize?: number): any;
            /**
            * ctor(placeholder, dimensions, alignment, fontName, fontSize)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates a cc.TextFieldTTF from a fontName, alignment, dimension and font size.
Parameters:
{String} placeholder
{cc.Size} dimensions
{Number} alignment
{String} fontName
{Number} fontSize

            */
            ctor(placeholder?: string, dimensions?: cc.Size, alignment?: number, fontName?: string, fontSize?: number);
            /**
            * deleteBackward()
Delete backward

            */
            deleteBackward();
            /**
            * {Boolean}
detachWithIME()
End text input  and close keyboard.
Returns:
{Boolean}

            */
            detachWithIME(): boolean;
            /**
            * didAttachWithIME()
When the delegate detach with IME, this method call by CCIMEDispatcher.

            */
            didAttachWithIME();
            /**
            * didDetachWithIME()
When the delegate detach with IME, this method call by CCIMEDispatcher.

            */
            didDetachWithIME();
            /**
            * draw(ctx)
Render function using the canvas 2d context or WebGL context, internal usage only, please do not call this function.
Parameters:
{CanvasRenderingContext2D | WebGLRenderingContext} ctx
The render context

            */
            draw(ctx?: any);
            /**
            * {Number}
getCharCount()
Gets the char count.
Returns:
{Number}

            */
            getCharCount(): number;
            /**
            * {cc.Color}
getColorSpaceHolder()
Returns the color of space holder.
Returns:
{cc.Color}

            */
            getColorSpaceHolder(): cc.Color;
            /**
            * {String}
getContentText()
Gets the input text.
Returns:
{String}

            */
            getContentText(): string;
            /**
            * {cc.Node}
getDelegate()
Gets the delegate.
Returns:
{cc.Node}

            */
            getDelegate(): cc.Node;
            /**
            * {String}
getPlaceHolder()
Gets the place holder.
default display string.
Returns:
{String}

            */
            getPlaceHolder(): string;
            /**
            * {String}
getString()
Gets the string
Returns:
{String}

            */
            getString(): string;
            /**
            * {Boolean}
initWithPlaceHolder(placeholder, dimensions, alignment, fontName, fontSize)
Initializes the cc.TextFieldTTF with a font name, alignment, dimension and font size
//example
var  textField = new cc.TextFieldTTF();
// When five parameters
textField.initWithPlaceHolder(&quot;&quot;, cc.size(100,50), cc.TEXT_ALIGNMENT_LEFT,&quot;Arial&quot;, 32);
// When three parameters
textField.initWithPlaceHolder(&quot;&quot;, &quot;Arial&quot;, 32);
Parameters:
{String} placeholder
{cc.Size} dimensions
{Number} alignment
{String} fontName
{Number} fontSize
Returns:
{Boolean}

            */
            initWithPlaceHolder(placeholder?: string, dimensions?: cc.Size, alignment?: number, fontName?: string, fontSize?: number): boolean;
            /**
            * insertText(text, len)
Append the text.
Input the character.
Parameters:
{String} text
{Number} len

            */
            insertText(text?: string, len?: number);
            /**
            * removeDelegate()
Remove delegate

            */
            removeDelegate();
            /**
            * setColorSpaceHolder(value)
Sets the color of space holder.
Parameters:
{cc.Color} value

            */
            setColorSpaceHolder(value?: cc.Color);
            /**
            * setDelegate(value)
Set the delegate.
Parameters:
{cc.Node} value

            */
            setDelegate(value?: cc.Node);
            /**
            * setPlaceHolder(text)
Set the place holder.
display this string if string equal &quot;&quot;.
Parameters:
{String} text

            */
            setPlaceHolder(text?: string);
            /**
            * setString(text)
Input text property
Parameters:
{String} text

            */
            setString(text?: string);
            /**
            * setTextColor(textColor)
Sets the color of cc.TextFieldTTF&#39;s text.
Parameters:
{cc.Color} textColor

            */
            setTextColor(textColor?: cc.Color);
            /**
            * visit(ctx)
Recursive method that visit its children and draw them.
Parameters:
{CanvasRenderingContext2D|WebGLRenderingContext} ctx

            */
            visit(ctx?: any);
        }
    }
declare module cc {
        /**
        * This class allows to easily create OpenGL or Canvas 2D textures from images, text or raw data.
The created cc.Texture2D object will always have power-of-two dimensions.
Depending on how you create the cc.Texture2D object, the actual image area of the texture might be smaller than the texture dimensions
i.e. &quot;contentSize&quot; != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0).
Be aware that the content of the generated textures will be upside-down!

        */
        export class Texture2D extends cc.Class {
            /**
            * 
This class allows to easily create OpenGL or Canvas 2D textures from images, text or raw data.
            */
            constructor();
            /**
            * - The default pixel format
            */
            defaultPixelFormat: number;
            /**
            * - Content height in points
            */
            height: number;
            /**
            * - Texture max S
            */
            maxS: number;
            /**
            * - Texture max T
            */
            maxT: number;
            /**
            * -  WebGLTexture Object
            */
            name: WebGLTexture;
            /**
            * -  Pixel format of the texture
            */
            pixelFormat: number;
            /**
            * -  Height in pixels
            */
            pixelsHeight: number;
            /**
            * -  Width in pixels
            */
            pixelsWidth: number;
            /**
            * - The shader program used by drawAtPoint and drawInRect
            */
            shaderProgram: cc.GLProgram;
            /**
            * - Content width in points
            */
            width: number;
            /**
            * addLoadedEventListener(callback, target)
add listener for loaded event
Parameters:
{Function} callback
{cc.Node} target
Deprecated:
since 3.1, please use addEventListener instead

            */
            addLoadedEventListener(callback?: Function, target?: cc.Node);
            /**
            * {string}
description()
description of cc.Texture2D
Returns:
{string}

            */
            description(): string;
            /**
            * {cc.Size}
getContentSize()
get content size
Returns:
{cc.Size}

            */
            getContentSize(): cc.Size;
            /**
            * {cc.Size}
getContentSizeInPixels()
get content size in pixels
Returns:
{cc.Size}

            */
            getContentSizeInPixels(): cc.Size;
            /**
            * {HTMLImageElement|HTMLCanvasElement}
getHtmlElementObj()
HTMLElement Object getter
Returns:
{HTMLImageElement|HTMLCanvasElement}

            */
            getHtmlElementObj(): any;
            /**
            * {Number}
getPixelsHigh()
get height of in pixels
Returns:
{Number}

            */
            getPixelsHigh(): number;
            /**
            * {Number}
getPixelsWide()
get width in pixels
Returns:
{Number}

            */
            getPixelsWide(): number;
            /**
            * handleLoadedTexture()
handle loaded texture

            */
            handleLoadedTexture();
            /**
            * initWithElement(element)
init with HTML element
Parameters:
{HTMLImageElement|HTMLCanvasElement} element

            */
            initWithElement(element?: any);
            /**
            * initWithETCFile(file)
init with ETC file
Parameters:
file

            */
            initWithETCFile();
            /**
            * initWithPVRFile(file)
init with PVR file
Parameters:
file

            */
            initWithPVRFile();
            /**
            * initWithPVRTCData(data, level, bpp, hasAlpha, length, pixelFormat)
init with PVRTC data
Parameters:
data
level
bpp
hasAlpha
length
pixelFormat

            */
            initWithPVRTCData();
            /**
            * {boolean}
isLoaded()
check whether texture is loaded
Returns:
{boolean}

            */
            isLoaded(): boolean;
            /**
            * removeLoadedEventListener(target)
remove listener from listeners by target
Parameters:
{cc.Node} target
Deprecated:
since 3.1, please use addEventListener instead

            */
            removeLoadedEventListener(target?: cc.Node);
        }
    }
declare module cc {
        /**
        * 
A class that implements a Texture Atlas.
Supported features:
The atlas file can be a PNG, JPG.
Quads can be updated in runtime
Quads can be added in runtime
Quads can be removed in runtime
Quads can be re-ordered in runtime
The TextureAtlas capacity can be increased or decreased in runtime.

        */
        export class TextureAtlas extends cc.Class {
            /**
            * A class that implements a Texture Atlas.
            */
            constructor();
            /**
            * -  Quantity of quads that can be stored with the current texture atlas size.
            */
            capacity: number;
            /**
            * - Indicates whether or not the array buffer of the VBO needs to be updated.
            */
            dirty: boolean;
            /**
            * -  Quads that are going to be rendered
            */
            quads: Array<any>;
            /**
            * - Image texture for cc.TextureAtlas.
            */
            texture: any;
            /**
            * -  Quantity of quads that are going to be drawn.
            */
            totalQuads: number;
            /**
            * &amp;lt;static&amp;gt;
{cc.TextureAtlas|Null}
cc.TextureAtlas.create(fileName, capacity)
Creates a TextureAtlas with an filename and with an initial capacity for Quads.
The TextureAtlas capacity can be increased in runtime.
Parameters:
{String|cc.Texture2D} fileName
{Number} capacity
Deprecated:
since v3.0, please use new cc.TextureAtlas(fileName, capacity) instead
Returns:
{cc.TextureAtlas|Null}

            */
            static create(fileName?: any, capacity?: number): any;
            /**
            * &amp;lt;static&amp;gt;
cc.TextureAtlas.createWithTexture()
Deprecated:
since v3.0, please use new cc.TextureAtlas(texture) instead

            */
            static createWithTexture();
            /**
            * ctor(fileName, capacity)
Creates a TextureAtlas with an filename and with an initial capacity for Quads.
The TextureAtlas capacity can be increased in runtime.
Constructor of cc.TextureAtlas
1.
//creates a TextureAtlas with  filename
var textureAtlas = new cc.TextureAtlas(&quot;res/hello.png&quot;, 3);
2.
//creates a TextureAtlas with texture
var texture = cc.textureCache.addImage(&quot;hello.png&quot;);
var textureAtlas = new cc.TextureAtlas(texture, 3);
Parameters:
{String|cc.Texture2D} fileName
{Number} capacity

            */
            ctor(fileName?: any, capacity?: number);
            /**
            * {String}
description()
Description
Returns:
{String}

            */
            description(): string;
            /**
            * drawQuads()
Draws all the Atlas&#39;s Quads

            */
            drawQuads();
            /**
            * fillWithEmptyQuadsFromIndex(index, amount)
Ensures that after a realloc quads are still empty
Used internally by CCParticleBatchNode
Parameters:
{Number} index
{Number} amount

            */
            fillWithEmptyQuadsFromIndex(index?: number, amount?: number);
            /**
            * {Number}
getCapacity()
Quantity of quads that can be stored with the current texture atlas size
Returns:
{Number}

            */
            getCapacity(): number;
            /**
            * {Array}
getQuads()
Quads that are going to be rendered
Returns:
{Array}

            */
            getQuads(): Array<any>;
            /**
            * {Image}
getTexture()
Texture of the texture atlas
Returns:
{Image}

            */
            getTexture(): Image;
            /**
            * {Number}
getTotalQuads()
Quantity of quads that are going to be drawn.
Returns:
{Number}

            */
            getTotalQuads(): number;
            /**
            * increaseTotalQuadsWith(amount)
Used internally by CCParticleBatchNode
don&#39;t use this unless you know what you&#39;re doing
Parameters:
{Number} amount

            */
            increaseTotalQuadsWith(amount?: number);
            /**
            * {Boolean}
initWithFile(file, capacity)
Initializes a TextureAtlas with a filename and with a certain capacity for Quads.
The TextureAtlas capacity can be increased in runtime.
WARNING: Do not reinitialize the TextureAtlas because it will leak memory.
//example
var textureAtlas = new cc.TextureAtlas();
textureAtlas.initWithTexture(&quot;hello.png&quot;, 3);
Parameters:
{String} file
{Number} capacity
Returns:
{Boolean}

            */
            initWithFile(file?: string, capacity?: number): boolean;
            /**
            * {Boolean}
initWithTexture(texture, capacity)
Initializes a TextureAtlas with a previously initialized Texture2D object, and
with an initial capacity for Quads.
The TextureAtlas capacity can be increased in runtime.
WARNING: Do not reinitialize the TextureAtlas because it will leak memory
//example
var texture = cc.textureCache.addImage(&quot;hello.png&quot;);
var textureAtlas = new cc.TextureAtlas();
textureAtlas.initWithTexture(texture, 3);
Parameters:
{Image} texture
{Number} capacity
Returns:
{Boolean}

            */
            initWithTexture(texture?: Image, capacity?: number): boolean;
            /**
            * insertQuad(quad, index)
Inserts a Quad (texture, vertex and color) at a certain index
index must be between 0 and the atlas capacity - 1
Parameters:
{cc.V3F_C4B_T2F_Quad} quad
{Number} index

            */
            insertQuad(quad?: cc.V3F_C4B_T2F_Quad, index?: number);
            /**
            * insertQuadFromIndex(fromIndex, newIndex)
Removes the quad that is located at a certain index and inserts it at a new index
This operation is faster than removing and inserting in a quad in 2 different steps
Parameters:
{Number} fromIndex
{Number} newIndex

            */
            insertQuadFromIndex(fromIndex?: number, newIndex?: number);
            /**
            * insertQuads(quads, index, amount)
Inserts a c array of quads at a given index
index must be between 0 and the atlas capacity - 1
this method doesn&#39;t enlarge the array when amount + index &gt; totalQuads
Parameters:
{Array} quads
{Number} index
{Number} amount

            */
            insertQuads(quads?: Array<any>, index?: number, amount?: number);
            /**
            * {boolean}
isDirty()
whether or not the array buffer of the VBO needs to be updated
Returns:
{boolean}

            */
            isDirty(): boolean;
            /**
            * moveQuadsFromIndex(oldIndex, amount, newIndex)
Moves an amount of quads from oldIndex at newIndex
Parameters:
{Number} oldIndex
{Number} amount
{Number} newIndex

            */
            moveQuadsFromIndex(oldIndex?: number, amount?: number, newIndex?: number);
            /**
            * removeAllQuads()
Removes all Quads.
The TextureAtlas capacity remains untouched. No memory is freed.
The total number of quads to be drawn will be 0

            */
            removeAllQuads();
            /**
            * removeQuadAtIndex(index)
Removes a quad at a given index number.
The capacity remains the same, but the total number of quads to be drawn is reduced in 1
Parameters:
{Number} index

            */
            removeQuadAtIndex(index?: number);
            /**
            * removeQuadsAtIndex(index, amount)
Removes a given number of quads at a given index
Parameters:
{Number} index
{Number} amount

            */
            removeQuadsAtIndex(index?: number, amount?: number);
            /**
            * {Boolean}
resizeCapacity(newCapacity)
Resize the capacity of the CCTextureAtlas.
The new capacity can be lower or higher than the current one
It returns YES if the resize was successful.
If it fails to resize the capacity it will return NO with a new capacity of 0.
no used for js
Parameters:
{Number} newCapacity
Returns:
{Boolean}

            */
            resizeCapacity(newCapacity?: number): boolean;
            /**
            * setDirty(dirty)
specify if the array buffer of the VBO needs to be updated
Parameters:
{Boolean} dirty

            */
            setDirty(dirty?: boolean);
            /**
            * setQuads(quads)
Parameters:
{Array} quads

            */
            setQuads(quads?: Array<any>);
            /**
            * setTexture(texture)
Parameters:
{Image} texture

            */
            setTexture(texture?: Image);
            /**
            * updateQuad(quad, index)
Updates a Quad (texture, vertex and color) at a certain index
index must be between 0 and the atlas capacity - 1
Parameters:
{cc.V3F_C4B_T2F_Quad} quad
{Number} index

            */
            updateQuad(quad?: cc.V3F_C4B_T2F_Quad, index?: number);
        }
    }
declare module cc {
        /**
        * 
cc.textureCache is a singleton object, it&#39;s the global cache for cc.Texture2D

        */
        export class textureCache  {
            /**
            * cc.textureCache is a singleton object, it&#39;s the global cache for cc.Texture2D
            */
            constructor();
            /**
            * {cc.Texture2D}
addETCImage(filename)
Returns a Texture2D object given an ETC filename
If the file image was not previously loaded, it will create a new CCTexture2D
object and it will return it. Otherwise it will return a reference of a previously loaded image
note:addETCImage does not support on HTML5
Parameters:
{String} filename
Returns:
{cc.Texture2D}

            */
            addETCImage(filename?: string): cc.Texture2D;
            /**
            * {cc.Texture2D}
addPVRImage(path)
Returns a Texture2D object given an PVR filename
If the file image was not previously loaded, it will create a new Texture2D
object and it will return it. Otherwise it will return a reference of a previously loaded image
Parameters:
{String} path
Returns:
{cc.Texture2D}

            */
            addPVRImage(path?: string): cc.Texture2D;
            /**
            * {cc.Texture2D}
addPVRTCImage(filename)
Returns a Texture2D object given an PVR filename
If the file image was not previously loaded, it will create a new CCTexture2D
object and it will return it. Otherwise it will return a reference of a previously loaded image
note: AddPVRTCImage does not support on HTML5
Parameters:
{String} filename
Returns:
{cc.Texture2D}

            */
            addPVRTCImage(filename?: string): cc.Texture2D;
            /**
            * {cc.Texture2D}
addUIImage(image, key)
Returns a Texture2D object given an UIImage image
If the image was not previously loaded, it will create a new Texture2D object and it will return it.
Otherwise it will return a reference of a previously loaded image
The &quot;key&quot; parameter will be used as the &quot;key&quot; for the cache.
If &quot;key&quot; is null, then a new texture will be created each time.
Parameters:
{HTMLImageElement|HTMLCanvasElement} image
{String} key
Returns:
{cc.Texture2D}

            */
            addUIImage(image?: any, key?: string): cc.Texture2D;
            /**
            * cacheImage(path, texture)
Cache the image data
Parameters:
{String} path
{Image|HTMLImageElement|HTMLCanvasElement} texture

            */
            cacheImage(path?: string, texture?: any);
            /**
            * {String}
description()
Description
Returns:
{String}

            */
            description(): string;
            /**
            * dumpCachedTextureInfo()
Output to cc.log the current contents of this TextureCache
This will attempt to calculate the size of each texture, and the total texture memory in use.

            */
            dumpCachedTextureInfo();
            /**
            * {String|Null}
getKeyByTexture(texture)
//example
var key = cc.textureCache.getKeyByTexture(texture);
Parameters:
{Image} texture
Returns:
{String|Null}

            */
            getKeyByTexture(texture?: Image): any;
            /**
            * {Array}
getTextureColors(texture)
//example
var cacheTextureForColor = cc.textureCache.getTextureColors(texture);
Parameters:
{Image} texture
Returns:
{Array}

            */
            getTextureColors(texture?: Image): Array<any>;
            /**
            * {cc.Texture2D|Null}
getTextureForKey(textureKeyName)
Returns an already created texture. Returns null if the texture doesn&#39;t exist.
//example
var key = cc.textureCache.getTextureForKey(&quot;hello.png&quot;);
Parameters:
{String} textureKeyName
Returns:
{cc.Texture2D|Null}

            */
            getTextureForKey(textureKeyName?: string): any;
            /**
            * removeAllTextures()
Purges the dictionary of loaded textures.
Call this method if you receive the &quot;Memory Warning&quot;
In the short term: it will free some resources preventing your app from being killed
In the medium term: it will allocate more resources
In the long term: it will be the same
//example
cc.textureCache.removeAllTextures();

            */
            removeAllTextures();
            /**
            * removeTexture(texture)
Deletes a texture from the cache given a texture
//example
cc.textureCache.removeTexture(texture);
Parameters:
{Image} texture

            */
            removeTexture(texture?: Image);
            /**
            * removeTextureForKey(textureKeyName)
Deletes a texture from the cache given a its key name
//example
cc.textureCache.removeTexture(&quot;hello.png&quot;);
Parameters:
{String} textureKeyName

            */
            removeTextureForKey(textureKeyName?: string);
            /**
            * {cc.Texture2D|Null}
textureForKey(textureKeyName)
Returns an already created texture. Returns null if the texture doesn&#39;t exist.
//example
var key = cc.textureCache.textureForKey(&quot;hello.png&quot;);
Parameters:
{String} textureKeyName
Returns:
{cc.Texture2D|Null}

            */
            textureForKey(textureKeyName?: string): any;
        }
    }
declare module cc {
        /**
        * 
A Tile composed of position, startPosition and delta.

        */
        export class Tile  {
            /**
            * A Tile composed of position, startPosition and delta.
            */
            constructor(position?: cc.Point, startPosition?: cc.Point, delta?: cc.Size);
        }
    }
declare module cc {
        /**
        * 
cc.TiledGrid3D is a 3D grid implementation. It differs from Grid3D in that
the tiles can be separated from the grid.

        */
        export class TiledGrid3D extends cc.GridBase {
            /**
            * cc.TiledGrid3D is a 3D grid implementation.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.TiledGrid3D}
cc.TiledGrid3D.create(gridSize, texture, flipped)
create one TiledGrid3D object
Parameters:
{cc.Size} gridSize
{cc.Texture2D} texture
Optional
{Boolean} flipped
Optional
Deprecated:
since v3.0, please use new cc.TiledGrid3D(gridSize, texture, flipped) instead
Returns:
{cc.TiledGrid3D}

            */
            static create(gridSize?: cc.Size, texture?: cc.Texture2D, flipped?: boolean): cc.TiledGrid3D;
            /**
            * ctor(gridSize, texture, flipped)
create one TiledGrid3D object
Constructor of cc.TiledGrid3D
Parameters:
{cc.Size} gridSize
{cc.Texture2D} texture
Optional
{Boolean} flipped
Optional

            */
            ctor(gridSize?: cc.Size, texture?: cc.Texture2D, flipped?: boolean);
            /**
            * {cc.Quad3}
originalTile(pos)
returns the original tile (untransformed) at the given position
Parameters:
{cc.Point} pos
Returns:
{cc.Quad3}

            */
            originalTile(pos?: cc.Point): cc.Quad3;
            /**
            * setTile(pos, coords)
sets a new tile
Parameters:
{cc.Point} pos
{cc.Quad3} coords

            */
            setTile(pos?: cc.Point, coords?: cc.Quad3);
            /**
            * {cc.Quad3}
tile(pos)
returns the tile at the given position
Parameters:
{cc.Point} pos
Returns:
{cc.Quad3}

            */
            tile(pos?: cc.Point): cc.Quad3;
        }
    }
declare module cc {
        /**
        * 
Base class for cc.TiledGrid3D actions.

        */
        export class TiledGrid3DAction extends cc.GridAction {
            /**
            * Base class for cc.TiledGrid3D actions.
            */
            constructor();
            /**
            * Please use cc.tiledGrid3DAction instead
Creates the action with duration and grid size
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.TiledGrid3DAction;
            /**
            * {cc.TiledGrid3D}
getGrid()
returns the grid
Returns:
{cc.TiledGrid3D}

            */
            getGrid(): cc.TiledGrid3D;
            /**
            * {cc.Quad3}
originalTile(position)
returns the non-transformed tile that belongs to a certain position of the grid
Parameters:
{cc.Point} position
Returns:
{cc.Quad3}

            */
            originalTile(position?: cc.Point): cc.Quad3;
            /**
            * setTile(position, coords)
sets a new tile to a certain position of the grid
Parameters:
{cc.Point} position
{cc.Quad3} coords

            */
            setTile(position?: cc.Point, coords?: cc.Quad3);
            /**
            * {cc.Quad3}
tile(position)
returns the tile that belongs to a certain position of the grid
Parameters:
{cc.Point} position
Returns:
{cc.Quad3}

            */
            tile(position?: cc.Point): cc.Quad3;
        }
    }
declare module cc {
        /**
        * 
Light weight timer

        */
        export class Timer extends cc.Class {
            /**
            * Light weight timer
            */
            constructor();
            /**
            * ctor(target, callback, interval, repeat, delay)
cc.Timer&#39;s Constructor
Constructor of cc.Timer
Parameters:
{cc.Class} target
target
{String|function} callback
Selector
{Number} interval
Optional, Default: 0
second
{Number} repeat
Optional, Default: cc.REPEAT_FOREVER
repeat times
{Number} delay
Optional, Default: 0
delay

            */
            ctor(target?: cc.Class, callback?: any, interval?: number, repeat?: number, delay?: number);
            /**
            * {String|function}
getCallback()
Returns:
{String|function} returns callback

            */
            getCallback(): any;
            /**
            * {Number}
getInterval()
Returns:
{Number} returns interval of timer

            */
            getInterval(): number;
            /**
            * setInterval(interval)
Parameters:
{Number} interval
set interval in seconds

            */
            setInterval(interval?: number);
            /**
            * update(dt)
triggers the timer
Parameters:
{Number} dt
delta time

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Tints a cc.Node that implements the cc.NodeRGB protocol from current tint to a custom one.
Relative to their own color change.

        */
        export class TintBy extends cc.ActionInterval {
            /**
            * Tints a cc.Node that implements the cc.NodeRGB protocol from current tint to a custom one.
            */
            constructor(duration?: number, deltaRed?: number, deltaGreen?: number, deltaBlue?: number);
            /**
            * Please use cc.tintBy instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.TintBy;
            /**
            * {cc.TintBy}
clone()
returns a new clone of the action
Returns:
{cc.TintBy}

            */
            clone(): cc.TintBy;
            /**
            * ctor(duration, deltaRed, deltaGreen, deltaBlue)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
duration in seconds
{Number} deltaRed
{Number} deltaGreen
{Number} deltaBlue

            */
            ctor(duration?: number, deltaRed?: number, deltaGreen?: number, deltaBlue?: number);
            /**
            * {Boolean}
initWithDuration(duration, deltaRed, deltaGreen, deltaBlue)
Initializes the action.
Parameters:
{Number} duration
{Number} deltaRed
0-255
{Number} deltaGreen
0-255
{Number} deltaBlue
0-255
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, deltaRed?: number, deltaGreen?: number, deltaBlue?: number): boolean;
            /**
            * {cc.TintBy}
reverse()
Returns a reversed action.
Returns:
{cc.TintBy}

            */
            reverse(): cc.TintBy;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt
time in seconds

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
Tints a cc.Node that implements the cc.NodeRGB protocol from current tint to a custom one.

        */
        export class TintTo extends cc.ActionInterval {
            /**
            * Tints a cc.Node that implements the cc.NodeRGB protocol from current tint to a custom one.
            */
            constructor(duration?: number, red?: number, green?: number, blue?: number);
            /**
            * Please use cc.tintTo instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.TintTo;
            /**
            * {cc.TintTo}
clone()
returns a new clone of the action
Returns:
{cc.TintTo}

            */
            clone(): cc.TintTo;
            /**
            * ctor(duration, red, green, blue)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} duration
{Number} red
0-255
{Number} green
0-255
{Number} blue
0-255

            */
            ctor(duration?: number, red?: number, green?: number, blue?: number);
            /**
            * {Boolean}
initWithDuration(duration, red, green, blue)
Initializes the action.
Parameters:
{Number} duration
{Number} red
0-255
{Number} green
0-255
{Number} blue
0-255
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, red?: number, green?: number, blue?: number): boolean;
            /**
            * startWithTarget(target)
Start the action with target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt
time in seconds

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.TMXLayer represents the TMX layer.

It is a subclass of cc.SpriteBatchNode. By default the tiles are rendered using a cc.TextureAtlas.
If you modify a tile on runtime, then, that tile will become a cc.Sprite, otherwise no cc.Sprite objects are created.
The benefits of using cc.Sprite objects as tiles are:
- tiles (cc.Sprite) can be rotated/scaled/moved with a nice API

If the layer contains a property named &quot;cc.vertexz&quot; with an integer (in can be positive or negative),
then all the tiles belonging to the layer will use that value as their OpenGL vertex Z for depth.

On the other hand, if the &quot;cc.vertexz&quot; property has the &quot;automatic&quot; value, then the tiles will use an automatic vertex Z value.
Also before drawing the tiles, GL_ALPHA_TEST will be enabled, and disabled after drawing them. The used alpha func will be:

glAlphaFunc( GL_GREATER, value )

&quot;value&quot; by default is 0, but you can change it from Tiled by adding the &quot;cc_alpha_func&quot; property to the layer.
The value 0 should work for most cases, but if you have tiles that are semi-transparent, then you might want to use a different value, like 0.5.

        */
        export class TMXLayer extends cc.SpriteBatchNode {
            /**
            * cc.TMXLayer represents the TMX layer.
            */
            constructor();
            /**
            * - Height of the layer
            */
            layerHeight: number;
            /**
            * - Name of the layer
            */
            layerName: string;
            /**
            * - Layer orientation
            */
            layerOrientation: number;
            /**
            * - Width of the layer
            */
            layerWidth: number;
            /**
            * - Properties from the layer.
            */
            properties: Array<any>;
            /**
            * - Height of a tile
            */
            tileHeight: number;
            /**
            * - Tiles for layer
            */
            tiles: Array<any>;
            /**
            * - Tileset for layer
            */
            tileset: cc.TMXTilesetInfo;
            /**
            * - Width of a tile
            */
            tileWidth: number;
            /**
            * addChild(child, zOrder, tag)
cc.TMXLayer doesn&#39;t support adding a cc.Sprite manually.
Parameters:
{cc.Node} child
{number} zOrder
{number} tag

            */
            addChild(child?: cc.Node, zOrder?: number, tag?: number);
            /**
            * &amp;lt;static&amp;gt;
{cc.TMXLayer|Null}
cc.TMXLayer.create(tilesetInfo, layerInfo, mapInfo)
Creates a cc.TMXLayer with an tile set info, a layer info and a map info
Parameters:
{cc.TMXTilesetInfo} tilesetInfo
{cc.TMXLayerInfo} layerInfo
{cc.TMXMapInfo} mapInfo
Deprecated:
since v3.0 please use new cc.TMXLayer(tilesetInfo, layerInfo, mapInfo) instead.
Returns:
{cc.TMXLayer|Null}

            */
            static create(tilesetInfo?: cc.TMXTilesetInfo, layerInfo?: cc.TMXLayerInfo, mapInfo?: cc.TMXMapInfo): any;
            /**
            * ctor(tilesetInfo, layerInfo, mapInfo)
Creates a cc.TMXLayer with an tile set info, a layer info and a map info
Constructor of cc.TMXLayer
Parameters:
{cc.TMXTilesetInfo} tilesetInfo
{cc.TMXLayerInfo} layerInfo
{cc.TMXMapInfo} mapInfo

            */
            ctor(tilesetInfo?: cc.TMXTilesetInfo, layerInfo?: cc.TMXLayerInfo, mapInfo?: cc.TMXMapInfo);
            /**
            * {String}
getLayerName()
Gets the layer name
Returns:
{String}

            */
            getLayerName(): string;
            /**
            * {Number}
getLayerOrientation()
Layer orientation, which is the same as the map orientation
Returns:
{Number}

            */
            getLayerOrientation(): number;
            /**
            * {cc.Size}
getLayerSize()
Gets layer size.
Returns:
{cc.Size}

            */
            getLayerSize(): cc.Size;
            /**
            * {cc.Size}
getMapTileSize()
Size of the map&#39;s tile (could be different from the tile&#39;s size)
Returns:
{cc.Size}

            */
            getMapTileSize(): cc.Size;
            /**
            * {cc.Point}
getPositionAt(pos, y)
Returns the position in pixels of a given tile coordinate
Parameters:
{cc.Point|Number} pos
position or x
{Number} y
Optional
Returns:
{cc.Point}

            */
            getPositionAt(pos?: any, y?: number): cc.Point;
            /**
            * {Array}
getProperties()
properties from the layer. They can be added using Tiled
Returns:
{Array}

            */
            getProperties(): Array<any>;
            /**
            * {*}
getProperty(propertyName)
Return the value for the specific property name
Parameters:
{String} propertyName
Returns:
{*}

            */
            getProperty(propertyName?: string): any;
            /**
            * {cc.Texture2D}
getTexture()
Return texture of cc.SpriteBatchNode
Returns:
{cc.Texture2D}

            */
            getTexture(): cc.Texture2D;
            /**
            * {cc.Sprite}
getTileAt(pos, y)
Returns the tile (cc.Sprite) at a given a tile coordinate.
The returned cc.Sprite will be already added to the cc.TMXLayer. Don&#39;t add it again.
The cc.Sprite can be treated like any other cc.Sprite: rotated, scaled, translated, opacity, color, etc.
You can remove either by calling:
- layer.removeChild(sprite, cleanup);
- or layer.removeTileAt(ccp(x,y));
Parameters:
{cc.Point|Number} pos
or x
{Number} y
Optional
Returns:
{cc.Sprite}

            */
            getTileAt(pos?: any, y?: number): cc.Sprite;
            /**
            * {Number}
getTileFlagsAt(pos, y)
lipped tiles can be changed dynamically
Parameters:
{cc.Point|Number} pos
or x
{Number} y
Optional
Returns:
{Number}

            */
            getTileFlagsAt(pos?: any, y?: number): number;
            /**
            * {Number}
getTileGIDAt(pos, y)
Returns the tile gid at a given tile coordinate.
if it returns 0, it means that the tile is empty.
This method requires the the tile map has not been previously released (eg. don&#39;t call layer.releaseMap())
Parameters:
{cc.Point|Number} pos
or x
{Number} y
Optional
Returns:
{Number}

            */
            getTileGIDAt(pos?: any, y?: number): number;
            /**
            * {Array}
getTiles()
Pointer to the map of tiles
Returns:
{Array}

            */
            getTiles(): Array<any>;
            /**
            * {cc.TMXTilesetInfo}
getTileset()
Tile set information for the layer
Returns:
{cc.TMXTilesetInfo}

            */
            getTileset(): cc.TMXTilesetInfo;
            /**
            * {Boolean}
initWithTilesetInfo(tilesetInfo, layerInfo, mapInfo)
Initializes a cc.TMXLayer with a tileset info, a layer info and a map info
Parameters:
{cc.TMXTilesetInfo} tilesetInfo
{cc.TMXLayerInfo} layerInfo
{cc.TMXMapInfo} mapInfo
Returns:
{Boolean}

            */
            initWithTilesetInfo(tilesetInfo?: cc.TMXTilesetInfo, layerInfo?: cc.TMXLayerInfo, mapInfo?: cc.TMXMapInfo): boolean;
            /**
            * releaseMap()
Dealloc the map that contains the tile position from memory.
Unless you want to know at runtime the tiles positions, you can safely call this method.
If you are going to call layer.getTileGIDAt() then, don&#39;t release the map

            */
            releaseMap();
            /**
            * removeChild(sprite, cleanup)
Remove child
Parameters:
{cc.Sprite} sprite
{Boolean} cleanup

            */
            removeChild(sprite?: cc.Sprite, cleanup?: boolean);
            /**
            * removeTileAt(pos, y)
Removes a tile at given tile coordinate
Parameters:
{cc.Point|Number} pos
position or x
{Number} y
Optional

            */
            removeTileAt(pos?: any, y?: number);
            /**
            * setContentSize(size, height)
Sets the untransformed size of the TMXLayer.
Parameters:
{cc.Size|Number} size
The untransformed size of the TMXLayer or The untransformed size&#39;s width of the TMXLayer.
{Number} height
Optional
The untransformed size&#39;s height of the TMXLayer.

            */
            setContentSize(size?: any, height?: number);
            /**
            * setLayerName(layerName)
Set the layer name
Parameters:
{String} layerName

            */
            setLayerName(layerName?: string);
            /**
            * setLayerOrientation(Var)
Layer orientation, which is the same as the map orientation
Parameters:
{Number} Var

            */
            setLayerOrientation(Var?: number);
            /**
            * setLayerSize(Var)
Set layer size
Parameters:
{cc.Size} Var

            */
            setLayerSize(Var?: cc.Size);
            /**
            * setMapTileSize(Var)
Set the map tile size.
Parameters:
{cc.Size} Var

            */
            setMapTileSize(Var?: cc.Size);
            /**
            * setProperties(Var)
properties from the layer. They can be added using Tiled
Parameters:
{Array} Var

            */
            setProperties(Var?: Array<any>);
            /**
            * setTileGID(gid, posOrX, flagsOrY, flags)
Sets the tile gid (gid = tile global id) at a given tile coordinate.
The Tile GID can be obtained by using the method &quot;tileGIDAt&quot; or by using the TMX editor . Tileset Mgr +1.
If a tile is already placed at that position, then it will be removed.
Parameters:
{Number} gid
{cc.Point|Number} posOrX
position or x
{Number} flagsOrY
flags or y
{Number} flags
Optional

            */
            setTileGID(gid?: number, posOrX?: any, flagsOrY?: number, flags?: number);
            /**
            * setTiles(Var)
Pointer to the map of tiles
Parameters:
{Array} Var

            */
            setTiles(Var?: Array<any>);
            /**
            * setTileset(Var)
Tile set information for the layer
Parameters:
{cc.TMXTilesetInfo} Var

            */
            setTileset(Var?: cc.TMXTilesetInfo);
            /**
            * setupTiles()
Creates the tiles

            */
            setupTiles();
        }
    }
declare module cc {
        /**
        * 
cc.TMXLayerInfo contains the information about the layers like:
- Layer name
- Layer size
- Layer opacity at creation time (it can be modified at runtime)
- Whether the layer is visible (if it&#39;s not visible, then the CocosNode won&#39;t be created)
This information is obtained from the TMX file.

        */
        export class TMXLayerInfo extends cc.Class {
            /**
            * cc.TMXLayerInfo contains the information about the layers like:
- Layer name
- Layer size
- Layer opacity at creation time (it can be modified at runtime)
- Whether the layer is visible (if it&#39;s not visible, then the CocosNode won&#39;t be created)
This information is obtained from the TMX file.
            */
            constructor();
            /**
            * 
            */
            static ATTRIB_BASE64: number;
            /**
            * 
            */
            static ATTRIB_GZIP: number;
            /**
            * 
            */
            static ATTRIB_NONE: number;
            /**
            * 
            */
            static ATTRIB_ZLIB: number;
            /**
            * - Properties of the layer info.
            */
            properties: Array<any>;
            /**
            * {Array}
getProperties()
Gets the Properties.
Returns:
{Array}

            */
            getProperties(): Array<any>;
            /**
            * setProperties(value)
Set the Properties.
Parameters:
{object} value

            */
            setProperties(value?: any);
        }
    }
declare module cc {
        /**
        * 
cc.TMXMapInfo contains the information about the map like:
- Map orientation (hexagonal, isometric or orthogonal)
- Tile size
- Map size

And it also contains:
- Layers (an array of TMXLayerInfo objects)
- Tilesets (an array of TMXTilesetInfo objects)
- ObjectGroups (an array of TMXObjectGroupInfo objects)

This information is obtained from the TMX file.

        */
        export class TMXMapInfo extends cc.saxParser {
            /**
            * cc.TMXMapInfo contains the information about the map like:
- Map orientation (hexagonal, isometric or orthogonal)
- Tile size
- Map size

And it also contains:
- Layers (an array of TMXLayerInfo objects)
- Tilesets (an array of TMXTilesetInfo objects)
- ObjectGroups (an array of TMXObjectGroupInfo objects)

This information is obtained from the TMX file.
            */
            constructor(tmxFile?: string, resourcePath?: string);
            /**
            * - Current string stored from characters stream.
            */
            currentString: string;
            /**
            * - Layer attributes.
            */
            layerAttrs: Object;
            /**
            * - Height of the map
            */
            mapHeight: number;
            /**
            * - Width of the map
            */
            mapWidth: number;
            /**
            * - Map orientation.
            */
            orientation: number;
            /**
            * - Parent element.
            */
            parentElement: Object;
            /**
            * - Parent GID.
            */
            parentGID: number;
            /**
            * - Properties of the map info.
            */
            properties: Array<any>;
            /**
            * - Is reading storing characters stream.
            */
            storingCharacters: boolean;
            /**
            * - Height of a tile
            */
            tileHeight: number;
            /**
            * - Width of a tile
            */
            tileWidth: number;
            /**
            * - TMX file name.
            */
            tmxFileName: string;
            /**
            * &amp;lt;static&amp;gt;
{cc.TMXMapInfo}
cc.TMXMapInfo.create(tmxFile, resourcePath)
Creates a TMX Format with a tmx file or content string
Parameters:
{String} tmxFile
fileName or content string
{String} resourcePath
If tmxFile is a file name ,it is not required.If tmxFile is content string ,it is must required.
Deprecated:
since v3.0 please use new cc.TMXMapInfo(tmxFile, resourcePath) instead.
Returns:
{cc.TMXMapInfo}

            */
            static create(tmxFile?: string, resourcePath?: string): cc.TMXMapInfo;
            /**
            * ctor(tmxFile, resourcePath)
Creates a TMX Format with a tmx file or content string
Constructor of cc.TMXMapInfo
Parameters:
{String} tmxFile
fileName or content string
{String} resourcePath
If tmxFile is a file name ,it is not required.If tmxFile is content string ,it is must required.

            */
            ctor(tmxFile?: string, resourcePath?: string);
            /**
            * {String}
getCurrentString()
Gets the currentString
Returns:
{String}

            */
            getCurrentString(): string;
            /**
            * {Object}
getLayerAttribs()
Layer attribute
Returns:
{Object}

            */
            getLayerAttribs(): Object;
            /**
            * {Array}
getLayers()
Layers
Returns:
{Array}

            */
            getLayers(): Array<any>;
            /**
            * {cc.Size}
getMapSize()
Map width &amp; height
Returns:
{cc.Size}

            */
            getMapSize(): cc.Size;
            /**
            * {Array}
getObjectGroups()
ObjectGroups
Returns:
{Array}

            */
            getObjectGroups(): Array<any>;
            /**
            * {Number}
getOrientation()
Gets Map orientation.
Returns:
{Number}

            */
            getOrientation(): number;
            /**
            * {Object}
getParentElement()
parent element
Returns:
{Object}

            */
            getParentElement(): Object;
            /**
            * {Number}
getParentGID()
parent GID
Returns:
{Number}

            */
            getParentGID(): number;
            /**
            * {Array}
getProperties()
Properties
Returns:
{Array}

            */
            getProperties(): Array<any>;
            /**
            * {Boolean}
getStoringCharacters()
Is reading storing characters stream
Returns:
{Boolean}

            */
            getStoringCharacters(): boolean;
            /**
            * {object}
getTileProperties()
Gets the tile properties.
Returns:
{object}

            */
            getTileProperties(): any;
            /**
            * {Array}
getTilesets()
tilesets
Returns:
{Array}

            */
            getTilesets(): Array<any>;
            /**
            * {cc.Size}
getTileSize()
Tiles width &amp; height
Returns:
{cc.Size}

            */
            getTileSize(): cc.Size;
            /**
            * {String}
getTMXFileName()
Gets the tmxFileName
Returns:
{String}

            */
            getTMXFileName(): string;
            /**
            * {Element}
initWithTMXFile(tmxFile)
Initializes a TMX format with a  tmx file
Parameters:
{String} tmxFile
Returns:
{Element}

            */
            initWithTMXFile(tmxFile?: string): Element;
            /**
            * {Boolean}
initWithXML(tmxString, resourcePath)
initializes a TMX format with an XML string and a TMX resource path
Parameters:
{String} tmxString
{String} resourcePath
Returns:
{Boolean}

            */
            initWithXML(tmxString?: string, resourcePath?: string): boolean;
            /**
            * {Element}
parseXMLFile(tmxFile, isXmlString)
Initalises parsing of an XML file, either a tmx (Map) file or tsx (Tileset) file
Parameters:
{String} tmxFile
{boolean} isXmlString
Optional, Default: false
Returns:
{Element}

            */
            parseXMLFile(tmxFile?: string, isXmlString?: boolean): Element;
            /**
            * {Boolean}
parseXMLString(xmlString)
initializes parsing of an XML string, either a tmx (Map) string or tsx (Tileset) string
Parameters:
{String} xmlString
Returns:
{Boolean}

            */
            parseXMLString(xmlString?: string): boolean;
            /**
            * setCurrentString(currentString)
Set the currentString
Parameters:
{String} currentString

            */
            setCurrentString(currentString?: string);
            /**
            * setLayerAttribs(value)
Layer attribute
Parameters:
{Object} value

            */
            setLayerAttribs(value?: Object);
            /**
            * setLayers(value)
Layers
Parameters:
{cc.TMXLayerInfo} value

            */
            setLayers(value?: cc.TMXLayerInfo);
            /**
            * setMapSize(value)
Map width &amp; height
Parameters:
{cc.Size} value

            */
            setMapSize(value?: cc.Size);
            /**
            * setObjectGroups(value)
ObjectGroups
Parameters:
{cc.TMXObjectGroup} value

            */
            setObjectGroups(value?: cc.TMXObjectGroup);
            /**
            * setOrientation(value)
Set the Map orientation.
Parameters:
{Number} value

            */
            setOrientation(value?: number);
            /**
            * setParentElement(value)
parent element
Parameters:
{Object} value

            */
            setParentElement(value?: Object);
            /**
            * setParentGID(value)
parent GID
Parameters:
{Number} value

            */
            setParentGID(value?: number);
            /**
            * setProperties(value)
Properties
Parameters:
{object} value

            */
            setProperties(value?: any);
            /**
            * setStoringCharacters(value)
Is reading storing characters stream
Parameters:
{Boolean} value

            */
            setStoringCharacters(value?: boolean);
            /**
            * setTileProperties(tileProperties)
Set the tile properties.
Parameters:
{object} tileProperties

            */
            setTileProperties(tileProperties?: any);
            /**
            * setTilesets(value)
tilesets
Parameters:
{cc.TMXTilesetInfo} value

            */
            setTilesets(value?: cc.TMXTilesetInfo);
            /**
            * setTileSize(value)
Tiles width &amp; height
Parameters:
{cc.Size} value

            */
            setTileSize(value?: cc.Size);
            /**
            * setTMXFileName(fileName)
Set the tmxFileName
Parameters:
{String} fileName

            */
            setTMXFileName(fileName?: string);
        }
    }
declare module cc {
        /**
        * 
cc.TMXObjectGroup represents the TMX object group.

        */
        export class TMXObjectGroup extends cc.Class {
            /**
            * cc.TMXObjectGroup represents the TMX object group.
            */
            constructor();
            /**
            * - Name of the group
            */
            groupName: string;
            /**
            * - Properties from the group.
            */
            properties: Array<any>;
            /**
            * ctor()
The cc.TMXObjectGroup&#39;s constructor.
This function will automatically be invoked when you create a node using new construction: &quot;var node = new cc.TMXObjectGroup()&quot;.
Override it to extend its behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * {String}
getGroupName()
Gets the Group name.
Returns:
{String}

            */
            getGroupName(): string;
            /**
            * {Array}
getObjects()
Gets the objects.
Returns:
{Array}

            */
            getObjects(): Array<any>;
            /**
            * {cc.Point}
getPositionOffset()
Offset position of child objects
Returns:
{cc.Point}

            */
            getPositionOffset(): cc.Point;
            /**
            * {Array}
getProperties()
List of properties stored in a dictionary
Returns:
{Array}

            */
            getProperties(): Array<any>;
            /**
            * {object|Null}
objectNamed(objectName)
Return the dictionary for the specific object name.
It will return the 1st object found on the array for the given name.
Parameters:
{String} objectName
Returns:
{object|Null}

            */
            objectNamed(objectName?: string): any;
            /**
            * {object}
propertyNamed(propertyName)
Return the value for the specific property name
Parameters:
{String} propertyName
Returns:
{object}

            */
            propertyNamed(propertyName?: string): any;
            /**
            * setGroupName(groupName)
Set the Group name
Parameters:
{String} groupName

            */
            setGroupName(groupName?: string);
            /**
            * setObjects(objects)
Set the objects.
Parameters:
{object} objects

            */
            setObjects(objects?: any);
            /**
            * setPositionOffset(offset)
Offset position of child objects
Parameters:
{cc.Point} offset

            */
            setPositionOffset(offset?: cc.Point);
            /**
            * setProperties(Var)
List of properties stored in a dictionary
Parameters:
{object} Var

            */
            setProperties(Var?: any);
        }
    }
declare module cc {
        /**
        * 
cc.TMXTiledMap knows how to parse and render a TMX map.

It adds support for the TMX tiled map format used by http://www.mapeditor.org
It supports isometric, hexagonal and orthogonal tiles.
It also supports object groups, objects, and properties.

Features:
- Each tile will be treated as an cc.Sprite
- The sprites are created on demand. They will be created only when you call &quot;layer.getTileAt(position)&quot;
- Each tile can be rotated / moved / scaled / tinted / &quot;opacitied&quot;, since each tile is a cc.Sprite
- Tiles can be added/removed in runtime
- The z-order of the tiles can be modified in runtime
- Each tile has an anchorPoint of (0,0)
- The anchorPoint of the TMXTileMap is (0,0)
- The TMX layers will be added as a child
- The TMX layers will be aliased by default
- The tileset image will be loaded using the cc.TextureCache
- Each tile will have a unique tag
- Each tile will have a unique z value. top-left: z=1, bottom-right: z=max z
- Each object group will be treated as an cc.MutableArray
- Object class which will contain all the properties in a dictionary
- Properties can be assigned to the Map, Layer, Object Group, and Object

Limitations:
- It only supports one tileset per layer.
- Embeded images are not supported
- It only supports the XML format (the JSON format is not supported)

Technical description:
Each layer is created using an cc.TMXLayer (subclass of cc.SpriteBatchNode). If you have 5 layers, then 5 cc.TMXLayer will be created,
unless the layer visibility is off. In that case, the layer won&#39;t be created at all.
You can obtain the layers (cc.TMXLayer objects) at runtime by:
- map.getChildByTag(tag_number);  // 0=1st layer, 1=2nd layer, 2=3rd layer, etc...
- map.getLayer(name_of_the_layer);

Each object group is created using a cc.TMXObjectGroup which is a subclass of cc.MutableArray.
You can obtain the object groups at runtime by:
- map.getObjectGroup(name_of_the_object_group);

Each object is a cc.TMXObject.

Each property is stored as a key-value pair in an cc.MutableDictionary.
You can obtain the properties at runtime by:

map.getProperty(name_of_the_property);
layer.getProperty(name_of_the_property);
objectGroup.getProperty(name_of_the_property);
object.getProperty(name_of_the_property);

        */
        export class TMXTiledMap extends cc.Node {
            /**
            * cc.TMXTiledMap knows how to parse and render a TMX map.
            */
            constructor(tmxFile?: string, resourcePath?: string);
            /**
            * - Height of the map
            */
            mapHeight: number;
            /**
            * - Map orientation
            */
            mapOrientation: number;
            /**
            * - Width of the map
            */
            mapWidth: number;
            /**
            * - Object groups of the map
            */
            objectGroups: Array<any>;
            /**
            * - Properties from the map.
            */
            properties: Array<any>;
            /**
            * - Height of a tile
            */
            tileHeight: number;
            /**
            * - Width of a tile
            */
            tileWidth: number;
            /**
            * {Array}
allLayers()
Return All layers array.
Returns:
{Array}

            */
            allLayers(): Array<any>;
            /**
            * &amp;lt;static&amp;gt;
{cc.TMXTiledMap|undefined}
cc.TMXTiledMap.create(tmxFile, resourcePath)
Creates a TMX Tiled Map with a TMX file  or content string.
Implementation cc.TMXTiledMap
Parameters:
{String} tmxFile
tmxFile fileName or content string
{String} resourcePath
If tmxFile is a file name ,it is not required.If tmxFile is content string ,it is must required.
Deprecated:
since v3.0 please use new cc.TMXTiledMap(tmxFile,resourcePath) instead.
Returns:
{cc.TMXTiledMap|undefined}

            */
            static create(tmxFile?: string, resourcePath?: string): any;
            /**
            * ctor(tmxFile, resourcePath)
Creates a TMX Tiled Map with a TMX file  or content string.
Constructor of cc.TMXTiledMap
Parameters:
{String} tmxFile
tmxFile fileName or content string
{String} resourcePath
If tmxFile is a file name ,it is not required.If tmxFile is content string ,it is must required.

            */
            ctor(tmxFile?: string, resourcePath?: string);
            /**
            * {cc.TMXLayer}
getLayer(layerName)
return the TMXLayer for the specific layer
Parameters:
{String} layerName
Returns:
{cc.TMXLayer}

            */
            getLayer(layerName?: string): cc.TMXLayer;
            /**
            * {Number}
getMapOrientation()
map orientation
Returns:
{Number}

            */
            getMapOrientation(): number;
            /**
            * {cc.Size}
getMapSize()
Gets the map size.
Returns:
{cc.Size}

            */
            getMapSize(): cc.Size;
            /**
            * {cc.TMXObjectGroup}
getObjectGroup(groupName)
Return the TMXObjectGroup for the specific group
Parameters:
{String} groupName
Returns:
{cc.TMXObjectGroup}

            */
            getObjectGroup(groupName?: string): cc.TMXObjectGroup;
            /**
            * {Array}
getObjectGroups()
object groups
Returns:
{Array}

            */
            getObjectGroups(): Array<any>;
            /**
            * {object}
getProperties()
Gets the properties
Returns:
{object}

            */
            getProperties(): any;
            /**
            * {object}
getPropertiesForGID(GID)
Return properties dictionary for tile GID
Parameters:
{Number} GID
Returns:
{object}

            */
            getPropertiesForGID(GID?: number): any;
            /**
            * {String}
getProperty(propertyName)
Return the value for the specific property name
Parameters:
{String} propertyName
Returns:
{String}

            */
            getProperty(propertyName?: string): string;
            /**
            * {cc.Size}
getTileSize()
Gets the tile size.
Returns:
{cc.Size}

            */
            getTileSize(): cc.Size;
            /**
            * {Boolean}
initWithTMXFile(tmxFile)
Initializes the instance of cc.TMXTiledMap with tmxFile
//example
var map = new cc.TMXTiledMap()
map.initWithTMXFile(&quot;hello.tmx&quot;);
Parameters:
{String} tmxFile
Returns:
{Boolean} Whether the initialization was successful.

            */
            initWithTMXFile(tmxFile?: string): boolean;
            /**
            * {Boolean}
initWithXML(tmxString, resourcePath)
Initializes the instance of cc.TMXTiledMap with tmxString
Parameters:
{String} tmxString
{String} resourcePath
Returns:
{Boolean} Whether the initialization was successful.

            */
            initWithXML(tmxString?: string, resourcePath?: string): boolean;
            /**
            * {object}
propertiesForGID(GID)
Return properties dictionary for tile GID
Parameters:
{Number} GID
Returns:
{object}

            */
            propertiesForGID(GID?: number): any;
            /**
            * setMapOrientation(Var)
map orientation
Parameters:
{Number} Var

            */
            setMapOrientation(Var?: number);
            /**
            * setMapSize(Var)
Set the map size.
Parameters:
{cc.Size} Var

            */
            setMapSize(Var?: cc.Size);
            /**
            * setObjectGroups(Var)
object groups
Parameters:
{Array} Var

            */
            setObjectGroups(Var?: Array<any>);
            /**
            * setProperties(Var)
Set the properties
Parameters:
{object} Var

            */
            setProperties(Var?: any);
            /**
            * setTileSize(Var)
Set the tile size
Parameters:
{cc.Size} Var

            */
            setTileSize(Var?: cc.Size);
        }
    }
declare module cc {
        /**
        * 
cc.TMXTilesetInfo contains the information about the tilesets like:
- Tileset name
- Tileset spacing
- Tileset margin
- size of the tiles
- Image used for the tiles
- Image size

This information is obtained from the TMX file.

        */
        export class TMXTilesetInfo extends cc.Class {
            /**
            * cc.TMXTilesetInfo contains the information about the tilesets like:
- Tileset name
- Tileset spacing
- Tileset margin
- size of the tiles
- Image used for the tiles
- Image size

This information is obtained from the TMX file.
            */
            constructor();
            /**
            * - First grid
            */
            firstGid: number;
            /**
            * - Size in pixels of the image
            */
            imageSize: any;
            /**
            * - Margin
            */
            margin: number;
            /**
            * - Tileset name
            */
            name: string;
            /**
            * - Filename containing the tiles (should be sprite sheet / texture atlas)
            */
            sourceImage: string;
            /**
            * - Spacing
            */
            spacing: number;
            /**
            * {cc.Rect}
rectForGID(gid)
Return rect
Parameters:
{Number} gid
Returns:
{cc.Rect}

            */
            rectForGID(gid?: number): cc.Rect;
        }
    }
declare module cc {
        /**
        * 
Toggles the visibility of a node.

        */
        export class ToggleVisibility extends cc.ActionInstant {
            /**
            * Toggles the visibility of a node.
            */
            constructor();
            /**
            * Toggles the visibility of a node.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.ToggleVisibility;
            /**
            * {cc.ToggleVisibility}
clone()
to copy object with deep copy.
returns a clone of action.
Returns:
{cc.ToggleVisibility}

            */
            clone(): cc.ToggleVisibility;
            /**
            * {cc.ToggleVisibility}
reverse()
returns a reversed action.
Returns:
{cc.ToggleVisibility}

            */
            reverse(): cc.ToggleVisibility;
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
The touch event class

        */
        export class Touch extends cc.Class {
            /**
            * The touch event class
            */
            constructor(x?: number, y?: number, id?: number);
            /**
            * {cc.Point}
getDelta()
Returns the delta distance from the previous touche to the current one in screen coordinates
Returns:
{cc.Point}

            */
            getDelta(): cc.Point;
            /**
            * {Number}
getID()
Returns the id of cc.Touch
Returns:
{Number}

            */
            getID(): number;
            /**
            * {Number}
getId()
Returns the id of cc.Touch
Deprecated:
since v3.0, please use getID() instead
Returns:
{Number}

            */
            getId(): number;
            /**
            * {cc.Point}
getLocation()
Returns the current touch location in OpenGL coordinates
Returns:
{cc.Point}

            */
            getLocation(): cc.Point;
            /**
            * {cc.Point}
getLocationInView()
Returns the current touch location in screen coordinates
Returns:
{cc.Point}

            */
            getLocationInView(): cc.Point;
            /**
            * {number}
getLocationX()
Returns X axis location value
Returns:
{number}

            */
            getLocationX(): number;
            /**
            * {number}
getLocationY()
Returns Y axis location value
Returns:
{number}

            */
            getLocationY(): number;
            /**
            * {cc.Point}
getPreviousLocation()
Returns the previous touch location in OpenGL coordinates
Returns:
{cc.Point}

            */
            getPreviousLocation(): cc.Point;
            /**
            * {cc.Point}
getPreviousLocationInView()
Returns the previous touch location in screen coordinates
Returns:
{cc.Point}

            */
            getPreviousLocationInView(): cc.Point;
            /**
            * {cc.Point}
getStartLocation()
Returns the start touch location in OpenGL coordinates
Returns:
{cc.Point}

            */
            getStartLocation(): cc.Point;
            /**
            * {cc.Point}
getStartLocationInView()
Returns the start touch location in screen coordinates
Returns:
{cc.Point}

            */
            getStartLocationInView(): cc.Point;
            /**
            * setTouchInfo(id, x, y)
Sets information to touch
Parameters:
{Number} id
{Number} x
{Number} y

            */
            setTouchInfo(id?: number, x?: number, y?: number);
        }
    }
declare module cc {
        /**
        * 
Cross fades two scenes using the cc.RenderTexture object.

        */
        export class TransitionCrossFade extends cc.TransitionScene {
            /**
            * Cross fades two scenes using the cc.RenderTexture object.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionCrossFade}
cc.TransitionCrossFade.create(t, scene)
Cross fades two scenes using the cc.RenderTexture object.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionCrossFade(t, scene) instead.
Returns:
{cc.TransitionCrossFade}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionCrossFade;
            /**
            * ctor(t, scene)
Constructor of TransitionCrossFade
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * draw()
overide draw

            */
            draw();
            /**
            * onEnter()
custom on enter

            */
            onEnter();
            /**
            * onExit()
custom on exit

            */
            onExit();
            /**
            * visit()
stuff gets drawn here

            */
            visit();
        }
    }
declare module cc {
        /**
        * 
Fade out the outgoing scene and then fade in the incoming scene.

        */
        export class TransitionFade extends cc.TransitionScene {
            /**
            * Fade out the outgoing scene and then fade in the incoming scene.
            */
            constructor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionFade}
cc.TransitionFade.create(t, scene, color)
Fade out the outgoing scene and then fade in the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.Color} color
Deprecated:
since v3.0,please use new cc.TransitionFade(time,scene,color) instead.
Returns:
{cc.TransitionFade}

            */
            static create(t?: number, scene?: cc.Scene, color?: cc.Color): cc.TransitionFade;
            /**
            * ctor(t, scene, o)
Constructor of TransitionFade
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o

            */
            ctor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * {Boolean}
initWithDuration(t, scene, color)
initializes the transition with a duration and with an RGB color
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.Color} color
Returns:
{Boolean}

            */
            initWithDuration(t?: number, scene?: cc.Scene, color?: cc.Color): boolean;
            /**
            * onEnter()
custom on enter

            */
            onEnter();
            /**
            * onExit()
custom on exit

            */
            onExit();
        }
    }
declare module cc {
        /**
        * 
Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.

        */
        export class TransitionFadeBL extends cc.TransitionFadeTR {
            /**
            * Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * {*}
actionWithSize(size)
Parameters:
{cc.Size} size
Returns:
{*}

            */
            actionWithSize(size?: cc.Size): any;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionFadeBL}
cc.TransitionFadeBL.create(t, scene)
Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionFadeBL(t, scene);
Returns:
{cc.TransitionFadeBL}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionFadeBL;
            /**
            * ctor(t, scene)
Constructor of TransitionFadeBL
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
        }
    }
declare module cc {
        /**
        * 
Fade the tiles of the outgoing scene from the top to the bottom.

        */
        export class TransitionFadeDown extends cc.TransitionFadeTR {
            /**
            * Fade the tiles of the outgoing scene from the top to the bottom.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * {*}
actionWithSize(size)
Parameters:
{cc.Size} size
Returns:
{*}

            */
            actionWithSize(size?: cc.Size): any;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionFadeDown}
cc.TransitionFadeDown.create(t, scene)
Fade the tiles of the outgoing scene from the top to the bottom.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionFadeDown(t, scene) instead.
Returns:
{cc.TransitionFadeDown}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionFadeDown;
            /**
            * ctor(t, scene)
Constructor of TransitionFadeDown
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
        }
    }
declare module cc {
        /**
        * 
Fade the tiles of the outgoing scene from the left-bottom corner the to top-right corner.

        */
        export class TransitionFadeTR extends cc.TransitionScene {
            /**
            * Fade the tiles of the outgoing scene from the left-bottom corner the to top-right corner.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * {*}
actionWithSize(size)
Parameters:
{cc.Size} size
Returns:
{*}

            */
            actionWithSize(size?: cc.Size): any;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionFadeTR}
cc.TransitionFadeTR.create(t, scene)
Fade the tiles of the outgoing scene from the left-bottom corner the to top-right corner.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0 please use new cc.TransitionFadeTR(t, scene) instead.
Returns:
{cc.TransitionFadeTR}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionFadeTR;
            /**
            * ctor(t, scene)
Constructor of TransitionFadeTR
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * {cc.ActionInterval}
easeActionWithAction(action)
Parameters:
{cc.ActionInterval} action
Returns:
{cc.ActionInterval}

            */
            easeActionWithAction(action?: cc.ActionInterval): cc.ActionInterval;
            /**
            * onEnter()
Custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.

        */
        export class TransitionFadeUp extends cc.TransitionFadeTR {
            /**
            * Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * {cc.FadeOutUpTiles}
actionWithSize(size)
Parameters:
{cc.Size} size
Returns:
{cc.FadeOutUpTiles}

            */
            actionWithSize(size?: cc.Size): cc.FadeOutUpTiles;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionFadeUp}
cc.TransitionFadeUp.create(t, scene)
Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionFadeUp(t, scene) instead.
Returns:
{cc.TransitionFadeUp}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionFadeUp;
            /**
            * ctor(t, scene)
Constructor of TransitionFadeUp
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
        }
    }
declare module cc {
        /**
        * 
Flips the screen half horizontally and half vertically.
The front face is the outgoing scene and the back face is the incoming scene.

        */
        export class TransitionFlipAngular extends cc.TransitionSceneOriented {
            /**
            * Flips the screen half horizontally and half vertically.
            */
            constructor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionFlipAngular}
cc.TransitionFlipAngular.create(t, scene, o)
Flips the screen half horizontally and half vertically.
The front face is the outgoing scene and the back face is the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o
Deprecated:
since v3.0,please use new new cc.TransitionFlipAngular(t, scene, o) instead
Returns:
{cc.TransitionFlipAngular}

            */
            static create(t?: number, scene?: cc.Scene, o?: any): cc.TransitionFlipAngular;
            /**
            * ctor(t, scene, o)
Constructor of TransitionFlipAngular
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o

            */
            ctor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * onEnter()
custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Flips the screen horizontally.
The front face is the outgoing scene and the back face is the incoming scene.

        */
        export class TransitionFlipX extends cc.TransitionSceneOriented {
            /**
            * Flips the screen horizontally.
            */
            constructor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionFlipX}
cc.TransitionFlipX.create(t, scene, o)
Flips the screen horizontally.
The front face is the outgoing scene and the back face is the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o
Deprecated:
since v3.0,please use new cc.TransitionFlipX(t, scene,o) instead.
Returns:
{cc.TransitionFlipX}

            */
            static create(t?: number, scene?: cc.Scene, o?: any): cc.TransitionFlipX;
            /**
            * ctor(t, scene, o)
Constructor of TransitionFlipX
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o

            */
            ctor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * onEnter()
custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Flips the screen vertically.
The front face is the outgoing scene and the back face is the incoming scene.

        */
        export class TransitionFlipY extends cc.TransitionSceneOriented {
            /**
            * Flips the screen vertically.
            */
            constructor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionFlipY}
cc.TransitionFlipY.create(t, scene, o)
Flips the screen vertically.
The front face is the outgoing scene and the back face is the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o
Deprecated:
since v3.0,please use new cc.TransitionFlipY(t, scene,o) instead.
Returns:
{cc.TransitionFlipY}

            */
            static create(t?: number, scene?: cc.Scene, o?: any): cc.TransitionFlipY;
            /**
            * ctor(t, scene, o)
Constructor of TransitionFlipY
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o

            */
            ctor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * onEnter()
custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Zoom out and jump the outgoing scene, and then jump and zoom in the incoming

        */
        export class TransitionJumpZoom extends cc.TransitionScene {
            /**
            * Zoom out and jump the outgoing scene, and then jump and zoom in the incoming
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionJumpZoom}
cc.TransitionJumpZoom.create(t, scene)
creates a scene transition that zooms then jump across the screen, the same for the incoming scene
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionJumpZoom(t, scene);
Returns:
{cc.TransitionJumpZoom}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionJumpZoom;
            /**
            * ctor(t, scene)
Constructor of TransitionJumpZoom
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * onEnter()
Custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Move in from to the bottom the incoming scene.

        */
        export class TransitionMoveInB extends cc.TransitionMoveInL {
            /**
            * Move in from to the bottom the incoming scene.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionMoveInB}
cc.TransitionMoveInB.create(t, scene)
create a scene transition that Move in from to the bottom the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionMoveInB(t, scene) instead
Returns:
{cc.TransitionMoveInB}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionMoveInB;
            /**
            * ctor(t, scene)
Constructor of TransitionMoveInB
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * initScenes()
init function

            */
            initScenes();
        }
    }
declare module cc {
        /**
        * 
Move in from to the left the incoming scene.

        */
        export class TransitionMoveInL extends cc.TransitionScene {
            /**
            * Move in from to the left the incoming scene.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * action()
returns the action that will be performed

            */
            action();
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionMoveInL}
cc.TransitionMoveInL.create(t, scene)
creates an action that  Move in from to the left the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionMoveInL(t, scene) instead
Returns:
{cc.TransitionMoveInL}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionMoveInL;
            /**
            * ctor(t, scene)
Constructor of TransitionMoveInL
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * {cc.EaseOut}
easeActionWithAction(action)
creates an ease action from action
Parameters:
{cc.ActionInterval} action
Returns:
{cc.EaseOut}

            */
            easeActionWithAction(action?: cc.ActionInterval): cc.EaseOut;
            /**
            * initScenes()
initializes the scenes

            */
            initScenes();
            /**
            * onEnter()
Custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Move in from to the right the incoming scene.

        */
        export class TransitionMoveInR extends cc.TransitionMoveInL {
            /**
            * Move in from to the right the incoming scene.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionMoveInR}
cc.TransitionMoveInR.create(t, scene)
create a scene transition that Move in from to the right the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionMoveInR(t, scene) instead
Returns:
{cc.TransitionMoveInR}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionMoveInR;
            /**
            * ctor(t, scene)
Constructor of TransitionMoveInR
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * initScenes()
Init function

            */
            initScenes();
        }
    }
declare module cc {
        /**
        * 
Move in from to the top the incoming scene.

        */
        export class TransitionMoveInT extends cc.TransitionMoveInL {
            /**
            * Move in from to the top the incoming scene.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionMoveInT}
cc.TransitionMoveInT.create(t, scene)
Move in from to the top the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionMoveInT(t, scene) instead
Returns:
{cc.TransitionMoveInT}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionMoveInT;
            /**
            * ctor(t, scene)
Constructor of TransitionMoveInT
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * initScenes()
init function

            */
            initScenes();
        }
    }
declare module cc {
        /**
        * 
A transition which peels back the bottom right hand corner of a scene
to transition to the scene beneath it simulating a page turn.

This uses a 3DAction so it&#39;s strongly recommended that depth buffering
is turned on in cc.director using:

cc.director.setDepthBufferFormat(kDepthBuffer16);

        */
        export class TransitionPageTurn extends cc.TransitionScene {
            /**
            * A transition which peels back the bottom right hand corner of a scene
to transition to the scene beneath it simulating a page turn.
            */
            constructor(t?: number, scene?: cc.Scene, backwards?: boolean);
            /**
            * {cc.ReverseTime|cc.TransitionScene}
actionWithSize(vector)
Parameters:
{cc.Size} vector
Returns:
{cc.ReverseTime|cc.TransitionScene}

            */
            actionWithSize(vector?: cc.Size): any;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionPageTurn}
cc.TransitionPageTurn.create(t, scene, backwards)
Creates a base transition with duration and incoming scene.
If back is true then the effect is reversed to appear as if the incoming
scene is being turned from left over the outgoing scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{Boolean} backwards
Deprecated:
since v3.0,please use new cc.TransitionPageTurn(t, scene, backwards) instead.
Returns:
{cc.TransitionPageTurn}

            */
            static create(t?: number, scene?: cc.Scene, backwards?: boolean): cc.TransitionPageTurn;
            /**
            * ctor(t, scene, backwards)
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{Boolean} backwards

            */
            ctor(t?: number, scene?: cc.Scene, backwards?: boolean);
            /**
            * {Boolean}
initWithDuration(t, scene, backwards)
Creates a base transition with duration and incoming scene.
If back is true then the effect is reversed to appear as if the incoming
scene is being turned from left over the outgoing scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{Boolean} backwards
Returns:
{Boolean}

            */
            initWithDuration(t?: number, scene?: cc.Scene, backwards?: boolean): boolean;
            /**
            * onEnter()
custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
cc.TransitionProgress transition.

        */
        export class TransitionProgress extends cc.TransitionScene {
            /**
            * cc.TransitionProgress transition.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionProgress}
cc.TransitionProgress.create(t, scene)
create a cc.TransitionProgress object
Parameters:
{Number} t
time
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionProgress(t, scene) instead.
Returns:
{cc.TransitionProgress}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionProgress;
            /**
            * ctor(t, scene)
Parameters:
{Number} t
time
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * onEnter()

            */
            onEnter();
            /**
            * onExit()

            */
            onExit();
        }
    }
declare module cc {
        /**
        * 
cc.TransitionProgressHorizontal transition.
A  colock-wise radial transition to the next scene

        */
        export class TransitionProgressHorizontal extends cc.TransitionProgress {
            /**
            * cc.TransitionProgressHorizontal transition.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionProgressHorizontal}
cc.TransitionProgressHorizontal.create(t, scene)
create a cc.TransitionProgressHorizontal object
Parameters:
{Number} t
time
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionProgressHorizontal(t, scene) instead.
Returns:
{cc.TransitionProgressHorizontal}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionProgressHorizontal;
            /**
            * ctor(t, scene)
Parameters:
{Number} t
time
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
        }
    }
declare module cc {
        /**
        * 
cc.TransitionProgressInOut transition.

        */
        export class TransitionProgressInOut extends cc.TransitionProgress {
            /**
            * cc.TransitionProgressInOut transition.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionProgressInOut}
cc.TransitionProgressInOut.create(t, scene)
create a cc.TransitionProgressInOut object
Parameters:
{Number} t
time
{cc.Scene} scene
Returns:
{cc.TransitionProgressInOut}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionProgressInOut;
            /**
            * ctor(t, scene)
The constructor of cc.TransitionProgressInOut. override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} t
time
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
        }
    }
declare module cc {
        /**
        * 
cc.TransitionProgressOutIn transition.

        */
        export class TransitionProgressOutIn extends cc.TransitionProgress {
            /**
            * cc.TransitionProgressOutIn transition.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionProgressOutIn}
cc.TransitionProgressOutIn.create(t, scene)
create a cc.TransitionProgressOutIn object
Parameters:
{Number} t
time
{cc.Scene} scene
Returns:
{cc.TransitionProgressOutIn}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionProgressOutIn;
            /**
            * ctor(t, scene)
The constructor of cc.TransitionProgressOutIn. override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{Number} t
time
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
        }
    }
declare module cc {
        /**
        * 
cc.TransitionRadialCCW transition.
A counter clock-wise radial transition to the next scene

        */
        export class TransitionProgressRadialCCW extends cc.TransitionProgress {
            /**
            * cc.TransitionRadialCCW transition.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionProgressRadialCCW}
cc.TransitionProgressRadialCCW.create(t, scene)
create a cc.TransitionProgressRadialCCW object
var trans = new cc.TransitionProgressRadialCCW(time,scene);
Parameters:
{Number} t
time
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionProgressRadialCCW(t, scene) instead.
Returns:
{cc.TransitionProgressRadialCCW}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionProgressRadialCCW;
            /**
            * ctor(t, scene)
Parameters:
{Number} t
time
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
        }
    }
declare module cc {
        /**
        * 
cc.TransitionRadialCW transition.
A counter colock-wise radial transition to the next scene

        */
        export class TransitionProgressRadialCW extends cc.TransitionProgress {
            /**
            * cc.TransitionRadialCW transition.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionProgressRadialCW}
cc.TransitionProgressRadialCW.create(t, scene)
create a cc.TransitionProgressRadialCW object
Parameters:
{Number} t
time
{cc.Scene} scene
Deprecated:
since v3.0,please use cc.TransitionProgressRadialCW(t, scene) instead.
Returns:
{cc.TransitionProgressRadialCW}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionProgressRadialCW;
            /**
            * ctor(t, scene)
Parameters:
{Number} t
time
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
        }
    }
declare module cc {
        /**
        * 
cc.TransitionProgressVertical transition.

        */
        export class TransitionProgressVertical extends cc.TransitionProgress {
            /**
            * cc.TransitionProgressVertical transition.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionProgressVertical}
cc.TransitionProgressVertical.create(t, scene)
create a cc.TransitionProgressVertical object
Parameters:
{Number} t
time
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionProgressVertical(t, scene) instead.
Returns:
{cc.TransitionProgressVertical}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionProgressVertical;
            /**
            * ctor(t, scene)
Parameters:
{Number} t
time
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
        }
    }
declare module cc {
        /**
        * 
Rotate and zoom out the outgoing scene, and then rotate and zoom in the incoming

        */
        export class TransitionRotoZoom extends cc.TransitionScene {
            /**
            * Rotate and zoom out the outgoing scene, and then rotate and zoom in the incoming
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionRotoZoom}
cc.TransitionRotoZoom.create(t, scene)
Creates a Transtion rotation and zoom
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
the scene to work with
Deprecated:
since v3.0,please use new cc.TransitionRotoZoom(t, scene) instead
Returns:
{cc.TransitionRotoZoom}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionRotoZoom;
            /**
            * ctor(t, scene)
Constructor of TransitionRotoZoom
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * onEnter()
Custom On Enter callback

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
        */
        export class TransitionScene extends cc.Scene {
            /**
            * 
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * cleanup()
custom cleanup

            */
            cleanup();
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionScene|Null}
cc.TransitionScene.create(t, scene)
creates a base transition with duration and incoming scene
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
the scene to transit with
Deprecated:
since v3.0, please use new cc.TransitionScene(t,scene) instead
Returns:
{cc.TransitionScene|Null}

            */
            static create(t?: number, scene?: cc.Scene): any;
            /**
            * ctor(t, scene)
creates a base transition with duration and incoming scene
Constructor of cc.TransitionScene
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
the scene to transit with

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * finish()
called after the transition finishes

            */
            finish();
            /**
            * hideOutShowIn()
set hide the out scene and show in scene

            */
            hideOutShowIn();
            /**
            * {Boolean}
initWithDuration(t, scene)
initializes a transition with duration and incoming scene
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
a scene to transit to
Returns:
{Boolean} return false if error

            */
            initWithDuration(t?: number, scene?: cc.Scene): boolean;
            /**
            * onEnter()
Event callback that is invoked every time when cc.TransitionScene enters the &#39;stage&#39;.
If the TransitionScene enters the &#39;stage&#39; with a transition, this event is called when the transition starts.
During onEnter you can&#39;t access a &quot;sister/brother&quot; node.
If you override onEnter, you must call its parent&#39;s onEnter function with this._super().

            */
            onEnter();
            /**
            * onExit()
callback that is called every time the cc.TransitionScene leaves the &#39;stage&#39;.
If the cc.TransitionScene leaves the &#39;stage&#39; with a transition, this callback is called when the transition finishes.
During onExit you can&#39;t access a sibling node.
If you override onExit, you shall call its parent&#39;s onExit with this._super().

            */
            onExit();
            /**
            * visit()
stuff gets drawn here

            */
            visit();
        }
    }
declare module cc {
        /**
        * 
A cc.Transition that supports orientation like.
Possible orientation: LeftOver, RightOver, UpOver, DownOver
useful for when you want to make a transition happen between 2 orientations

        */
        export class TransitionSceneOriented extends cc.TransitionScene {
            /**
            * A cc.Transition that supports orientation like.
            */
            constructor(t?: number, scene?: cc.Scene, orientation?: any);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionSceneOriented}
cc.TransitionSceneOriented.create(t, scene, orientation)
creates a base transition with duration and incoming scene
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} orientation
Deprecated:
since v3.0 ,please use new cc.TransitionSceneOriented(t, scene, orientation) instead.
Returns:
{cc.TransitionSceneOriented}

            */
            static create(t?: number, scene?: cc.Scene, orientation?: any): cc.TransitionSceneOriented;
            /**
            * ctor(t, scene, orientation)
Constructor of TransitionSceneOriented
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} orientation

            */
            ctor(t?: number, scene?: cc.Scene, orientation?: any);
            /**
            * {Boolean}
initWithDuration(t, scene, orientation)
initialize the transition
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} orientation
Returns:
{Boolean}

            */
            initWithDuration(t?: number, scene?: cc.Scene, orientation?: any): boolean;
        }
    }
declare module cc {
        /**
        * 
Shrink the outgoing scene while grow the incoming scene

        */
        export class TransitionShrinkGrow extends cc.TransitionScene {
            /**
            * Shrink the outgoing scene while grow the incoming scene
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionShrinkGrow}
cc.TransitionShrinkGrow.create(t, scene)
Shrink the outgoing scene while grow the incoming scene
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionShrinkGrow(t, scene) instead.
Returns:
{cc.TransitionShrinkGrow}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionShrinkGrow;
            /**
            * ctor(t, scene)
Constructor of TransitionShrinkGrow
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * {cc.EaseOut}
easeActionWithAction(action)
Parameters:
action
Returns:
{cc.EaseOut}

            */
            easeActionWithAction(): cc.EaseOut;
            /**
            * onEnter()
Custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Slide in the incoming scene from the bottom border.

        */
        export class TransitionSlideInB extends cc.TransitionSlideInL {
            /**
            * Slide in the incoming scene from the bottom border.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * {cc.MoveBy}
action()
returns the action that will be performed by the incomming and outgoing scene
Returns:
{cc.MoveBy}

            */
            action(): cc.MoveBy;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionSlideInB}
cc.TransitionSlideInB.create(t, scene)
create a Slide in the incoming scene from the bottom border.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionSlideInB(t, scene) instead.
Returns:
{cc.TransitionSlideInB}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionSlideInB;
            /**
            * ctor(t, scene)
Constructor of TransitionSlideInB
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * initScenes()
initializes the scenes

            */
            initScenes();
        }
    }
declare module cc {
        /**
        * 
a transition that a new scene is slided from left

        */
        export class TransitionSlideInL extends cc.TransitionScene {
            /**
            * a transition that a new scene is slided from left
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * {cc.MoveBy}
action()
returns the action that will be performed by the incomming and outgoing scene
Returns:
{cc.MoveBy}

            */
            action(): cc.MoveBy;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionSlideInL}
cc.TransitionSlideInL.create(t, scene)
create a transition that a new scene is slided from left
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionSlideInL(t, scene) instead
Returns:
{cc.TransitionSlideInL}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionSlideInL;
            /**
            * ctor(t, scene)
Constructor of TransitionSlideInL
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * {*}
easeActionWithAction(action)
Parameters:
{cc.ActionInterval} action
Returns:
{*}

            */
            easeActionWithAction(action?: cc.ActionInterval): any;
            /**
            * initScenes()
initializes the scenes

            */
            initScenes();
            /**
            * onEnter()
custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Slide in the incoming scene from the right border.

        */
        export class TransitionSlideInR extends cc.TransitionSlideInL {
            /**
            * Slide in the incoming scene from the right border.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * {cc.MoveBy}
action()
returns the action that will be performed by the incomming and outgoing scene
Returns:
{cc.MoveBy}

            */
            action(): cc.MoveBy;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionSlideInR}
cc.TransitionSlideInR.create(t, scene)
create Slide in the incoming scene from the right border.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionSlideInR(t, scene) instead
Returns:
{cc.TransitionSlideInR}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionSlideInR;
            /**
            * ctor(t, scene)
Constructor of TransitionSlideInR
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * initScenes()
initializes the scenes

            */
            initScenes();
        }
    }
declare module cc {
        /**
        * 
Slide in the incoming scene from the top border.

        */
        export class TransitionSlideInT extends cc.TransitionSlideInL {
            /**
            * Slide in the incoming scene from the top border.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * {cc.MoveBy}
action()
returns the action that will be performed by the incomming and outgoing scene
Returns:
{cc.MoveBy}

            */
            action(): cc.MoveBy;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionSlideInT}
cc.TransitionSlideInT.create(t, scene)
create a Slide in the incoming scene from the top border.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionSlideInT(t, scene) instead.
Returns:
{cc.TransitionSlideInT}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionSlideInT;
            /**
            * ctor(t, scene)
Constructor of TransitionSlideInT
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * initScenes()
initializes the scenes

            */
            initScenes();
        }
    }
declare module cc {
        /**
        * 
The odd columns goes upwards while the even columns goes downwards.

        */
        export class TransitionSplitCols extends cc.TransitionScene {
            /**
            * The odd columns goes upwards while the even columns goes downwards.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * {*}
action()
Returns:
{*}

            */
            action(): any;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionSplitCols}
cc.TransitionSplitCols.create(t, scene)
The odd columns goes upwards while the even columns goes downwards.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionSplitCols(t, scene) instead.
Returns:
{cc.TransitionSplitCols}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionSplitCols;
            /**
            * ctor(t, scene)
Constructor of TransitionSplitCols
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * {cc.EaseInOut}
easeActionWithAction(action)
Parameters:
{cc.ActionInterval} action
Returns:
{cc.EaseInOut}

            */
            easeActionWithAction(action?: cc.ActionInterval): cc.EaseInOut;
            /**
            * onEnter()
custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
The odd rows goes to the left while the even rows goes to the right.

        */
        export class TransitionSplitRows extends cc.TransitionSplitCols {
            /**
            * The odd rows goes to the left while the even rows goes to the right.
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * {*}
action()
Returns:
{*}

            */
            action(): any;
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionSplitRows}
cc.TransitionSplitRows.create(t, scene)
The odd rows goes to the left while the even rows goes to the right.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionSplitRows(t, scene) instead.
Returns:
{cc.TransitionSplitRows}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionSplitRows;
            /**
            * ctor(t, scene)
Constructor of TransitionSplitRows
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
        }
    }
declare module cc {
        /**
        * 
Turn off the tiles of the outgoing scene in random order

        */
        export class TransitionTurnOffTiles extends cc.TransitionScene {
            /**
            * Turn off the tiles of the outgoing scene in random order
            */
            constructor(t?: number, scene?: cc.Scene);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionTurnOffTiles}
cc.TransitionTurnOffTiles.create(t, scene)
Turn off the tiles of the outgoing scene in random order
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
Deprecated:
since v3.0,please use new cc.TransitionTurnOffTiles(t, scene) instead.
Returns:
{cc.TransitionTurnOffTiles}

            */
            static create(t?: number, scene?: cc.Scene): cc.TransitionTurnOffTiles;
            /**
            * ctor(t, scene)
Constructor of TransitionCrossFade
Parameters:
{Number} t
time in seconds
{cc.Scene} scene

            */
            ctor(t?: number, scene?: cc.Scene);
            /**
            * {cc.ActionInterval}
easeActionWithAction(action)
Parameters:
{cc.ActionInterval} action
Returns:
{cc.ActionInterval}

            */
            easeActionWithAction(action?: cc.ActionInterval): cc.ActionInterval;
            /**
            * onEnter()
custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Flips the screen half horizontally and half vertically doing a little zooming out/in.
The front face is the outgoing scene and the back face is the incoming scene.

        */
        export class TransitionZoomFlipAngular extends cc.TransitionSceneOriented {
            /**
            * Flips the screen half horizontally and half vertically doing a little zooming out/in.
            */
            constructor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionZoomFlipAngular}
cc.TransitionZoomFlipAngular.create(t, scene, o)
Flips the screen half horizontally and half vertically doing a little zooming out/in.
The front face is the outgoing scene and the back face is the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o
Deprecated:
since v3.0,please use new new cc.TransitionZoomFlipAngular(t, scene, o) instead
Returns:
{cc.TransitionZoomFlipAngular}

            */
            static create(t?: number, scene?: cc.Scene, o?: any): cc.TransitionZoomFlipAngular;
            /**
            * ctor(t, scene, o)
Constructor of TransitionZoomFlipAngular
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o

            */
            ctor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * onEnter()
custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Flips the screen horizontally doing a zoom out/in
The front face is the outgoing scene and the back face is the incoming scene.

        */
        export class TransitionZoomFlipX extends cc.TransitionSceneOriented {
            /**
            * Flips the screen horizontally doing a zoom out/in
The front face is the outgoing scene and the back face is the incoming scene.
            */
            constructor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionZoomFlipX}
cc.TransitionZoomFlipX.create(t, scene, o)
Flips the screen horizontally doing a zoom out/in
The front face is the outgoing scene and the back face is the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o
Deprecated:
since v3.0,please use new new cc.TransitionZoomFlipX(t, scene, o) instead
Returns:
{cc.TransitionZoomFlipX}

            */
            static create(t?: number, scene?: cc.Scene, o?: any): cc.TransitionZoomFlipX;
            /**
            * ctor(t, scene, o)
Constructor of TransitionZoomFlipX
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o

            */
            ctor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * onEnter()
custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
Flips the screen vertically doing a little zooming out/in
The front face is the outgoing scene and the back face is the incoming scene.

        */
        export class TransitionZoomFlipY extends cc.TransitionSceneOriented {
            /**
            * Flips the screen vertically doing a little zooming out/in
The front face is the outgoing scene and the back face is the incoming scene.
            */
            constructor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * &amp;lt;static&amp;gt;
{cc.TransitionZoomFlipY}
cc.TransitionZoomFlipY.create(t, scene, o)
Flips the screen vertically doing a little zooming out/in
The front face is the outgoing scene and the back face is the incoming scene.
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o
Deprecated:
since v3.0,please use new new cc.TransitionZoomFlipY(t, scene, o) instead
Returns:
{cc.TransitionZoomFlipY}

            */
            static create(t?: number, scene?: cc.Scene, o?: any): cc.TransitionZoomFlipY;
            /**
            * ctor(t, scene, o)
Constructor of TransitionZoomFlipY
Parameters:
{Number} t
time in seconds
{cc.Scene} scene
{cc.TRANSITION_ORIENTATION_LEFT_OVER|cc.TRANSITION_ORIENTATION_RIGHT_OVER|cc.TRANSITION_ORIENTATION_UP_OVER|cc.TRANSITION_ORIENTATION_DOWN_OVER} o

            */
            ctor(t?: number, scene?: cc.Scene, o?: any);
            /**
            * onEnter()
custom on enter

            */
            onEnter();
        }
    }
declare module cc {
        /**
        * 
cc.TurnOffTiles action.
Turn off the files in random order.
Reference the test cases (Effects Test)

        */
        export class TurnOffTiles extends cc.TiledGrid3DAction {
            /**
            * cc.TurnOffTiles action.
            */
            constructor(duration?: number, gridSize?: cc.Size, seed?: any);
            /**
            * Please use cc.turnOffTiles instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.TurnOffTiles;
            /**
            * ctor(duration, gridSize, seed)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Creates the action with a random seed, the grid size and the duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number|Null} seed
Optional, Default: 0

            */
            ctor(duration?: number, gridSize?: cc.Size, seed?: any);
            /**
            * {Boolean}
initWithDuration(duration, gridSize, seed)
Initializes the action with a random seed, the grid size and the duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number|Null} seed
Optional, Default: 0
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, seed?: any): boolean;
            /**
            * shuffle(array, len)
Shuffle
Parameters:
{Array} array
{Number} len

            */
            shuffle(array?: Array<any>, len?: number);
            /**
            * startWithTarget(target)
called before the action start. It will also set the target.
Parameters:
{cc.Node} target

            */
            startWithTarget(target?: cc.Node);
            /**
            * turnOffTile(pos)
Turn off title.
Parameters:
{cc.Point} pos

            */
            turnOffTile(pos?: cc.Point);
            /**
            * turnOnTile(pos)
Turn on tile.
Parameters:
{cc.Point} pos

            */
            turnOnTile(pos?: cc.Point);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Twirl action.
Reference the test cases (Effects Test)

        */
        export class Twirl extends cc.Grid3DAction {
            /**
            * cc.Twirl action.
            */
            constructor(duration?: number, gridSize?: cc.Size, position?: cc.Point, twirls?: number, amplitude?: number);
            /**
            * Please use cc.twirl instead
creates the action with center position, number of twirls, amplitude, a grid size and duration
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Twirl;
            /**
            * ctor(duration, gridSize, position, twirls, amplitude)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a grid 3d action with center position, number of twirls, amplitude, a grid size and duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{cc.Point} position
{Number} twirls
{Number} amplitude

            */
            ctor(duration?: number, gridSize?: cc.Size, position?: cc.Point, twirls?: number, amplitude?: number);
            /**
            * {Number}
getAmplitude()
get amplitude
Returns:
{Number}

            */
            getAmplitude(): number;
            /**
            * {Number}
getAmplitudeRate()
get amplitude rate
Returns:
{Number}

            */
            getAmplitudeRate(): number;
            /**
            * {cc.Point}
getPosition()
get twirl center
Returns:
{cc.Point}

            */
            getPosition(): cc.Point;
            /**
            * initWithDuration(duration, gridSize, position, twirls, amplitude)
initializes the action with center position, number of twirls, amplitude, a grid size and duration
Parameters:
duration
gridSize
position
twirls
amplitude

            */
            initWithDuration();
            /**
            * setAmplitude(amplitude)
set amplitude
Parameters:
{Number} amplitude

            */
            setAmplitude(amplitude?: number);
            /**
            * setAmplitudeRate(amplitudeRate)
set amplitude rate
Parameters:
{Number} amplitudeRate

            */
            setAmplitudeRate(amplitudeRate?: number);
            /**
            * setPosition(position)
set twirl center
Parameters:
{cc.Point} position

            */
            setPosition(position?: cc.Point);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
        */
        export class Vertex2F  {
            /**
            * 
            */
            constructor(x1?: number, y1?: number);
        }
    }
declare module cc {
        /**
        * 
        */
        export class Vertex3F  {
            /**
            * 
            */
            constructor(x1?: number, y1?: number, z1?: number);
        }
    }
declare module cc {
        /**
        * 
cc.view is the singleton object which represents the game window.
It&#39;s main task include:
- Apply the design resolution policy
- Provide interaction with the window, like resize event on web, retina display support, etc...
- Manage the game view port which can be different with the window
- Manage the content scale and translation

Since the cc.view is a singleton, you don&#39;t need to call any constructor or create functions,
the standard way to use it is by calling:
- cc.view.methodName();

        */
        export class view  {
            /**
            * cc.view is the singleton object which represents the game window.
            */
            constructor();
            /**
            * adjustViewPort(enabled)
Sets whether the engine modify the &quot;viewport&quot; meta in your web page.
It&#39;s enabled by default, we strongly suggest you not to disable it.
And even when it&#39;s enabled, you can still set your own &quot;viewport&quot; meta, it won&#39;t be overridden
Only useful on web
Parameters:
{Boolean} enabled
Enable automatic modification to &quot;viewport&quot; meta

            */
            adjustViewPort(enabled?: boolean);
            /**
            * {Boolean}
canSetContentScaleFactor()
Returns whether developer can set content&#39;s scale factor.
Returns:
{Boolean}

            */
            canSetContentScaleFactor(): boolean;
            /**
            * centerWindow()
Empty function

            */
            centerWindow();
            /**
            * {cc.Point}
convertToLocationInView(tx, ty, relatedPos)
Returns the real location in view for a translation based on a related position
Parameters:
{Number} tx
The X axis translation
{Number} ty
The Y axis translation
{Object} relatedPos
The related position object including &quot;left&quot;, &quot;top&quot;, &quot;width&quot;, &quot;height&quot; informations
Returns:
{cc.Point}

            */
            convertToLocationInView(tx?: number, ty?: number, relatedPos?: Object): cc.Point;
            /**
            * ctor()
Constructor of cc.EGLView

            */
            ctor();
            /**
            * enableAutoFullScreen(enabled)
If enabled, the application will try automatically to enter full screen mode on mobile devices
You can pass true as parameter to enable it and disable it by passing false.
Only useful on web
Parameters:
{Boolean} enabled
Enable or disable auto full screen on mobile devices

            */
            enableAutoFullScreen(enabled?: boolean);
            /**
            * enableRetina(enabled)
Retina support is enabled by default for Apple device but disabled for other devices,
it takes effect only when you called setDesignResolutionPolicy
Only useful on web
Parameters:
{Boolean} enabled
Enable or disable retina display

            */
            enableRetina(enabled?: boolean);
            /**
            * end()
Force destroying EGL view, subclass must implement this method.

            */
            end();
            /**
            * {cc.Size|Object}
getContentTranslateLeftTop()
Returns the resolution translate on EGLView
Returns:
{cc.Size|Object}

            */
            getContentTranslateLeftTop(): any;
            /**
            * {cc.Size}
getDesignResolutionSize()
Returns the designed size for the view.
Default resolution size is the same as &#39;getFrameSize&#39;.
Returns:
{cc.Size}

            */
            getDesignResolutionSize(): cc.Size;
            /**
            * {Number}
getDevicePixelRatio()
Returns device pixel ratio for retina display.
Returns:
{Number}

            */
            getDevicePixelRatio(): number;
            /**
            * {cc.Size}
getFrameSize()
Returns the frame size of the view.
On native platforms, it returns the screen size since the view is a fullscreen view.
On web, it returns the size of the canvas&#39;s outer DOM element.
Returns:
{cc.Size}

            */
            getFrameSize(): cc.Size;
            /**
            * {cc.ResolutionPolicy}
getResolutionPolicy()
Returns the current resolution policy
Returns:
{cc.ResolutionPolicy}
See:
cc.ResolutionPolicy

            */
            getResolutionPolicy(): cc.ResolutionPolicy;
            /**
            * {Number}
getScaleX()
Returns scale factor of the horizontal direction (X axis).
Returns:
{Number}

            */
            getScaleX(): number;
            /**
            * {Number}
getScaleY()
Returns scale factor of the vertical direction (Y axis).
Returns:
{Number}

            */
            getScaleY(): number;
            /**
            * {cc.Rect}
getScissorRect()
Returns the current scissor rectangle
Returns:
{cc.Rect}

            */
            getScissorRect(): cc.Rect;
            /**
            * {String}
getTargetDensityDPI()
Returns the current target-densitydpi value of cc.view.
Returns:
{String}

            */
            getTargetDensityDPI(): string;
            /**
            * {String}
getViewName()
Returns the name of the view
Returns:
{String}

            */
            getViewName(): string;
            /**
            * {cc.Rect}
getViewPortRect()
Returns the view port rectangle.
Returns:
{cc.Rect}

            */
            getViewPortRect(): cc.Rect;
            /**
            * {cc.Point}
getVisibleOrigin()
Returns the visible origin of the view port.
Returns:
{cc.Point}

            */
            getVisibleOrigin(): cc.Point;
            /**
            * {cc.Size}
getVisibleSize()
Returns the visible area size of the view port.
Returns:
{cc.Size}

            */
            getVisibleSize(): cc.Size;
            /**
            * {Boolean}
isAutoFullScreenEnabled()
Check whether auto full screen is enabled.
Only useful on web
Returns:
{Boolean} Auto full screen enabled or not

            */
            isAutoFullScreenEnabled(): boolean;
            /**
            * {Boolean}
isOpenGLReady()
Get whether render system is ready(no matter opengl or canvas),
this name is for the compatibility with cocos2d-x, subclass must implement this method.
Returns:
{Boolean}

            */
            isOpenGLReady(): boolean;
            /**
            * {Boolean}
isRetinaEnabled()
Check whether retina display is enabled.
Only useful on web
Returns:
{Boolean}

            */
            isRetinaEnabled(): boolean;
            /**
            * {Boolean}
isScissorEnabled()
Returns whether GL_SCISSOR_TEST is enable
Returns:
{Boolean}

            */
            isScissorEnabled(): boolean;
            /**
            * resizeWithBrowserSize(enabled)
Sets whether resize canvas automatically when browser&#39;s size changed.
Useful only on web.
Parameters:
{Boolean} enabled
Whether enable automatic resize with browser&#39;s resize event

            */
            resizeWithBrowserSize(enabled?: boolean);
            /**
            * setContentTranslateLeftTop(offsetLeft, offsetTop)
Sets the resolution translate on EGLView
Parameters:
{Number} offsetLeft
{Number} offsetTop

            */
            setContentTranslateLeftTop(offsetLeft?: number, offsetTop?: number);
            /**
            * setDesignResolutionSize(width, height, resolutionPolicy)
Sets the resolution policy with designed view size in points.
The resolution policy include:
[1] ResolutionExactFit       Fill screen by stretch-to-fit: if the design resolution ratio of width to height is different from the screen resolution ratio, your game view will be stretched.
[2] ResolutionNoBorder       Full screen without black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two areas of your game view will be cut.
[3] ResolutionShowAll        Full screen with black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two black borders will be shown.
[4] ResolutionFixedHeight    Scale the content&#39;s height to screen&#39;s height and proportionally scale its width
[5] ResolutionFixedWidth     Scale the content&#39;s width to screen&#39;s width and proportionally scale its height
[cc.ResolutionPolicy]        [Web only feature] Custom resolution policy, constructed by cc.ResolutionPolicy
Parameters:
{Number} width
Design resolution width.
{Number} height
Design resolution height.
{cc.ResolutionPolicy|Number} resolutionPolicy
The resolution policy desired

            */
            setDesignResolutionSize(width?: number, height?: number, resolutionPolicy?: any);
            /**
            * setFrameSize(width, height)
On native, it sets the frame size of view.
On web, it sets the size of the canvas&#39;s outer DOM element.
Parameters:
{Number} width
{Number} height

            */
            setFrameSize(width?: number, height?: number);
            /**
            * setIMEKeyboardState(isOpen)
Open or close IME keyboard , subclass must implement this method.
Parameters:
{Boolean} isOpen

            */
            setIMEKeyboardState(isOpen?: boolean);
            /**
            * setResizeCallback(callback)
Sets the callback function for cc.view&#39;s resize action,
this callback will be invoked before applying resolution policy,
so you can do any additional modifications within the callback.
Useful only on web.
Parameters:
{Function|null} callback
The callback function

            */
            setResizeCallback(callback?: any);
            /**
            * setResolutionPolicy(resolutionPolicy)
Sets the current resolution policy
Parameters:
{cc.ResolutionPolicy|Number} resolutionPolicy
See:
cc.ResolutionPolicy

            */
            setResolutionPolicy(resolutionPolicy?: any);
            /**
            * setScissorInPoints(x, y, w, h)
Sets Scissor rectangle with points.
Parameters:
{Number} x
{Number} y
{Number} w
{Number} h

            */
            setScissorInPoints(x?: number, y?: number, w?: number, h?: number);
            /**
            * setTargetDensityDPI(densityDPI)
Sets view&#39;s target-densitydpi for android mobile browser. it can be set to:
1. cc.DENSITYDPI_DEVICE, value is &quot;device-dpi&quot;
2. cc.DENSITYDPI_HIGH, value is &quot;high-dpi&quot;  (default value)
3. cc.DENSITYDPI_MEDIUM, value is &quot;medium-dpi&quot; (browser&#39;s default value)
4. cc.DENSITYDPI_LOW, value is &quot;low-dpi&quot;
5. Custom value, e.g: &quot;480&quot;
Parameters:
{String} densityDPI

            */
            setTargetDensityDPI(densityDPI?: string);
            /**
            * setViewName(viewName)
Sets the name of the view
Parameters:
{String} viewName

            */
            setViewName(viewName?: string);
            /**
            * setViewPortInPoints(x, y, w, h)
Sets view port rectangle with points.
Parameters:
{Number} x
{Number} y
{Number} w
width
{Number} h
height

            */
            setViewPortInPoints(x?: number, y?: number, w?: number, h?: number);
            /**
            * swapBuffers()
Exchanges the front and back buffers, subclass must implement this method.

            */
            swapBuffers();
        }
    }
declare module cc {
        /**
        * 
cc.visibleRect is a singleton object which defines the actual visible rect of the current view,
it should represent the same rect as cc.view.getViewportRect()

        */
        export class visibleRect  {
            /**
            * cc.visibleRect is a singleton object which defines the actual visible rect of the current view,
it should represent the same rect as cc.view.getViewportRect()
            */
            constructor();
            /**
            * - Bottom center coordinate of the screen related to the game scene
            */
            bottom: cc.Point;
            /**
            * - Bottom left coordinate of the screen related to the game scene
            */
            bottomLeft: cc.Point;
            /**
            * - Bottom right coordinate of the screen related to the game scene
            */
            bottomRight: cc.Point;
            /**
            * - Center coordinate of the screen related to the game scene
            */
            center: cc.Point;
            /**
            * - Height of the screen
            */
            height: number;
            /**
            * - Left center coordinate of the screen related to the game scene
            */
            left: cc.Point;
            /**
            * - Right center coordinate of the screen related to the game scene
            */
            right: cc.Point;
            /**
            * - Top center coordinate of the screen related to the game scene
            */
            top: cc.Point;
            /**
            * - Top left coordinate of the screen related to the game scene
            */
            topLeft: cc.Point;
            /**
            * - Top right coordinate of the screen related to the game scene
            */
            topRight: cc.Point;
            /**
            * - Width of the screen
            */
            width: number;
            /**
            * &amp;lt;static&amp;gt;
cc.visibleRect.init(visibleRect)
initialize
Parameters:
{cc.Rect} visibleRect

            */
            static init(visibleRect?: cc.Rect);
        }
    }
declare module cc {
        /**
        * 
cc.Waves action.
Reference the test cases (Effects Test)

        */
        export class Waves extends cc.Grid3DAction {
            /**
            * cc.Waves action.
            */
            constructor(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number, horizontal?: boolean, vertical?: boolean);
            /**
            * Please use cc.waves instead
initializes the action with amplitude, horizontal sin, vertical sin, a grid and duration
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.Waves;
            /**
            * ctor(duration, gridSize, waves, amplitude, horizontal, vertical)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a wave action with amplitude, horizontal sin, vertical sin, a grid and duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} waves
{Number} amplitude
{Boolean} horizontal
{Boolean} vertical

            */
            ctor(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number, horizontal?: boolean, vertical?: boolean);
            /**
            * {Number}
getAmplitude()
get amplitude
Returns:
{Number}

            */
            getAmplitude(): number;
            /**
            * {Number}
getAmplitudeRate()
get amplitude rate
Returns:
{Number}

            */
            getAmplitudeRate(): number;
            /**
            * {Boolean}
initWithDuration(duration, gridSize, waves, amplitude, horizontal, vertical)
initializes the action with amplitude, horizontal sin, vertical sin, a grid and duration
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} waves
{Number} amplitude
{Boolean} horizontal
{Boolean} vertical
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number, horizontal?: boolean, vertical?: boolean): boolean;
            /**
            * setAmplitude(amplitude)
set amplitude
Parameters:
{Number} amplitude

            */
            setAmplitude(amplitude?: number);
            /**
            * setAmplitudeRate(amplitudeRate)
set amplitude rate
Parameters:
{Number} amplitudeRate

            */
            setAmplitudeRate(amplitudeRate?: number);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.Waves3D action.
Reference the test cases (Effects Advanced Test)

        */
        export class Waves3D extends cc.Grid3DAction {
            /**
            * cc.Waves3D action.
            */
            constructor(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number);
            /**
            * Please use cc.waves3D instead.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): Waves3D;
            /**
            * ctor(duration, gridSize, waves, amplitude)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Create a wave 3d action with duration, grid size, waves and amplitude.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} waves
{Number} amplitude

            */
            ctor(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number);
            /**
            * {Number}
getAmplitude()
get Amplitude
Returns:
{Number}

            */
            getAmplitude(): number;
            /**
            * {Number}
getAmplitudeRate()
get Amplitude Rate
Returns:
{Number}

            */
            getAmplitudeRate(): number;
            /**
            * {Boolean}
initWithDuration(duration, gridSize, waves, amplitude)
initializes an action with duration, grid size, waves and amplitude
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} waves
{Number} amplitude
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number): boolean;
            /**
            * setAmplitude(amplitude)
set Amplitude
Parameters:
{Number} amplitude

            */
            setAmplitude(amplitude?: number);
            /**
            * setAmplitudeRate(amplitudeRate)
set Amplitude Rate
Parameters:
{Number} amplitudeRate

            */
            setAmplitudeRate(amplitudeRate?: number);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module cc {
        /**
        * 
cc.WavesTiles3D action.
Reference the test cases (Effects Test)

        */
        export class WavesTiles3D extends cc.TiledGrid3DAction {
            /**
            * cc.WavesTiles3D action.
            */
            constructor(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number);
            /**
            * Please use cc.wavesTiles3D instead
creates the action with a number of waves, the waves amplitude, the grid size and the duration.
            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any):cc.WavesTiles3D;
            /**
            * ctor(duration, gridSize, waves, amplitude)
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
creates the action with a number of waves, the waves amplitude, the grid size and the duration.
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} waves
{Number} amplitude

            */
            ctor(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number);
            /**
            * {Number}
getAmplitude()
get amplitude of waves
Returns:
{Number}

            */
            getAmplitude(): number;
            /**
            * {Number}
getAmplitudeRate()
get amplitude rate of waves
Returns:
{Number}

            */
            getAmplitudeRate(): number;
            /**
            * {Boolean}
initWithDuration(duration, gridSize, waves, amplitude)
initializes the action with a number of waves, the waves amplitude, the grid size and the duration
Parameters:
{Number} duration
{cc.Size} gridSize
{Number} waves
{Number} amplitude
Returns:
{Boolean}

            */
            initWithDuration(duration?: number, gridSize?: cc.Size, waves?: number, amplitude?: number): boolean;
            /**
            * setAmplitude(amplitude)
set amplitude of waves
Parameters:
{Number} amplitude

            */
            setAmplitude(amplitude?: number);
            /**
            * setAmplitudeRate(amplitudeRate)
set amplitude rate of waves
Parameters:
{Number} amplitudeRate

            */
            setAmplitudeRate(amplitudeRate?: number);
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module ccs {
        /**
        * 
The Cocostudio&#39;s fade action frame.

        */
        export class ActionFadeFrame extends ccs.ActionFrame {
            /**
            * The Cocostudio&#39;s fade action frame.
            */
            constructor();
            /**
            * ctor()
Construction of ccs.ActionFadeFrame

            */
            ctor();
            /**
            * {cc.FadeTo}
getAction(duration)
Returns a fade action with easing.
Parameters:
{Number} duration
Returns:
{cc.FadeTo}

            */
            getAction(duration?: number): cc.FadeTo;
            /**
            * {number}
getOpacity()
Returns the fade action opacity.
Returns:
{number}

            */
            getOpacity(): number;
            /**
            * setOpacity(opacity)
Changes the fade action opacity.
Parameters:
{number} opacity

            */
            setOpacity(opacity?: number);
        }
    }
declare module ccs {
        /**
        * 
The action frame of Cocostudio. It&#39;s the base class of ccs.ActionMoveFrame, ccs.ActionScaleFrame etc.

        */
        export class ActionFrame extends ccs.Class {
            /**
            * The action frame of Cocostudio.
            */
            constructor();
            /**
            * - easing type of ccs.ActionFrame
            */
            easingType: number;
            /**
            * - frame index of ccs.ActionFrame
            */
            frameIndex: number;
            /**
            * - frame type of ccs.ActionFrame
            */
            frameType: number;
            /**
            * - time of ccs.ActionFrame
            */
            time: number;
            /**
            * ctor()
The constructor of cc.ActionFrame.

            */
            ctor();
            /**
            * {null}
getAction(duration, srcFrame)
Returns the action of ActionFrame. its subClass need override it.
Parameters:
{number} duration
the duration time of ActionFrame
{ccs.ActionFrame} srcFrame
source frame.
Returns:
{null}

            */
            getAction(duration?: number, srcFrame?: ccs.ActionFrame): void;
            /**
            * setEasingParameter(parameter)
Sets the easing parameter to action frame.
Parameters:
{Array} parameter

            */
            setEasingParameter(parameter?: Array<any>);
            /**
            * setEasingType(easingType)
Sets the easing type to ccs.ActionFrame
Parameters:
{Number} easingType

            */
            setEasingType(easingType?: number);
        }
    }
declare module ccs {
        /**
        * 
Base singleton object for ccs.ActionManager.

        */
        export class actionManager  {
            /**
            * Base singleton object for ccs.ActionManager.
            */
            constructor();
            /**
            * clear()
Clear data: Release all actions.

            */
            clear();
            /**
            * {ccs.ActionObject}
getActionByName(jsonName, actionName)
Gets an actionObject with a name.
Parameters:
{String} jsonName
{String} actionName
Returns:
{ccs.ActionObject}

            */
            getActionByName(jsonName?: string, actionName?: string): ccs.ActionObject;
            /**
            * initWithDictionary(jsonName, dic, root)
Init properties with json dictionary
Parameters:
{String} jsonName
{Object} dic
{Object} root

            */
            initWithDictionary(jsonName?: string, dic?: Object, root?: Object);
            /**
            * playActionByName(jsonName, actionName, fun)
Play an Action with a name.
Parameters:
{String} jsonName
{String} actionName
{cc.CallFunc} fun

            */
            playActionByName(jsonName?: string, actionName?: string, fun?: cc.CallFunc);
            /**
            * releaseActions()
Release all actions.

            */
            releaseActions();
            /**
            * stopActionByName(jsonName, actionName)
Stop an Action with a name.
Parameters:
{String} jsonName
{String} actionName

            */
            stopActionByName(jsonName?: string, actionName?: string);
        }
    }
declare module ccs {
        /**
        * 
The Cocostudio&#39;s move action frame.

        */
        export class ActionMoveFrame extends ccs.ActionFrame {
            /**
            * The Cocostudio&#39;s move action frame.
            */
            constructor();
            /**
            * ctor()
Construction of ccs.ActionMoveFrame

            */
            ctor();
            /**
            * {cc.MoveTo}
getAction(duration)
Returns the CCAction of ActionFrame.
Parameters:
{number} duration
Returns:
{cc.MoveTo}

            */
            getAction(duration?: number): cc.MoveTo;
            /**
            * {cc.Point}
getPosition()
Returns the move action position.
Returns:
{cc.Point}

            */
            getPosition(): cc.Point;
            /**
            * setPosition(pos, y)
Changes the move action position.
Parameters:
{cc.Point|Number} pos
{Number} y

            */
            setPosition(pos?: any, y?: number);
        }
    }
declare module ccs {
        /**
        * 
The Cocostudio&#39;s action node, it contains action target, action frame list and current frame index.  it can be play action by calling playAciton.

        */
        export class ActionNode extends ccs.Class {
            /**
            * The Cocostudio&#39;s action node, it contains action target, action frame list and current frame index.
            */
            constructor();
            /**
            * addFrame(frame)
Pushes back an ActionFrame to ccs.ActionNode.
Parameters:
{ccs.ActionFrame} frame

            */
            addFrame(frame?: ccs.ActionFrame);
            /**
            * clearAllFrame()
Removes all ActionFrames from ccs.ActionNode.

            */
            clearAllFrame();
            /**
            * ctor()
Construction of ccs.ActionNode

            */
            ctor();
            /**
            * deleteFrame(frame)
Removes an ActionFrame from ccs.ActionNode.
Parameters:
{ccs.ActionFrame} frame

            */
            deleteFrame(frame?: ccs.ActionFrame);
            /**
            * {cc.Node}
getActionNode()
Returns the target node of ccs.ActionNode
Returns:
{cc.Node}

            */
            getActionNode(): cc.Node;
            /**
            * {number}
getActionTag()
Returns the tag of ccs.ActionNode
Returns:
{number}

            */
            getActionTag(): number;
            /**
            * {number}
getFirstFrameIndex()
Returns index of first ActionFrame.
Returns:
{number}

            */
            getFirstFrameIndex(): number;
            /**
            * {number}
getLastFrameIndex()
Returns the index of last ccs.ActionFrame.
Returns:
{number}

            */
            getLastFrameIndex(): number;
            /**
            * {*}
getObject()
Returns node which will run a action.
Returns:
{*}

            */
            getObject(): any;
            /**
            * {number}
getUnitTime()
Returns the time interval of frame.
Returns:
{number}

            */
            getUnitTime(): number;
            /**
            * initWithDictionary(dic, root)
Init properties with a json dictionary
Parameters:
{Object} dic
{Object} root

            */
            initWithDictionary(dic?: Object, root?: Object);
            /**
            * insertFrame(index, frame)
Inserts an ActionFrame to ccs.ActionNode.
Parameters:
{number} index
{ccs.ActionFrame} frame

            */
            insertFrame(index?: number, frame?: ccs.ActionFrame);
            /**
            * {Boolean}
isActionDoneOnce()
Returns if the action is done once time.
Returns:
{Boolean} that if the action is done once time

            */
            isActionDoneOnce(): boolean;
            /**
            * playAction(fun)
Plays ccs.ActionNode&#39;s action.
Parameters:
{cc.CallFunc} fun

            */
            playAction(fun?: cc.CallFunc);
            /**
            * setActionTag(tag)
Sets tag to ccs.ActionNode
Parameters:
{Number} tag

            */
            setActionTag(tag?: number);
            /**
            * setObject(node)
Sets node which will run a action.
Parameters:
{Object} node

            */
            setObject(node?: Object);
            /**
            * setUnitTime(time)
Sets the time interval of frame.
Parameters:
{number} time

            */
            setUnitTime(time?: number);
            /**
            * stopAction()
Stops action.

            */
            stopAction();
            /**
            * {boolean}
updateActionToTimeLine(time)
Updates action states to some time.
Parameters:
{Number} time
Returns:
{boolean}

            */
            updateActionToTimeLine(time?: number): boolean;
        }
    }
declare module ccs {
        /**
        * 
The Cocostudio&#39;s action object.

        */
        export class ActionObject extends ccs.Class {
            /**
            * The Cocostudio&#39;s action object.
            */
            constructor();
            /**
            * addActionNode(node)
Adds a ActionNode to play the action.
Parameters:
{ccs.ActionNode} node

            */
            addActionNode(node?: ccs.ActionNode);
            /**
            * ctor()
Construction of ccs.ActionObject.

            */
            ctor();
            /**
            * {number}
getCurrentTime()
Returns the current time of frame.
Returns:
{number}

            */
            getCurrentTime(): number;
            /**
            * {boolean}
getLoop()
Returns if the action will loop play.
Returns:
{boolean}

            */
            getLoop(): boolean;
            /**
            * {string}
getName()
Returns name fo ccs.ActionObject
Returns:
{string}

            */
            getName(): string;
            /**
            * {number}
getTotalTime()
Returns the total time of frame.
Returns:
{number} the total time of frame

            */
            getTotalTime(): number;
            /**
            * {number}
getUnitTime()
Returns the time interval of frame.
Returns:
{number} the time interval of frame

            */
            getUnitTime(): number;
            /**
            * initWithDictionary(dic, root)
Init properties with a json dictionary
Parameters:
{Object} dic
{Object} root

            */
            initWithDictionary(dic?: Object, root?: Object);
            /**
            * {boolean}
isPlaying()
Returns if the action is playing.
Returns:
{boolean} true if the action is playing, false the otherwise

            */
            isPlaying(): boolean;
            /**
            * pause()
Pauses the action.

            */
            pause();
            /**
            * play(fun)
Plays the action.
Parameters:
{cc.CallFunc} fun
Optional
Action Call Back

            */
            play(fun?: cc.CallFunc);
            /**
            * removeActionNode(node)
Removes a ActionNode which play the action.
Parameters:
{ccs.ActionNode} node

            */
            removeActionNode(node?: ccs.ActionNode);
            /**
            * setCurrentTime(time)
Sets the current time of frame.
Parameters:
{Number} time
the current time of frame

            */
            setCurrentTime(time?: number);
            /**
            * setLoop(loop)
Sets if the action will loop play.
Parameters:
{boolean} loop

            */
            setLoop(loop?: boolean);
            /**
            * setName(name)
Sets name to ccs.ActionObject
Parameters:
{string} name

            */
            setName(name?: string);
            /**
            * setUnitTime(time)
Sets the time interval of frame.
Parameters:
{number} time

            */
            setUnitTime(time?: number);
            /**
            * simulationActionUpdate(dt)
scheduler update function
Parameters:
{Number} dt
delta time

            */
            simulationActionUpdate(dt?: number);
            /**
            * stop()
Stop the action.

            */
            stop();
            /**
            * updateToFrameByTime(time)
Updates frame by time.
Parameters:
time

            */
            updateToFrameByTime();
        }
    }
declare module ccs {
        /**
        * 
The Cocostudio&#39;s rotation action frame.

        */
        export class ActionRotationFrame extends ccs.ActionFrame {
            /**
            * The Cocostudio&#39;s rotation action frame.
            */
            constructor();
            /**
            * ctor()
Construction of ccs.ActionRotationFrame

            */
            ctor();
            /**
            * {cc.RotateTo}
getAction(duration, srcFrame)
Returns the CCAction of ActionFrame.
Parameters:
{number} duration
{cc.ActionFrame} srcFrame
Optional
Returns:
{cc.RotateTo}

            */
            getAction(duration?: number, srcFrame?: cc.ActionFrame): cc.RotateTo;
            /**
            * {number}
getRotation()
Returns the rotate action rotation.
Returns:
{number}

            */
            getRotation(): number;
            /**
            * setRotation(rotation)
Changes rotate action rotation.
Parameters:
{number} rotation

            */
            setRotation(rotation?: number);
        }
    }
declare module ccs {
        /**
        * 
The Cocostudio&#39;s scale action frame

        */
        export class ActionScaleFrame extends ccs.ActionFrame {
            /**
            * The Cocostudio&#39;s scale action frame
            */
            constructor();
            /**
            * ctor()
Construction of ccs.ActionScaleFrame

            */
            ctor();
            /**
            * {cc.ScaleTo}
getAction(duration)
Returns the action of ActionFrame.
Parameters:
{number} duration
Returns:
{cc.ScaleTo}

            */
            getAction(duration?: number): cc.ScaleTo;
            /**
            * {number}
getScaleX()
Returns the scale action scaleX.
Returns:
{number}

            */
            getScaleX(): number;
            /**
            * {number}
getScaleY()
Returns the scale action scaleY.
Returns:
{number}

            */
            getScaleY(): number;
            /**
            * setScaleX(scaleX)
Changes the scale action scaleX.
Parameters:
{number} scaleX

            */
            setScaleX(scaleX?: number);
            /**
            * setScaleY(scaleY)
Changes the scale action scaleY.
Parameters:
{number} scaleY

            */
            setScaleY(scaleY?: number);
        }
    }
declare module ccs {
        /**
        * 
The Cocostudio&#39;s tint action frame.

        */
        export class ActionTintFrame extends ccs.ActionFrame {
            /**
            * The Cocostudio&#39;s tint action frame.
            */
            constructor();
            /**
            * ctor()
Construction of ccs.ActionTintFrame

            */
            ctor();
            /**
            * {cc.TintTo}
getAction(duration)
Returns a tint action with easing.
Parameters:
duration
Returns:
{cc.TintTo}

            */
            getAction(): cc.TintTo;
            /**
            * {cc.Color}
getColor()
Returns the color of tint action.
Returns:
{cc.Color}

            */
            getColor(): cc.Color;
            /**
            * setColor(color)
Changes the tint action color.
Parameters:
{cc.Color} color

            */
            setColor(color?: cc.Color);
        }
    }
declare module ccs {
        /**
        * The animation data information of Cocos Armature. It include all movement information for the Armature.
The struct is AnimationData -&gt; MovementData -&gt; MovementBoneData -&gt; FrameData
-&gt; MovementFrameData

        */
        export class AnimationData extends ccs.Class {
            /**
            * 
The animation data information of Cocos Armature.
            */
            constructor();
            /**
            * addMovement(moveData)
adds movement data to the movement data dictionary
Parameters:
{ccs.MovementData} moveData

            */
            addMovement(moveData?: ccs.MovementData);
            /**
            * {ccs.MovementData}
getMovement(moveName)
gets movement data from movement data dictionary
Parameters:
{String} moveName
Returns:
{ccs.MovementData}

            */
            getMovement(moveName?: string): ccs.MovementData;
            /**
            * {Number}
getMovementCount()
gets the count of movement data dictionary
Returns:
{Number}

            */
            getMovementCount(): number;
        }
    }
declare module ccs {
        /**
        * 
The animation event class, it has the callback, target and arguments.

        */
        export class AnimationEvent extends ccs.Class {
            /**
            * The animation event class, it has the callback, target and arguments.
            */
            constructor();
            /**
            * ctor(callFunc, target, data)
Constructor of ccs.AnimationEvent
Parameters:
{function} callFunc
{object} target
{object} data
Optional

            */
            ctor(callFunc?: any, target?: any, data?: any);
        }
    }
declare module ccs {
        /**
        * 
The main class of Armature, it plays armature animation, manages and updates bones&#39; state.

        */
        export class Armature extends ccs.Node {
            /**
            * The main class of Armature, it plays armature animation, manages and updates bones&#39; state.
            */
            constructor();
            /**
            * - The animation
            */
            animation: ccs.ArmatureAnimation;
            /**
            * - The armature data
            */
            armatureData: ccs.ArmatureData;
            /**
            * - The batch node of the armature
            */
            batchNode: cc.SpriteBatchNode;
            /**
            * - The body of the armature
            */
            body: Object;
            /**
            * -  The collider filter of the armature
            */
            colliderFilter: ccs.ColliderFilter;
            /**
            * - The name of the armature
            */
            name: string;
            /**
            * - The parent bone of the armature node
            */
            parentBone: ccs.Bone;
            /**
            * - The version
            */
            version: number;
            /**
            * addBone(bone, parentName)
Add a Bone to this Armature
Parameters:
{ccs.Bone} bone
The Bone you want to add to Armature
{String} parentName
The parent Bone&#39;s name you want to add to. If it&#39;s  null, then set Armature to its parent

            */
            addBone(bone?: ccs.Bone, parentName?: string);
            /**
            * changeBoneParent(bone, parentName)
Change a bone&#39;s parent with the specified parent name.
Parameters:
{ccs.Bone} bone
The bone you want to change parent
{String} parentName
The new parent&#39;s name

            */
            changeBoneParent(bone?: ccs.Bone, parentName?: string);
            /**
            * &amp;lt;static&amp;gt;
{ccs.Armature}
ccs.Armature.create(name, parentBone)
Allocates an armature, and use the ArmatureData named name in ArmatureDataManager to initializes the armature.
Parameters:
{String} name
Optional
Bone name
{ccs.Bone} parentBone
Optional
the parent bone
Deprecated:
since v3.1, please use new construction instead
Returns:
{ccs.Armature}

            */
            static create(name?: string, parentBone?: ccs.Bone): ccs.Armature;
            /**
            * {ccs.Bone}
createBone(boneName)
create a bone with name
Parameters:
{String} boneName
Returns:
{ccs.Bone}

            */
            createBone(boneName?: string): ccs.Bone;
            /**
            * ctor(name, parentBone)
Create a armature node.
Constructor of ccs.Armature
var armature = new ccs.Armature();
Parameters:
{String} name
{ccs.Bone} parentBone

            */
            ctor(name?: string, parentBone?: ccs.Bone);
            /**
            * drawContour()
draw contour

            */
            drawContour();
            /**
            * {ccs.ArmatureAnimation}
getAnimation()
Gets the animation of this Armature.
Returns:
{ccs.ArmatureAnimation}

            */
            getAnimation(): ccs.ArmatureAnimation;
            /**
            * {ccs.ArmatureData}
getArmatureData()
Returns the armatureData of ccs.Armature
Returns:
{ccs.ArmatureData}

            */
            getArmatureData(): ccs.ArmatureData;
            /**
            * {Boolean}
getArmatureTransformDirty()
armatureTransformDirty getter
Returns:
{Boolean}

            */
            getArmatureTransformDirty(): boolean;
            /**
            * {cc.BlendFunc}
getBlendFunc()
Returns the blendFunc of ccs.Armature
Returns:
{cc.BlendFunc}

            */
            getBlendFunc(): cc.BlendFunc;
            /**
            * {ccs.Bone}
getBone(name)
Gets a bone with the specified name
Parameters:
{String} name
The bone&#39;s name you want to get
Returns:
{ccs.Bone}

            */
            getBone(name?: string): ccs.Bone;
            /**
            * {ccs.Bone}
getBoneAtPoint(x, y)
when bone  contain the point ,then return it.
Parameters:
{Number} x
{Number} y
Returns:
{ccs.Bone}

            */
            getBoneAtPoint(x?: number, y?: number): ccs.Bone;
            /**
            * {Object}
getBoneDic()
Get CCArmature&#39;s bone dictionary
Returns:
{Object} Armature&#39;s bone dictionary

            */
            getBoneDic(): Object;
            /**
            * {cc.Rect}
getBoundingBox()
This boundingBox will calculate all bones&#39; boundingBox every time
Returns:
{cc.Rect}

            */
            getBoundingBox(): cc.Rect;
            /**
            * {ccs.Bone}
getParentBone()
Return parent bone of ccs.Armature.
Returns:
{ccs.Bone}

            */
            getParentBone(): ccs.Bone;
            /**
            * {Number}
getVersion()
version getter
Returns:
{Number}

            */
            getVersion(): number;
            /**
            * {Boolean}
init(name, parentBone)
Initializes a CCArmature with the specified name and CCBone
Parameters:
{String} name
Optional
{ccs.Bone} parentBone
Optional
Returns:
{Boolean}

            */
            init(name?: string, parentBone?: ccs.Bone): boolean;
            /**
            * onEnter()
The callback when ccs.Armature enter stage.

            */
            onEnter();
            /**
            * onExit()
The callback when ccs.Armature exit stage.

            */
            onExit();
            /**
            * removeBone(bone, recursion)
Remove a bone with the specified name. If recursion it will also remove child Bone recursively.
Parameters:
{ccs.Bone} bone
The bone you want to remove
{Boolean} recursion
Determine whether remove the bone&#39;s child  recursion.

            */
            removeBone(bone?: ccs.Bone, recursion?: boolean);
            /**
            * setAnimation(animation)
Sets animation to this Armature
Parameters:
{ccs.ArmatureAnimation} animation

            */
            setAnimation(animation?: ccs.ArmatureAnimation);
            /**
            * setArmatureData(armatureData)
Sets armatureData to this Armature
Parameters:
{ccs.ArmatureData} armatureData

            */
            setArmatureData(armatureData?: ccs.ArmatureData);
            /**
            * setBlendFunc(blendFunc, dst)
Sets the blendFunc to ccs.Armature
Parameters:
{cc.BlendFunc|Number} blendFunc
{Number} dst
Optional

            */
            setBlendFunc(blendFunc?: any, dst?: number);
            /**
            * setColliderFilter(filter)
set collider filter
Parameters:
{ccs.ColliderFilter} filter

            */
            setColliderFilter(filter?: ccs.ColliderFilter);
            /**
            * setParentBone(parentBone)
Sets parent bone of this Armature
Parameters:
{ccs.Bone} parentBone

            */
            setParentBone(parentBone?: ccs.Bone);
            /**
            * setVersion(version)
version setter
Parameters:
{Number} version

            */
            setVersion(version?: number);
            /**
            * update(dt)
The update callback of ccs.Armature, it updates animation&#39;s state and updates bone&#39;s state.
Parameters:
{Number} dt

            */
            update(dt?: number);
            /**
            * updateOffsetPoint()
Set contentSize and Calculate anchor point.

            */
            updateOffsetPoint();
        }
    }
declare module ccs {
        /**
        * 
The Animation class for Armature, it plays armature animation, and controls speed scale and manages animation frame.

        */
        export class ArmatureAnimation extends ccs.ProcessBase {
            /**
            * The Animation class for Armature, it plays armature animation, and controls speed scale and manages animation frame.
            */
            constructor(armature?: ccs.Armature);
            /**
            * - Animation data
            */
            animationData: ccs.AnimationData;
            /**
            * - Animation play speed scale
            */
            animationScale: number;
            /**
            * - Indicate whether the frame event is ignored
            */
            ignoreFrameEvent: boolean;
            /**
            * - Animation play speed scale
            */
            speedScale: number;
            /**
            * - User custom object
            */
            userObject: Object;
            /**
            * &amp;lt;static&amp;gt;
{ccs.ArmatureAnimation}
ccs.ArmatureAnimation.create(armature)
Allocates and initializes a ArmatureAnimation.
Parameters:
armature
Deprecated:
since v3.1, please use new construction instead
Returns:
{ccs.ArmatureAnimation}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccs.ArmatureAnimation;
            /**
            * frameEvent(bone, frameEventName, originFrameIndex, currentFrameIndex)
Emits a frame event
Parameters:
{ccs.Bone} bone
{String} frameEventName
{Number} originFrameIndex
{Number} currentFrameIndex

            */
            frameEvent(bone?: ccs.Bone, frameEventName?: string, originFrameIndex?: number, currentFrameIndex?: number);
            /**
            * {ccs.AnimationData}
getAnimationData()
Returns animation data of animation.
Returns:
{ccs.AnimationData}

            */
            getAnimationData(): ccs.AnimationData;
            /**
            * {Number}
getAnimationScale()
Returns animation play speed scale.
Deprecated:
since v3.0, please use getSpeedScale instead.
Returns:
{Number}

            */
            getAnimationScale(): number;
            /**
            * {String}
getCurrentMovementID()
Returns the Id of current movement
Returns:
{String}

            */
            getCurrentMovementID(): string;
            /**
            * {Number}
getMovementCount()
Returns the length of armature&#39;s movements
Returns:
{Number}

            */
            getMovementCount(): number;
            /**
            * {Number}
getSpeedScale()
Returns animation play speed scale.
Returns:
{Number}

            */
            getSpeedScale(): number;
            /**
            * {Object}
getUserObject()
Returns the user object of animation.
Returns:
{Object}

            */
            getUserObject(): Object;
            /**
            * gotoAndPause(frameIndex)
Goes to specified frame and pauses current movement.
Parameters:
{Number} frameIndex

            */
            gotoAndPause(frameIndex?: number);
            /**
            * gotoAndPlay(frameIndex)
Goes to specified frame and plays current movement.
You need first switch to the movement you want to play, then call this function.
example : playByIndex(0);
gotoAndPlay(0);
playByIndex(1);
gotoAndPlay(0);
gotoAndPlay(15);
Parameters:
{Number} frameIndex

            */
            gotoAndPlay(frameIndex?: number);
            /**
            * {Boolean}
init(armature)
Initializes with an armature object
Parameters:
{ccs.Armature} armature
Returns:
{Boolean}

            */
            init(armature?: ccs.Armature): boolean;
            /**
            * {boolean}
isIgnoreFrameEvent()
Determines if the frame event is ignored
Returns:
{boolean}

            */
            isIgnoreFrameEvent(): boolean;
            /**
            * movementEvent(armature, movementType, movementID)
Emits a movement event
Parameters:
{ccs.Armature} armature
{Number} movementType
{String} movementID

            */
            movementEvent(armature?: ccs.Armature, movementType?: number, movementID?: string);
            /**
            * pause()
Pauses armature animation.

            */
            pause();
            /**
            * play(animationName, durationTo, loop)
play animation by animation name.
// example
armature.getAnimation().play(&quot;run&quot;,-1,1);//loop play
armature.getAnimation().play(&quot;run&quot;,-1,0);//not loop play
Parameters:
{String} animationName
The animation name you want to play
{Number} durationTo
Optional, Default: -1
he frames between two animation changing-over.It&#39;s meaning is changing to this animation need how many frames
-1 : use the value from CCMovementData get from flash design panel
{Number} loop
Optional, Default: -1
Whether the animation is loop.
loop  0 : this animation is loop

            */
            play(animationName?: string, durationTo?: number, loop?: number);
            /**
            * playByIndex(animationIndex, durationTo, durationTween, loop, tweenEasing)
Plays animation with index, the other param is the same to play.
Parameters:
{Number} animationIndex
{Number} durationTo
{Number} durationTween
{Number} loop
{Number} tweenEasing
Optional
Deprecated:
since v3.0, please use playWithIndex instead.

            */
            playByIndex(animationIndex?: number, durationTo?: number, durationTween?: number, loop?: number, tweenEasing?: number);
            /**
            * playWithIndex(animationIndex, durationTo, loop)
Plays animation with index, the other param is the same to play.
Parameters:
{Number|Array} animationIndex
{Number} durationTo
{Number} loop

            */
            playWithIndex(animationIndex?: any, durationTo?: number, loop?: number);
            /**
            * playWithIndexes(movementIndexes, durationTo, loop)
Plays animation by indexes
Parameters:
{Array} movementIndexes
{Number} durationTo
{Boolean} loop

            */
            playWithIndexes(movementIndexes?: Array<any>, durationTo?: number, loop?: boolean);
            /**
            * playWithNames(movementNames, durationTo, loop)
Plays animation with names
Parameters:
{Array} movementNames
{Number} durationTo
{Boolean} loop

            */
            playWithNames(movementNames?: Array<any>, durationTo?: number, loop?: boolean);
            /**
            * resume()
Resumes armature animation.

            */
            resume();
            /**
            * setAnimationData(data)
Sets animation data to animation.
Parameters:
{ccs.AnimationData} data

            */
            setAnimationData(data?: ccs.AnimationData);
            /**
            * setAnimationScale(animationScale)
Sets animation play speed scale.
Parameters:
{Number} animationScale
Deprecated:
since v3.0, please use setSpeedScale instead.

            */
            setAnimationScale(animationScale?: number);
            /**
            * setFrameEventCallFunc(callFunc, target)
Sets frame event callback to animation.
Parameters:
{function} callFunc
{Object} target

            */
            setFrameEventCallFunc(callFunc?: any, target?: Object);
            /**
            * setMovementEventCallFunc(callFunc, target)
Sets movement event callback to animation.
Parameters:
{function} callFunc
{Object} target

            */
            setMovementEventCallFunc(callFunc?: any, target?: Object);
            /**
            * setSpeedScale(speedScale)
Sets animation play speed scale.
Parameters:
{Number} speedScale

            */
            setSpeedScale(speedScale?: number);
            /**
            * setUserObject(userObject)
Sets user object to animation.
Parameters:
{Object} userObject

            */
            setUserObject(userObject?: Object);
            /**
            * stop()
Stops armature animation.

            */
            stop();
            /**
            * update(dt)
Updates the state of ccs.Tween list, calls frame event&#39;s callback and calls movement event&#39;s callback.
Parameters:
{Number} dt

            */
            update(dt?: number);
            /**
            * updateHandler()
Updates will call this handler, you can handle your logic here

            */
            updateHandler();
            /**
            * updateMovementList()
Updates movement list.

            */
            updateMovementList();
        }
    }
declare module ccs {
        /**
        * ArmatureData saved the Armature name and BoneData needed for the CCBones in this Armature
When we create a Armature, we need to get each Bone&#39;s BoneData as it&#39;s init information.
So we can get a BoneData from the Dictionary saved in the ArmatureData.

        */
        export class ArmatureData extends ccs.Class {
            /**
            * 
ArmatureData saved the Armature name and BoneData needed for the CCBones in this Armature
When we create a Armature, we need to get each Bone&#39;s BoneData as it&#39;s init information.
            */
            constructor();
            /**
            * - the bone data dictionary
            */
            boneDataDic: Object;
            /**
            * - the data version of armature data
            */
            dataVersion: number;
            /**
            * - the name of armature data
            */
            name: string;
            /**
            * addBoneData(boneData)
Adds bone data to dictionary
Parameters:
{ccs.BoneData} boneData

            */
            addBoneData(boneData?: ccs.BoneData);
            /**
            * ctor()
Construction of ccs.ArmatureData

            */
            ctor();
            /**
            * {ccs.BoneData}
getBoneData(boneName)
Gets bone data by bone name
Parameters:
{String} boneName
Returns:
{ccs.BoneData}

            */
            getBoneData(boneName?: string): ccs.BoneData;
            /**
            * {Object}
getBoneDataDic()
Gets bone data dictionary
Returns:
{Object}

            */
            getBoneDataDic(): Object;
            /**
            * {boolean}
init()
Initializes a ccs.ArmatureData
Returns:
{boolean}

            */
            init(): boolean;
        }
    }
declare module ccs {
        /**
        * 
ccs.armatureDataManager is a singleton object which format and manage armature configuration and armature animation

        */
        export class armatureDataManager  {
            /**
            * ccs.armatureDataManager is a singleton object which format and manage armature configuration and armature animation
            */
            constructor();
            /**
            * addAnimationData(id, animationData, configFilePath)
Adds animation data to armature data manager.
Parameters:
{String} id
{ccs.AnimationData} animationData
configFilePath

            */
            addAnimationData(id?: string, animationData?: ccs.AnimationData);
            /**
            * addArmatureData(id, armatureData, configFilePath)
Adds armature data
Parameters:
{string} id
The id of the armature data
{ccs.ArmatureData} armatureData
configFilePath

            */
            addArmatureData(id?: string, armatureData?: ccs.ArmatureData);
            /**
            * addArmatureFileInfo(imagePath, plistPath, configFilePath)
Adds ArmatureFileInfo, it is managed by CCArmatureDataManager.
//example1
ccs.armatureDataManager.addArmatureFileInfo(&quot;res/test.json&quot;);
//example2
ccs.armatureDataManager.addArmatureFileInfo(&quot;res/test.png&quot;,&quot;res/test.plist&quot;,&quot;res/test.json&quot;);
Parameters:
{String} imagePath
{String} plistPath
{String} configFilePath

            */
            addArmatureFileInfo(imagePath?: string, plistPath?: string, configFilePath?: string);
            /**
            * addArmatureFileInfoAsync(imagePath, plistPath, configFilePath, selector, target)
Adds ArmatureFileInfo, it is managed by CCArmatureDataManager.
Parameters:
{String} imagePath
{String} plistPath
{String} configFilePath
{Function} selector
{Object} target

            */
            addArmatureFileInfoAsync(imagePath?: string, plistPath?: string, configFilePath?: string, selector?: Function, target?: Object);
            /**
            * addRelativeData(configFilePath)
Adds Relative data of Armature data manager.
Parameters:
{String} configFilePath

            */
            addRelativeData(configFilePath?: string);
            /**
            * addSpriteFrameFromFile(plistPath, imagePath, configFilePath)
Add sprite frame to CCSpriteFrameCache, it will save display name and it&#39;s relative image name
Parameters:
{String} plistPath
{String} imagePath
{String} configFilePath

            */
            addSpriteFrameFromFile(plistPath?: string, imagePath?: string, configFilePath?: string);
            /**
            * addTextureData(id, textureData, configFilePath)
Adds texture data to Armature data manager.
Parameters:
{String} id
{ccs.TextureData} textureData
configFilePath

            */
            addTextureData(id?: string, textureData?: ccs.TextureData);
            /**
            * clear()
Clear data

            */
            clear();
            /**
            * {ccs.AnimationData}
getAnimationData(id)
Gets animationData by id
Parameters:
{String} id
Returns:
{ccs.AnimationData}

            */
            getAnimationData(id?: string): ccs.AnimationData;
            /**
            * {Object}
getAnimationDatas()
Returns animation data of Armature data manager.
Returns:
{Object}

            */
            getAnimationDatas(): Object;
            /**
            * {ccs.ArmatureData}
getArmatureData(id)
Gets armatureData by id
Parameters:
{String} id
Returns:
{ccs.ArmatureData}

            */
            getArmatureData(id?: string): ccs.ArmatureData;
            /**
            * {Object}
getArmatureDatas()
Returns armature Data of Armature data manager.
Returns:
{Object}

            */
            getArmatureDatas(): Object;
            /**
            * {ccs.RelativeData}
getRelativeData(configFilePath)
Gets RelativeData of Armature data manager.
Parameters:
{String} configFilePath
Returns:
{ccs.RelativeData}

            */
            getRelativeData(configFilePath?: string): ccs.RelativeData;
            /**
            * {ccs.TextureData}
getTextureData(id)
Gets textureData by id
Parameters:
{String} id
Returns:
{ccs.TextureData}

            */
            getTextureData(id?: string): ccs.TextureData;
            /**
            * {Object}
getTextureDatas()
Returns texture data of Armature data manager.
Returns:
{Object}

            */
            getTextureDatas(): Object;
            /**
            * {boolean}
isAutoLoadSpriteFile()
Returns whether or not need auto load sprite file
Returns:
{boolean}

            */
            isAutoLoadSpriteFile(): boolean;
            /**
            * removeAnimationData(id)
Removes animation data
Parameters:
{string} id

            */
            removeAnimationData(id?: string);
            /**
            * removeArmatureData(id)
Removes armature data from armature data manager.
Parameters:
{string} id

            */
            removeArmatureData(id?: string);
            /**
            * removeArmatureFileInfo(configFilePath)
Removes armature cache data by configFilePath
Parameters:
{String} configFilePath

            */
            removeArmatureFileInfo(configFilePath?: string);
            /**
            * removeTextureData(id)
Removes texture data by id
Parameters:
{string} id

            */
            removeTextureData(id?: string);
        }
    }
declare module ccs {
        /**
        * 
The armature display data class

        */
        export class ArmatureDisplayData extends ccs.DisplayData {
            /**
            * The armature display data class
            */
            constructor();
            /**
            * ctor()
Construction of ccs.ArmatureDisplayData

            */
            ctor();
        }
    }
declare module ccs {
        /**
        * The base data class for Armature. it contains position, zOrder, skew, scale, color datas.
x y skewX skewY scaleX scaleY used to calculate transform matrix
skewX, skewY can have rotation effect
To get more matrix information, you can have a look at this pape : http://www.senocular.com/flash/tutorials/transformmatrix/

        */
        export class BaseData extends ccs.Class {
            /**
            * 
The base data class for Armature.
            */
            constructor();
            /**
            * - a of color
            */
            a: number;
            /**
            * - b of color
            */
            b: number;
            /**
            * - g of color
            */
            g: number;
            /**
            * - is Use Color Info
            */
            isUseColorInfo: number;
            /**
            * - r of color
            */
            r: number;
            /**
            * - scaleX
            */
            scaleX: number;
            /**
            * - scaleY
            */
            scaleY: number;
            /**
            * - skewX
            */
            skewX: number;
            /**
            * - skewY
            */
            skewY: number;
            /**
            * - tween Rotate
            */
            tweenRotate: number;
            /**
            * - x
            */
            x: number;
            /**
            * - y
            */
            y: number;
            /**
            * - zOrder
            */
            zOrder: number;
            /**
            * copy(node)
Copy data from node
Parameters:
{ccs.BaseData} node

            */
            copy(node?: ccs.BaseData);
            /**
            * ctor()
Construction of ccs.BaseData

            */
            ctor();
            /**
            * {cc.Color}
getColor()
Returns the color of ccs.BaseData
Returns:
{cc.Color}

            */
            getColor(): cc.Color;
            /**
            * setColor(color)
Sets color to base data.
Parameters:
{cc.Color} color

            */
            setColor(color?: cc.Color);
            /**
            * subtract(from, to, limit)
Calculate two baseData&#39;s between value(to - from) and set to self
Parameters:
{ccs.BaseData} from
{ccs.BaseData} to
{Boolean} limit

            */
            subtract(from?: ccs.BaseData, to?: ccs.BaseData, limit?: boolean);
        }
    }
declare module ccs {
        /**
        * 
The Bone of Armature, it has bone data, display manager and transform data for armature.

        */
        export class Bone extends ccs.Node {
            /**
            * The Bone of Armature, it has bone data, display manager and transform data for armature.
            */
            constructor(name?: string);
            /**
            * - The armature
            */
            armature: ccs.Armature;
            /**
            * - Indicate whether the blend is dirty
            */
            blendDirty: boolean;
            /**
            * - The bone data
            */
            boneData: ccs.BoneData;
            /**
            * - The child armature
            */
            childArmature: ccs.Armature;
            /**
            * -  All children bones
            */
            childrenBone: Array<any>;
            /**
            * - The collider filter
            */
            colliderFilter: ccs.ColliderFilter;
            /**
            * - The displayManager
            */
            displayManager: ccs.DisplayManager;
            /**
            * - Indicate whether force the bone to show When CCArmature play a animation and there isn&#39;t a CCMovementBoneData of this bone in this CCMovementData.
            */
            ignoreMovementBoneData: boolean;
            /**
            * - The name of the bone
            */
            name: string;
            /**
            * - The parent bone
            */
            parentBone: ccs.Bone;
            /**
            * -  Tween
            */
            tween: ccs.Tween;
            /**
            * -  The tween data
            */
            tweenData: ccs.FrameData;
            /**
            * addChildBone(child)
Adds a child to this bone, and it will let this child call setParent(ccs.Bone) function to set self to it&#39;s parent
Parameters:
{ccs.Bone} child

            */
            addChildBone(child?: ccs.Bone);
            /**
            * addDisplay(displayData, index)
Add display and use  _displayData init the display.
If index already have a display, then replace it.
If index is current display index, then also change display to _index
Parameters:
{ccs.DisplayData} displayData
it include the display information, like DisplayType.
If you want to create a sprite display, then create a CCSpriteDisplayData param
{Number} index
the index of the display you want to replace or add to
-1 : append display from back

            */
            addDisplay(displayData?: ccs.DisplayData, index?: number);
            /**
            * changeDisplayByIndex(index, force)
Changes display by index
Parameters:
{Number} index
{Boolean} force
Deprecated:
since v3.0, please use changeDisplayWithIndex instead.

            */
            changeDisplayByIndex(index?: number, force?: boolean);
            /**
            * changeDisplayByName(name, force)
Changes display by name
Parameters:
{String} name
{Boolean} force
Deprecated:
since v3.0, please use changeDisplayWithName instead.

            */
            changeDisplayByName(name?: string, force?: boolean);
            /**
            * changeDisplayWithIndex(index, force)
Changes display with index
Parameters:
{Number} index
{Boolean} force

            */
            changeDisplayWithIndex(index?: number, force?: boolean);
            /**
            * changeDisplayWithName(name, force)
Changes display with name
Parameters:
{String} name
{Boolean} force

            */
            changeDisplayWithName(name?: string, force?: boolean);
            /**
            * &amp;lt;static&amp;gt;
{ccs.Bone}
ccs.Bone.create(name)
Allocates and initializes a bone.
Parameters:
name
Deprecated:
since v3.1, please use new construction instead
Returns:
{ccs.Bone}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccs.Bone;
            /**
            * {ccs.Armature}
getArmature()
Returns the armature reference of ccs.Bone.
Returns:
{ccs.Armature}

            */
            getArmature(): ccs.Armature;
            /**
            * {cc.BlendFunc}
getBlendFunc()
Returns the blendFunc of ccs.Bone.
Returns:
{cc.BlendFunc}

            */
            getBlendFunc(): cc.BlendFunc;
            /**
            * {ccs.BoneData}
getBoneData()
Returns boneData of ccs.Bone.
Returns:
{ccs.BoneData}

            */
            getBoneData(): ccs.BoneData;
            /**
            * {ccs.Armature}
getChildArmature()
Returns ccs.Bone&#39;s child armature.
Returns:
{ccs.Armature}

            */
            getChildArmature(): ccs.Armature;
            /**
            * {Array}
getChildrenBone()
Returns the children of ccs.Bone
Deprecated:
since v3.0, please use getChildren instead.
Returns:
{Array}

            */
            getChildrenBone(): Array<any>;
            /**
            * {Array|null}
getColliderBodyList()
Returns the collider body list in this bone.
Deprecated:
since v3.0, please use getColliderDetector to get a delector, and calls its getColliderBodyList instead.
Returns:
{Array|null}

            */
            getColliderBodyList(): any;
            /**
            * {*}
getColliderDetector()
Returns the collide detector of ccs.Bone.
Returns:
{*}

            */
            getColliderDetector(): any;
            /**
            * {cc.ColliderFilter}
getColliderFilter()
Returns collider filter of ccs.Bone.
Returns:
{cc.ColliderFilter}

            */
            getColliderFilter(): cc.ColliderFilter;
            /**
            * {ccs.DisplayManager}
getDisplayManager()
displayManager dirty getter
Returns:
{ccs.DisplayManager}

            */
            getDisplayManager(): ccs.DisplayManager;
            /**
            * {cc.Node}
getDisplayRenderNode()
Returns the display render node.
Returns:
{cc.Node}

            */
            getDisplayRenderNode(): cc.Node;
            /**
            * {Number}
getDisplayRenderNodeType()
Returns the type of display render node
Returns:
{Number}

            */
            getDisplayRenderNodeType(): number;
            /**
            * {Boolean}
getIgnoreMovementBoneData()
Returns whether is ignore movement bone data.
Deprecated:
since v3.0, please isIgnoreMovementBoneData instead.
Returns:
{Boolean}

            */
            getIgnoreMovementBoneData(): boolean;
            /**
            * {cc.AffineTransform}
getNodeToArmatureTransform()
Return the worldTransform of ccs.Bone.
Returns:
{cc.AffineTransform}

            */
            getNodeToArmatureTransform(): cc.AffineTransform;
            /**
            * {cc.AffineTransform}
getNodeToWorldTransform()
Returns the world transform of ccs.Bone.
Returns:
{cc.AffineTransform}

            */
            getNodeToWorldTransform(): cc.AffineTransform;
            /**
            * {ccs.Bone}
getParentBone()
Returns the parent bone of ccs.Bone.
Returns:
{ccs.Bone}

            */
            getParentBone(): ccs.Bone;
            /**
            * {ccs.Tween}
getTween()
Return the tween of ccs.Bone
Returns:
{ccs.Tween}

            */
            getTween(): ccs.Tween;
            /**
            * {ccs.FrameData}
getTweenData()
Returns the tweenData of ccs.Bone.
Returns:
{ccs.FrameData}

            */
            getTweenData(): ccs.FrameData;
            /**
            * {ccs.BaseData}
getWorldInfo()
Returns the world information of ccs.Bone.
Returns:
{ccs.BaseData}

            */
            getWorldInfo(): ccs.BaseData;
            /**
            * {Boolean}
init(name)
Initializes a ccs.Bone with the specified name
Parameters:
{String} name
bone name
Returns:
{Boolean}

            */
            init(name?: string): boolean;
            /**
            * {Boolean|*|ccs.Bone._blendDirty}
isBlendDirty()
Returns the blend dirty flag whether is dirty.
Returns:
{Boolean|*|ccs.Bone._blendDirty}

            */
            isBlendDirty(): any;
            /**
            * {Boolean}
isIgnoreMovementBoneData()
Returns whether is ignore movement bone data.
Returns:
{Boolean}

            */
            isIgnoreMovementBoneData(): boolean;
            /**
            * {Boolean}
isTransformDirty()
Returns ccs.Bone&#39;s transform dirty flag whether is dirty.
Returns:
{Boolean}

            */
            isTransformDirty(): boolean;
            /**
            * {cc.AffineTransform}
nodeToArmatureTransform()
Returns the worldTransform of ccs.Bone.
Deprecated:
since v3.0, please use getNodeToArmatureTransform instead.
Returns:
{cc.AffineTransform}

            */
            nodeToArmatureTransform(): cc.AffineTransform;
            /**
            * {cc.AffineTransform}
nodeToWorldTransform()
Deprecated:
Returns the world affine transform matrix. The matrix is in Pixels.
Returns:
{cc.AffineTransform}

            */
            nodeToWorldTransform(): cc.AffineTransform;
            /**
            * removeChildBone(bone, recursion)
Removes a child bone
Parameters:
{ccs.Bone} bone
{Boolean} recursion

            */
            removeChildBone(bone?: ccs.Bone, recursion?: boolean);
            /**
            * removeDisplay(index)
Removes display by index.
Parameters:
{Number} index
display renderer&#39;s index

            */
            removeDisplay(index?: number);
            /**
            * removeFromParent(recursion)
Removes itself from its parent ccs.Bone.
Parameters:
{Boolean} recursion

            */
            removeFromParent(recursion?: boolean);
            /**
            * setArmature(armature)
Sets the armature reference to ccs.Bone.
Parameters:
{ccs.Armature} armature

            */
            setArmature(armature?: ccs.Armature);
            /**
            * setBlendDirty(dirty)
Sets blend dirty flag
Parameters:
{Boolean} dirty

            */
            setBlendDirty(dirty?: boolean);
            /**
            * setBlendFunc(blendFunc, dst)
Sets BlendFunc to ccs.Bone.
Parameters:
{cc.BlendFunc|Number} blendFunc
blendFunc or src of blendFunc
{Number} dst
Optional
dst of blendFunc

            */
            setBlendFunc(blendFunc?: any, dst?: number);
            /**
            * setBoneData(boneData)
Sets the boneData to ccs.Bone.
Parameters:
{ccs.BoneData} boneData

            */
            setBoneData(boneData?: ccs.BoneData);
            /**
            * setChildArmature(armature)
Sets ccs.Bone&#39;s child armature
Parameters:
{ccs.Armature} armature

            */
            setChildArmature(armature?: ccs.Armature);
            /**
            * setColliderFilter(filter)
Sets collider filter to ccs.Bone.
Parameters:
{ccs.ColliderFilter} filter

            */
            setColliderFilter(filter?: ccs.ColliderFilter);
            /**
            * setIgnoreMovementBoneData(bool)
When CCArmature play a animation, if there is not a CCMovementBoneData of this bone in this CCMovementData, this bone will hide.
Set IgnoreMovementBoneData to true, then this bone will also show.
Parameters:
{Boolean} bool

            */
            setIgnoreMovementBoneData(bool?: boolean);
            /**
            * setLocalZOrder(zOrder)
Sets the local zOrder to ccs.Bone.
Parameters:
{Number} zOrder

            */
            setLocalZOrder(zOrder?: number);
            /**
            * setParentBone(parent)
Sets parent bone to ccs.Bone.
If _parent is NUll, then also remove this bone from armature.
It will not set the ccs.Armature, if you want to add the bone to a ccs.Armature, you should use ccs.Armature.addBone(bone, parentName).
Parameters:
{ccs.Bone} parent
the parent bone.

            */
            setParentBone(parent?: ccs.Bone);
            /**
            * setTransformDirty(dirty)
Sets ccs.Bone&#39;s transform dirty flag.
Parameters:
{Boolean} dirty

            */
            setTransformDirty(dirty?: boolean);
            /**
            * update(delta)
Updates worldTransform by tween data and updates display state
Parameters:
{Number} delta

            */
            update(delta?: number);
            /**
            * updateColor()
Updates display color

            */
            updateColor();
            /**
            * updateDisplayedColor(color)
Updates display color
Parameters:
{cc.Color} color

            */
            updateDisplayedColor(color?: cc.Color);
            /**
            * updateDisplayedOpacity(opacity)
Updates display opacity
Parameters:
{Number} opacity

            */
            updateDisplayedOpacity(opacity?: number);
            /**
            * updateZOrder()
Updates display zOrder

            */
            updateZOrder();
        }
    }
declare module ccs {
        /**
        * BoneData used to init a Bone.
BoneData keeps a DisplayData list, a Bone can have many display to change.
The display information saved in the DisplayData

        */
        export class BoneData extends ccs.BaseData {
            /**
            * 
BoneData used to init a Bone.
            */
            constructor();
            /**
            * - the bone transform data
            */
            boneDataTransform: cc.AffineTransform;
            /**
            * - the display data list
            */
            displayDataList: Array<any>;
            /**
            * - the name of Bone
            */
            name: string;
            /**
            * - the parent name of bone
            */
            parentName: string;
            /**
            * addDisplayData(displayData)
Adds display data to list
Parameters:
{ccs.DisplayData} displayData

            */
            addDisplayData(displayData?: ccs.DisplayData);
            /**
            * ctor()
Construction of ccs.BoneData

            */
            ctor();
            /**
            * {ccs.DisplayData}
getDisplayData(index)
Returns display data with index.
Parameters:
{Number} index
Returns:
{ccs.DisplayData}

            */
            getDisplayData(index?: number): ccs.DisplayData;
            /**
            * {boolean}
init()
Initializes a ccs.BoneData
Returns:
{boolean}

            */
            init(): boolean;
        }
    }
declare module ccs {
        /**
        * 
The same as cc.Class

        */
        export class Class  {
            /**
            * The same as cc.Class
            */
            constructor();
        }
    }
declare module ccs {
        /**
        * 
Base class for ccs.ColliderBody

        */
        export class ColliderBody extends ccs.Class {
            /**
            * Base class for ccs.ColliderBody
            */
            constructor();
            /**
            * - The collider filter of collider body
            */
            colliderFilter: ccs.ColliderFilter;
            /**
            * - The contour data of collider body
            */
            contourData: ccs.ContourData;
            /**
            * - The shape of collider body
            */
            shape: ccs.Shape;
            /**
            * {Array}
getCalculatedVertexList()
get calculated vertex list
Returns:
{Array}

            */
            getCalculatedVertexList(): Array<any>;
            /**
            * {ccs.ColliderFilter}
getColliderFilter()
colliderFilter getter
Returns:
{ccs.ColliderFilter}

            */
            getColliderFilter(): ccs.ColliderFilter;
            /**
            * {ccs.ContourData}
getContourData()
contourData getter
Returns:
{ccs.ContourData}

            */
            getContourData(): ccs.ContourData;
            /**
            * {ccs.Shape}
getShape()
shape setter
Returns:
{ccs.Shape}

            */
            getShape(): ccs.Shape;
            /**
            * setColliderFilter(colliderFilter)
colliderFilter setter
Parameters:
{ccs.ColliderFilter} colliderFilter

            */
            setColliderFilter(colliderFilter?: ccs.ColliderFilter);
            /**
            * setContourData(contourData)
contourData setter
Parameters:
{ccs.ContourData} contourData

            */
            setContourData(contourData?: ccs.ContourData);
            /**
            * setShape(shape)
shape getter
Parameters:
{ccs.Shape} shape

            */
            setShape(shape?: ccs.Shape);
        }
    }
declare module ccs {
        /**
        * 
Base class for ccs.ColliderDetector

        */
        export class ColliderDetector extends ccs.Class {
            /**
            * Base class for ccs.ColliderDetector
            */
            constructor(bone?: ccs.Bone);
            /**
            * - Indicate whether the collider detector is active
            */
            active: boolean;
            /**
            * - The collider body
            */
            body: Object;
            /**
            * - The collider filter of the collider detector
            */
            colliderFilter: ccs.ColliderFilter;
            /**
            * addContourData(contourData)
add contourData
Parameters:
{ccs.ContourData} contourData

            */
            addContourData(contourData?: ccs.ContourData);
            /**
            * addContourDataList(contourDataList)
add contourData
Parameters:
{Array} contourDataList

            */
            addContourDataList(contourDataList?: Array<any>);
            /**
            * {ccs.ColliderFilter}
getColliderFilter()
get colliderFilter
Returns:
{ccs.ColliderFilter}

            */
            getColliderFilter(): ccs.ColliderFilter;
            /**
            * removeAll()
remove all body

            */
            removeAll();
            /**
            * removeContourData(contourData)
remove contourData
Parameters:
contourData

            */
            removeContourData();
            /**
            * setColliderFilter(filter)
set colliderFilter
Parameters:
{ccs.ColliderFilter} filter

            */
            setColliderFilter(filter?: ccs.ColliderFilter);
        }
    }
declare module ccs {
        /**
        * 
Base class for ccs.ColliderFilter

        */
        export class ColliderFilter extends ccs.Class {
            /**
            * Base class for ccs.ColliderFilter
            */
            constructor();
        }
    }
declare module ccs {
        /**
        * 
The attribute component for Cocostudio.

        */
        export class ComAttribute extends ccs.Component {
            /**
            * The attribute component for Cocostudio.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{ccs.ComAttribute}
ccs.ComAttribute.create()
allocates and initializes a ComAttribute.
// example
var com = ccs.ComAttribute.create();
Deprecated:
since v3.0, please use new construction instead.
Returns:
{ccs.ComAttribute}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccs.ComAttribute;
            /**
            * ctor()
Construction of ccs.ComAttribute

            */
            ctor();
            /**
            * {Boolean}
getBool(key)
Returns boolean value from attribute
Parameters:
{String} key
Returns:
{Boolean}

            */
            getBool(key?: string): boolean;
            /**
            * {Number}
getDouble(key)
Returns double value from attribute
Parameters:
{String} key
Returns:
{Number}

            */
            getDouble(key?: string): number;
            /**
            * {Number}
getFloat(key)
Returns float value from attribute
Parameters:
{String} key
Returns:
{Number}

            */
            getFloat(key?: string): number;
            /**
            * {Number}
getInt(key)
Returns int value from attribute
Parameters:
{String} key
Returns:
{Number}

            */
            getInt(key?: string): number;
            /**
            * {Object}
getObject(key)
Returns object value from attribute
Parameters:
{String} key
Returns:
{Object}

            */
            getObject(key?: string): Object;
            /**
            * {String}
getString(key)
Returns string value from attribute
Parameters:
{String} key
Returns:
{String}

            */
            getString(key?: string): string;
            /**
            * {boolean}
init()
Initializes a ccs.ComAttribute
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * parse(filename)
Parses json file.
Parameters:
filename

            */
            parse();
            /**
            * setBool(key, value)
Sets boolean attribute
Parameters:
{String} key
{Boolean} value

            */
            setBool(key?: string, value?: boolean);
            /**
            * setDouble(key, value)
Sets double attribute
Parameters:
{String} key
{number} value

            */
            setDouble(key?: string, value?: number);
            /**
            * setFloat(key, value)
Sets float attribute
Parameters:
{String} key
{number} value

            */
            setFloat(key?: string, value?: number);
            /**
            * setInt(key, value)
Sets int attribute
Parameters:
{String} key
{number} value

            */
            setInt(key?: string, value?: number);
            /**
            * setObject(key, value)
Sets object attribute
Parameters:
{String} key
{Object} value

            */
            setObject(key?: string, value?: Object);
            /**
            * setString(key, value)
Sets string attribute
Parameters:
{String} key
{Boolean} value

            */
            setString(key?: string, value?: boolean);
        }
    }
declare module ccs {
        /**
        * 
The audio component for Cocostudio.

        */
        export class ComAudio extends ccs.Component {
            /**
            * The audio component for Cocostudio.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{ccs.ComAudio}
ccs.ComAudio.create()
allocates and initializes a ComAudio.
// example
var com = ccs.ComAudio.create();
Deprecated:
since v3.0, please use new construction instead.
Returns:
{ccs.ComAudio}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccs.ComAudio;
            /**
            * ctor()
Construction of ccs.ComAudio

            */
            ctor();
            /**
            * end()
Stops all audios.

            */
            end();
            /**
            * {Number}
getBackgroundMusicVolume()
The volume of the music max value is 1.0,the min value is 0.0 .
Returns:
{Number}

            */
            getBackgroundMusicVolume(): number;
            /**
            * {Number}
getEffectsVolume()
The volume of the effects max value is 1.0,the min value is 0.0 .
Returns:
{Number}

            */
            getEffectsVolume(): number;
            /**
            * {string}
getFile()
Returns the file path of audio component.
Returns:
{string}

            */
            getFile(): string;
            /**
            * {boolean}
init()
Initializes a ccs.ComAudio.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * {Boolean}
isBackgroundMusicPlaying()
Whether the music is playing.
Returns:
{Boolean}

            */
            isBackgroundMusicPlaying(): boolean;
            /**
            * {boolean}
isLoop()
Returns audio component whether plays loop
Returns:
{boolean}

            */
            isLoop(): boolean;
            /**
            * onExit()
The callback calls when a audio component enter stage.

            */
            onExit();
            /**
            * pauseAllEffects()
Pause all effects

            */
            pauseAllEffects();
            /**
            * pauseBackgroundMusic()
Pause background music

            */
            pauseBackgroundMusic();
            /**
            * pauseEffect(soundId)
Pause playing sound effect.
Parameters:
{Number} soundId

            */
            pauseEffect(soundId?: number);
            /**
            * playBackgroundMusic(pszFilePath, loop)
Play background music
Parameters:
{String} pszFilePath
Optional
{Boolean} loop
Optional

            */
            playBackgroundMusic(pszFilePath?: string, loop?: boolean);
            /**
            * {Boolean}
playEffect(pszFilePath, loop)
Play sound effect.
Parameters:
{String} pszFilePath
Optional
{Boolean} loop
Optional
Returns:
{Boolean}

            */
            playEffect(pszFilePath?: string, loop?: boolean): boolean;
            /**
            * preloadBackgroundMusic(pszFilePath)
Preload background music resource
Parameters:
{String} pszFilePath

            */
            preloadBackgroundMusic(pszFilePath?: string);
            /**
            * preloadEffect(pszFilePath)
Preload effect
Parameters:
{String} pszFilePath

            */
            preloadEffect(pszFilePath?: string);
            /**
            * resumeAllEffects()
Resume all effects

            */
            resumeAllEffects();
            /**
            * resumeBackgroundMusic()
Resume background music

            */
            resumeBackgroundMusic();
            /**
            * resumeEffect(soundId)
Resume effect
Parameters:
{Number} soundId

            */
            resumeEffect(soundId?: number);
            /**
            * rewindBackgroundMusic()
Rewind background music

            */
            rewindBackgroundMusic();
            /**
            * setBackgroundMusicVolume(volume)
Set the volume of music.
Parameters:
{Number} volume
must be in 0.0~1.0 .

            */
            setBackgroundMusicVolume(volume?: number);
            /**
            * setEffectsVolume(volume)
Set the volume of sound effects.
Parameters:
{Number} volume

            */
            setEffectsVolume(volume?: number);
            /**
            * setFile(pszFilePath)
File path setter
Parameters:
{String} pszFilePath

            */
            setFile(pszFilePath?: string);
            /**
            * setLoop(loop)
Sets audio component whether plays loop
Parameters:
{Boolean} loop

            */
            setLoop(loop?: boolean);
            /**
            * stopAllEffects()
stop all effects

            */
            stopAllEffects();
            /**
            * stopBackgroundMusic(releaseData)
Stop background music
Parameters:
{String} releaseData

            */
            stopBackgroundMusic(releaseData?: string);
            /**
            * stopEffect(soundId)
Stop effect
Parameters:
{Number} soundId

            */
            stopEffect(soundId?: number);
            /**
            * unloadEffect(pszFilePath)
Unload effect
Parameters:
{String} pszFilePath

            */
            unloadEffect(pszFilePath?: string);
            /**
            * {boolean}
willPlayBackgroundMusic()
Indicates whether any background music can be played or not.
Returns:
{boolean}

            */
            willPlayBackgroundMusic(): boolean;
        }
    }
declare module ccs {
        /**
        * 
The controller component for Cocostudio.

        */
        export class ComController extends ccs.Component {
            /**
            * The controller component for Cocostudio.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{ccs.ComController}
ccs.ComController.create()
Allocates and initializes a ComController.
// example
var com = ccs.ComController.create();
Deprecated:
since v3.0, please use new construction instead.
Returns:
{ccs.ComController}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccs.ComController;
            /**
            * ctor()
Construction of ccs.ComController.

            */
            ctor();
            /**
            * {Boolean}
isEnabled()
Returns controller component whether is enabled
Returns:
{Boolean}

            */
            isEnabled(): boolean;
            /**
            * onEnter()
The callback calls when controller component enter stage.

            */
            onEnter();
            /**
            * setEnabled(bool)
Sets controller component whether is enabled
Parameters:
{Boolean} bool

            */
            setEnabled(bool?: boolean);
        }
    }
declare module ccs {
        /**
        * 
The same as cc.Component

        */
        export class Component extends ccs.Class {
            /**
            * The same as cc.Component
            */
            constructor();
        }
    }
declare module ccs {
        /**
        * 
The render component for Cocostudio.

        */
        export class ComRender extends ccs.Component {
            /**
            * The render component for Cocostudio.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{ccs.ComRender}
ccs.ComRender.create(node, comName)
allocates and initializes a ComRender.
// example
var com = ccs.ComRender.create();
Parameters:
node
comName
Deprecated:
since v3.0, please use new construction instead.
Returns:
{ccs.ComRender}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccs.ComRender;
            /**
            * ctor(node, comName)
Construction of ccs.ComRender
Parameters:
{cc.Node} node
{String} comName

            */
            ctor(node?: cc.Node, comName?: string);
            /**
            * {cc.Node}
getNode()
Returns a render node
Returns:
{cc.Node}

            */
            getNode(): cc.Node;
            /**
            * onEnter()
The callback calls when a render component enter stage.

            */
            onEnter();
            /**
            * onExit()
The callback calls when a render component exit stage.

            */
            onExit();
            /**
            * setNode(node)
Sets a render node to component.
Parameters:
{cc.Node} node

            */
            setNode(node?: cc.Node);
        }
    }
declare module ccs {
        /**
        * 
The Contour data information of Cocos Armature.

        */
        export class ContourData  {
            /**
            * The Contour data information of Cocos Armature.
            */
            constructor();
            /**
            * addVertex(p)
add a vertex object to vertex list
Parameters:
{cc.Point} p

            */
            addVertex(p?: cc.Point);
        }
    }
declare module ccs {
        /**
        * 
contour vertex

        */
        export class ContourVertex2  {
            /**
            * contour vertex
            */
            constructor(x?: number, y?: number);
        }
    }
declare module ccs {
        /**
        * 
ccs.dataReaderHelper is a singleton object for reading CocoStudio data

        */
        export class dataReaderHelper  {
            /**
            * ccs.dataReaderHelper is a singleton object for reading CocoStudio data
            */
            constructor();
            /**
            * addDataFromCache(skeleton, dataInfo)
Translate XML export from Dragon Bone flash tool to data, and save them. When you add a new xml, the data already saved will be keeped.
Parameters:
{Object} skeleton
{ccs.DataInfo} dataInfo

            */
            addDataFromCache(skeleton?: Object, dataInfo?: ccs.DataInfo);
            /**
            * addDataFromFile(filePath)
Add armature data from file.
Parameters:
{String} filePath

            */
            addDataFromFile(filePath?: string);
            /**
            * addDataFromFileAsync(imagePath, plistPath, filePath, selector, target)
Adds data from file with Async.
Parameters:
{String} imagePath
{String} plistPath
{String} filePath
{function} selector
{Object} target
Optional

            */
            addDataFromFileAsync(imagePath?: string, plistPath?: string, filePath?: string, selector?: any, target?: Object);
            /**
            * addDataFromJson(filePath, dataInfo)
Adds json armature data to armature data manager.
Parameters:
{String} filePath
{ccs.DataInfo} dataInfo

            */
            addDataFromJson(filePath?: string, dataInfo?: ccs.DataInfo);
            /**
            * addDataFromJsonCache(dic, dataInfo)
Adds json armature data to armature data manager.
Parameters:
{Object} dic
json armature data
{ccs.DataInfo} dataInfo

            */
            addDataFromJsonCache(dic?: Object, dataInfo?: ccs.DataInfo);
            /**
            * addDataFromXML(xml, dataInfo)
Adds xml armature data to armature data manager.
Parameters:
{XMLDocument} xml
{ccs.DataInfo} dataInfo

            */
            addDataFromXML(xml?: XMLDocument, dataInfo?: ccs.DataInfo);
            /**
            * {ccs.AnimationData}
decodeAnimation(animationXML, dataInfo)
Decodes xml animation data.
Parameters:
{XMLDocument} animationXML
{ccs.DataInfo} dataInfo
Returns:
{ccs.AnimationData}

            */
            decodeAnimation(animationXML?: XMLDocument, dataInfo?: ccs.DataInfo): ccs.AnimationData;
            /**
            * {ccs.AnimationData}
decodeAnimationFromJson(json, dataInfo)
Decodes animation json data.
Parameters:
{Object} json
{ccs.DataInfo} dataInfo
Returns:
{ccs.AnimationData}

            */
            decodeAnimationFromJson(json?: Object, dataInfo?: ccs.DataInfo): ccs.AnimationData;
            /**
            * {ccs.ArmatureData}
decodeArmature(armatureXML, dataInfo)
decode xml armature data.
Parameters:
{XMLDocument} armatureXML
{ccs.DataInfo} dataInfo
Returns:
{ccs.ArmatureData}

            */
            decodeArmature(armatureXML?: XMLDocument, dataInfo?: ccs.DataInfo): ccs.ArmatureData;
            /**
            * {ccs.ArmatureData}
decodeArmatureFromJSON(json, dataInfo)
decode json armature data.
Parameters:
{Object} json
{ccs.DataInfo} dataInfo
Returns:
{ccs.ArmatureData}

            */
            decodeArmatureFromJSON(json?: Object, dataInfo?: ccs.DataInfo): ccs.ArmatureData;
            /**
            * {ccs.BoneData}
decodeBone(boneXML, parentXML, dataInfo)
decode xml bone data.
Parameters:
{XMLDocument} boneXML
{XMLDocument} parentXML
{ccs.DataInfo} dataInfo
Returns:
{ccs.BoneData}

            */
            decodeBone(boneXML?: XMLDocument, parentXML?: XMLDocument, dataInfo?: ccs.DataInfo): ccs.BoneData;
            /**
            * {ccs.DisplayData}
decodeBoneDisplay(displayXML, dataInfo)
decode xml display data of bone
Parameters:
{XMLDocument} displayXML
{ccs.DataInfo} dataInfo
Returns:
{ccs.DisplayData}

            */
            decodeBoneDisplay(displayXML?: XMLDocument, dataInfo?: ccs.DataInfo): ccs.DisplayData;
            /**
            * {ccs.DisplayData}
decodeBoneDisplayFromJson(json, dataInfo)
Decodes json display data of bone.
Parameters:
{Object} json
{ccs.DataInfo} dataInfo
Returns:
{ccs.DisplayData}

            */
            decodeBoneDisplayFromJson(json?: Object, dataInfo?: ccs.DataInfo): ccs.DisplayData;
            /**
            * {ccs.BoneData}
decodeBoneFromJson(json, dataInfo)
decode json bone data.
Parameters:
{Object} json
json bone data.
{ccs.DataInfo} dataInfo
Returns:
{ccs.BoneData}

            */
            decodeBoneFromJson(json?: Object, dataInfo?: ccs.DataInfo): ccs.BoneData;
            /**
            * {ccs.ContourData}
decodeContour(contourXML, dataInfo)
Decodes xml data of contour.
Parameters:
{XMLDocument} contourXML
{ccs.DataInfo} dataInfo
Returns:
{ccs.ContourData}

            */
            decodeContour(contourXML?: XMLDocument, dataInfo?: ccs.DataInfo): ccs.ContourData;
            /**
            * {ccs.ContourData}
decodeContourFromJson(json)
Decodes json data of contour.
Parameters:
{Object} json
Returns:
{ccs.ContourData}

            */
            decodeContourFromJson(json?: Object): ccs.ContourData;
            /**
            * {ccs.FrameData}
decodeFrame(frameXML, parentFrameXml, boneData, dataInfo)
Decodes xml data of frame.
Parameters:
{XMLDocument} frameXML
{XMLDocument} parentFrameXml
{ccs.BoneData} boneData
{ccs.DataInfo} dataInfo
Returns:
{ccs.FrameData}

            */
            decodeFrame(frameXML?: XMLDocument, parentFrameXml?: XMLDocument, boneData?: ccs.BoneData, dataInfo?: ccs.DataInfo): ccs.FrameData;
            /**
            * {ccs.FrameData}
decodeFrameFromJson(json, dataInfo)
Decodes json data of frame.
Parameters:
{Object} json
{ccs.DataInfo} dataInfo
Returns:
{ccs.FrameData}

            */
            decodeFrameFromJson(json?: Object, dataInfo?: ccs.DataInfo): ccs.FrameData;
            /**
            * {ccs.MovementData}
decodeMovement(movementXML, armatureData, dataInfo)
Decodes xml movement data.
Parameters:
{XMLDocument} movementXML
{ccs.ArmatureData} armatureData
{ccs.DataInfo} dataInfo
Returns:
{ccs.MovementData}

            */
            decodeMovement(movementXML?: XMLDocument, armatureData?: ccs.ArmatureData, dataInfo?: ccs.DataInfo): ccs.MovementData;
            /**
            * {ccs.MovementBoneData}
decodeMovementBone(movBoneXml, parentXml, boneData, dataInfo)
Decodes xml data of bone&#39;s movement.
Parameters:
{XMLDocument} movBoneXml
{XMLDocument} parentXml
{ccs.BoneData} boneData
{ccs.DataInfo} dataInfo
Returns:
{ccs.MovementBoneData}

            */
            decodeMovementBone(movBoneXml?: XMLDocument, parentXml?: XMLDocument, boneData?: ccs.BoneData, dataInfo?: ccs.DataInfo): ccs.MovementBoneData;
            /**
            * {ccs.MovementBoneData}
decodeMovementBoneFromJson(json, dataInfo)
Decodes json data of bone&#39;s movement.
Parameters:
{Object} json
{ccs.DataInfo} dataInfo
Returns:
{ccs.MovementBoneData}

            */
            decodeMovementBoneFromJson(json?: Object, dataInfo?: ccs.DataInfo): ccs.MovementBoneData;
            /**
            * {ccs.MovementData}
decodeMovementFromJson(json, dataInfo)
Decodes json movement data.
Parameters:
{Object} json
{ccs.DataInfo} dataInfo
Returns:
{ccs.MovementData}

            */
            decodeMovementFromJson(json?: Object, dataInfo?: ccs.DataInfo): ccs.MovementData;
            /**
            * decodeNodeFromJson(node, json, dataInfo)
Decodes json data of node.
Parameters:
node
json
dataInfo

            */
            decodeNodeFromJson();
            /**
            * {ccs.TextureData}
decodeTexture(textureXML, dataInfo)
Decodes xml data of texture
Parameters:
{XMLDocument} textureXML
{ccs.DataInfo} dataInfo
Returns:
{ccs.TextureData}

            */
            decodeTexture(textureXML?: XMLDocument, dataInfo?: ccs.DataInfo): ccs.TextureData;
            /**
            * {ccs.TextureData}
decodeTextureFromJson(json)
Decodes json data of Texture.
Parameters:
json
Returns:
{ccs.TextureData}

            */
            decodeTextureFromJson(): ccs.TextureData;
            /**
            * removeConfigFile(configFile)
Removes config file from config file list.
Parameters:
{String} configFile

            */
            removeConfigFile(configFile?: string);
        }
    }
declare module ccs {
        /**
        * 
Decorative a display node for Cocos Armature

        */
        export class DecorativeDisplay extends ccs.Class {
            /**
            * Decorative a display node for Cocos Armature
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{ccs.DecorativeDisplay}
ccs.DecorativeDisplay.create()
Allocates and initializes a decorative display.
Deprecated:
since v3.1, please use new construction instead
Returns:
{ccs.DecorativeDisplay}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccs.DecorativeDisplay;
            /**
            * {ccs.ColliderDetector}
getColliderDetector()
Returns collide detector
Returns:
{ccs.ColliderDetector}

            */
            getColliderDetector(): ccs.ColliderDetector;
            /**
            * {cc.Node}
getDisplay()
Returns the display node
Returns:
{cc.Node}

            */
            getDisplay(): cc.Node;
            /**
            * {ccs.DisplayData}
getDisplayData()
Returns display data
Returns:
{ccs.DisplayData}

            */
            getDisplayData(): ccs.DisplayData;
            /**
            * {boolean}
init()
Initializes a ccs.DecorativeDisplay
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * setColliderDetector(colliderDetector)
Sets collide detector
Parameters:
{ccs.ColliderDetector} colliderDetector

            */
            setColliderDetector(colliderDetector?: ccs.ColliderDetector);
            /**
            * setDisplay(display)
Sets display node to decorative
Parameters:
{cc.Node} display

            */
            setDisplay(display?: cc.Node);
            /**
            * setDisplayData(displayData)
Sets display data
Parameters:
{ccs.DisplayData} displayData

            */
            setDisplayData(displayData?: ccs.DisplayData);
        }
    }
declare module ccs {
        /**
        * 
The class use for save display data.

        */
        export class DisplayData extends ccs.Class {
            /**
            * The class use for save display data.
            */
            constructor();
            /**
            * - the display name
            */
            displayName: string;
            /**
            * - the display type
            */
            displayType: number;
            /**
            * {String}
changeDisplayToTexture(displayName)
Changes display name to texture type
Parameters:
{String} displayName
Returns:
{String}

            */
            changeDisplayToTexture(displayName?: string): string;
            /**
            * copy(displayData)
copy data
Parameters:
{ccs.DisplayData} displayData

            */
            copy(displayData?: ccs.DisplayData);
            /**
            * ctor()
Construction of ccs.DisplayData

            */
            ctor();
        }
    }
declare module ccs {
        /**
        * 
FrameData saved the frame data needed for armature animation in this Armature.

        */
        export class FrameData extends ccs.BaseData {
            /**
            * FrameData saved the frame data needed for armature animation in this Armature.
            */
            constructor();
            /**
            * - the blendFunc of frame.
            */
            blendFunc: Object;
            /**
            * - the display renderer index.
            */
            displayIndex: number;
            /**
            * - the duration of frame
            */
            duration: number;
            /**
            * - the count of easing parameters.
            */
            easingParamNumber: number;
            /**
            * - the dictionary of easing parameters.
            */
            easingParams: Object;
            /**
            * - the event name
            */
            event: string;
            /**
            * - the frame ID of frame
            */
            frameID: number;
            /**
            * - the flag which frame whether is tween.
            */
            isTween: boolean;
            /**
            * - the movement name.
            */
            movement: string;
            /**
            * - the sound path.
            */
            sound: string;
            /**
            * - the sound effect path.
            */
            soundEffect: string;
            /**
            * - the easing type of frame
            */
            tweenEasing: number;
            /**
            * copy(frameData)
copy data
Parameters:
frameData

            */
            copy();
            /**
            * ctor()
Construction of ccs.FrameData.

            */
            ctor();
        }
    }
declare module ccs {
        /**
        * 
The frame event class for Armature.

        */
        export class FrameEvent  {
            /**
            * The frame event class for Armature.
            */
            constructor();
            /**
            * - The bone reference of frame event.
            */
            bone: ccs.Bone;
            /**
            * - The index of current frame.
            */
            currentFrameIndex: number;
            /**
            * - The name of frame event.
            */
            frameEventName: string;
            /**
            * - The index of origin frame.
            */
            originFrameIndex: number;
        }
    }
declare module ccs {
        /**
        * 
MovementBoneData saved the name, delay, frame list of Bone&#39;s movement.

        */
        export class MovementBoneData extends ccs.Class {
            /**
            * MovementBoneData saved the name, delay, frame list of Bone&#39;s movement.
            */
            constructor();
            /**
            * - the delay of bone&#39;s movement.
            */
            delay: number;
            /**
            * - the duration of bone&#39;s movement.
            */
            duration: number;
            /**
            * - the frame list of bone&#39;s movement.
            */
            frameList: Array<any>;
            /**
            * - the name of bone&#39;s movement.
            */
            name: string;
            /**
            * - the scale of bone&#39;s movement.
            */
            scale: number;
            /**
            * addFrameData(frameData)
Adds frame data to frame list.
Parameters:
{ccs.FrameData} frameData

            */
            addFrameData(frameData?: ccs.FrameData);
            /**
            * ctor()
Construction of ccs.MovementBoneData.

            */
            ctor();
            /**
            * {ccs.FrameData}
getFrameData(index)
Gets frame data by Index.
Parameters:
{Number} index
Returns:
{ccs.FrameData}

            */
            getFrameData(index?: number): ccs.FrameData;
            /**
            * {boolean}
init()
Initializes a ccs.MovementBoneData.
Returns:
{boolean}

            */
            init(): boolean;
        }
    }
declare module ccs {
        /**
        * 
The movement data information of Cocos Armature.

        */
        export class MovementData  {
            /**
            * The movement data information of Cocos Armature.
            */
            constructor();
            /**
            * Change to this movement will last durationTo frames.
            */
            durationTo;
            /**
            * This is different from duration, durationTween contain tween effect.
            */
            durationTween;
            /**
            * Which tween easing effect the movement use
TWEEN_EASING_MAX : use the value from MovementData get from flash design panel
            */
            tweenEasing;
            /**
            * addMovementBoneData(movBoneData)
add a movement bone data to dictionary
Parameters:
{ccs.MovementBoneData} movBoneData

            */
            addMovementBoneData(movBoneData?: ccs.MovementBoneData);
            /**
            * {ccs.MovementBoneData}
getMovementBoneData(boneName)
add a movement bone data from dictionary by name
Parameters:
boneName
Returns:
{ccs.MovementBoneData}

            */
            getMovementBoneData(): ccs.MovementBoneData;
        }
    }
declare module ccs {
        /**
        * 
The movement event class for Armature.

        */
        export class MovementEvent  {
            /**
            * The movement event class for Armature.
            */
            constructor();
            /**
            * - The armature reference of movement event.
            */
            armature: ccs.Armature;
            /**
            * - The ID of movement.
            */
            movementID: string;
            /**
            * - The type of movement.
            */
            movementType: number;
        }
    }
declare module ccs {
        /**
        * 
The same as cc.Node

        */
        export class Node extends ccs.Class {
            /**
            * The same as cc.Node
            */
            constructor();
        }
    }
declare module ccs {
        /**
        * 
The particle display data class.

        */
        export class ParticleDisplayData extends ccs.DisplayData {
            /**
            * The particle display data class.
            */
            constructor();
            /**
            * ctor()
Construction of ccs.ParticleDisplayData

            */
            ctor();
        }
    }
declare module ccs {
        /**
        * 
The Base Process class for Cocostudio.

        */
        export class ProcessBase extends ccs.Class {
            /**
            * The Base Process class for Cocostudio.
            */
            constructor();
            /**
            * - The animation internal
            */
            animationInterval: number;
            /**
            * -  Indicate whether the process is done
            */
            completed: boolean;
            /**
            * -  The current frame&#39;s index
            */
            currentFrameIndex: number;
            /**
            * -  The current percentage of the process
            */
            currentPercent: number;
            /**
            * -  The number of loop
            */
            loop: number;
            /**
            * -  Indicate whether the process is paused
            */
            paused: boolean;
            /**
            * -  Indicate whether the process is playing
            */
            playing: boolean;
            /**
            * - The process scale
            */
            processScale: number;
            /**
            * -  The duration
            */
            rawDuration: number;
            /**
            * -  The tween easing
            */
            tweenEasing: number;
            /**
            * ctor()
Constructor of ccs.ProcessBase

            */
            ctor();
            /**
            * {number}
getAnimationInternal()
Returns animation interval of ccs.ProcessBase
Returns:
{number}

            */
            getAnimationInternal(): number;
            /**
            * {Number}
getCurrentFrameIndex()
Returns the index of current frame.
Returns:
{Number}

            */
            getCurrentFrameIndex(): number;
            /**
            * {number}
getCurrentPercent()
Returns current percent of ccs.ProcessBase
Returns:
{number}

            */
            getCurrentPercent(): number;
            /**
            * {number}
getLoop()
Returns loop type of ccs.ProcessBase
Returns:
{number}

            */
            getLoop(): number;
            /**
            * {number}
getProcessScale()
Returns process scale
Returns:
{number}

            */
            getProcessScale(): number;
            /**
            * {number}
getRawDuration()
Returns the raw duration of ccs.ProcessBase
Returns:
{number}

            */
            getRawDuration(): number;
            /**
            * {number}
getTweenEasing()
Returns tween easing of ccs.ProcessBase
Returns:
{number}

            */
            getTweenEasing(): number;
            /**
            * gotoFrame(frameIndex)
Goes to specified frame by frameIndex.
Parameters:
{Number} frameIndex

            */
            gotoFrame(frameIndex?: number);
            /**
            * {boolean}
isComplete()
Returns whether the animation is complete
Returns:
{boolean}

            */
            isComplete(): boolean;
            /**
            * {boolean}
isPause()
Returns whether the animation is pause
Returns:
{boolean}

            */
            isPause(): boolean;
            /**
            * {boolean}
isPlaying()
Returns whether the animation is playing
Returns:
{boolean}

            */
            isPlaying(): boolean;
            /**
            * pause()
Pauses the Process

            */
            pause();
            /**
            * play(durationTo, durationTween, loop, tweenEasing)
Plays animation by animation name.
Parameters:
{Number} durationTo
The frames between two animation changing-over.
It&#39;s meaning is changing to this animation need how many frames
-1 : use the value from MovementData get from flash design panel
{Number} durationTween
The frame count you want to play in the game.
if  _durationTween is 80, then the animation will played 80 frames in a loop
-1 : use the value from MovementData get from flash design panel
{Number} loop
Whether the animation is loop
loop  0 : this animation is loop
{Number} tweenEasing
Tween easing is used for calculate easing effect
TWEEN_EASING_MAX : use the value from MovementData get from flash design panel
-1 : fade out
0  : line
1  : fade in
2  : fade in and out

            */
            play(durationTo?: number, durationTween?: number, loop?: number, tweenEasing?: number);
            /**
            * resume()
Resumes the Process

            */
            resume();
            /**
            * setAnimationInternal(animationInternal)
Sets animation interval to ccs.ProcessBase.
Parameters:
animationInternal

            */
            setAnimationInternal();
            /**
            * setProcessScale(processScale)
Sets process scale
Parameters:
processScale

            */
            setProcessScale();
            /**
            * stop()
Stops the Process

            */
            stop();
            /**
            * update(dt)
Update process&#39; state.
Parameters:
{Number} dt

            */
            update(dt?: number);
            /**
            * updateHandler()
Updates will call this handler, you can handle your logic here

            */
            updateHandler();
        }
    }
declare module ccs {
        /**
        * 
RelativeData uses to save plist files, armature files, animations and textures for armature data manager.

        */
        export class RelativeData  {
            /**
            * RelativeData uses to save plist files, armature files, animations and textures for armature data manager.
            */
            constructor();
        }
    }
declare module ccs {
        /**
        * 
ccs.sceneReader is the reader for Cocos Studio scene editor.

        */
        export class sceneReader  {
            /**
            * ccs.sceneReader is the reader for Cocos Studio scene editor.
            */
            constructor();
            /**
            * clear()
Clear all triggers and stops all sounds.

            */
            clear();
            /**
            * {cc.Node}
createNodeWithSceneFile(pszFileName)
Creates a node with json file that exported by CocoStudio scene editor
Parameters:
pszFileName
Returns:
{cc.Node}

            */
            createNodeWithSceneFile(): cc.Node;
            /**
            * {cc.Node}
createObject(inputFiles, parenet)
create UI object from data
Parameters:
{Object} inputFiles
{cc.Node} parenet
Returns:
{cc.Node}

            */
            createObject(inputFiles?: Object, parenet?: cc.Node): cc.Node;
            /**
            * {cc.Node|null}
getNodeByTag(tag)
Get a node by tag.
Parameters:
{Number} tag
Returns:
{cc.Node|null}

            */
            getNodeByTag(tag?: number): any;
            /**
            * setPropertyFromJsonDict(node, dict)
Sets properties from json dictionary.
Parameters:
{cc.Node} node
{Object} dict

            */
            setPropertyFromJsonDict(node?: cc.Node, dict?: Object);
            /**
            * setTarget(selector, listener)
Sets the listener to reader.
Parameters:
{function} selector
{Object} listener
the target object.

            */
            setTarget(selector?: any, listener?: Object);
            /**
            * {string}
version()
Returns the version of ccs.SceneReader.
Returns:
{string}

            */
            version(): string;
        }
    }
declare module ccs {
        /**
        * 
ccs.Bone uses ccs.Skin to displays on screen.

        */
        export class Skin extends ccs.Sprite {
            /**
            * ccs.Bone uses ccs.Skin to displays on screen.
            */
            constructor(fileName?: string, rect?: cc.Rect);
            /**
            * - The bone of the skin
            */
            bone: ccs.Bone;
            /**
            * -  The displayed name of skin
            */
            displayName: string;
            /**
            * - The data of the skin
            */
            skinData: Object;
            /**
            * &amp;lt;static&amp;gt;
{ccs.Skin}
ccs.Skin.create(fileName, rect)
allocates and initializes a skin.
Parameters:
{String} fileName
Optional
fileName or sprite frame name
{cc.Rect} rect
Optional
Deprecated:
since v3.1, please use new construction instead
Returns:
{ccs.Skin}

            */
            static create(fileName?: string, rect?: cc.Rect): ccs.Skin;
            /**
            * &amp;lt;static&amp;gt;
{ccs.Skin}
ccs.Skin.createWithSpriteFrameName(spriteFrameName)
allocates and initializes a skin.
Parameters:
{String} spriteFrameName
Deprecated:
since v3.1, please use new construction instead
Returns:
{ccs.Skin}

            */
            static createWithSpriteFrameName(spriteFrameName?: string): ccs.Skin;
            /**
            * {null}
getBone()
Returns the bone reference of ccs.Skin.
Returns:
{null}

            */
            getBone(): void;
            /**
            * {String}
getDisplayName()
display name getter
Returns:
{String}

            */
            getDisplayName(): string;
            /**
            * {cc.AffineTransform}
getNodeToWorldTransform()
Returns skin&#39;s world transform.
Returns:
{cc.AffineTransform}

            */
            getNodeToWorldTransform(): cc.AffineTransform;
            /**
            * {ccs.BaseData}
getSkinData()
Returns skin date of ccs.Skin.
Returns:
{ccs.BaseData}

            */
            getSkinData(): ccs.BaseData;
            /**
            * {Boolean}
initWithFile(fileName, rect)
Initializes with texture file name.
Parameters:
{String} fileName
{cc.Rect} rect
Returns:
{Boolean}

            */
            initWithFile(fileName?: string, rect?: cc.Rect): boolean;
            /**
            * {Boolean}
initWithSpriteFrameName(spriteFrameName)
Initializes with sprite frame name
Parameters:
{String} spriteFrameName
Returns:
{Boolean}

            */
            initWithSpriteFrameName(spriteFrameName?: string): boolean;
            /**
            * setBone(bone)
Sets the bone reference to ccs.Skin.
Parameters:
bone

            */
            setBone();
            /**
            * setSkinData(skinData)
Sets skin data to ccs.Skin.
Parameters:
{ccs.BaseData} skinData

            */
            setSkinData(skinData?: ccs.BaseData);
            /**
            * updateArmatureTransform()
Updates armature skin&#39;s transform with skin transform and bone&#39;s transform.

            */
            updateArmatureTransform();
        }
    }
declare module ccs {
        /**
        * 
The same as cc.Sprite

        */
        export class Sprite extends ccs.Class {
            /**
            * The same as cc.Sprite
            */
            constructor();
        }
    }
declare module ccs {
        /**
        * 
The sprite display data class.

        */
        export class SpriteDisplayData extends ccs.DisplayData {
            /**
            * The sprite display data class.
            */
            constructor();
            /**
            * - the skin data
            */
            skinData: ccs.BaseData;
            /**
            * copy(displayData)
copy data
Parameters:
{ccs.SpriteDisplayData} displayData

            */
            copy(displayData?: ccs.SpriteDisplayData);
            /**
            * ctor()
Construction of ccs.SpriteDisplayData

            */
            ctor();
        }
    }
declare module ccs {
        /**
        * 
ccs.spriteFrameCacheHelper is a singleton object, it&#39;s a sprite frame cache helper

        */
        export class spriteFrameCacheHelper  {
            /**
            * ccs.spriteFrameCacheHelper is a singleton object, it&#39;s a sprite frame cache helper
            */
            constructor();
            /**
            * addSpriteFrameFromFile(plistPath, imagePath)
Adds sprite frame from file
Parameters:
plistPath
imagePath

            */
            addSpriteFrameFromFile();
            /**
            * clear()
Clear the sprite frame cache&#39;s data.

            */
            clear();
            /**
            * {*}
getTextureAtlasWithTexture(texture)
Returns texture atlas with texture.
Parameters:
texture
Returns:
{*}

            */
            getTextureAtlasWithTexture(): any;
        }
    }
declare module ccs {
        /**
        * 
The texture data information of Cocos Armature

        */
        export class TextureData  {
            /**
            * The texture data information of Cocos Armature
            */
            constructor();
            /**
            * addContourData(contourData)
Adds a contourData to contourDataList
Parameters:
{ccs.ContourData} contourData

            */
            addContourData(contourData?: ccs.ContourData);
            /**
            * {ccs.ContourData}
getContourData(index)
gets a contourData from contourDataList by index
Parameters:
{Number} index
Returns:
{ccs.ContourData}

            */
            getContourData(index?: number): ccs.ContourData;
        }
    }
declare module ccs {
        /**
        * 
use to calculate the matrix of node from parent node

        */
        export class TransformHelp  {
            /**
            * use to calculate the matrix of node from parent node
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
ccs.TransformHelp.matrixToNode(matrix, node)
Parameters:
{cc.AffineTransform} matrix
{ccs.BaseData} node

            */
            static matrixToNode(matrix?: cc.AffineTransform, node?: ccs.BaseData);
            /**
            * &amp;lt;static&amp;gt;
ccs.TransformHelp.nodeConcat(target, source)
Parameters:
{ccs.BaseData} target
{ccs.BaseData} source

            */
            static nodeConcat(target?: ccs.BaseData, source?: ccs.BaseData);
            /**
            * &amp;lt;static&amp;gt;
ccs.TransformHelp.nodeSub(target, source)
Parameters:
{ccs.BaseData} target
{ccs.BaseData} source

            */
            static nodeSub(target?: ccs.BaseData, source?: ccs.BaseData);
            /**
            * &amp;lt;static&amp;gt;
ccs.TransformHelp.nodeToMatrix(node, matrix)
Parameters:
{ccs.BaseData} node
{cc.AffineTransform} matrix

            */
            static nodeToMatrix(node?: ccs.BaseData, matrix?: cc.AffineTransform);
            /**
            * &amp;lt;static&amp;gt;
ccs.TransformHelp.transformFromParent(bone, parentNode)
Calculate a BaseData&#39;s transform matrix from parent node.
Parameters:
{ccs.BaseData} bone
Constructor
parentNode

            */
            static transformFromParent(bone?: ccs.BaseData);
        }
    }
declare module ccs {
        /**
        * 
The tween class for Armature.

        */
        export class Tween extends ccs.ProcessBase {
            /**
            * The tween class for Armature.
            */
            constructor(The?: ccs.Bone);
            /**
            * - The animation
            */
            animation: ccs.ArmatureAnimation;
            /**
            * arriveKeyFrame(keyFrameData)
Update display index and process the key frame event when arrived a key frame
Parameters:
{ccs.FrameData} keyFrameData

            */
            arriveKeyFrame(keyFrameData?: ccs.FrameData);
            /**
            * &amp;lt;static&amp;gt;
{ccs.Tween}
ccs.Tween.create(bone)
Allocates and initializes a ArmatureAnimation.
Parameters:
{ccs.Bone} bone
Deprecated:
since v3.1, please use new construction instead
Returns:
{ccs.Tween}

            */
            static create(bone?: ccs.Bone): ccs.Tween;
            /**
            * {ccs.ArmatureAnimation}
getAnimation()
Returns Armature animation of ccs.Tween.
Returns:
{ccs.ArmatureAnimation}

            */
            getAnimation(): ccs.ArmatureAnimation;
            /**
            * gotoAndPause(frameIndex)
Goes to specified frame and pauses frame.
Parameters:
{Number} frameIndex

            */
            gotoAndPause(frameIndex?: number);
            /**
            * gotoAndPlay(frameIndex)
Goes to specified frame and plays frame.
Parameters:
{Number} frameIndex

            */
            gotoAndPlay(frameIndex?: number);
            /**
            * {Boolean}
init(bone)
initializes a ccs.Tween with a CCBone
Parameters:
{ccs.Bone} bone
Returns:
{Boolean}

            */
            init(bone?: ccs.Bone): boolean;
            /**
            * play(movementBoneData, durationTo, durationTween, loop, tweenEasing)
Plays the tween.
Parameters:
{ccs.MovementBoneData} movementBoneData
{Number} durationTo
{Number} durationTween
{Boolean} loop
{ccs.TweenType} tweenEasing

            */
            play(movementBoneData?: ccs.MovementBoneData, durationTo?: number, durationTween?: number, loop?: boolean, tweenEasing?: ccs.TweenType);
            /**
            * setAnimation(animation)
Sets Armature animation to ccs.Tween.
Parameters:
{ccs.ArmatureAnimation} animation

            */
            setAnimation(animation?: ccs.ArmatureAnimation);
            /**
            * setBetween(from, to, limit)
Calculate the between value of _from and _to, and give it to between frame data
Parameters:
{ccs.FrameData} from
{ccs.FrameData} to
{Boolean} limit
Optional, Default: true

            */
            setBetween(from?: ccs.FrameData, to?: ccs.FrameData, limit?: boolean);
            /**
            * setMovementBoneData(data)
Sets movement bone data to ccs.Tween.
Parameters:
data

            */
            setMovementBoneData();
            /**
            * tweenColorTo(percent, node)
According to the percent to calculate current color with tween effect
Parameters:
{Number} percent
{ccs.FrameData} node

            */
            tweenColorTo(percent?: number, node?: ccs.FrameData);
            /**
            * {ccs.FrameData}
tweenNodeTo(percent, node)
According to the percent to calculate current CCFrameData with tween effect
Parameters:
{Number} percent
{ccs.FrameData} node
Optional
Returns:
{ccs.FrameData}

            */
            tweenNodeTo(percent?: number, node?: ccs.FrameData): ccs.FrameData;
            /**
            * {Number}
updateFrameData(currentPercent)
Calculate which frame arrived, and if current frame have event, then call the event listener
Parameters:
{Number} currentPercent
Returns:
{Number}

            */
            updateFrameData(currentPercent?: number): number;
            /**
            * updateHandler()
update will call this handler, you can handle your logic here

            */
            updateHandler();
        }
    }
declare module ccs {
        /**
        * 
ccs.uiReader is a singleton object which is the reader for Cocos Studio ui.

        */
        export class uiReader  {
            /**
            * ccs.uiReader is a singleton object which is the reader for Cocos Studio ui.
            */
            constructor();
            /**
            * clear()
Resets the states and clear the file design sizes.

            */
            clear();
            /**
            * {cc.Size}
getFileDesignSize(fileName)
Gets the design size by filename.
Parameters:
{String} fileName
Returns:
{cc.Size}

            */
            getFileDesignSize(fileName?: string): cc.Size;
            /**
            * {string}
getFilePath()
Returns the file path
Returns:
{string}

            */
            getFilePath(): string;
            /**
            * {*}
getParseCallBackMap()
Returns the parsed callback map.
Returns:
{*}

            */
            getParseCallBackMap(): any;
            /**
            * {Object}
getParseObjectMap()
Returns the parsed object map.
Returns:
{Object}

            */
            getParseObjectMap(): Object;
            /**
            * {Number}
getVersionInteger(str)
Gets the version number by version string.
Parameters:
{String} str
version string.
Returns:
{Number}

            */
            getVersionInteger(str?: string): number;
            /**
            * registerTypeAndCallBack(classType, ins, object, callback)
Registers class type and callback.
Parameters:
{String} classType
{ccs.objectFactory} ins
{Object} object
{function} callback

            */
            registerTypeAndCallBack(classType?: string, ins?: ccs.objectFactory, object?: Object, callback?: any);
            /**
            * storeFileDesignSize(fileName, size)
stores the designSize of UI file.
Parameters:
{String} fileName
{cc.Size} size

            */
            storeFileDesignSize(fileName?: string, size?: cc.Size);
            /**
            * {ccui.Widget}
widgetFromJsonFile(fileName)
Creates uiWidget from a json file that exported by cocostudio UI editor
Parameters:
{String} fileName
Returns:
{ccui.Widget}

            */
            widgetFromJsonFile(fileName?: string): ccui.Widget;
        }
    }
declare module ccs {
        /**
        * 
The base class of widget properties reader. It parse the foundation properties of widget.

        */
        export class WidgetPropertiesReader extends ccs.Class {
            /**
            * The base class of widget properties reader.
            */
            constructor();
            /**
            * createWidget(jsonDict, fullPath, fileName)
Create a widget object by json object.
Parameters:
{Object} jsonDict
{String} fullPath
{String} fileName

            */
            createWidget(jsonDict?: Object, fullPath?: string, fileName?: string);
            /**
            * widgetFromJsonDictionary(data)
Parses the widget properties.
Parameters:
{Object} data

            */
            widgetFromJsonDictionary(data?: Object);
        }
    }
declare module ccs {
        /**
        * 
The widget properties reader to parse Cocostudio exported file v0.3 -- v1.0

        */
        export class WidgetPropertiesReader0250 extends ccs.WidgetPropertiesReader {
            /**
            * The widget properties reader to parse Cocostudio exported file v0.3 -- v1.0
            */
            constructor();
            /**
            * {*}
createWidget(jsonDict, fullPath, fileName)
Creates a widget by json object.
Parameters:
{Object} jsonDict
{string} fullPath
{string} fileName
Returns:
{*}

            */
            createWidget(jsonDict?: Object, fullPath?: string, fileName?: string): any;
            /**
            * setColorPropsForWidgetFromJsonDictionary(widget, options)
Sets widget&#39;s color, anchor point, flipped properties from json object.
Parameters:
{ccui.Widget} widget
{Object} options
json object.

            */
            setColorPropsForWidgetFromJsonDictionary(widget?: ccui.Widget, options?: Object);
            /**
            * setPropsForAllCustomWidgetFromJsonDictionary()
Sets all custom widget&#39;s properties from json dictionary.

            */
            setPropsForAllCustomWidgetFromJsonDictionary();
            /**
            * setPropsForAllWidgetFromJsonDictionary()
Sets all widgets&#39; properties from json dictionary.

            */
            setPropsForAllWidgetFromJsonDictionary();
            /**
            * setPropsForButtonFromJsonDictionary(widget, options)
Sets ccui.Button&#39;s properties from json object.
Parameters:
{ccui.Button} widget
{Object} options

            */
            setPropsForButtonFromJsonDictionary(widget?: ccui.Button, options?: Object);
            /**
            * setPropsForCheckBoxFromJsonDictionary(widget, options)
Sets ccui.CheckBox&#39;s properties from json object.
Parameters:
{ccui.CheckBox} widget
{Object} options

            */
            setPropsForCheckBoxFromJsonDictionary(widget?: ccui.CheckBox, options?: Object);
            /**
            * setPropsForContainerWidgetFromJsonDictionary(widget, options)
Sets the container&#39;s properties from json dictionary.
Parameters:
{ccui.Widget} widget
{Object} options
json dictionary.

            */
            setPropsForContainerWidgetFromJsonDictionary(widget?: ccui.Widget, options?: Object);
            /**
            * setPropsForImageViewFromJsonDictionary(widget, options)
Sets ccui.ImageView&#39;s properties from json object.
Parameters:
{ccui.ImageView} widget
{Object} options

            */
            setPropsForImageViewFromJsonDictionary(widget?: ccui.ImageView, options?: Object);
            /**
            * setPropsForLabelAtlasFromJsonDictionary(widget, options)
Sets ccui.TextAtlas&#39; properties from json object.
Parameters:
{ccui.TextAtlas} widget
{Object} options

            */
            setPropsForLabelAtlasFromJsonDictionary(widget?: ccui.TextAtlas, options?: Object);
            /**
            * setPropsForLabelBMFontFromJsonDictionary(widget, options)
Sets ccui.TextBMFont&#39;s properties from json dictionary.
Parameters:
{ccui.TextBMFont} widget
{Object} options
json dictionary

            */
            setPropsForLabelBMFontFromJsonDictionary(widget?: ccui.TextBMFont, options?: Object);
            /**
            * setPropsForLabelFromJsonDictionary(widget, options)
Sets ccui.Text&#39;s properties from json object.
Parameters:
{ccui.Text} widget
{Object} options
json dictionary

            */
            setPropsForLabelFromJsonDictionary(widget?: ccui.Text, options?: Object);
            /**
            * setPropsForLayoutFromJsonDictionary(widget, options)
Sets ccui.Layout&#39;s properties from json object.
Parameters:
{ccui.Layout} widget
{Object} options

            */
            setPropsForLayoutFromJsonDictionary(widget?: ccui.Layout, options?: Object);
            /**
            * setPropsForListViewFromJsonDictionary(widget, options)
Sets ccui.ListView&#39;s properties from json dictionary.
Parameters:
{ccui.ListView} widget
{Object} options
json dictionary

            */
            setPropsForListViewFromJsonDictionary(widget?: ccui.ListView, options?: Object);
            /**
            * setPropsForLoadingBarFromJsonDictionary(widget, options)
Sets ccui.LoadingBar&#39;s properties from json dictionary.
Parameters:
{ccui.LoadingBar} widget
{Object} options
json dictionary

            */
            setPropsForLoadingBarFromJsonDictionary(widget?: ccui.LoadingBar, options?: Object);
            /**
            * setPropsForPageViewFromJsonDictionary(widget, options)
Sets ccui.PageView&#39;s properties from json dictionary.
Parameters:
{ccui.PageView} widget
{Object} options
json dictionary

            */
            setPropsForPageViewFromJsonDictionary(widget?: ccui.PageView, options?: Object);
            /**
            * setPropsForScrollViewFromJsonDictionary(widget, options)
Sets ccui.ScrollView&#39;s properties from json dictionary.
Parameters:
{ccui.ScrollView} widget
{Object} options
json dictionary.

            */
            setPropsForScrollViewFromJsonDictionary(widget?: ccui.ScrollView, options?: Object);
            /**
            * setPropsForSliderFromJsonDictionary(widget, options)
Sets ccui.Slider&#39;s properties from json dictionary.
Parameters:
{ccui.Slider} widget
{Object} options
json dictionary.

            */
            setPropsForSliderFromJsonDictionary(widget?: ccui.Slider, options?: Object);
            /**
            * setPropsForTextAreaFromJsonDictionary(widget, options)
Sets ccui.TextField&#39;s properties from json object.
Parameters:
{ccui.TextField} widget
{Object} options

            */
            setPropsForTextAreaFromJsonDictionary(widget?: ccui.TextField, options?: Object);
            /**
            * setPropsForTextButtonFromJsonDictionary(widget, options)
Sets ccui.Button&#39;s text properties from json dictionary.
Parameters:
{ccui.Button} widget
{Object} options

            */
            setPropsForTextButtonFromJsonDictionary(widget?: ccui.Button, options?: Object);
            /**
            * setPropsForTextFieldFromJsonDictionary(widget, options)
Sets ccui.TextField&#39;s properties from json dictionary.
Parameters:
{ccui.TextField} widget
{Object} options
json dictionary

            */
            setPropsForTextFieldFromJsonDictionary(widget?: ccui.TextField, options?: Object);
            /**
            * setPropsForWidgetFromJsonDictionary(widget, options)
Sets widget&#39;s properties from json dictionary.
Parameters:
{ccui.Widget} widget
{Object} options
the json dictionary.

            */
            setPropsForWidgetFromJsonDictionary(widget?: ccui.Widget, options?: Object);
            /**
            * {ccui.Widget}
widgetFromJsonDictionary(data)
Creates a widget by json dictionary.
Parameters:
{Object} data
Returns:
{ccui.Widget}

            */
            widgetFromJsonDictionary(data?: Object): ccui.Widget;
        }
    }
declare module ccs {
        /**
        * 
The widget properties reader to parse Cocostudio exported file v1.0 higher.

        */
        export class WidgetPropertiesReader0300 extends ccs.WidgetPropertiesReader {
            /**
            * The widget properties reader to parse Cocostudio exported file v1.0 higher.
            */
            constructor();
            /**
            * {ccui.Widget}
createWidget(jsonDict, fullPath, fileName)
Creates widget by json object.
Parameters:
{Object} jsonDict
json dictionary
{String} fullPath
{String} fileName
Returns:
{ccui.Widget}

            */
            createWidget(jsonDict?: Object, fullPath?: string, fileName?: string): ccui.Widget;
            /**
            * setColorPropsForWidgetFromJsonDictionary(widget, options)
Sets widget&#39;s color, anchor point, flipped properties from json dictionary.
Parameters:
{ccui.Widget} widget
{Object} options
json dictionary

            */
            setColorPropsForWidgetFromJsonDictionary(widget?: ccui.Widget, options?: Object);
            /**
            * setPropsForAllCustomWidgetFromJsonDictionary(classType, widget, customOptions)
Sets widget&#39;s custom properties from json dictionary
Parameters:
{String} classType
class type
{ccui.Widget} widget
{Object} customOptions

            */
            setPropsForAllCustomWidgetFromJsonDictionary(classType?: string, widget?: ccui.Widget, customOptions?: Object);
            /**
            * setPropsForAllWidgetFromJsonDictionary(reader, widget, options)
Sets widget&#39;s foundation properties from json dictionary.
Parameters:
{Object} reader
widget reader
{ccui.Widget} widget
{Object} options
json dictionary

            */
            setPropsForAllWidgetFromJsonDictionary(reader?: Object, widget?: ccui.Widget, options?: Object);
            /**
            * setPropsForButtonFromJsonDictionary(widget, options)
Sets ccui.Button&#39;s properties from json dictionary.
Parameters:
{ccui.Button} widget
{Object} options
json dictionary

            */
            setPropsForButtonFromJsonDictionary(widget?: ccui.Button, options?: Object);
            /**
            * setPropsForCheckBoxFromJsonDictionary(widget, options)
Sets ccui.CheckBox&#39;s properties from json dictionary.
Parameters:
{ccui.CheckBox} widget
{Object} options
json dictionary

            */
            setPropsForCheckBoxFromJsonDictionary(widget?: ccui.CheckBox, options?: Object);
            /**
            * setPropsForImageViewFromJsonDictionary(widget, options)
Sets ccui.ImageView&#39;s properties from json dictionary.
Parameters:
{ccui.ImageView} widget
{Object} options
json dictionary

            */
            setPropsForImageViewFromJsonDictionary(widget?: ccui.ImageView, options?: Object);
            /**
            * setPropsForLabelAtlasFromJsonDictionary(widget, options)
Sets ccui.TextAtlas&#39;s properties from json dictionary.
Parameters:
{ccui.TextAtlas} widget
{Object} options
json dictionary

            */
            setPropsForLabelAtlasFromJsonDictionary(widget?: ccui.TextAtlas, options?: Object);
            /**
            * setPropsForLabelBMFontFromJsonDictionary(widget, options)
Sets ccui.TextBMFont&#39;s properties from json dictionary.
Parameters:
{ccui.TextBMFont} widget
{Object} options
json dictionary

            */
            setPropsForLabelBMFontFromJsonDictionary(widget?: ccui.TextBMFont, options?: Object);
            /**
            * setPropsForLabelFromJsonDictionary(widget, options)
Sets ccui.Text&#39;s properties from json dictionary.
Parameters:
{ccui.Text} widget
{Object} options
json dictionary

            */
            setPropsForLabelFromJsonDictionary(widget?: ccui.Text, options?: Object);
            /**
            * setPropsForLayoutFromJsonDictionary(widget, options)
Sets ccui.Layout&#39;s properties from json dictionary.
Parameters:
{ccui.Layout} widget
{Object} options
json dictionary

            */
            setPropsForLayoutFromJsonDictionary(widget?: ccui.Layout, options?: Object);
            /**
            * setPropsForListViewFromJsonDictionary(widget, options)
Sets ccui.ListView&#39;s properties from json dictionary.
Parameters:
{ccui.ListView} widget
{Object} options
json dictionary

            */
            setPropsForListViewFromJsonDictionary(widget?: ccui.ListView, options?: Object);
            /**
            * setPropsForLoadingBarFromJsonDictionary(widget, options)
Sets ccui.LoadingBar&#39;s properties from json dictionary.
Parameters:
{ccui.LoadingBar} widget
{Object} options
json dictionary

            */
            setPropsForLoadingBarFromJsonDictionary(widget?: ccui.LoadingBar, options?: Object);
            /**
            * setPropsForPageViewFromJsonDictionary(widget, options)
Sets ccui.PageView&#39;s properties from json dictionary.
Parameters:
{ccui.PageView} widget
{Object} options
json dictionary

            */
            setPropsForPageViewFromJsonDictionary(widget?: ccui.PageView, options?: Object);
            /**
            * setPropsForScrollViewFromJsonDictionary(widget, options)
Sets ccui.ScrollView&#39;s properties from json dictionary.
Parameters:
{ccui.ScrollView} widget
{Object} options
json dictionary

            */
            setPropsForScrollViewFromJsonDictionary(widget?: ccui.ScrollView, options?: Object);
            /**
            * setPropsForSliderFromJsonDictionary(widget, options)
Sets ccui.Slider&#39;s properties from json dictionary.
Parameters:
{ccui.Slider} widget
{Object} options
json dictionary

            */
            setPropsForSliderFromJsonDictionary(widget?: ccui.Slider, options?: Object);
            /**
            * setPropsForTextAreaFromJsonDictionary(widget, options)
Sets ccui.TextField&#39;s properties from json dictionary.
Parameters:
{ccui.TextField} widget
{Object} options
json dictionary

            */
            setPropsForTextAreaFromJsonDictionary(widget?: ccui.TextField, options?: Object);
            /**
            * setPropsForTextButtonFromJsonDictionary(widget, options)
Sets ccui.Button&#39;s text properties from json dictionary.
Parameters:
{ccui.Button} widget
{Object} options
json dictionary

            */
            setPropsForTextButtonFromJsonDictionary(widget?: ccui.Button, options?: Object);
            /**
            * setPropsForTextFieldFromJsonDictionary(widget, options)
Sets ccui.TextField&#39;s text properties from json dictionary.
Parameters:
{ccui.TextField} widget
{Object} options
json dictionary

            */
            setPropsForTextFieldFromJsonDictionary(widget?: ccui.TextField, options?: Object);
            /**
            * setPropsForWidgetFromJsonDictionary(widget, options)
Sets widget&#39;s foundation properties from json dictionary.
Parameters:
{ccui.Widget} widget
{Object} options
json dictionary

            */
            setPropsForWidgetFromJsonDictionary(widget?: ccui.Widget, options?: Object);
            /**
            * {ccui.Widget}
widgetFromJsonDictionary(data)
Creates a widget from json dictionary.
Parameters:
{Object} data
json data
Returns:
{ccui.Widget}

            */
            widgetFromJsonDictionary(data?: Object): ccui.Widget;
        }
    }
declare module ccui {
        /**
        * 
The button controls of Cocos UI.

        */
        export class Button extends ccui.Widget {
            /**
            * The button controls of Cocos UI.
            */
            constructor();
            /**
            * The disabled renderer&#39;s zOrder value.
            */
            static DISABLED_RENDERER_ZORDER;
            /**
            * The normal renderer&#39;s zOrder value.
            */
            static NORMAL_RENDERER_ZORDER;
            /**
            * The pressed renderer&#39;s zOrder value.
            */
            static PRESSED_RENDERER_ZORDER;
            /**
            * - Indicate whether button has zoom effect when clicked
            */
            pressedActionEnabled: boolean;
            /**
            * The title renderer&#39;s zOrder value.
            */
            static TITLE_RENDERER_ZORDER;
            /**
            * - The content string font of the button title
            */
            titleFont: string;
            /**
            * - The content string font color of the button title
            */
            titleFontColor: cc.Color;
            /**
            * - The content string font name of the button title
            */
            titleFontName: string;
            /**
            * - The content string font size of the button title
            */
            titleFontSize: number;
            /**
            * - The content string of the button title
            */
            titleText: string;
            /**
            * &amp;lt;static&amp;gt;
{ccui.Button}
ccui.Button.create(normalImage, selectedImage, disableImage, texType)
allocates and initializes a UIButton.
Parameters:
{string} normalImage
Optional
normal state texture name
{string} selectedImage
Optional
selected state texture name
{string} disableImage
Optional
disabled state texture name
{string} texType
Optional
Deprecated:
since v3.0, please use new ccui.Button() instead.
Returns:
{ccui.Button}

            */
            static create(normalImage?: string, selectedImage?: string, disableImage?: string, texType?: string): ccui.Button;
            /**
            * ctor(normalImage, selectedImage, disableImage, texType)
Allocates and initializes a UIButton.
Constructor of ccui.Button. override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
// example
var uiButton = new ccui.Button();
Parameters:
{String} normalImage
{String} selectedImage
Optional, Default: &quot;&quot;
{String} disableImage
Optional, Default: &quot;&quot;
{Number} texType
Optional, Default: ccui.Widget.LOCAL_TEXTURE

            */
            ctor(normalImage?: string, selectedImage?: string, disableImage?: string, texType?: number);
            /**
            * {cc.Rect}
getCapInsetsDisabledRenderer()
Returns disable renderer cap insets.
Returns:
{cc.Rect}

            */
            getCapInsetsDisabledRenderer(): cc.Rect;
            /**
            * {cc.Rect}
getCapInsetsNormalRenderer()
Returns normal renderer cap insets.
Returns:
{cc.Rect}

            */
            getCapInsetsNormalRenderer(): cc.Rect;
            /**
            * {cc.Rect}
getCapInsetsPressedRenderer()
Returns pressed renderer cap insets.
Returns:
{cc.Rect}

            */
            getCapInsetsPressedRenderer(): cc.Rect;
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of widget.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * {cc.Color}
getTitleColor()
Returns title color of ccui.Button
Returns:
{cc.Color}

            */
            getTitleColor(): cc.Color;
            /**
            * {String}
getTitleFontName()
Gets title fontName of ccui.Button.
Returns:
{String}

            */
            getTitleFontName(): string;
            /**
            * {cc.Size}
getTitleFontSize()
Returns title fontSize of ccui.Button.
Returns:
{cc.Size}

            */
            getTitleFontSize(): cc.Size;
            /**
            * {cc.LabelTTF}
getTitleRenderer()
Get the title renderer.
title ttf object.
Returns:
{cc.LabelTTF}

            */
            getTitleRenderer(): cc.LabelTTF;
            /**
            * {String}
getTitleText()
Returns title text of ccui.Button
Returns:
{String} text

            */
            getTitleText(): string;
            /**
            * {cc.Node}
getVirtualRenderer()
Gets the Virtual Renderer of widget.
Returns:
{cc.Node}

            */
            getVirtualRenderer(): cc.Node;
            /**
            * {cc.Size}
getVirtualRendererSize()
Returns the renderer size.
Returns:
{cc.Size}

            */
            getVirtualRendererSize(): cc.Size;
            /**
            * ignoreContentAdaptWithSize(ignore)
Sets whether ignore the widget size
Parameters:
{Boolean} ignore
true that widget will ignore it&#39;s size, use texture size, false otherwise. Default value is true.

            */
            ignoreContentAdaptWithSize(ignore?: boolean);
            /**
            * {boolean}
init(normalImage, selectedImage, disableImage, texType)
Initializes a button. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Parameters:
{String} normalImage
{String} selectedImage
Optional, Default: &quot;&quot;
{String} disableImage
Optional, Default: &quot;&quot;
{Number} texType
Optional, Default: ccui.Widget.LOCAL_TEXTURE
Returns:
{boolean}

            */
            init(normalImage?: string, selectedImage?: string, disableImage?: string, texType?: number): boolean;
            /**
            * {Boolean}
isScale9Enabled()
Returns button is using scale9 renderer or not.
Returns:
{Boolean}

            */
            isScale9Enabled(): boolean;
            /**
            * loadTextureDisabled(disabled, texType)
Load dark state texture for button.
Parameters:
{String} disabled
disabled state of texture&#39;s filename.
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTextureDisabled(disabled?: string, texType?: any);
            /**
            * loadTextureNormal(normal, texType)
Load normal state texture for button.
Parameters:
{String} normal
normal state of texture&#39;s filename.
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTextureNormal(normal?: string, texType?: any);
            /**
            * loadTexturePressed(selected, texType)
Load selected state texture for button.
Parameters:
{String} selected
selected state of texture&#39;s filename.
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTexturePressed(selected?: string, texType?: any);
            /**
            * loadTextures(normal, selected, disabled, texType)
Load textures for button.
Parameters:
{String} normal
normal state of texture&#39;s filename.
{String} selected
selected state of texture&#39;s filename.
{String} disabled
disabled state of texture&#39;s filename.
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTextures(normal?: string, selected?: string, disabled?: string, texType?: any);
            /**
            * setCapInsets(capInsets)
Sets capinsets for button, if button is using scale9 renderer.
Parameters:
{cc.Rect} capInsets

            */
            setCapInsets(capInsets?: cc.Rect);
            /**
            * setCapInsetsDisabledRenderer(capInsets)
Sets capinsets for button, if button is using scale9 renderer.
Parameters:
{cc.Rect} capInsets

            */
            setCapInsetsDisabledRenderer(capInsets?: cc.Rect);
            /**
            * setCapInsetsNormalRenderer(capInsets)
Sets capinsets for button, if button is using scale9 renderer.
Parameters:
{cc.Rect} capInsets

            */
            setCapInsetsNormalRenderer(capInsets?: cc.Rect);
            /**
            * setCapInsetsPressedRenderer(capInsets)
Sets capinsets for button, if button is using scale9 renderer.
Parameters:
{cc.Rect} capInsets

            */
            setCapInsetsPressedRenderer(capInsets?: cc.Rect);
            /**
            * setPressedActionEnabled(enabled)
Changes if button can be clicked zoom effect.
Parameters:
{Boolean} enabled

            */
            setPressedActionEnabled(enabled?: boolean);
            /**
            * setScale9Enabled(able)
Sets if button is using scale9 renderer.
Parameters:
{Boolean} able
true that using scale9 renderer, false otherwise.

            */
            setScale9Enabled(able?: boolean);
            /**
            * setTitleColor(color)
Sets title color to ccui.Button.
Parameters:
{cc.Color} color

            */
            setTitleColor(color?: cc.Color);
            /**
            * setTitleFontName(fontName)
Sets title fontName to ccui.Button.
Parameters:
{String} fontName

            */
            setTitleFontName(fontName?: string);
            /**
            * setTitleFontSize(size)
Sets title fontSize to ccui.Button
Parameters:
{cc.Size} size

            */
            setTitleFontSize(size?: cc.Size);
            /**
            * setTitleText(text)
Sets title text to ccui.Button
Parameters:
{String} text

            */
            setTitleText(text?: string);
        }
    }
declare module ccui {
        /**
        * 
The CheckBox control of Cocos UI.

        */
        export class CheckBox extends ccui.Widget {
            /**
            * The CheckBox control of Cocos UI.
            */
            constructor();
            /**
            * The disabled Background renderer&#39;s zOrder
            */
            static BOX_DISABLED_RENDERER_ZORDER;
            /**
            * The normal background renderer&#39;s zOrder
            */
            static BOX_RENDERER_ZORDER;
            /**
            * The selected Background renderer&#39;s zOrder
            */
            static BOX_SELECTED_RENDERER_ZORDER;
            /**
            * The selected state of ccui.CheckBox&#39;s event.
            */
            static EVENT_SELECTED;
            /**
            * The unselected state of ccui.CheckBox&#39;s event.
            */
            static EVENT_UNSELECTED;
            /**
            * The disabled front renderer&#39;s zOrder
            */
            static FRONT_CROSS_DISABLED_RENDERER_ZORDER;
            /**
            * The normal front renderer&#39;s zOrder
            */
            static FRONT_CROSS_RENDERER_ZORDER;
            /**
            * - Indicate whether the check box has been selected
            */
            selected: boolean;
            /**
            * addEventListener(selector, target)
add a call back function would called when checkbox is selected or unselected.
Parameters:
{Function} selector
{Object} target
Optional

            */
            addEventListener(selector?: Function, target?: Object);
            /**
            * addEventListenerCheckBox(selector, target)
add event listener to ccui.CheckBox. it would called when checkbox is selected or unselected.
Parameters:
{Function} selector
{Object} target
Optional
Deprecated:
since v3.0, please use addEventListener instead.

            */
            addEventListenerCheckBox(selector?: Function, target?: Object);
            /**
            * &amp;lt;static&amp;gt;
{ccui.CheckBox}
ccui.CheckBox.create(backGround, backGroundSeleted, cross, backGroundDisabled, frontCrossDisabled, texType)
allocates and initializes a UICheckBox.
// example
var uiCheckBox = new ccui.CheckBox();
Parameters:
{string} backGround
Optional
backGround texture.
{string} backGroundSeleted
Optional
backGround selected state texture.
{string} cross
Optional
cross texture.
{string} backGroundDisabled
Optional
cross dark state texture.
{string} frontCrossDisabled
Optional
cross dark state texture.
{Number} texType
Optional
Deprecated:
since v3.0, please use new ccui.CheckBox() instead.
Returns:
{ccui.CheckBox}

            */
            static create(backGround?: string, backGroundSeleted?: string, cross?: string, backGroundDisabled?: string, frontCrossDisabled?: string, texType?: number): ccui.CheckBox;
            /**
            * ctor(backGround, backGroundSelected, cross, backGroundDisabled, frontCrossDisabled, texType)
allocates and initializes a UICheckBox.
Constructor of ccui.CheckBox, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
// example
var uiCheckBox = new ccui.CheckBox();
Parameters:
{String} backGround
{String} backGroundSelected
{String} cross
{String} backGroundDisabled
{String} frontCrossDisabled
{Number} texType
Optional, Default: ccui.Widget.LOCAL_TEXTURE

            */
            ctor(backGround?: string, backGroundSelected?: string, cross?: string, backGroundDisabled?: string, frontCrossDisabled?: string, texType?: number);
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of widget.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * getSelectedState()
Deprecated:
since v3.1, please use isSelected.

            */
            getSelectedState();
            /**
            * {cc.Node}
getVirtualRenderer()
override &quot;getVirtualRenderer&quot; method of widget.
Returns:
{cc.Node} the renderer of ccui.CheckBox.

            */
            getVirtualRenderer(): cc.Node;
            /**
            * {cc.Size}
getVirtualRendererSize()
Returns the content size of Renderer.
Returns:
{cc.Size}

            */
            getVirtualRendererSize(): cc.Size;
            /**
            * {boolean}
init(backGround, backGroundSelected, cross, backGroundDisabled, frontCrossDisabled, texType)
Initializes a checkBox. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Parameters:
{String} backGround
{String} backGroundSelected
{String} cross
{String} backGroundDisabled
{String} frontCrossDisabled
{Number} texType
Optional, Default: ccui.Widget.LOCAL_TEXTURE
Returns:
{boolean}

            */
            init(backGround?: string, backGroundSelected?: string, cross?: string, backGroundDisabled?: string, frontCrossDisabled?: string, texType?: number): boolean;
            /**
            * {boolean}
isSelected()
Returns the selected state of ccui.CheckBox.
Returns:
{boolean}

            */
            isSelected(): boolean;
            /**
            * loadTextureBackGround(backGround, texType)
Loads background texture for checkbox.
Parameters:
{String} backGround
background filename
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTextureBackGround(backGround?: string, texType?: any);
            /**
            * loadTextureBackGroundDisabled(backGroundDisabled, texType)
Loads disabled state of backGround texture for checkbox.
Parameters:
{String} backGroundDisabled
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTextureBackGroundDisabled(backGroundDisabled?: string, texType?: any);
            /**
            * loadTextureBackGroundSelected(backGroundSelected, texType)
Loads selected state of background texture for checkbox.
Parameters:
{String} backGroundSelected
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTextureBackGroundSelected(backGroundSelected?: string, texType?: any);
            /**
            * loadTextureFrontCross(cross, texType)
Loads cross texture for checkbox.
Parameters:
{String} cross
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTextureFrontCross(cross?: string, texType?: any);
            /**
            * loadTextureFrontCrossDisabled(frontCrossDisabled, texType)
Loads frontCrossDisabled texture for checkbox.
Parameters:
{String} frontCrossDisabled
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTextureFrontCrossDisabled(frontCrossDisabled?: string, texType?: any);
            /**
            * loadTextures(backGround, backGroundSelected, cross, backGroundDisabled, frontCrossDisabled, texType)
Loads textures for checkbox.
Parameters:
{String} backGround
{String} backGroundSelected
{String} cross
{String} backGroundDisabled
{String} frontCrossDisabled
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTextures(backGround?: string, backGroundSelected?: string, cross?: string, backGroundDisabled?: string, frontCrossDisabled?: string, texType?: any);
            /**
            * setSelected(selected)
Sets the selected state to ccui.CheckBox
Parameters:
{Boolean} selected

            */
            setSelected(selected?: boolean);
            /**
            * setSelectedState(selected)
Parameters:
selected
Deprecated:
since v3.1, please use setSelected.

            */
            setSelectedState();
        }
    }
declare module ccui {
        /**
        * 
The same as cc.Class

        */
        export class Class  {
            /**
            * The same as cc.Class
            */
            constructor();
        }
    }
declare module ccui {
        /**
        * 
The horizontal box of Cocos UI. Its layout type is ccui.Layout.LINEAR_HORIZONTAL.

        */
        export class HBox extends ccui.Layout {
            /**
            * The horizontal box of Cocos UI.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{ccui.HBox}
ccui.HBox.create(size)
Creates a HBox object
Parameters:
{cc.Size} size
Deprecated:
since v3.0, please use new ccui.HBox(size) instead.
Returns:
{ccui.HBox}

            */
            static create(size?: cc.Size): ccui.HBox;
            /**
            * ctor(size)
The constructor of ccui.HBox
Parameters:
{cc.Size} size
Optional

            */
            ctor(size?: cc.Size);
            /**
            * {boolean}
init()
Initialize a HBox. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * {boolean}
initWithSize(size)
Initializes a HBox with size.
Parameters:
size
Returns:
{boolean}

            */
            initWithSize(): boolean;
        }
    }
declare module ccui {
        /**
        * 
ccui.helper is the singleton object which is the Helper object contains some functions for seek widget

        */
        export class helper  {
            /**
            * ccui.helper is the singleton object which is the Helper object contains some functions for seek widget
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{ccui.Widget}
ccui.helper.seekActionWidgetByActionTag(root, tag)
Finds a widget whose action tag equals to param name from root widget.
Parameters:
{ccui.Widget} root
{Number} tag
Returns:
{ccui.Widget}

            */
            static seekActionWidgetByActionTag(root?: ccui.Widget, tag?: number): ccui.Widget;
            /**
            * &amp;lt;static&amp;gt;
{ccui.Widget}
ccui.helper.seekWidgetByName(root, name)
Finds a widget whose name equals to param name from root widget.
Parameters:
{ccui.Widget} root
{String} name
Returns:
{ccui.Widget}

            */
            static seekWidgetByName(root?: ccui.Widget, name?: string): ccui.Widget;
            /**
            * &amp;lt;static&amp;gt;
{ccui.Widget}
ccui.helper.seekWidgetByRelativeName(root, name)
Finds a widget whose name equals to param name from root widget.
RelativeLayout will call this method to find the widget witch is needed.
Parameters:
{ccui.Widget} root
{String} name
Returns:
{ccui.Widget}

            */
            static seekWidgetByRelativeName(root?: ccui.Widget, name?: string): ccui.Widget;
            /**
            * &amp;lt;static&amp;gt;
{ccui.Widget}
ccui.helper.seekWidgetByTag(root, tag)
Finds a widget whose tag equals to param tag from root widget.
Parameters:
{ccui.Widget} root
{number} tag
Returns:
{ccui.Widget}

            */
            static seekWidgetByTag(root?: ccui.Widget, tag?: number): ccui.Widget;
        }
    }
declare module ccui {
        /**
        * 
The ImageView control of Cocos GUI

        */
        export class ImageView extends ccui.Widget {
            /**
            * The ImageView control of Cocos GUI
            */
            constructor();
            /**
            * The zOrder value of ccui.ImageView&#39;s renderer.
            */
            static RENDERER_ZORDER;
            /**
            * &amp;lt;static&amp;gt;
{ccui.ImageView}
ccui.ImageView.create(imageFileName, texType)
Allocates and initializes a UIImageView.
Parameters:
{string} imageFileName
{Number} texType
Deprecated:
since v3.0, please use new ccui.ImageView() instead.
Returns:
{ccui.ImageView}

            */
            static create(imageFileName?: string, texType?: number): ccui.ImageView;
            /**
            * ctor(imageFileName, texType)
allocates and initializes a ccui.ImageView.
Constructor of ccui.ImageView, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
// example
var uiImageView = new ccui.ImageView;
Parameters:
{String} imageFileName
{Number} texType
Optional, Default: =ccui.Widget.LOCAL_TEXTURE

            */
            ctor(imageFileName?: string, texType?: number);
            /**
            * {cc.Rect}
getCapInsets()
Returns cap insets of ccui.ImageView.
Returns:
{cc.Rect}

            */
            getCapInsets(): cc.Rect;
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of ccui.ImageView.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * {cc.Node}
getVirtualRenderer()
Returns the renderer of ccui.ImageView
Returns:
{cc.Node}

            */
            getVirtualRenderer(): cc.Node;
            /**
            * {cc.Size}
getVirtualRendererSize()
Returns the image&#39;s texture size.
Returns:
{cc.Size}

            */
            getVirtualRendererSize(): cc.Size;
            /**
            * ignoreContentAdaptWithSize(ignore)
Ignore the imageView&#39;s custom size, true that imageView will ignore it&#39;s custom size, use renderer&#39;s content size, false otherwise.
Parameters:
{Boolean} ignore

            */
            ignoreContentAdaptWithSize(ignore?: boolean);
            /**
            * {boolean}
init(imageFileName, texType)
Initializes an imageView. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Parameters:
{String} imageFileName
{Number} texType
Optional, Default: =ccui.Widget.LOCAL_TEXTURE
Returns:
{boolean}

            */
            init(imageFileName?: string, texType?: number): boolean;
            /**
            * {Boolean}
isScale9Enabled()
Returns ImageView is using scale9 renderer or not.
Returns:
{Boolean}

            */
            isScale9Enabled(): boolean;
            /**
            * loadTexture(fileName, texType)
Loads textures for button.
Parameters:
{String} fileName
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTexture(fileName?: string, texType?: any);
            /**
            * setCapInsets(capInsets)
Sets capinsets for button, if button is using scale9 renderer.
Parameters:
{cc.Rect} capInsets

            */
            setCapInsets(capInsets?: cc.Rect);
            /**
            * setScale9Enabled(able)
Sets if button is using scale9 renderer.
Parameters:
{Boolean} able

            */
            setScale9Enabled(able?: boolean);
            /**
            * setTextureRect(rect)
Sets texture rect
Parameters:
{cc.Rect} rect

            */
            setTextureRect(rect?: cc.Rect);
        }
    }
declare module ccui {
        /**
        * 
ccui.Layout is the base class of  ccui.PageView and ccui.ScrollView, it does layout by layout manager
and clips area by its _clippingStencil when clippingEnabled is true.

        */
        export class Layout extends ccui.Widget {
            /**
            * ccui.Layout is the base class of  ccui.PageView and ccui.ScrollView, it does layout by layout manager
and clips area by its _clippingStencil when clippingEnabled is true.
            */
            constructor();
            /**
            * The absolute of ccui.Layout&#39;s layout type.
            */
            static ABSOLUTE;
            /**
            * The zOrder value of ccui.Layout&#39;s image background.
            */
            static BACKGROUND_IMAGE_ZORDER;
            /**
            * The zOrder value of ccui.Layout&#39;s color background.
            */
            static BACKGROUND_RENDERER_ZORDER;
            /**
            * The gradient of ccui.Layout&#39;s background color type, it will use a LayerGradient to draw the background.
            */
            static BG_COLOR_GRADIENT;
            /**
            * The None of ccui.Layout&#39;s background color type
            */
            static BG_COLOR_NONE;
            /**
            * The solid of ccui.Layout&#39;s background color type, it will use a LayerColor to draw the background.
            */
            static BG_COLOR_SOLID;
            /**
            * The scissor of ccui.Layout&#39;s clipping type.
            */
            static CLIPPING_SCISSOR;
            /**
            * The stencil of ccui.Layout&#39;s clipping type.
            */
            static CLIPPING_STENCIL;
            /**
            * - Indicate whether clipping is enabled
            */
            clippingEnabled: boolean;
            /**
            * 
            */
            clippingType: any;
            /**
            * 
            */
            layoutType: any;
            /**
            * The horizontal of ccui.Layout&#39;s layout type.
            */
            static LINEAR_HORIZONTAL;
            /**
            * The vertical of ccui.Layout&#39;s layout type.
            */
            static LINEAR_VERTICAL;
            /**
            * The relative of ccui.Layout&#39;s layout type.
            */
            static RELATIVE;
            /**
            * addChild(widget, zOrder, tag)
Adds a widget to the container.
Parameters:
{ccui.Widget} widget
{Number} zOrder
Optional
{Number|string} tag
Optional
tag or name

            */
            addChild(widget?: ccui.Widget, zOrder?: number, tag?: any);
            /**
            * &amp;lt;static&amp;gt;
{ccui.Layout}
ccui.Layout.create()
allocates and initializes a UILayout.
Deprecated:
since v3.0, please use new ccui.Layout() instead.
Returns:
{ccui.Layout}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccui.Layout;
            /**
            * ctor()
Allocates and initializes an UILayout.
Constructor of ccui.Layout
// example
var uiLayout = new ccui.Layout();

            */
            ctor();
            /**
            * {ccui.Widget}
findNextFocusedWidget(direction, current)
When a widget is in a layout, you could call this method to get the next focused widget within a specified direction.
If the widget is not in a layout, it will return itself
Parameters:
{Number} direction
the direction to look for the next focused widget in a layout
{ccui.Widget} current
the current focused widget
Returns:
{ccui.Widget} return the index of widget in the layout

            */
            findNextFocusedWidget(direction?: number, current?: ccui.Widget): ccui.Widget;
            /**
            * {cc.Color}
getBackGroundColor()
Gets background color of ccui.Layout, if color type is Layout.COLOR_SOLID.
Returns:
{cc.Color}

            */
            getBackGroundColor(): cc.Color;
            /**
            * {Number}
getBackGroundColorOpacity()
Get background opacity value of ccui.Layout.
Returns:
{Number}

            */
            getBackGroundColorOpacity(): number;
            /**
            * {ccui.Layout.BG_COLOR_NONE|ccui.Layout.BG_COLOR_SOLID|ccui.Layout.BG_COLOR_GRADIENT}
getBackGroundColorType()
Get background color type of ccui.Layout.
Returns:
{ccui.Layout.BG_COLOR_NONE|ccui.Layout.BG_COLOR_SOLID|ccui.Layout.BG_COLOR_GRADIENT}

            */
            getBackGroundColorType(): any;
            /**
            * {cc.Point}
getBackGroundColorVector()
Gets background color vector of ccui.Layout, if color type is Layout.COLOR_GRADIENT
Returns:
{cc.Point}

            */
            getBackGroundColorVector(): cc.Point;
            /**
            * {cc.Color}
getBackGroundEndColor()
Gets background end color of ccui.Layout
Returns:
{cc.Color}

            */
            getBackGroundEndColor(): cc.Color;
            /**
            * {cc.Rect}
getBackGroundImageCapInsets()
Gets background image capinsets of ccui.Layout.
Returns:
{cc.Rect}

            */
            getBackGroundImageCapInsets(): cc.Rect;
            /**
            * {cc.Color}
getBackGroundImageColor()
Gets backGround image color
Returns:
{cc.Color}

            */
            getBackGroundImageColor(): cc.Color;
            /**
            * {Number}
getBackGroundImageOpacity()
Gets backGround image opacity
Returns:
{Number}

            */
            getBackGroundImageOpacity(): number;
            /**
            * {cc.Size}
getBackGroundImageTextureSize()
Gets background image texture size.
Returns:
{cc.Size}

            */
            getBackGroundImageTextureSize(): cc.Size;
            /**
            * {cc.Color}
getBackGroundStartColor()
Gets background start color of ccui.Layout
Returns:
{cc.Color}

            */
            getBackGroundStartColor(): cc.Color;
            /**
            * {ccui.Layout.CLIPPING_STENCIL|ccui.Layout.CLIPPING_SCISSOR}
getClippingType()
Gets clipping type of ccui.Layout
Returns:
{ccui.Layout.CLIPPING_STENCIL|ccui.Layout.CLIPPING_SCISSOR}

            */
            getClippingType(): any;
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of widget.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * {null}
getLayoutType()
Gets LayoutType of ccui.Layout.
Returns:
{null}

            */
            getLayoutType(): void;
            /**
            * {boolean}
init()
override &quot;init&quot; method of widget. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * {Boolean}
isBackGroundImageScale9Enabled()
Get whether background image is use scale9 renderer.
Returns:
{Boolean}

            */
            isBackGroundImageScale9Enabled(): boolean;
            /**
            * {Boolean}
isClippingEnabled()
Gets if layout is clipping enabled.
Returns:
{Boolean} if layout is clipping enabled.

            */
            isClippingEnabled(): boolean;
            /**
            * {boolean}
isLoopFocus()
Gets whether enable focus loop
Returns:
{boolean} If focus loop is enabled, then it will return true, otherwise it returns false. The default value is false.

            */
            isLoopFocus(): boolean;
            /**
            * {boolean}
isPassFocusToChild()
Returns whether the layout will pass the focus to its children or not. The default value is true
Returns:
{boolean} To query whether the layout will pass the focus to its children or not. The default value is true

            */
            isPassFocusToChild(): boolean;
            /**
            * onEnter()
Calls its parent&#39;s onEnter, and calls its clippingStencil&#39;s onEnter if clippingStencil isn&#39;t null.

            */
            onEnter();
            /**
            * onExit()
Calls its parent&#39;s onExit, and calls its clippingStencil&#39;s onExit if clippingStencil isn&#39;t null.

            */
            onExit();
            /**
            * onPassFocusToChild(direction, current)
To specify a user-defined functor to decide which child widget of the layout should get focused
Parameters:
{Number} direction
{ccui.Widget} current

            */
            onPassFocusToChild(direction?: number, current?: ccui.Widget);
            /**
            * removeAllChildren(cleanup)
Removes all children from the container with a cleanup, and sets the layout dirty flag to true.
Parameters:
{Boolean} cleanup

            */
            removeAllChildren(cleanup?: boolean);
            /**
            * removeAllChildrenWithCleanup(cleanup)
Removes all children from the container, do a cleanup to all running actions depending on the cleanup parameter,
and sets the layout dirty flag to true.
Parameters:
{Boolean} cleanup
true if all running actions on all children nodes should be cleanup, false otherwise.

            */
            removeAllChildrenWithCleanup(cleanup?: boolean);
            /**
            * removeBackGroundImage()
Remove the background image of ccui.Layout.

            */
            removeBackGroundImage();
            /**
            * removeChild(widget, cleanup)
Removes child widget from ccui.Layout, and sets the layout dirty flag to true.
Parameters:
{ccui.Widget} widget
{Boolean} cleanup
Optional, Default: true

            */
            removeChild(widget?: ccui.Widget, cleanup?: boolean);
            /**
            * requestDoLayout()
request do layout, it will do layout at visit calls

            */
            requestDoLayout();
            /**
            * setBackGroundColor(color, endColor)
Sets background color for layout, if color type is Layout.COLOR_SOLID
Parameters:
{cc.Color} color
{cc.Color} endColor
Optional

            */
            setBackGroundColor(color?: cc.Color, endColor?: cc.Color);
            /**
            * setBackGroundColorOpacity(opacity)
Sets background opacity to ccui.Layout.
Parameters:
{number} opacity

            */
            setBackGroundColorOpacity(opacity?: number);
            /**
            * setBackGroundColorType(type)
Sets Color Type for ccui.Layout.
Parameters:
{ccui.Layout.BG_COLOR_NONE|ccui.Layout.BG_COLOR_SOLID|ccui.Layout.BG_COLOR_GRADIENT} type

            */
            setBackGroundColorType(type?: any);
            /**
            * setBackGroundColorVector(vector)
Sets background color vector for layout, if color type is Layout.COLOR_GRADIENT
Parameters:
{cc.Point} vector

            */
            setBackGroundColorVector(vector?: cc.Point);
            /**
            * setBackGroundImage(fileName, texType)
Sets a background image for layout
Parameters:
{String} fileName
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            setBackGroundImage(fileName?: string, texType?: any);
            /**
            * setBackGroundImageCapInsets(capInsets)
Sets a background image CapInsets for layout, if the background image is a scale9 render.
Parameters:
{cc.Rect} capInsets
capinsets of background image.

            */
            setBackGroundImageCapInsets(capInsets?: cc.Rect);
            /**
            * setBackGroundImageColor(color)
Sets backGround image color
Parameters:
{cc.Color} color

            */
            setBackGroundImageColor(color?: cc.Color);
            /**
            * setBackGroundImageOpacity(opacity)
Sets backGround image Opacity
Parameters:
{Number} opacity

            */
            setBackGroundImageOpacity(opacity?: number);
            /**
            * setBackGroundImageScale9Enabled(able)
Sets background image use scale9 renderer.
Parameters:
{Boolean} able
true that use scale9 renderer, false otherwise.

            */
            setBackGroundImageScale9Enabled(able?: boolean);
            /**
            * setClippingEnabled(able)
Changes if layout can clip it&#39;s content and locChild.
If you really need this, please enable it. But it would reduce the rendering efficiency.
Parameters:
{Boolean} able
clipping enabled.

            */
            setClippingEnabled(able?: boolean);
            /**
            * setClippingType(type)
Sets clipping type to ccui.Layout
Parameters:
{ccui.Layout.CLIPPING_STENCIL|ccui.Layout.CLIPPING_SCISSOR} type

            */
            setClippingType(type?: any);
            /**
            * setLayoutType(type)
Sets LayoutType to ccui.Layout, LayoutManager will do layout by layout type..
Parameters:
{ccui.Layout.ABSOLUTE|ccui.Layout.LINEAR_VERTICAL|ccui.Layout.LINEAR_HORIZONTAL|ccui.Layout.RELATIVE} type

            */
            setLayoutType(type?: any);
            /**
            * setLoopFocus(loop)
If a layout is loop focused which means that the focus movement will be inside the layout
Parameters:
{Boolean} loop
pass true to let the focus movement loop inside the layout

            */
            setLoopFocus(loop?: boolean);
            /**
            * setPassFocusToChild(pass)
Specifies whether the layout pass its focus to its child
Parameters:
pass
To specify whether the layout pass its focus to its child

            */
            setPassFocusToChild();
            /**
            * visit(ctx)
Calls adaptRenderers (its subclass will override it.) and do layout.
If clippingEnabled is true, it will clip/scissor area.
Parameters:
{CanvasRenderingContext2D|WebGLRenderingContext} ctx

            */
            visit(ctx?: any);
        }
    }
declare module ccui {
        /**
        * 
Layout parameter contains a margin and layout parameter type. It uses for ccui.LayoutManager.

        */
        export class LayoutParameter extends ccui.Class {
            /**
            * Layout parameter contains a margin and layout parameter type.
            */
            constructor();
            /**
            * The linear of ccui.LayoutParameter&#39;s type.
            */
            static LINEAR;
            /**
            * The none of ccui.LayoutParameter&#39;s type.
            */
            static NONE;
            /**
            * The relative of ccui.LayoutParameter&#39;s type.
            */
            static RELATIVE;
            /**
            * {ccui.LayoutParameter}
clone()
Clones a ccui.LayoutParameter object from itself.
Returns:
{ccui.LayoutParameter}

            */
            clone(): ccui.LayoutParameter;
            /**
            * &amp;lt;static&amp;gt;
{ccui.LayoutParameter}
ccui.LayoutParameter.create()
allocates and initializes a LayoutParameter.
Returns:
{ccui.LayoutParameter}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccui.LayoutParameter;
            /**
            * ctor()
The constructor of ccui.LayoutParameter.

            */
            ctor();
            /**
            * {Number}
getLayoutType()
Gets LayoutParameterType of LayoutParameter.
Returns:
{Number}

            */
            getLayoutType(): number;
            /**
            * {ccui.Margin}
getMargin()
Gets Margin of LayoutParameter.
Returns:
{ccui.Margin}

            */
            getMargin(): ccui.Margin;
            /**
            * setMargin(margin)
Sets Margin to LayoutParameter.
Parameters:
{ccui.Margin} margin

            */
            setMargin(margin?: ccui.Margin);
        }
    }
declare module ccui {
        /**
        * 
ccui.linearHorizontalLayoutManager is a singleton object which is the linear horizontal layout manager for ccui.Layout

        */
        export class linearHorizontalLayoutManager  {
            /**
            * ccui.linearHorizontalLayoutManager is a singleton object which is the linear horizontal layout manager for ccui.Layout
            */
            constructor();
        }
    }
declare module ccui {
        /**
        * 
The linear of Layout parameter. its parameter type is ccui.LayoutParameter.LINEAR.

        */
        export class LinearLayoutParameter extends ccui.LayoutParameter {
            /**
            * The linear of Layout parameter.
            */
            constructor();
            /**
            * The bottom of ccui.LinearLayoutParameter&#39;s linear gravity.
            */
            static BOTTOM;
            /**
            * The center horizontal of ccui.LinearLayoutParameter&#39;s linear gravity.
            */
            static CENTER_HORIZONTAL;
            /**
            * The center vertical of ccui.LinearLayoutParameter&#39;s linear gravity.
            */
            static CENTER_VERTICAL;
            /**
            * The left of ccui.LinearLayoutParameter&#39;s linear gravity.
            */
            static LEFT;
            /**
            * The none of ccui.LinearLayoutParameter&#39;s linear gravity.
            */
            static NONE;
            /**
            * The right of ccui.LinearLayoutParameter&#39;s linear gravity.
            */
            static RIGHT;
            /**
            * The top of ccui.LinearLayoutParameter&#39;s linear gravity.
            */
            static TOP;
            /**
            * &amp;lt;static&amp;gt;
{ccui.LinearLayoutParameter}
ccui.LinearLayoutParameter.create()
allocates and initializes a LinearLayoutParameter.
Deprecated:
since v3.0, please use new construction instead
Returns:
{ccui.LinearLayoutParameter}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccui.LinearLayoutParameter;
            /**
            * ctor()
The constructor of ccui.LinearLayoutParameter.

            */
            ctor();
            /**
            * {Number}
getGravity()
Gets LinearGravity of LayoutParameter.
Returns:
{Number}

            */
            getGravity(): number;
            /**
            * setGravity(gravity)
Sets LinearGravity to LayoutParameter.
Parameters:
{Number} gravity

            */
            setGravity(gravity?: number);
        }
    }
declare module ccui {
        /**
        * 
ccui.linearVerticalLayoutManager is a singleton object which is the linear vertical layout manager for ccui.Layout.

        */
        export class linearVerticalLayoutManager  {
            /**
            * ccui.linearVerticalLayoutManager is a singleton object which is the linear vertical layout manager for ccui.Layout.
            */
            constructor();
        }
    }
declare module ccui {
        /**
        * 
The list view control of Cocos UI.

        */
        export class ListView extends ccui.ScrollView {
            /**
            * The list view control of Cocos UI.
            */
            constructor();
            /**
            * The flag selected item of ccui.ListView&#39;s event.
            */
            static EVENT_SELECTED_ITEM;
            /**
            * The bottom flag of ccui.ListView&#39;s gravity.
            */
            static GRAVITY_BOTTOM;
            /**
            * The center horizontal flag of ccui.ListView&#39;s gravity.
            */
            static GRAVITY_CENTER_HORIZONTAL;
            /**
            * The center vertical flag of ccui.ListView&#39;s gravity.
            */
            static GRAVITY_CENTER_VERTICAL;
            /**
            * The left flag of ccui.ListView&#39;s gravity.
            */
            static GRAVITY_LEFT;
            /**
            * The right flag of ccui.ListView&#39;s gravity.
            */
            static GRAVITY_RIGHT;
            /**
            * The top flag of ccui.ListView&#39;s gravity.
            */
            static GRAVITY_TOP;
            /**
            * The flag selected item end of ccui.ListView&#39;s event.
            */
            static ON_SELECTED_ITEM_END;
            /**
            * The flag selected item start of ccui.ListView&#39;s event.
            */
            static ON_SELECTED_ITEM_START;
            /**
            * addChild(widget, zOrder, tag)
add child to ListView
Parameters:
{cc.Node} widget
{Number} zOrder
Optional
{Number|String} tag
Optional
tag or name

            */
            addChild(widget?: cc.Node, zOrder?: number, tag?: any);
            /**
            * addEventListener(selector, target)
Adds event listener to ccui.ListView.
Parameters:
{Function} selector
{Object} target
Optional

            */
            addEventListener(selector?: Function, target?: Object);
            /**
            * addEventListenerListView(selector, target)
Adds event listener to ccui.ListView.
Parameters:
{Function} selector
{Object} target
Optional
Deprecated:
since v3.0, please use addEventListener instead.

            */
            addEventListenerListView(selector?: Function, target?: Object);
            /**
            * &amp;lt;static&amp;gt;
ccui.ListView.create()
allocates and initializes a UIListView.
Deprecated:
since v3.0, please use new ccui.ListView() instead.

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ListView;
            /**
            * ctor()
allocates and initializes a UIListView.
Constructor of ccui.ListView, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
// example
var aListView = new ccui.ListView();

            */
            ctor();
            /**
            * doLayout()
provides a public _doLayout function for Editor. it calls _doLayout.

            */
            doLayout();
            /**
            * {number}
getCurSelectedIndex()
Returns current selected index
Returns:
{number}

            */
            getCurSelectedIndex(): number;
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of ccui.ListView.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * {Number}
getIndex(item)
Returns the index of item.
Parameters:
{ccui.Widget} item
the item which need to be checked.
Returns:
{Number} the index of item.

            */
            getIndex(item?: ccui.Widget): number;
            /**
            * {ccui.Widget}
getItem(index)
Returns a item whose index is same as the parameter.
Parameters:
{Number} index
Returns:
{ccui.Widget}

            */
            getItem(index?: number): ccui.Widget;
            /**
            * {Array}
getItems()
Returns the item container.
Returns:
{Array}

            */
            getItems(): Array<any>;
            /**
            * {Number}
getItemsMargin()
Returns the margin between each item.
Returns:
{Number}

            */
            getItemsMargin(): number;
            /**
            * {boolean}
init()
Initializes a ccui.ListView. Please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * insertCustomItem(item, index)
Push back custom item into ccui.ListView.
Parameters:
{ccui.Widget} item
{Number} index

            */
            insertCustomItem(item?: ccui.Widget, index?: number);
            /**
            * insertDefaultItem(index)
Insert a default item(create by a cloned model) into ListView.
Parameters:
{Number} index

            */
            insertDefaultItem(index?: number);
            /**
            * interceptTouchEvent(eventType, sender, touch)
Intercept touch event, handle its child&#39;s touch event.
Parameters:
{Number} eventType
{ccui.Widget} sender
{cc.Touch} touch

            */
            interceptTouchEvent(eventType?: number, sender?: ccui.Widget, touch?: cc.Touch);
            /**
            * pushBackCustomItem(item)
Push back custom item into ListView.
Parameters:
{ccui.Widget} item

            */
            pushBackCustomItem(item?: ccui.Widget);
            /**
            * pushBackDefaultItem()
Push back a default item(create by a cloned model) into ListView.

            */
            pushBackDefaultItem();
            /**
            * refreshView()
Refreshes list view.

            */
            refreshView();
            /**
            * removeAllChildren()
Removes all children from ccui.ListView.

            */
            removeAllChildren();
            /**
            * removeAllChildrenWithCleanup(cleanup)
Removes all children from ccui.ListView and do a cleanup all running actions depending on the cleanup parameter.
Parameters:
{Boolean} cleanup

            */
            removeAllChildrenWithCleanup(cleanup?: boolean);
            /**
            * removeAllItems()
Removes all items from ccui.ListView.

            */
            removeAllItems();
            /**
            * removeChild(widget, cleanup)
remove child from ListView
Parameters:
{cc.Node} widget
{Boolean} cleanup
Optional, Default: true

            */
            removeChild(widget?: cc.Node, cleanup?: boolean);
            /**
            * removeItem(index)
Removes a item whose index is same as the parameter.
Parameters:
{Number} index

            */
            removeItem(index?: number);
            /**
            * removeLastItem()
Removes the last item of ccui.ListView.

            */
            removeLastItem();
            /**
            * requestRefreshView()
Requests refresh list view.

            */
            requestRefreshView();
            /**
            * setDirection(dir)
Changes scroll direction of ccui.ListView.
Parameters:
{ccui.ScrollView.DIR_NONE | ccui.ScrollView.DIR_VERTICAL | ccui.ScrollView.DIR_HORIZONTAL | ccui.ScrollView.DIR_BOTH} dir

            */
            setDirection(dir?: any);
            /**
            * setGravity(gravity)
Changes the gravity of ListView.
Parameters:
{ccui.ListView.GRAVITY_LEFT|ccui.ListView.GRAVITY_RIGHT|ccui.ListView.GRAVITY_CENTER_HORIZONTAL|ccui.ListView.GRAVITY_BOTTOM|ccui.ListView.GRAVITY_CENTER_VERTICAL} gravity

            */
            setGravity(gravity?: any);
            /**
            * setItemModel(model)
Sets a item model for ListView. A model will be cloned for adding default item.
Parameters:
{ccui.Widget} model

            */
            setItemModel(model?: ccui.Widget);
            /**
            * setItemsMargin(margin)
Changes the margin between each item.
Parameters:
{Number} margin

            */
            setItemsMargin(margin?: number);
        }
    }
declare module ccui {
        /**
        * 
The LoadingBar control of Cocos UI.

        */
        export class LoadingBar extends ccui.Widget {
            /**
            * The LoadingBar control of Cocos UI.
            */
            constructor();
            /**
            * - The progress direction of loadingbar
            */
            direction: any;
            /**
            * - The current progress of loadingbar
            */
            percent: number;
            /**
            * The zOrder value of ccui.LoadingBar&#39;s renderer.
            */
            static RENDERER_ZORDER;
            /**
            * The left direction of ccui.LoadingBar.
            */
            static TYPE_LEFT;
            /**
            * The right direction of ccui.LoadingBar.
            */
            static TYPE_RIGHT;
            /**
            * &amp;lt;static&amp;gt;
{ccui.LoadingBar}
ccui.LoadingBar.create(textureName, percentage)
Allocates and initializes a UILoadingBar.
Parameters:
{string} textureName
{Number} percentage
Deprecated:
since v3.0, please use new ccui.LoadingBar() instead.
Returns:
{ccui.LoadingBar}

            */
            static create(textureName?: string, percentage?: number): ccui.LoadingBar;
            /**
            * ctor(textureName, percentage)
allocates and initializes a UILoadingBar.
Constructor of ccui.LoadingBar, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
// example
var uiLoadingBar = new ccui.LoadingBar;
Parameters:
{string} textureName
{Number} percentage

            */
            ctor(textureName?: string, percentage?: number);
            /**
            * {cc.Rect}
getCapInsets()
Returns cap insets for loadingBar.
Returns:
{cc.Rect}

            */
            getCapInsets(): cc.Rect;
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of widget.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * {ccui.LoadingBar.TYPE_LEFT | ccui.LoadingBar.TYPE_RIGHT}
getDirection()
Returns the progress direction of LoadingBar.
LoadingBarTypeLeft means progress left to right, LoadingBarTypeRight otherwise.
Returns:
{ccui.LoadingBar.TYPE_LEFT | ccui.LoadingBar.TYPE_RIGHT}

            */
            getDirection(): any;
            /**
            * {number}
getPercent()
Returns the progress direction of LoadingBar.
Returns:
{number} percent value from 1 to 100.

            */
            getPercent(): number;
            /**
            * {cc.Node}
getVirtualRenderer()
Returns the renderer of ccui.LoadingBar
Returns:
{cc.Node}

            */
            getVirtualRenderer(): cc.Node;
            /**
            * {cc.Size|*}
getVirtualRendererSize()
Returns the texture size of renderer.
Returns:
{cc.Size|*}

            */
            getVirtualRendererSize(): any;
            /**
            * ignoreContentAdaptWithSize(ignore)
Ignore the LoadingBar&#39;s custom size,  if ignore is true that LoadingBar will ignore it&#39;s custom size, use renderer&#39;s content size, false otherwise.
Parameters:
{Boolean} ignore

            */
            ignoreContentAdaptWithSize(ignore?: boolean);
            /**
            * {Boolean}
isScale9Enabled()
Returns LoadingBar is using scale9 renderer or not..
Returns:
{Boolean}

            */
            isScale9Enabled(): boolean;
            /**
            * loadTexture(texture, texType)
Loads texture for LoadingBar.
Parameters:
{String} texture
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadTexture(texture?: string, texType?: any);
            /**
            * setCapInsets(capInsets)
Sets capinsets for LoadingBar, if LoadingBar is using scale9 renderer.
Parameters:
{cc.Rect} capInsets

            */
            setCapInsets(capInsets?: cc.Rect);
            /**
            * setContentSize(contentSize, height)
Sets the contentSize of ccui.LoadingBar
Parameters:
{Number|cc.Size} contentSize
{Number} height
Optional

            */
            setContentSize(contentSize?: any, height?: number);
            /**
            * setDirection(dir)
Changes the progress direction of LoadingBar.
LoadingBarTypeLeft means progress left to right, LoadingBarTypeRight otherwise.
Parameters:
{ccui.LoadingBar.TYPE_LEFT | ccui.LoadingBar.TYPE_RIGHT} dir

            */
            setDirection(dir?: any);
            /**
            * setPercent(percent)
The current progress of loadingBar
Parameters:
{number} percent
percent value from 1 to 100.

            */
            setPercent(percent?: number);
            /**
            * setScale9Enabled(enabled)
Sets if LoadingBar is using scale9 renderer.
Parameters:
{Boolean} enabled

            */
            setScale9Enabled(enabled?: boolean);
        }
    }
declare module ccui {
        /**
        * 
Base class for ccui.Margin

        */
        export class Margin extends ccui.Class {
            /**
            * Base class for ccui.Margin
            */
            constructor();
            /**
            * - bottom of margin
            */
            bottom: number;
            /**
            * - Left of margin
            */
            left: number;
            /**
            * - right of margin
            */
            right: number;
            /**
            * - Top of margin
            */
            top: number;
            /**
            * ctor(margin, top, right, bottom)
Constructor of ccui.Margin.
Parameters:
{Number|ccui.Margin} margin
a margin or left
{Number} top
Optional
{Number} right
Optional
{Number} bottom
Optional

            */
            ctor(margin?: any, top?: number, right?: number, bottom?: number);
            /**
            * {boolean}
equals(target)
Checks target whether equals itself.
Parameters:
{ccui.Margin} target
Returns:
{boolean}

            */
            equals(target?: ccui.Margin): boolean;
            /**
            * setMargin(l, t, r, b)
Sets boundary of margin
Parameters:
{Number} l
left
{Number} t
top
{Number} r
right
{Number} b
bottom

            */
            setMargin(l?: number, t?: number, r?: number, b?: number);
        }
    }
declare module ccui {
        /**
        * 
that same as cc.Node

        */
        export class Node extends ccui.Class {
            /**
            * that same as cc.Node
            */
            constructor();
        }
    }
declare module ccui {
        /**
        * 
The PageView control of Cocos UI.

        */
        export class PageView extends ccui.Layout {
            /**
            * The PageView control of Cocos UI.
            */
            constructor();
            /**
            * The right flag of ccui.PageView&#39;s auto scroll direction.
            */
            static DIRECTION_LEFT;
            /**
            * The right flag of ccui.PageView&#39;s auto scroll direction.
            */
            static DIRECTION_RIGHT;
            /**
            * The turning flag of ccui.PageView&#39;s event.
            */
            static EVENT_TURNING;
            /**
            * The left flag of ccui.PageView&#39;s touch direction.
            */
            static TOUCH_DIR_LEFT;
            /**
            * The right flag of ccui.PageView&#39;s touch direction.
            */
            static TOUCH_DIR_RIGHT;
            /**
            * addEventListener(selector, target)
Adds event listener to ccui.PageView.
Parameters:
{Function} selector
{Object} target
Optional

            */
            addEventListener(selector?: Function, target?: Object);
            /**
            * addEventListenerPageView(selector, target)
Adds event listener to ccui.PageView.
Parameters:
{Function} selector
{Object} target
Optional
Deprecated:
since v3.0, please use addEventListener instead.

            */
            addEventListenerPageView(selector?: Function, target?: Object);
            /**
            * addPage(page)
Adds a page to ccui.PageView.
Parameters:
{ccui.Layout} page

            */
            addPage(page?: ccui.Layout);
            /**
            * addWidgetToPage(widget, pageIdx, forceCreate)
Add a widget to a page of PageView.
Parameters:
{ccui.Widget} widget
widget to be added to PageView.
{number} pageIdx
index of page.
{Boolean} forceCreate
if force create and there is no page exist, PageView would create a default page for adding widget.

            */
            addWidgetToPage(widget?: ccui.Widget, pageIdx?: number, forceCreate?: boolean);
            /**
            * &amp;lt;static&amp;gt;
{ccui.PageView}
ccui.PageView.create()
allocates and initializes a UIPageView.
Deprecated:
since v3.0, please use new ccui.PageView() instead.
Returns:
{ccui.PageView}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccui.PageView;
            /**
            * ctor()
Allocates and initializes a UIPageView.
Constructor of ccui.PageView. please do not call this function by yourself, you should pass the parameters to constructor to initialize it
.
// example
var uiPageView = new ccui.PageView();

            */
            ctor();
            /**
            * {number}
getCurPageIndex()
Returns current page index
Returns:
{number}

            */
            getCurPageIndex(): number;
            /**
            * getCustomScrollThreshold()
Gets the _customScrollThreshold.

            */
            getCustomScrollThreshold();
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of ccui.PageView.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * {number}
getLayoutType()
Returns the layout type of ccui.PageView. it&#39;s always ccui.Layout.ABSOLUTE.
Returns:
{number}

            */
            getLayoutType(): number;
            /**
            * {ccui.Layout}
getPage(index)
Returns a page from PageView by index
Parameters:
{Number} index
Returns:
{ccui.Layout}

            */
            getPage(index?: number): ccui.Layout;
            /**
            * {Array}
getPages()
Returns all pages of PageView
Returns:
{Array}

            */
            getPages(): Array<any>;
            /**
            * {boolean}
init()
Initializes a ccui.PageView. Please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * insertPage(page, idx)
Inserts a page in the specified location.
Parameters:
{ccui.Layout} page
page to be added to PageView.
{Number} idx
index

            */
            insertPage(page?: ccui.Layout, idx?: number);
            /**
            * interceptTouchEvent(eventType, sender, touch)
Intercept touch event, handle its child&#39;s touch event.
Parameters:
{Number} eventType
event type
{ccui.Widget} sender
{cc.Touch} touch

            */
            interceptTouchEvent(eventType?: number, sender?: ccui.Widget, touch?: cc.Touch);
            /**
            * isUsingCustomScrollThreshold()
Gets the UsingCustomScrollThreshold

            */
            isUsingCustomScrollThreshold();
            /**
            * onEnter()
Calls the parent class&#39; onEnter and schedules update function.

            */
            onEnter();
            /**
            * onTouchCancelled(touch, event)
The touch canceled event callback handler of ccui.PageView.
Parameters:
{cc.Touch} touch
{cc.Event} event

            */
            onTouchCancelled(touch?: cc.Touch, event?: cc.Event);
            /**
            * onTouchEnded(touch, event)
The touch ended event callback handler of ccui.PageView.
Parameters:
{cc.Touch} touch
{cc.Event} event

            */
            onTouchEnded(touch?: cc.Touch, event?: cc.Event);
            /**
            * onTouchMoved(touch, event)
The touch moved event callback handler of ccui.PageView.
Parameters:
{cc.Touch} touch
{cc.Event} event

            */
            onTouchMoved(touch?: cc.Touch, event?: cc.Event);
            /**
            * removeAllPages()
Removes all pages from PageView

            */
            removeAllPages();
            /**
            * removePage(page)
Removes a page from PageView.
Parameters:
{ccui.Layout} page

            */
            removePage(page?: ccui.Layout);
            /**
            * removePageAtIndex(index)
Removes a page at index of PageView.
Parameters:
{number} index

            */
            removePageAtIndex(index?: number);
            /**
            * scrollToPage(idx)
scroll PageView to index.
Parameters:
{number} idx
index of page.

            */
            scrollToPage(idx?: number);
            /**
            * setCustomScrollThreshold(threshold)
Set CustomScrollThreshold
Parameters:
threshold

            */
            setCustomScrollThreshold();
            /**
            * setLayoutType(type)
Does nothing. ccui.PageView&#39;s layout type is ccui.Layout.ABSOLUTE.
Parameters:
{Number} type

            */
            setLayoutType(type?: number);
            /**
            * setUsingCustomScrollThreshold(flag)
Set the UsingCustomScrollThreshold
Parameters:
flag

            */
            setUsingCustomScrollThreshold();
            /**
            * update(dt)
Called once per frame. Time is the number of seconds of a frame interval.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module ccui {
        /**
        * 
that same as cc.Node

        */
        export class ProtectedNode extends ccui.Node {
            /**
            * that same as cc.Node
            */
            constructor();
        }
    }
declare module ccui {
        /**
        * 
The Relative box for Cocos UI layout.  Its layout type is ccui.Layout.RELATIVE.

        */
        export class RelativeBox extends ccui.Layout {
            /**
            * The Relative box for Cocos UI layout.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{ccui.RelativeBox}
ccui.RelativeBox.create(size)
Creates a relative box
Parameters:
{cc.Size} size
Deprecated:
since v3.0, please use new ccui.RelativeBox(size) instead.
Returns:
{ccui.RelativeBox}

            */
            static create(size?: cc.Size): ccui.RelativeBox;
            /**
            * ctor(size)
The constructor of ccui.RelativeBox
Parameters:
{cc.Size} size
Optional

            */
            ctor(size?: cc.Size);
            /**
            * {boolean}
init()
Initializes a relative box. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * {boolean}
initWithSize(size)
Initializes a relative box with size
Parameters:
{cc.Size} size
Optional
Returns:
{boolean}

            */
            initWithSize(size?: cc.Size): boolean;
        }
    }
declare module ccui {
        /**
        * 
ccui.relativeLayoutManager is the singleton object which is the relative layout manager for ccui.Layout, it has a _doLayout function to do layout.

        */
        export class relativeLayoutManager  {
            /**
            * ccui.relativeLayoutManager is the singleton object which is the relative layout manager for ccui.Layout, it has a _doLayout function to do layout.
            */
            constructor();
        }
    }
declare module ccui {
        /**
        * 
The relative of layout parameter. Its layout parameter type is ccui.LayoutParameter.RELATIVE.

        */
        export class RelativeLayoutParameter extends ccui.LayoutParameter {
            /**
            * The relative of layout parameter.
            */
            constructor();
            /**
            * The center in parent of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static CENTER_IN_PARENT;
            /**
            * The location above center of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_ABOVE_CENTER;
            /**
            * The location above left align of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_ABOVE_LEFTALIGN;
            /**
            * The location above right align of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_ABOVE_RIGHTALIGN;
            /**
            * The location below center of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_BELOW_CENTER;
            /**
            * The location below left align of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_BELOW_LEFTALIGN;
            /**
            * The location below right align of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_BELOW_RIGHTALIGN;
            /**
            * The location left of bottom align of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_LEFT_OF_BOTTOMALIGN;
            /**
            * The location left of center of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_LEFT_OF_CENTER;
            /**
            * The location left of top align of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_LEFT_OF_TOPALIGN;
            /**
            * The location right of bottom align of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_RIGHT_OF_BOTTOMALIGN;
            /**
            * The location right of center of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_RIGHT_OF_CENTER;
            /**
            * The location right of top align of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static LOCATION_RIGHT_OF_TOPALIGN;
            /**
            * The none of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static NONE;
            /**
            * The parent&#39;s bottom center horizontal of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static PARENT_BOTTOM_CENTER_HORIZONTAL;
            /**
            * The parent&#39;s left bottom of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static PARENT_LEFT_BOTTOM;
            /**
            * The parent&#39;s left center vertical of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static PARENT_LEFT_CENTER_VERTICAL;
            /**
            * The parent&#39;s right bottom of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static PARENT_RIGHT_BOTTOM;
            /**
            * The parent&#39;s right center vertical of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static PARENT_RIGHT_CENTER_VERTICAL;
            /**
            * The parent&#39;s top center horizontal of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static PARENT_TOP_CENTER_HORIZONTAL;
            /**
            * The parent&#39;s top left of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static PARENT_TOP_LEFT;
            /**
            * The parent&#39;s top right of ccui.RelativeLayoutParameter&#39;s relative align.
            */
            static PARENT_TOP_RIGHT;
            /**
            * &amp;lt;static&amp;gt;
{ccui.RelativeLayoutParameter}
ccui.RelativeLayoutParameter.create()
Allocates and initializes a RelativeLayoutParameter.
Deprecated:
since v3.0, please use new ccui.RelativeLayoutParameter() instead.
Returns:
{ccui.RelativeLayoutParameter}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccui.RelativeLayoutParameter;
            /**
            * ctor()
The constructor of ccui.RelativeLayoutParameter

            */
            ctor();
            /**
            * {Number}
getAlign()
Gets RelativeAlign parameter for LayoutParameter.
Returns:
{Number}

            */
            getAlign(): number;
            /**
            * {string}
getRelativeName()
Gets a name in Relative Layout of LayoutParameter.
Returns:
{string}

            */
            getRelativeName(): string;
            /**
            * {string}
getRelativeToWidgetName()
Gets the key of LayoutParameter. Witch widget named this is relative to.
Returns:
{string}

            */
            getRelativeToWidgetName(): string;
            /**
            * setAlign(align)
Sets RelativeAlign parameter for LayoutParameter.
Parameters:
{Number} align

            */
            setAlign(align?: number);
            /**
            * setRelativeName(name)
Sets a name in Relative Layout for LayoutParameter.
Parameters:
{String} name

            */
            setRelativeName(name?: string);
            /**
            * setRelativeToWidgetName(name)
Sets a key for LayoutParameter. Witch widget named this is relative to.
Parameters:
{String} name

            */
            setRelativeToWidgetName(name?: string);
        }
    }
declare module ccui {
        /**
        * A 9-slice sprite for cocos2d UI.
9-slice scaling allows you to specify how scaling is applied
to specific areas of a sprite. With 9-slice scaling (3x3 grid),
you can ensure that the sprite does not become distorted when
scaled.

        */
        export class Scale9Sprite extends cc.Node {
            /**
            * 
A 9-slice sprite for cocos2d UI.
            */
            constructor();
            /**
            * - The cap insets of the 9-slice sprite
            */
            capInsets: cc.Rect;
            /**
            * - The bottom inset of the 9-slice sprite
            */
            insetBottom: number;
            /**
            * - The left inset of the 9-slice sprite
            */
            insetLeft: number;
            /**
            * - The right inset of the 9-slice sprite
            */
            insetRight: number;
            /**
            * - The top inset of the 9-slice sprite
            */
            insetTop: number;
            /**
            * - The preferred size of the 9-slice sprite
            */
            preferredSize: cc.Size;
            /**
            * addLoadedEventListener(callback, target)
add texture loaded event listener
Parameters:
{Function} callback
{Object} target
Deprecated:
since 3.1, please use addEventListener instead

            */
            addLoadedEventListener(callback?: Function, target?: Object);
            /**
            * &amp;lt;static&amp;gt;
{ccui.Scale9Sprite}
ccui.Scale9Sprite.create(file, rect, capInsets)
Creates a 9-slice sprite with a texture file, a delimitation zone and
with the specified cap insets.
Parameters:
{String|cc.SpriteFrame} file
file name of texture or a cc.Sprite object
{cc.Rect} rect
the rect of the texture
{cc.Rect} capInsets
the cap insets of ccui.Scale9Sprite
Deprecated:
since v3.0, please use new ccui.Scale9Sprite(file, rect, capInsets) instead.
Returns:
{ccui.Scale9Sprite}

            */
            static create(file?: any, rect?: cc.Rect, capInsets?: cc.Rect): ccui.Scale9Sprite;
            /**
            * &amp;lt;static&amp;gt;
{ccui.Scale9Sprite}
ccui.Scale9Sprite.createWithSpriteFrame(spriteFrame, capInsets)
create a ccui.Scale9Sprite with Sprite frame.
Parameters:
{cc.SpriteFrame} spriteFrame
{cc.Rect} capInsets
Deprecated:
since v3.0, please use &quot;new ccui.Scale9Sprite(spriteFrame, capInsets)&quot; instead.
Returns:
{ccui.Scale9Sprite}

            */
            static createWithSpriteFrame(spriteFrame?: cc.SpriteFrame, capInsets?: cc.Rect): ccui.Scale9Sprite;
            /**
            * &amp;lt;static&amp;gt;
{Scale9Sprite}
ccui.Scale9Sprite.createWithSpriteFrameName(spriteFrameName, capInsets)
create a ccui.Scale9Sprite with a Sprite frame name
Parameters:
{string} spriteFrameName
{cc.Rect} capInsets
Deprecated:
since v3.0, please use &quot;new ccui.Scale9Sprite(spriteFrameName, capInsets)&quot; instead.
Returns:
{Scale9Sprite}

            */
            static createWithSpriteFrameName(spriteFrameName?: string, capInsets?: cc.Rect): Scale9Sprite;
            /**
            * {Scale9Sprite}
ctor(file, rect, capInsets)
Constructor function. override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
{string|cc.SpriteFrame} file
file name of texture or a SpriteFrame
{cc.Rect} rect
{cc.Rect} capInsets
Returns:
{Scale9Sprite}

            */
            ctor(file?: any, rect?: cc.Rect, capInsets?: cc.Rect): Scale9Sprite;
            /**
            * {number}
getInsetBottom()
Gets the bottom side inset
Returns:
{number}

            */
            getInsetBottom(): number;
            /**
            * {number}
getInsetLeft()
Gets the left side inset
Returns:
{number}

            */
            getInsetLeft(): number;
            /**
            * {number}
getInsetRight()
Gets the right side inset
Returns:
{number}

            */
            getInsetRight(): number;
            /**
            * {number}
getInsetTop()
Gets the top side inset
Returns:
{number}

            */
            getInsetTop(): number;
            /**
            * getOriginalSize()
Original sprite&#39;s size.

            */
            getOriginalSize();
            /**
            * {boolean}
init()
Initializes a ccui.Scale9Sprite. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * {boolean}
initWithBatchNode(batchNode, rect, rotated, capInsets)
Initializes a 9-slice sprite with a SpriteBatchNode.
Parameters:
{cc.SpriteBatchNode} batchNode
{cc.Rect} rect
{boolean|cc.Rect} rotated
{cc.Rect} capInsets
Optional
Returns:
{boolean}

            */
            initWithBatchNode(batchNode?: cc.SpriteBatchNode, rect?: cc.Rect, rotated?: any, capInsets?: cc.Rect): boolean;
            /**
            * initWithFile(file, rect, capInsets)
Initializes a 9-slice sprite with a texture file, a delimitation zone and
with the specified cap insets.
Once the sprite is created, you can then call its &quot;setContentSize:&quot; method
to resize the sprite will all it&#39;s 9-slice goodness intact.
It respects the anchorPoint too.
Parameters:
{String} file
The name of the texture file.
{cc.Rect} rect
The rectangle that describes the sub-part of the texture that
is the whole image. If the shape is the whole texture, set this to the texture&#39;s full rect.
{cc.Rect} capInsets
The values to use for the cap insets.

            */
            initWithFile(file?: string, rect?: cc.Rect, capInsets?: cc.Rect);
            /**
            * initWithSpriteFrame(spriteFrame, capInsets)
Initializes a 9-slice sprite with an sprite frame and with the specified
cap insets.
Once the sprite is created, you can then call its &quot;setContentSize:&quot; method
to resize the sprite will all it&#39;s 9-slice goodness interact.
It respects the anchorPoint too.
Parameters:
spriteFrame
The sprite frame object.
capInsets
The values to use for the cap insets.

            */
            initWithSpriteFrame();
            /**
            * initWithSpriteFrameName(spriteFrameName, capInsets)
Initializes a 9-slice sprite with an sprite frame name and with the specified
cap insets.
Once the sprite is created, you can then call its &quot;setContentSize:&quot; method
to resize the sprite will all it&#39;s 9-slice goodness interact.
It respects the anchorPoint too.
Parameters:
spriteFrameName
The sprite frame name.
capInsets
The values to use for the cap insets.

            */
            initWithSpriteFrameName();
            /**
            * isOpacityModifyRGB()
returns whether or not the opacity will be applied using glColor(R,G,B,opacity) or glColor(opacity, opacity, opacity, opacity);
Since:
v0.8

            */
            isOpacityModifyRGB();
            /**
            * resizableSpriteWithCapInsets(capInsets)
Creates and returns a new sprite object with the specified cap insets.
You use this method to add cap insets to a sprite or to change the existing
cap insets of a sprite. In both cases, you get back a new image and the
original sprite remains untouched.
Parameters:
{cc.Rect} capInsets
The values to use for the cap insets.

            */
            resizableSpriteWithCapInsets(capInsets?: cc.Rect);
            /**
            * setColor(color)
Color: conforms to CCRGBAProtocol protocol
Parameters:
color

            */
            setColor();
            /**
            * setContentSize(size, height)
Sets the untransformed size of the Scale9Sprite.
Parameters:
{cc.Size|Number} size
The untransformed size of the Scale9Sprite or The untransformed size&#39;s width of the Scale9Sprite.
{Number} height
Optional
The untransformed size&#39;s height of the Scale9Sprite.

            */
            setContentSize(size?: any, height?: number);
            /**
            * setInsetBottom(insetBottom)
Sets the bottom side inset
Parameters:
{number} insetBottom

            */
            setInsetBottom(insetBottom?: number);
            /**
            * setInsetLeft(insetLeft)
Sets the left side inset
Parameters:
{Number} insetLeft

            */
            setInsetLeft(insetLeft?: number);
            /**
            * setInsetRight(insetRight)
Sets the right side inset
Parameters:
{Number} insetRight

            */
            setInsetRight(insetRight?: number);
            /**
            * setInsetTop(insetTop)
Sets the top side inset
Parameters:
{Number} insetTop

            */
            setInsetTop(insetTop?: number);
            /**
            * setOpacity(opacity)
Opacity: conforms to CCRGBAProtocol protocol
Parameters:
opacity

            */
            setOpacity();
            /**
            * setOpacityModifyRGB(value)
sets the premultipliedAlphaOpacity property.
If set to NO then opacity will be applied as: glColor(R,G,B,opacity);
If set to YES then opacity will be applied as: glColor(opacity, opacity, opacity, opacity );
Textures with premultiplied alpha will have this property by default on YES. Otherwise the default value is NO
Parameters:
value
Since:
v0.8

            */
            setOpacityModifyRGB();
            /**
            * setSpriteFrame(spriteFrame)
set the sprite frame of ccui.Scale9Sprite
Parameters:
{cc.SpriteFrame} spriteFrame

            */
            setSpriteFrame(spriteFrame?: cc.SpriteFrame);
            /**
            * {boolean}
textureLoaded()
return  texture is loaded
Returns:
{boolean}

            */
            textureLoaded(): boolean;
            /**
            * {boolean}
updateWithBatchNode(batchNode, originalRect, rotated, capInsets)
Update the scale9Sprite with a SpriteBatchNode.
Parameters:
{cc.SpriteBatchNode} batchNode
{cc.Rect} originalRect
{boolean} rotated
{cc.Rect} capInsets
Returns:
{boolean}

            */
            updateWithBatchNode(batchNode?: cc.SpriteBatchNode, originalRect?: cc.Rect, rotated?: boolean, capInsets?: cc.Rect): boolean;
        }
    }
declare module ccui {
        /**
        * 
The ScrollView control of Cocos UI

        */
        export class ScrollView extends ccui.Layout {
            /**
            * The ScrollView control of Cocos UI
            */
            constructor();
            /**
            * The auto scroll max speed of ccui.ScrollView.
            */
            static AUTO_SCROLL_MAX_SPEED;
            /**
            * - Indicate whether bounce is enabled
            */
            bounceEnabled: boolean;
            /**
            * The both flag of ccui.ScrollView&#39;s direction.
            */
            static DIR_BOTH;
            /**
            * The horizontal flag of ccui.ScrollView&#39;s direction.
            */
            static DIR_HORIZONTAL;
            /**
            * The none flag of ccui.ScrollView&#39;s direction.
            */
            static DIR_NONE;
            /**
            * The vertical flag of ccui.ScrollView&#39;s direction.
            */
            static DIR_VERTICAL;
            /**
            * - Scroll direction of the scroll view
            */
            direction: any;
            /**
            * The flag bounce bottom of ccui.ScrollView&#39;s event.
            */
            static EVENT_BOUNCE_BOTTOM;
            /**
            * The flag bounce left of ccui.ScrollView&#39;s event.
            */
            static EVENT_BOUNCE_LEFT;
            /**
            * The flag bounce right of ccui.ScrollView&#39;s event.
            */
            static EVENT_BOUNCE_RIGHT;
            /**
            * The flag bounce top of ccui.ScrollView&#39;s event.
            */
            static EVENT_BOUNCE_TOP;
            /**
            * The flag scroll to bottom of ccui.ScrollView&#39;s event.
            */
            static EVENT_SCROLL_TO_BOTTOM;
            /**
            * The flag scroll to left of ccui.ScrollView&#39;s event.
            */
            static EVENT_SCROLL_TO_LEFT;
            /**
            * The flag scroll to right of ccui.ScrollView&#39;s event.
            */
            static EVENT_SCROLL_TO_RIGHT;
            /**
            * The flag scroll to top of ccui.ScrollView&#39;s event.
            */
            static EVENT_SCROLL_TO_TOP;
            /**
            * The scrolling flag of ccui.ScrollView&#39;s event.
            */
            static EVENT_SCROLLING;
            /**
            * - Indicate whether inertiaScroll is enabled
            */
            inertiaScrollEnabled: boolean;
            /**
            * - Inner container height of the scroll view
            */
            innerHeight: number;
            /**
            * - Inner container width of the scroll view
            */
            innerWidth: number;
            /**
            * {boolean}
addChild(widget, zOrder, tag)
Add child to ccui.ScrollView.
Parameters:
{cc.Node} widget
{Number} zOrder
Optional
{Number|string} tag
Optional
tag or name
Returns:
{boolean}

            */
            addChild(widget?: cc.Node, zOrder?: number, tag?: any): boolean;
            /**
            * addEventListener(selector, target)
Adds callback function called ScrollView event triggered
Parameters:
{Function} selector
{Object} target
Optional

            */
            addEventListener(selector?: Function, target?: Object);
            /**
            * addEventListenerScrollView(selector, target)
Adds callback function called ScrollView event triggered
Parameters:
{Function} selector
{Object} target
Optional
Deprecated:
since v3.0, please use addEventListener instead.

            */
            addEventListenerScrollView(selector?: Function, target?: Object);
            /**
            * addNode(node, zOrder, tag)
Add node for scrollView
Parameters:
{cc.Node} node
{Number} zOrder
{Number} tag
Deprecated:
since v3.0, please use addChild instead.

            */
            addNode(node?: cc.Node, zOrder?: number, tag?: number);
            /**
            * &amp;lt;static&amp;gt;
{ccui.ScrollView}
ccui.ScrollView.create()
allocates and initializes a UIScrollView.
Deprecated:
since v3.0, please use new ccui.ScrollView() instead.
Returns:
{ccui.ScrollView}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccui.ScrollView;
            /**
            * ctor()
Allocates and initializes a UIScrollView.
Constructor of ccui.ScrollView. override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
// example
var uiScrollView = new ccui.ScrollView();

            */
            ctor();
            /**
            * {ccui.Widget}
findNextFocusedWidget(direction, current)
When a widget is in a layout, you could call this method to get the next focused widget within a specified direction.
If the widget is not in a layout, it will return itself
Parameters:
{Number} direction
the direction to look for the next focused widget in a layout
{ccui.Widget} current
the current focused widget
Returns:
{ccui.Widget}

            */
            findNextFocusedWidget(direction?: number, current?: ccui.Widget): ccui.Widget;
            /**
            * {ccui.Widget}
getChildByName(name)
Gets a child from the container given its name
Parameters:
{String} name
Returns:
{ccui.Widget}

            */
            getChildByName(name?: string): ccui.Widget;
            /**
            * {ccui.Widget}
getChildByTag(tag)
Gets a child from the container given its tag
Parameters:
{Number} tag
Returns:
{ccui.Widget}

            */
            getChildByTag(tag?: number): ccui.Widget;
            /**
            * {Array}
getChildren()
Returns inner container&#39;s children
Returns:
{Array}

            */
            getChildren(): Array<any>;
            /**
            * {Number}
getChildrenCount()
Gets the count of inner container&#39;s children
Returns:
{Number}

            */
            getChildrenCount(): number;
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of ccui.ScrollView.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * {ccui.ScrollView.DIR_NONE | ccui.ScrollView.DIR_VERTICAL | ccui.ScrollView.DIR_HORIZONTAL | ccui.ScrollView.DIR_BOTH}
getDirection()
Returns scroll direction of ScrollView.
Returns:
{ccui.ScrollView.DIR_NONE | ccui.ScrollView.DIR_VERTICAL | ccui.ScrollView.DIR_HORIZONTAL | ccui.ScrollView.DIR_BOTH}

            */
            getDirection(): any;
            /**
            * {ccui.Layout}
getInnerContainer()
Gets inner container of ScrollView. Inner container is the container of ScrollView&#39;s children.
Returns:
{ccui.Layout}

            */
            getInnerContainer(): ccui.Layout;
            /**
            * {cc.Size}
getInnerContainerSize()
Returns inner container size of ScrollView.
Inner container size must be larger than or equal ScrollView&#39;s size.
Returns:
{cc.Size} inner container size.

            */
            getInnerContainerSize(): cc.Size;
            /**
            * {ccui.Layout.ABSOLUTE|ccui.Layout.LINEAR_VERTICAL|ccui.Layout.LINEAR_HORIZONTAL|ccui.Layout.RELATIVE}
getLayoutType()
Returns the layout type of ccui.ScrollView.
Returns:
{ccui.Layout.ABSOLUTE|ccui.Layout.LINEAR_VERTICAL|ccui.Layout.LINEAR_HORIZONTAL|ccui.Layout.RELATIVE}

            */
            getLayoutType(): any;
            /**
            * {cc.Node}
getNodeByTag(tag)
Returns a node by tag
Parameters:
{Number} tag
Deprecated:
since v3.0, please use getChildByTag instead.
Returns:
{cc.Node}

            */
            getNodeByTag(tag?: number): cc.Node;
            /**
            * {Array}
getNodes()
Returns all nodes of inner container
Deprecated:
since v3.0, please use getChildren instead.
Returns:
{Array}

            */
            getNodes(): Array<any>;
            /**
            * {boolean}
init()
Initializes a ccui.ScrollView. Please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * interceptTouchEvent(event, sender, touch)
Intercept touch event, handle its child&#39;s touch event.
Parameters:
{number} event
event type
{ccui.Widget} sender
{cc.Touch} touch

            */
            interceptTouchEvent(event?: number, sender?: ccui.Widget, touch?: cc.Touch);
            /**
            * {boolean}
isBounceEnabled()
Returns whether bounce is enabled
Returns:
{boolean}

            */
            isBounceEnabled(): boolean;
            /**
            * {boolean}
isInertiaScrollEnabled()
Returns whether inertiaScroll is enabled
Returns:
{boolean}

            */
            isInertiaScrollEnabled(): boolean;
            /**
            * jumpToBottom()
Move inner container to bottom boundary of ScrollView.

            */
            jumpToBottom();
            /**
            * jumpToBottomLeft()
Move inner container to bottom and left boundary of ScrollView.

            */
            jumpToBottomLeft();
            /**
            * jumpToBottomRight()
Move inner container to bottom and right boundary of ScrollView.

            */
            jumpToBottomRight();
            /**
            * jumpToLeft()
Move inner container to left boundary of ScrollView.

            */
            jumpToLeft();
            /**
            * jumpToPercentBothDirection(percent)
Move inner container to both direction percent position of ScrollView.
Parameters:
{cc.Point} percent
The destination vertical percent, accept value between 0 - 100

            */
            jumpToPercentBothDirection(percent?: cc.Point);
            /**
            * jumpToPercentHorizontal(percent)
Move inner container to horizontal percent position of ScrollView.
Parameters:
{Number} percent
The destination vertical percent, accept value between 0 - 100

            */
            jumpToPercentHorizontal(percent?: number);
            /**
            * jumpToPercentVertical(percent)
Move inner container to vertical percent position of ScrollView.
Parameters:
{Number} percent
The destination vertical percent, accept value between 0 - 100

            */
            jumpToPercentVertical(percent?: number);
            /**
            * jumpToRight()
Move inner container to right boundary of ScrollView.

            */
            jumpToRight();
            /**
            * jumpToTop()
Move inner container to top boundary of ScrollView.

            */
            jumpToTop();
            /**
            * jumpToTopLeft()
Move inner container to top and left boundary of ScrollView.

            */
            jumpToTopLeft();
            /**
            * jumpToTopRight()
Move inner container to top and right boundary of ScrollView.

            */
            jumpToTopRight();
            /**
            * onEnter()
Calls the parent class&#39; onEnter and schedules update function.

            */
            onEnter();
            /**
            * {boolean}
onTouchBegan(touch, event)
The touch began event callback handler of ccui.ScrollView.
Parameters:
{cc.Touch} touch
{cc.Event} event
Returns:
{boolean}

            */
            onTouchBegan(touch?: cc.Touch, event?: cc.Event): boolean;
            /**
            * onTouchCancelled(touch, event)
The touch canceled event callback of ccui.ScrollView.
Parameters:
{cc.Touch} touch
{cc.Event} event

            */
            onTouchCancelled(touch?: cc.Touch, event?: cc.Event);
            /**
            * onTouchEnded(touch, event)
The touch ended event callback handler of ccui.ScrollView.
Parameters:
{cc.Touch} touch
{cc.Event} event

            */
            onTouchEnded(touch?: cc.Touch, event?: cc.Event);
            /**
            * onTouchMoved(touch, event)
The touch moved event callback handler of ccui.ScrollView.
Parameters:
{cc.Touch} touch
{cc.Event} event

            */
            onTouchMoved(touch?: cc.Touch, event?: cc.Event);
            /**
            * removeAllChildren()
Removes all children.

            */
            removeAllChildren();
            /**
            * removeAllChildrenWithCleanup(cleanup)
Removes all children.
Parameters:
{Boolean} cleanup

            */
            removeAllChildrenWithCleanup(cleanup?: boolean);
            /**
            * removeAllNodes()
Remove all node from ccui.ScrollView.
Deprecated:
since v3.0, please use removeAllChildren instead.

            */
            removeAllNodes();
            /**
            * {boolean}
removeChild(child, cleanup)
Removes widget child
Parameters:
{ccui.Widget} child
{Boolean} cleanup
Returns:
{boolean}

            */
            removeChild(child?: ccui.Widget, cleanup?: boolean): boolean;
            /**
            * removeNode(node)
Removes a node from ccui.ScrollView.
Parameters:
{cc.Node} node
Deprecated:
since v3.0, please use removeChild instead.

            */
            removeNode(node?: cc.Node);
            /**
            * removeNodeByTag(tag)
Removes a node by tag
Parameters:
{Number} tag
Deprecated:
since v3.0, please use removeChildByTag instead.

            */
            removeNodeByTag(tag?: number);
            /**
            * scrollToBottom(time, attenuated)
Scroll inner container to bottom boundary of ScrollView.
Parameters:
{Number} time
{Boolean} attenuated

            */
            scrollToBottom(time?: number, attenuated?: boolean);
            /**
            * scrollToBottomLeft(time, attenuated)
Scroll inner container to bottom and left boundary of ScrollView.
Parameters:
{Number} time
{Boolean} attenuated

            */
            scrollToBottomLeft(time?: number, attenuated?: boolean);
            /**
            * scrollToBottomRight(time, attenuated)
Scroll inner container to bottom and right boundary of ScrollView.
Parameters:
{Number} time
{Boolean} attenuated

            */
            scrollToBottomRight(time?: number, attenuated?: boolean);
            /**
            * scrollToLeft(time, attenuated)
Scroll inner container to left boundary of ScrollView.
Parameters:
{Number} time
{Boolean} attenuated

            */
            scrollToLeft(time?: number, attenuated?: boolean);
            /**
            * scrollToPercentBothDirection(percent, time, attenuated)
Scroll inner container to both direction percent position of ScrollView.
Parameters:
{cc.Point} percent
{Number} time
{Boolean} attenuated

            */
            scrollToPercentBothDirection(percent?: cc.Point, time?: number, attenuated?: boolean);
            /**
            * scrollToPercentHorizontal(percent, time, attenuated)
Scroll inner container to horizontal percent position of ScrollView.
Parameters:
{Number} percent
{Number} time
{Boolean} attenuated

            */
            scrollToPercentHorizontal(percent?: number, time?: number, attenuated?: boolean);
            /**
            * scrollToPercentVertical(percent, time, attenuated)
Scroll inner container to vertical percent position of ScrollView.
Parameters:
{Number} percent
{Number} time
{Boolean} attenuated

            */
            scrollToPercentVertical(percent?: number, time?: number, attenuated?: boolean);
            /**
            * scrollToRight(time, attenuated)
Scroll inner container to right boundary of ScrollView.
Parameters:
{Number} time
{Boolean} attenuated

            */
            scrollToRight(time?: number, attenuated?: boolean);
            /**
            * scrollToTop(time, attenuated)
Scroll inner container to top boundary of ScrollView.
Parameters:
{Number} time
{Boolean} attenuated

            */
            scrollToTop(time?: number, attenuated?: boolean);
            /**
            * scrollToTopLeft(time, attenuated)
Scroll inner container to top and left boundary of ScrollView.
Parameters:
{Number} time
{Boolean} attenuated

            */
            scrollToTopLeft(time?: number, attenuated?: boolean);
            /**
            * scrollToTopRight(time, attenuated)
Scroll inner container to top and right boundary of ScrollView.
Parameters:
{Number} time
{Boolean} attenuated

            */
            scrollToTopRight(time?: number, attenuated?: boolean);
            /**
            * setBounceEnabled(enabled)
Sets bounce enabled
Parameters:
{Boolean} enabled

            */
            setBounceEnabled(enabled?: boolean);
            /**
            * setDirection(dir)
Changes scroll direction of ScrollView.
Parameters:
{ccui.ScrollView.DIR_NONE | ccui.ScrollView.DIR_VERTICAL | ccui.ScrollView.DIR_HORIZONTAL | ccui.ScrollView.DIR_BOTH} dir
Direction::VERTICAL means vertical scroll, Direction::HORIZONTAL means horizontal scroll

            */
            setDirection(dir?: any);
            /**
            * setInertiaScrollEnabled(enabled)
Sets inertiaScroll enabled
Parameters:
{boolean} enabled

            */
            setInertiaScrollEnabled(enabled?: boolean);
            /**
            * setInnerContainerSize(size)
Changes inner container size of ScrollView.
Inner container size must be larger than or equal the size of ScrollView.
Parameters:
{cc.Size} size
inner container size.

            */
            setInnerContainerSize(size?: cc.Size);
            /**
            * setLayoutType(type)
Sets LayoutType of ccui.ScrollView.
Parameters:
{ccui.Layout.ABSOLUTE|ccui.Layout.LINEAR_VERTICAL|ccui.Layout.LINEAR_HORIZONTAL|ccui.Layout.RELATIVE} type

            */
            setLayoutType(type?: any);
            /**
            * update(dt)
The update callback handler.
Parameters:
{Number} dt

            */
            update(dt?: number);
        }
    }
declare module ccui {
        /**
        * 
The Slider control of Cocos UI.

        */
        export class Slider extends ccui.Widget {
            /**
            * The Slider control of Cocos UI.
            */
            constructor();
            /**
            * The zOrder value of ccui.Slider&#39;s ball renderer.
            */
            static BALL_RENDERER_ZORDER;
            /**
            * The zOrder value of ccui.Slider&#39;s base bar renderer.
            */
            static BASEBAR_RENDERER_ZORDER;
            /**
            * The percent change event flag of ccui.Slider.
            */
            static EVENT_PERCENT_CHANGED;
            /**
            * - The current progress of loadingbar
            */
            percent: number;
            /**
            * The zOrder value of ccui.Slider&#39;s progress bar renderer.
            */
            static PROGRESSBAR_RENDERER_ZORDER;
            /**
            * addEventListener(selector, target)
Adds a callback
Parameters:
{Function} selector
{Object} target
Optional

            */
            addEventListener(selector?: Function, target?: Object);
            /**
            * addEventListenerSlider(selector, target)
add event listener
Parameters:
{Function} selector
{Object} target
Optional
Deprecated:
since v3.0, please use addEventListener instead.

            */
            addEventListenerSlider(selector?: Function, target?: Object);
            /**
            * &amp;lt;static&amp;gt;
{ccui.Slider}
ccui.Slider.create()
allocates and initializes a UISlider.
Deprecated:
since v3.0, please use new ccui.Slider() instead.
Returns:
{ccui.Slider}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccui.Slider;
            /**
            * ctor()
allocates and initializes a UISlider.
Constructor of ccui.Slider. override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
// example
var uiSlider = new ccui.Slider();

            */
            ctor();
            /**
            * {cc.Rect}
getCapInsetsBarRenderer()
Returns cap insets for slider.
Returns:
{cc.Rect}

            */
            getCapInsetsBarRenderer(): cc.Rect;
            /**
            * {cc.Rect}
getCapInsetsProgressBarRenderer()
Returns cap insets of ProgressBar for slider.
Returns:
{cc.Rect}

            */
            getCapInsetsProgressBarRenderer(): cc.Rect;
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of ccui.LoadingBar.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * {number}
getPercent()
Gets the progress direction of slider.
Returns:
{number}

            */
            getPercent(): number;
            /**
            * {cc.Node}
getVirtualRenderer()
Returns the bar renderer.
Returns:
{cc.Node}

            */
            getVirtualRenderer(): cc.Node;
            /**
            * {cc.Size}
getVirtualRendererSize()
Returns the content size of bar renderer.
Returns:
{cc.Size}

            */
            getVirtualRendererSize(): cc.Size;
            /**
            * {boolean}
hitTest(pt)
test the point whether location in loadingBar&#39;s bounding box.
Parameters:
{cc.Point} pt
Returns:
{boolean}

            */
            hitTest(pt?: cc.Point): boolean;
            /**
            * ignoreContentAdaptWithSize(ignore)
override &quot;ignoreContentAdaptWithSize&quot; method of widget.
Parameters:
{Boolean} ignore

            */
            ignoreContentAdaptWithSize(ignore?: boolean);
            /**
            * {boolean}
init()
Initializes a ccui.Slider. Please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * {Boolean}
isScale9Enabled()
Returns slider is using scale9 renderer or not.
Returns:
{Boolean}

            */
            isScale9Enabled(): boolean;
            /**
            * loadBarTexture(fileName, texType)
Loads texture for slider bar.
Parameters:
{String} fileName
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadBarTexture(fileName?: string, texType?: any);
            /**
            * loadProgressBarTexture(fileName, texType)
Loads dark state texture for slider progress bar.
Parameters:
{String} fileName
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadProgressBarTexture(fileName?: string, texType?: any);
            /**
            * loadSlidBallTextureDisabled(disabled, texType)
Load dark state texture for slider ball.
Parameters:
{String} disabled
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadSlidBallTextureDisabled(disabled?: string, texType?: any);
            /**
            * loadSlidBallTextureNormal(normal, texType)
Loads normal state texture for slider ball.
Parameters:
{String} normal
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadSlidBallTextureNormal(normal?: string, texType?: any);
            /**
            * loadSlidBallTexturePressed(pressed, texType)
Loads selected state texture for slider ball.
Parameters:
{String} pressed
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadSlidBallTexturePressed(pressed?: string, texType?: any);
            /**
            * loadSlidBallTextures(normal, pressed, disabled, texType)
Loads textures for slider ball.
Parameters:
{String} normal
{String} pressed
{String} disabled
{ccui.Widget.LOCAL_TEXTURE|ccui.Widget.PLIST_TEXTURE} texType

            */
            loadSlidBallTextures(normal?: string, pressed?: string, disabled?: string, texType?: any);
            /**
            * setCapInsetProgressBarRenderer(capInsets)
Sets capinsets of ProgressBar for slider, if slider is using scale9 renderer.
Parameters:
{cc.Rect} capInsets

            */
            setCapInsetProgressBarRenderer(capInsets?: cc.Rect);
            /**
            * setCapInsets(capInsets)
Sets capinsets for slider, if slider is using scale9 renderer.
Parameters:
{cc.Rect} capInsets

            */
            setCapInsets(capInsets?: cc.Rect);
            /**
            * setCapInsetsBarRenderer(capInsets)
Sets capinsets for slider&#39;s renderer, if slider is using scale9 renderer.
Parameters:
{cc.Rect} capInsets

            */
            setCapInsetsBarRenderer(capInsets?: cc.Rect);
            /**
            * setPercent(percent)
Changes the progress direction of slider.
Parameters:
{number} percent

            */
            setPercent(percent?: number);
            /**
            * setScale9Enabled(able)
Sets if slider is using scale9 renderer.
Parameters:
{Boolean} able

            */
            setScale9Enabled(able?: boolean);
        }
    }
declare module ccui {
        /**
        * 
        */
        export class TextField extends ccui.Widget {
            /**
            * 
            */
            constructor();
            /**
            * The attach with IME event flag of ccui.TextField
            */
            static EVENT_ATTACH_WITH_IME;
            /**
            * The delete backward event flag of ccui.TextField
            */
            static EVENT_DELETE_BACKWARD;
            /**
            * The detach with IME event flag of ccui.TextField
            */
            static EVENT_DETACH_WITH_IME;
            /**
            * The insert text event flag of ccui.TextField
            */
            static EVENT_INSERT_TEXT;
            /**
            * - The text field font with a style string: e.g.
            */
            font: string;
            /**
            * - The text field font name
            */
            fontName: string;
            /**
            * - The text field font size
            */
            fontSize: number;
            /**
            * - The max length of the text field
            */
            maxLength: number;
            /**
            * - Indicate whether max length limit is enabled
            */
            maxLengthEnabled: boolean;
            /**
            * - Indicate whether the text field is for entering password
            */
            passwordEnabled: boolean;
            /**
            * - The place holder of the text field
            */
            placeHolder: string;
            /**
            * The zOrder value of ccui.TextField&#39;s renderer.
            */
            static RENDERER_ZORDER;
            /**
            * - The content string of the label
            */
            string: string;
            /**
            * addEventListener(target, selector)
Adds event listener callback.
Parameters:
{Object} target
Optional
{Function} selector

            */
            addEventListener(target?: Object, selector?: Function);
            /**
            * addEventListenerTextField(target, selector)
Adds event listener to cuci.TextField.
Parameters:
{Object} target
Optional
{Function} selector
Deprecated:
since v3.0, please use addEventListener instead.

            */
            addEventListenerTextField(target?: Object, selector?: Function);
            /**
            * {Boolean}
attachWithIME()
Open keyboard and receive input text.
Returns:
{Boolean}

            */
            attachWithIME(): boolean;
            /**
            * &amp;lt;static&amp;gt;
{ccui.TextField}
ccui.TextField.create(placeholder, fontName, fontSize)
Creates a ccui.TextField.
Parameters:
{String} placeholder
{String} fontName
{Number} fontSize
Deprecated:
since v3.0, please use new ccui.TextField() instead.
Returns:
{ccui.TextField}

            */
            static create(placeholder?: string, fontName?: string, fontSize?: number): ccui.TextField;
            /**
            * ctor(placeholder, fontName, fontSize)
allocates and initializes a UITextField.
Constructor of ccui.TextField. override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
// example
var uiTextField = new ccui.TextField();
Parameters:
{string} placeholder
{string} fontName
{Number} fontSize

            */
            ctor(placeholder?: string, fontName?: string, fontSize?: number);
            /**
            * didNotSelectSelf()
detach with IME

            */
            didNotSelectSelf();
            /**
            * {Boolean}
getAttachWithIME()
Returns whether attach with IME.
Returns:
{Boolean}

            */
            getAttachWithIME(): boolean;
            /**
            * {Boolean}
getDeleteBackward()
Returns the delete backward of ccui.TextField.
Returns:
{Boolean}

            */
            getDeleteBackward(): boolean;
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of ccui.TextField.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * {Boolean}
getDetachWithIME()
Returns whether detach with IME.
Returns:
{Boolean}

            */
            getDetachWithIME(): boolean;
            /**
            * {String}
getFontName()
Returns font name of ccui.TextField.
Returns:
{String} font name

            */
            getFontName(): string;
            /**
            * {Number}
getFontSize()
Gets font size of ccui.TextField.
Returns:
{Number} size

            */
            getFontSize(): number;
            /**
            * {String}
getInsertText()
Returns insertText string of ccui.TextField.
Returns:
{String}

            */
            getInsertText(): string;
            /**
            * {number}
getMaxLength()
Returns the max length of ccui.TextField.
Returns:
{number} length

            */
            getMaxLength(): number;
            /**
            * {String}
getPasswordStyleText()
Returns the password style character.
Returns:
{String}

            */
            getPasswordStyleText(): string;
            /**
            * {String}
getPlaceHolder()
Returns the placeholder string.
Returns:
{String}

            */
            getPlaceHolder(): string;
            /**
            * {cc.Color}
getPlaceHolderColor()
Returns the color of ccui.TextField&#39;s place holder.
Returns:
{cc.Color}

            */
            getPlaceHolderColor(): cc.Color;
            /**
            * {String}
getString()
Returns string value of ccui.TextField.
Returns:
{String}

            */
            getString(): string;
            /**
            * {Number}
getStringLength()
Returns the length of ccui.TextField.
Returns:
{Number}

            */
            getStringLength(): number;
            /**
            * {String}
getStringValue()
Returns textField string value
Deprecated:
since v3.0, please use getString instead.
Returns:
{String}

            */
            getStringValue(): string;
            /**
            * {cc.Size}
getTouchSize()
Returns touch size of ccui.TextField.
Returns:
{cc.Size}

            */
            getTouchSize(): cc.Size;
            /**
            * {cc.Node}
getVirtualRenderer()
Returns the renderer of ccui.TextField.
Returns:
{cc.Node}

            */
            getVirtualRenderer(): cc.Node;
            /**
            * {cc.Size}
getVirtualRendererSize()
Returns the ccui.TextField&#39;s content size.
Returns:
{cc.Size}

            */
            getVirtualRendererSize(): cc.Size;
            /**
            * {boolean}
hitTest(pt)
Checks a point if is in ccui.TextField&#39;s space
Parameters:
{cc.Point} pt
Returns:
{boolean}

            */
            hitTest(pt?: cc.Point): boolean;
            /**
            * {boolean}
init()
Initializes a ccui.TextField. Please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * {Boolean}
isMaxLengthEnabled()
Returns Whether to open string length limit.
Returns:
{Boolean}

            */
            isMaxLengthEnabled(): boolean;
            /**
            * {Boolean}
isPasswordEnabled()
Returns whether to open setting string as password character.
Returns:
{Boolean}

            */
            isPasswordEnabled(): boolean;
            /**
            * onEnter()
Calls parent class&#39; onEnter and schedules update function.

            */
            onEnter();
            /**
            * onTouchBegan(touchPoint, unusedEvent)
The touch began event callback handler.
Parameters:
{cc.Point} touchPoint
unusedEvent

            */
            onTouchBegan(touchPoint?: cc.Point);
            /**
            * setAttachWithIME(attach)
Sets attach with IME.
Parameters:
{Boolean} attach

            */
            setAttachWithIME(attach?: boolean);
            /**
            * setDeleteBackward(deleteBackward)
Sets the delete backward of ccui.TextField.
Parameters:
{Boolean} deleteBackward

            */
            setDeleteBackward(deleteBackward?: boolean);
            /**
            * setDetachWithIME(detach)
Sets detach with IME.
Parameters:
{Boolean} detach

            */
            setDetachWithIME(detach?: boolean);
            /**
            * setFontName(name)
Sets font name for ccui.TextField
Parameters:
{String} name

            */
            setFontName(name?: string);
            /**
            * setFontSize(size)
Sets font size for ccui.TextField.
Parameters:
{Number} size

            */
            setFontSize(size?: number);
            /**
            * setInsertText(insertText)
Sets insertText string to ccui.TextField.
Parameters:
{String} insertText

            */
            setInsertText(insertText?: string);
            /**
            * setMaxLength(length)
Sets the max length of ccui.TextField. Only when you turn on the string length limit, it is valid.
Parameters:
{number} length

            */
            setMaxLength(length?: number);
            /**
            * setMaxLengthEnabled(enable)
Sets Whether to open string length limit for ccui.TextField.
Parameters:
{Boolean} enable

            */
            setMaxLengthEnabled(enable?: boolean);
            /**
            * setPasswordEnabled(enable)
Sets whether to open setting string as password character.
Parameters:
{Boolean} enable

            */
            setPasswordEnabled(enable?: boolean);
            /**
            * setPasswordStyleText(styleText)
Sets the password style character, Only when you turn on setting string as password character, it is valid.
Parameters:
styleText

            */
            setPasswordStyleText();
            /**
            * setPlaceHolder(value)
Sets the placeholder string.
display this string if string equal &quot;&quot;.
Parameters:
{String} value

            */
            setPlaceHolder(value?: string);
            /**
            * setPlaceHolderColor(color)
Sets the place holder color to ccui.TextField.
Parameters:
color

            */
            setPlaceHolderColor();
            /**
            * setString(text)
Changes the string value of textField.
Parameters:
{String} text

            */
            setString(text?: string);
            /**
            * setText(text)
Changes the string value of textField.
Parameters:
{String} text
Deprecated:
since v3.0, please use setString instead.

            */
            setText(text?: string);
            /**
            * setTextAreaSize(size)
Sets the text area size to ccui.TextField.
Parameters:
{cc.Size} size

            */
            setTextAreaSize(size?: cc.Size);
            /**
            * setTextColor(textColor)
Sets the text color to ccui.TextField
Parameters:
textColor

            */
            setTextColor();
            /**
            * setTextHorizontalAlignment(alignment)
Sets the text horizontal alignment of ccui.TextField.
Parameters:
alignment

            */
            setTextHorizontalAlignment();
            /**
            * setTextVerticalAlignment(alignment)
Sets the text vertical alignment of ccui.TextField.
Parameters:
alignment

            */
            setTextVerticalAlignment();
            /**
            * setTouchAreaEnabled(enable)
Sets whether use touch area.
Parameters:
enable

            */
            setTouchAreaEnabled();
            /**
            * setTouchSize(size)
Sets touch size of ccui.TextField.
Parameters:
{cc.Size} size

            */
            setTouchSize(size?: cc.Size);
        }
    }
declare module ccui {
        /**
        * 
The vertical box of Cocos UI. Its layout type is ccui.Layout.LINEAR_VERTICAL.

        */
        export class VBox extends ccui.Layout {
            /**
            * The vertical box of Cocos UI.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{ccui.VBox}
ccui.VBox.create(size)
Creates a VBox
Parameters:
{cc.Size} size
Returns:
{ccui.VBox}

            */
            static create(size?: cc.Size): ccui.VBox;
            /**
            * ctor(size)
The constructor of ccui.VBox
Parameters:
{cc.Size} size

            */
            ctor(size?: cc.Size);
            /**
            * {boolean}
init()
Initializes a VBox. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * {boolean}
initWithSize(size)
Initializes a VBox with size.
Parameters:
{cc.Size} size
Returns:
{boolean}

            */
            initWithSize(size?: cc.Size): boolean;
        }
    }
declare module ccui {
        /**
        * 
The base class for ccui controls and layout

        */
        export class Widget extends ccui.ProtectedNode {
            /**
            * The base class for ccui controls and layout
            */
            constructor();
            /**
            * - The action tag of the widget
            */
            actionTag: number;
            /**
            * - Indicate whether the widget is bright
            */
            bright: boolean;
            /**
            * Light bright style of ccui.Widget.
            */
            static BRIGHT_STYLE_HIGH_LIGHT;
            /**
            * None bright style of ccui.Widget.
            */
            static BRIGHT_STYLE_NONE;
            /**
            * Normal bright style of ccui.Widget.
            */
            static BRIGHT_STYLE_NORMAL;
            /**
            * The down of Focus direction for ccui.Widget
            */
            static DOWN;
            /**
            * - Indicate whether the widget is enabled
            */
            enabled: boolean;
            /**
            * - Indicate whether the widget is focused
            */
            focused: boolean;
            /**
            * - Height in percentage of parent height
            */
            heightPercent: number;
            /**
            * The left of Focus direction for ccui.Widget
            */
            static LEFT;
            /**
            * The image file texture type of ccui.Widget loads.
            */
            static LOCAL_TEXTURE;
            /**
            * - The name of the widget
            */
            name: string;
            /**
            * 
When a widget lose/get focus, this method will be called.
            */
            onFocusChanged;
            /**
            * use this function to manually specify the next focused widget regards to each direction
            */
            onNextFocusedWidget;
            /**
            * The sprite frame texture type of ccui.Widget loads.
            */
            static PLIST_TEXTURE;
            /**
            * The absolute of ccui.Widget&#39;s position type.
            */
            static POSITION_ABSOLUTE;
            /**
            * The percent of ccui.Widget&#39;s position type.
            */
            static POSITION_PERCENT;
            /**
            * The right of Focus direction for ccui.Widget
            */
            static RIGHT;
            /**
            * The absolute of ccui.Widget&#39;s size type.
            */
            static SIZE_ABSOLUTE;
            /**
            * The percent of ccui.Widget&#39;s size type.
            */
            static SIZE_PERCENT;
            /**
            * - The size type of the widget
            */
            sizeType: any;
            /**
            * The touch began type of ccui.Widget&#39;s touch event
            */
            static TOUCH_BEGAN;
            /**
            * The touch canceled type of ccui.Widget&#39;s touch event
            */
            static TOUCH_CANCELED;
            /**
            * The touch end type of ccui.Widget&#39;s touch event
            */
            static TOUCH_ENDED;
            /**
            * The touch moved type of ccui.Widget&#39;s touch event
            */
            static TOUCH_MOVED;
            /**
            * - Indicate whether touch events are enabled
            */
            touchEnabled: boolean;
            /**
            * The type code of Container for ccui controls.
            */
            static TYPE_CONTAINER;
            /**
            * The type code of Widget for ccui controls.
            */
            static TYPE_WIDGET;
            /**
            * The up of Focus direction for ccui.Widget
            */
            static UP;
            /**
            * - Indicate whether the update function is scheduled
            */
            updateEnabled: boolean;
            /**
            * -  The direct parent when it&#39;s a widget also, otherwise equals null
            */
            widgetParent: ccui.Widget;
            /**
            * -  The type of the widget
            */
            widgetType: any;
            /**
            * - Width in percentage of parent width
            */
            widthPercent: number;
            /**
            * - Position x in percentage of width
            */
            xPercent: number;
            /**
            * - Position y in percentage of height
            */
            yPercent: number;
            /**
            * addNode(node, zOrder, tag)
Adds a node for widget (this function is deleted in -x)
Parameters:
{cc.Node} node
{Number} zOrder
{Number} tag
Deprecated:
since v3.0, please use addChild instead.

            */
            addNode(node?: cc.Node, zOrder?: number, tag?: number);
            /**
            * addTouchEventListener(selector, target)
Sets the touch event target/selector of the ccui.Widget
Parameters:
{Function} selector
{Object} target

            */
            addTouchEventListener(selector?: Function, target?: Object);
            /**
            * checkChildInfo(handleState, sender, touchPoint)
Calls the checkChildInfo of widget&#39;s parent, its subclass will override it.
Parameters:
{number} handleState
{ccui.Widget} sender
{cc.Point} touchPoint

            */
            checkChildInfo(handleState?: number, sender?: ccui.Widget, touchPoint?: cc.Point);
            /**
            * {Boolean}
clippingParentAreaContainPoint(pt)
Checks a point if in parent&#39;s area.
Parameters:
{cc.Point} pt
Deprecated:
since v3.0, please use isClippingParentContainsPoint instead.
Returns:
{Boolean}

            */
            clippingParentAreaContainPoint(pt?: cc.Point): boolean;
            /**
            * {ccui.Widget}
clone()
Clones a new widget.
Returns:
{ccui.Widget}

            */
            clone(): ccui.Widget;
            /**
            * &amp;lt;static&amp;gt;
{ccui.Widget}
ccui.Widget.create()
allocates and initializes a UIWidget.
Returns:
{ccui.Widget}

            */
            static create(arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): ccui.Widget;
            /**
            * ctor()
Constructor function, override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.

            */
            ctor();
            /**
            * didNotSelectSelf()
A call back function when widget lost of focus.

            */
            didNotSelectSelf();
            /**
            * dispatchFocusEvent(widgetLostFocus, widgetGetFocus)
Dispatch a EventFocus through a EventDispatcher
Parameters:
{ccui.Widget} widgetLostFocus
{ccui.Widget} widgetGetFocus

            */
            dispatchFocusEvent(widgetLostFocus?: ccui.Widget, widgetGetFocus?: ccui.Widget);
            /**
            * enableDpadNavigation(enable)
call this method with parameter true to enable the Android Dpad focus navigation feature
Parameters:
{Boolean} enable
set true to enable dpad focus navigation, otherwise disable dpad focus navigation

            */
            enableDpadNavigation(enable?: boolean);
            /**
            * findNextFocusedWidget(direction, current)
When a widget is in a layout, you could call this method to get the next focused widget within a specified direction.
If the widget is not in a layout, it will return itself
Parameters:
direction
the direction to look for the next focused widget in a layout
current
the current focused widget
Returns:
the next focused widget in a layout

            */
            findNextFocusedWidget();
            /**
            * {number}
getBottomBoundary()
Gets the bottom boundary position of this widget.
Returns:
{number}

            */
            getBottomBoundary(): number;
            /**
            * {number}
getBottomInParent()
Gets the bottom boundary position of this widget.
Deprecated:
since v3.0, please use getBottomBoundary instead.
Returns:
{number}

            */
            getBottomInParent(): number;
            /**
            * &amp;lt;static&amp;gt;
{null|ccui.Widget}
ccui.Widget.getCurrentFocusedWidget()
Gets the focused widget of current stage.
Returns:
{null|ccui.Widget}

            */
            static getCurrentFocusedWidget(): any;
            /**
            * getCurrentFocusedWidget()
no matter what widget object you call this method on , it will return you the exact one focused widget

            */
            getCurrentFocusedWidget();
            /**
            * {cc.Size}
getCustomSize()
Get custom size of ccui.Widget
Returns:
{cc.Size}

            */
            getCustomSize(): cc.Size;
            /**
            * {string}
getDescription()
Returns the &quot;class name&quot; of widget.
Returns:
{string}

            */
            getDescription(): string;
            /**
            * {ccui.LayoutParameter}
getLayoutParameter(type)
Gets layout parameter
Parameters:
{ccui.LayoutParameter.NONE|ccui.LayoutParameter.LINEAR|ccui.LayoutParameter.RELATIVE} type
Returns:
{ccui.LayoutParameter}

            */
            getLayoutParameter(type?: any): ccui.LayoutParameter;
            /**
            * {cc.Size}
getLayoutSize()
Gets layout size of ccui.Widget.
Returns:
{cc.Size}

            */
            getLayoutSize(): cc.Size;
            /**
            * {number}
getLeftBoundary()
Gets the left boundary position of this widget.
Returns:
{number}

            */
            getLeftBoundary(): number;
            /**
            * {number}
getLeftInParent()
Gets the left boundary position of this widget.
Deprecated:
since v3.0, please use getLeftBoundary instead.
Returns:
{number}

            */
            getLeftInParent(): number;
            /**
            * {cc.Node}
getNodeByTag(tag)
Gets node by tag
Parameters:
{Number} tag
Deprecated:
since v3.0, please use getChildByTag instead.
Returns:
{cc.Node}

            */
            getNodeByTag(tag?: number): cc.Node;
            /**
            * {Array}
getNodes()
Returns all children.
Deprecated:
since v3.0, please use getChildren instead.
Returns:
{Array}

            */
            getNodes(): Array<any>;
            /**
            * {cc.Point}
getPositionPercent()
Gets the percent (x,y) of the widget
Returns:
{cc.Point} The percent (x,y) of the widget in OpenGL coordinates

            */
            getPositionPercent(): cc.Point;
            /**
            * {Number}
getPositionType()
Gets the position type of the widget
Returns:
{Number} the position type of widget

            */
            getPositionType(): number;
            /**
            * {number}
getRightBoundary()
Gets the right boundary position of this widget.
Returns:
{number}

            */
            getRightBoundary(): number;
            /**
            * {number}
getRightInParent()
Gets the right boundary position of this widget.
Deprecated:
since v3.0, please use getRightBoundary instead.
Returns:
{number}

            */
            getRightInParent(): number;
            /**
            * {cc.Size}
getSize()
Returns size of widget
Deprecated:
since v3.0, please use getContentSize instead.
Returns:
{cc.Size}

            */
            getSize(): cc.Size;
            /**
            * {cc.Point}
getSizePercent()
Returns size percent of ccui.Widget
Returns:
{cc.Point}

            */
            getSizePercent(): cc.Point;
            /**
            * {ccui.Widget.SIZE_ABSOLUTE|ccui.Widget.SIZE_PERCENT}
getSizeType()
Gets the size type of widget.
Returns:
{ccui.Widget.SIZE_ABSOLUTE|ccui.Widget.SIZE_PERCENT} that is widget&#39;s size type

            */
            getSizeType(): any;
            /**
            * {number}
getTopBoundary()
Gets the top boundary position of this widget.
Returns:
{number}

            */
            getTopBoundary(): number;
            /**
            * {number}
getTopInParent()
Gets the top boundary position of this widget.
Deprecated:
since v3.0, please use getTopBoundary instead.
Returns:
{number}

            */
            getTopInParent(): number;
            /**
            * {cc.Point}
getTouchBeganPosition()
Gets the position of touch began event.
Returns:
{cc.Point}

            */
            getTouchBeganPosition(): cc.Point;
            /**
            * {cc.Point}
getTouchEndPos()
Gets the touch end point of widget when widget is selected.
Deprecated:
since v3.0, please use getTouchEndPosition instead.
Returns:
{cc.Point} the touch end point.

            */
            getTouchEndPos(): cc.Point;
            /**
            * {cc.Point}
getTouchEndPosition()
Gets the position of touch end event
Returns:
{cc.Point}

            */
            getTouchEndPosition(): cc.Point;
            /**
            * {cc.Point}
getTouchMovePos()
Gets the touch move point of widget when widget is selected.
Deprecated:
since v3.0, please use getTouchMovePosition instead.
Returns:
{cc.Point} the touch move point.

            */
            getTouchMovePos(): cc.Point;
            /**
            * {cc.Point}
getTouchMovePosition()
Gets the position of touch moved event
Returns:
{cc.Point}

            */
            getTouchMovePosition(): cc.Point;
            /**
            * {cc.Point}
getTouchStartPos()
Gets the touch began point of widget when widget is selected.
Deprecated:
since v3.0, please use getTouchBeganPosition instead.
Returns:
{cc.Point} the touch began point.

            */
            getTouchStartPos(): cc.Point;
            /**
            * {ccui.Widget}
getVirtualRenderer()
Gets the Virtual Renderer of widget.
Returns:
{ccui.Widget}

            */
            getVirtualRenderer(): ccui.Widget;
            /**
            * getVirtualRendererSize()
Gets the content size of widget.  Content size is widget&#39;s texture size.

            */
            getVirtualRendererSize();
            /**
            * {ccui.Widget|null}
getWidgetParent()
The direct parent when it&#39;s a widget also, otherwise equals null
Returns:
{ccui.Widget|null}

            */
            getWidgetParent(): any;
            /**
            * {ccui.Widget.TYPE_WIDGET|ccui.Widget.TYPE_CONTAINER}
getWidgetType()
get widget type
Returns:
{ccui.Widget.TYPE_WIDGET|ccui.Widget.TYPE_CONTAINER}

            */
            getWidgetType(): any;
            /**
            * {cc.Point}
getWorldPosition()
Gets world position of ccui.Widget.
Returns:
{cc.Point} world position of ccui.Widget.

            */
            getWorldPosition(): cc.Point;
            /**
            * {boolean}
hitTest(pt)
Checks a point if is in widget&#39;s space
Parameters:
{cc.Point} pt
Returns:
{boolean} true if the point is in widget&#39;s space, false otherwise.

            */
            hitTest(pt?: cc.Point): boolean;
            /**
            * ignoreContentAdaptWithSize(ignore)
Ignore the widget size
Parameters:
{Boolean} ignore
true that widget will ignore it&#39;s size, use texture size, false otherwise. Default value is true.

            */
            ignoreContentAdaptWithSize(ignore?: boolean);
            /**
            * {boolean}
init()
initializes state of widget. please do not call this function by yourself, you should pass the parameters to constructor to initialize it
.
Returns:
{boolean}

            */
            init(): boolean;
            /**
            * interceptTouchEvent(eventType, sender, touch)
Sends the touch event to widget&#39;s parent, its subclass will override it, e.g. ccui.ScrollView, ccui.PageView
Parameters:
{Number} eventType
{ccui.Widget} sender
{cc.Touch} touch

            */
            interceptTouchEvent(eventType?: number, sender?: ccui.Widget, touch?: cc.Touch);
            /**
            * {boolean}
isBright()
Determines if the widget is bright
Returns:
{boolean} true if the widget is bright, false if the widget is dark.

            */
            isBright(): boolean;
            /**
            * {Boolean}
isClippingParentContainsPoint(pt)
returns whether clipping parent widget contains point.
Parameters:
{cc.Point} pt
location point
Returns:
{Boolean}

            */
            isClippingParentContainsPoint(pt?: cc.Point): boolean;
            /**
            * {boolean}
isEnabled()
Determines if the widget is enabled
Returns:
{boolean}

            */
            isEnabled(): boolean;
            /**
            * {Boolean}
isFlippedX()
Returns the flag which indicates whether the widget is flipped horizontally or not.
It only flips the texture of the widget, and not the texture of the widget&#39;s children.
Also, flipping the texture doesn&#39;t alter the anchorPoint.
If you want to flip the anchorPoint too, and/or to flip the children too use:
widget.setScaleX(sprite.getScaleX() * -1);
Returns:
{Boolean} true if the widget is flipped horizontally, false otherwise.

            */
            isFlippedX(): boolean;
            /**
            * {Boolean}
isFlippedY()
Return the flag which indicates whether the widget is flipped vertically or not.
It only flips the texture of the widget, and not the texture of the widget&#39;s children.
Also, flipping the texture doesn&#39;t alter the anchorPoint.
If you want to flip the anchorPoint too, and/or to flip the children too use:
widget.setScaleY(widget.getScaleY() * -1);
Returns:
{Boolean} true if the widget is flipped vertically, false otherwise.

            */
            isFlippedY(): boolean;
            /**
            * {boolean}
isFocused()
Determines if the widget is on focused
Returns:
{boolean} whether the widget is focused or not

            */
            isFocused(): boolean;
            /**
            * {boolean}
isFocusEnabled()
returns whether the widget could accept focus.
Returns:
{boolean} true represent the widget could accept focus, false represent the widget couldn&#39;t accept focus

            */
            isFocusEnabled(): boolean;
            /**
            * {boolean}
isHighlighted()
Determines if the widget is highlighted
Returns:
{boolean} true if the widget is highlighted, false if the widget is not highlighted .

            */
            isHighlighted(): boolean;
            /**
            * {boolean}
isIgnoreContentAdaptWithSize()
Gets whether ignore the content size (custom size)
Returns:
{boolean} true that widget will ignore it&#39;s size, use texture size, false otherwise.

            */
            isIgnoreContentAdaptWithSize(): boolean;
            /**
            * {boolean}
isTouchEnabled()
Returns whether or not touch is enabled.
Returns:
{boolean} true if the widget is touch enabled, false if the widget is touch disabled.

            */
            isTouchEnabled(): boolean;
            /**
            * onEnter()
Calls updateSizeAndPosition and its parent&#39;s onEnter

            */
            onEnter();
            /**
            * onExit()
Calls unscheduleUpdate and its parent&#39;s onExit

            */
            onExit();
            /**
            * onFocusChange(widgetLostFocus, widgetGetFocus)
This method is called when a focus change event happens
Parameters:
{ccui.Widget} widgetLostFocus
{ccui.Widget} widgetGetFocus

            */
            onFocusChange(widgetLostFocus?: ccui.Widget, widgetGetFocus?: ccui.Widget);
            /**
            * {boolean}
onTouchBegan(touch, event)
The callback of touch began event.
If the bounding box of ccui.Widget contains the touch point, it will do the following things:
1. sets highlight state,
2. sends event to parent widget by interceptTouchEvent
3. calls the callback of touch began event.
4. returns true,
otherwise returns false directly.
Parameters:
{cc.Touch} touch
{cc.Event} event
Returns:
{boolean}

            */
            onTouchBegan(touch?: cc.Touch, event?: cc.Event): boolean;
            /**
            * onTouchCancelled(touchPoint)
A call back function called when widget is selected, and on touch canceled.
Parameters:
{cc.Point} touchPoint

            */
            onTouchCancelled(touchPoint?: cc.Point);
            /**
            * onTouchEnded(touch, event)
The callback of touch end event
It sends event to parent widget by interceptTouchEvent,
calls the callback of touch end event (highlight= true) or touch canceled event (highlight= false).
sets the highlight state to false ,
Parameters:
touch
event

            */
            onTouchEnded();
            /**
            * onTouchLongClicked(touchPoint)
A call back function called when widget is selected, and on touch long clicked.
Parameters:
{cc.Point} touchPoint

            */
            onTouchLongClicked(touchPoint?: cc.Point);
            /**
            * onTouchMoved(touch, event)
The callback of touch moved event.
It sets the highlight state by touch, sends event to parent widget by interceptTouchEvent and calls the callback of touch moved event.
Parameters:
{cc.Touch} touch
{cc.Event} event

            */
            onTouchMoved(touch?: cc.Touch, event?: cc.Event);
            /**
            * removeAllNodes()
Removes all node
Deprecated:
since v3.0, please use removeAllChildren instead.

            */
            removeAllNodes();
            /**
            * removeNode(node, cleanup)
Removes a node from ccui.Widget
Parameters:
{cc.Node} node
{Boolean} cleanup
Deprecated:
since v3.0, please use removeChild instead.

            */
            removeNode(node?: cc.Node, cleanup?: boolean);
            /**
            * removeNodeByTag(tag, cleanup)
Removes node by tag
Parameters:
{Number} tag
{Boolean} cleanup
Optional
Deprecated:
since v3.0, please use removeChildByTag instead.

            */
            removeNodeByTag(tag?: number, cleanup?: boolean);
            /**
            * requestFocus()
when a widget calls this method, it will get focus immediately.

            */
            requestFocus();
            /**
            * setBright(bright)
Sets whether the widget is bright. The default value is true, a widget is default to bright
Parameters:
{Boolean} bright
true if the widget is bright, false if the widget is dark.

            */
            setBright(bright?: boolean);
            /**
            * setBrightStyle(style)
To set the bright style of ccui.Widget.
Parameters:
{Number} style
BRIGHT_NORMAL the widget is normal state, BRIGHT_HIGHLIGHT the widget is height light state.

            */
            setBrightStyle(style?: number);
            /**
            * setContentSize(contentSize, height)
Sets _customSize of ccui.Widget, if ignoreSize is true, the content size is its renderer&#39;s contentSize, otherwise the content size is parameter.
and updates size percent by parent content size. At last, updates its children&#39;s size and position.
Parameters:
{cc.Size|Number} contentSize
content size or width of content size
{Number} height
Optional

            */
            setContentSize(contentSize?: any, height?: number);
            /**
            * setEnabled(enabled)
Sets whether the widget is enabled
true if the widget is enabled, widget may be touched , false if the widget is disabled, widget cannot be touched.
The default value is true, a widget is default to enabled
Parameters:
{Boolean} enabled

            */
            setEnabled(enabled?: boolean);
            /**
            * setFlippedX(flipX)
Sets whether the widget should be flipped horizontally or not.
Parameters:
{Boolean} flipX
true if the widget should be flipped horizontally, false otherwise.

            */
            setFlippedX(flipX?: boolean);
            /**
            * setFlippedY(flipY)
Sets whether the widget should be flipped vertically or not.
Parameters:
{Boolean} flipY
true if the widget should be flipped vertically, false otherwise.

            */
            setFlippedY(flipY?: boolean);
            /**
            * setFocused(focus)
Sets whether the widget is on focused
The default value is false, a widget is default to not on focused
Parameters:
{boolean} focus
pass true to let the widget get focus or pass false to let the widget lose focus

            */
            setFocused(focus?: boolean);
            /**
            * setFocusEnabled(enable)
sets whether the widget could accept focus.
Parameters:
{Boolean} enable
true represent the widget could accept focus, false represent the widget couldn&#39;t accept focus

            */
            setFocusEnabled(enable?: boolean);
            /**
            * setHighlighted(highlight)
Sets whether the widget is highlighted. The default value is false, a widget is default to not highlighted
Parameters:
highlight
true if the widget is highlighted, false if the widget is not highlighted.

            */
            setHighlighted();
            /**
            * setLayoutParameter(parameter)
Gets LayoutParameter of widget.
Parameters:
{ccui.LayoutParameter} parameter

            */
            setLayoutParameter(parameter?: ccui.LayoutParameter);
            /**
            * setPosition(pos, posY)
Changes the position (x,y) of the widget .
The original point (0,0) is at the left-bottom corner of screen.
Parameters:
{cc.Point|Number} pos
{Number} posY
Optional

            */
            setPosition(pos?: any, posY?: number);
            /**
            * setPositionPercent(percent)
Changes the position (x,y) of the widget
Parameters:
{cc.Point} percent

            */
            setPositionPercent(percent?: cc.Point);
            /**
            * setPositionType(type)
Changes the position type of the widget
Parameters:
{Number} type
the position type of widget

            */
            setPositionType(type?: number);
            /**
            * setSize(size)
Changes the size that is widget&#39;s size
Parameters:
{cc.Size} size
that is widget&#39;s size
Deprecated:
since v3.0, please use setContentSize instead.

            */
            setSize(size?: cc.Size);
            /**
            * setSizePercent(percent)
Changes the percent that is widget&#39;s percent size
Parameters:
{cc.Point} percent
that is widget&#39;s percent size, width and height value from 0 to 1.

            */
            setSizePercent(percent?: cc.Point);
            /**
            * setSizeType(type)
TEXTURE_RES_TYPE
Changes the size type of widget.
Parameters:
{ccui.Widget.SIZE_ABSOLUTE|ccui.Widget.SIZE_PERCENT} type
that is widget&#39;s size type

            */
            setSizeType(type?: any);
            /**
            * setTouchEnabled(enable)
Sets whether the widget is touch enabled. The default value is false, a widget is default to touch disabled
Parameters:
{Boolean} enable
true if the widget is touch enabled, false if the widget is touch disabled.

            */
            setTouchEnabled(enable?: boolean);
            /**
            * updateSizeAndPosition(parentSize)
updates its size by size type and its position by position type.
Parameters:
{cc.Size} parentSize
Optional
parent size

            */
            updateSizeAndPosition(parentSize?: cc.Size);
            /**
            * visit(ctx)
Calls _adaptRenderers(its subClass will override it) before calls its parent&#39;s visit.
Parameters:
{CanvasRenderingContext2D|WebGLRenderingContext} ctx

            */
            visit(ctx?: any);
        }
    }
declare module jsb {
        /**
        * 
        */
        export class AssetsManager  {
            /**
            * 
            */
            constructor();
            /**
            * checkUpdate()

            */
            checkUpdate();
            /**
            * {jsb.AssetsManager}
create(arg0, arg1)
Parameters:
{String} arg0
{String} arg1
Returns:
{jsb.AssetsManager}

            */
            create(arg0?: string, arg1?: string): jsb.AssetsManager;
            /**
            * ctor(arg0, arg1)
Parameters:
{String} arg0
{String} arg1

            */
            ctor(arg0?: string, arg1?: string);
            /**
            * downloadFailedAssets()

            */
            downloadFailedAssets();
            /**
            * {jsb.Manifest}
getLocalManifest()
Returns:
{jsb.Manifest}

            */
            getLocalManifest(): jsb.Manifest;
            /**
            * {jsb.Manifest}
getRemoteManifest()
Returns:
{jsb.Manifest}

            */
            getRemoteManifest(): jsb.Manifest;
            /**
            * {jsb.AssetsManager::State}
getState()
Returns:
{jsb.AssetsManager::State}

            */
            getState(): any;
            /**
            * {String}
getStoragePath()
Returns:
{String}

            */
            getStoragePath(): string;
            /**
            * update()

            */
            update();
        }
    }
declare module jsb {
        /**
        * 
        */
        export class EventAssetsManager  {
            /**
            * 
            */
            constructor();
            /**
            * EventAssetsManager(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
Parameters:
{String} arg0
{cc.AssetsManager} arg1
{cc.EventAssetsManager::EventCode} arg2
{float} arg3
{float} arg4
{String} arg5
{String} arg6
{int} arg7
{int} arg8

            */
            EventAssetsManager(arg0?: string, arg1?: any, arg2?: any, arg3?: number, arg4?: number, arg5?: string, arg6?: string, arg7?: number, arg8?: number);
            /**
            * {String}
getAssetId()
Returns:
{String}

            */
            getAssetId(): string;
            /**
            * {cc.AssetsManager}
getAssetsManager()
Returns:
{cc.AssetsManager}

            */
            getAssetsManager(): any;
            /**
            * {int}
getCURLECode()
Returns:
{int}

            */
            getCURLECode(): number;
            /**
            * {int}
getCURLMCode()
Returns:
{int}

            */
            getCURLMCode(): number;
            /**
            * {cc.EventAssetsManager::EventCode}
getEventCode()
Returns:
{cc.EventAssetsManager::EventCode}

            */
            getEventCode(): any;
            /**
            * {String}
getMessage()
Returns:
{String}

            */
            getMessage(): string;
            /**
            * {float}
getPercent()
Returns:
{float}

            */
            getPercent(): number;
            /**
            * {float}
getPercentByFile()
Returns:
{float}

            */
            getPercentByFile(): number;
        }
    }
declare module jsb {
        /**
        * 
        */
        export class EventListenerAssetsManager  {
            /**
            * 
            */
            constructor();
            /**
            * {cc.EventListenerAssetsManager}
create(arg0, arg1)
Parameters:
{cc.AssetsManager} arg0
{function} arg1
Returns:
{cc.EventListenerAssetsManager}

            */
            create(arg0?: cc.AssetsManager, arg1?: any): cc.EventListenerAssetsManager;
            /**
            * EventListenerAssetsManager()

            */
            EventListenerAssetsManager();
            /**
            * {bool}
init(arg0, arg1)
Parameters:
{cc.AssetsManager} arg0
{function} arg1
Returns:
{bool}

            */
            init(arg0?: cc.AssetsManager, arg1?: any): boolean;
        }
    }
declare module jsb {
        /**
        * 
ATTENTION: USE jsb.fileUtils INSTEAD OF jsb.FileUtils.
jsb.fileUtils is the native file utils&#39; singleton object,
please refer to Cocos2d-x&#39;s API to know how to use it.
Only available in JSB

        */
        export class fileUtils  {
            /**
            * ATTENTION: USE jsb.fileUtils INSTEAD OF jsb.FileUtils.
            */
            constructor();
            /**
            * addSearchPath(arg0)
Parameters:
{String} arg0

            */
            addSearchPath(arg0?: string);
            /**
            * addSearchResolutionsOrder(arg0)
Parameters:
{String} arg0

            */
            addSearchResolutionsOrder(arg0?: string);
            /**
            * {bool}
createDirectories(arg0)
Parameters:
{String} arg0
Returns:
{bool}

            */
            createDirectories(arg0?: string): boolean;
            /**
            * {bool}
createDirectory(arg0)
Parameters:
{String} arg0
Returns:
{bool}

            */
            createDirectory(arg0?: string): boolean;
            /**
            * {String}
fullPathForFilename(arg0)
Parameters:
{String} arg0
Returns:
{String}

            */
            fullPathForFilename(arg0?: string): string;
            /**
            * {String}
fullPathFromRelativeFile(arg0, arg1)
Parameters:
{String} arg0
{String} arg1
Returns:
{String}

            */
            fullPathFromRelativeFile(arg0?: string, arg1?: string): string;
            /**
            * {long}
getFileSize(arg0)
Parameters:
{String} arg0
Returns:
{long}

            */
            getFileSize(arg0?: string): number;
            /**
            * {Array}
getSearchPaths()
Returns:
{Array}

            */
            getSearchPaths(): Array<any>;
            /**
            * {Array}
getSearchResolutionsOrder()
Returns:
{Array}

            */
            getSearchResolutionsOrder(): Array<any>;
            /**
            * {String}
getStringFromFile(arg0)
Parameters:
{String} arg0
Returns:
{String}

            */
            getStringFromFile(arg0?: string): string;
            /**
            * {map_object}
getValueMapFromFile(arg0)
Parameters:
{String} arg0
Returns:
{map_object}

            */
            getValueMapFromFile(arg0?: string): any;
            /**
            * {Array}
getValueVectorFromFile(arg0)
Parameters:
{String} arg0
Returns:
{Array}

            */
            getValueVectorFromFile(arg0?: string): Array<any>;
            /**
            * {String}
getWritablePath()
Returns:
{String}

            */
            getWritablePath(): string;
            /**
            * {bool}
isAbsolutePath(arg0)
Parameters:
{String} arg0
Returns:
{bool}

            */
            isAbsolutePath(arg0?: string): boolean;
            /**
            * {bool}
isDirectoryExist(arg0)
Parameters:
{String} arg0
Returns:
{bool}

            */
            isDirectoryExist(arg0?: string): boolean;
            /**
            * {bool}
isFileExist(arg0)
Parameters:
{String} arg0
Returns:
{bool}

            */
            isFileExist(arg0?: string): boolean;
            /**
            * {bool}
isPopupNotify()
Returns:
{bool}

            */
            isPopupNotify(): boolean;
            /**
            * loadFilenameLookupDictionaryFromFile(arg0)
Parameters:
{String} arg0

            */
            loadFilenameLookupDictionaryFromFile(arg0?: string);
            /**
            * purgeCachedEntries()

            */
            purgeCachedEntries();
            /**
            * {bool}
removeDirectory(arg0)
Parameters:
{String} arg0
Returns:
{bool}

            */
            removeDirectory(arg0?: string): boolean;
            /**
            * {bool}
removeFile(arg0)
Parameters:
{String} arg0
Returns:
{bool}

            */
            removeFile(arg0?: string): boolean;
            /**
            * {bool}
renameFile(arg0, arg1, arg2)
Parameters:
{String} arg0
{String} arg1
{String} arg2
Returns:
{bool}

            */
            renameFile(arg0?: string, arg1?: string, arg2?: string): boolean;
            /**
            * setSearchPaths(arg0)
Parameters:
{Array} arg0

            */
            setSearchPaths(arg0?: Array<any>);
            /**
            * setSearchResolutionsOrder(arg0)
Parameters:
{Array} arg0

            */
            setSearchResolutionsOrder(arg0?: Array<any>);
            /**
            * {bool}
writeStringToFile(arg0, arg1)
Parameters:
{String} arg0
{String} arg1
Returns:
{bool}

            */
            writeStringToFile(arg0?: string, arg1?: string): boolean;
            /**
            * {bool}
writeToFile(arg0, arg1)
Parameters:
{map_object} arg0
{String} arg1
Returns:
{bool}

            */
            writeToFile(arg0?: any, arg1?: string): boolean;
        }
    }
declare module jsb {
        /**
        * 
        */
        export class Manifest  {
            /**
            * 
            */
            constructor();
            /**
            * {String}
getManifestFileUrl()
Returns:
{String}

            */
            getManifestFileUrl(): string;
            /**
            * {String}
getPackageUrl()
Returns:
{String}

            */
            getPackageUrl(): string;
            /**
            * {String}
getVersion()
Returns:
{String}

            */
            getVersion(): string;
            /**
            * {String}
getVersionFileUrl()
Returns:
{String}

            */
            getVersionFileUrl(): string;
            /**
            * {bool}
isLoaded()
Returns:
{bool}

            */
            isLoaded(): boolean;
            /**
            * {bool}
isVersionLoaded()
Returns:
{bool}

            */
            isVersionLoaded(): boolean;
        }
    }
declare module jsb {
        /**
        * 
jsb.reflection is a bridge to let you invoke Java static functions.
please refer to this document to know how to use it: http://www.cocos2d-x.org/docs/manual/framework/html5/v3/reflection/en
Only available on iOS/Mac/Android platform

        */
        export class reflection  {
            /**
            * jsb.reflection is a bridge to let you invoke Java static functions.
            */
            constructor();
            /**
            * callStaticMethod()

            */
            callStaticMethod();
        }
    }
declare module sp {
        /**
        * The skeleton of Spine.
Skeleton has a reference to a SkeletonData and stores the state for skeleton instance,
which consists of the current pose&#39;s bone SRT, slot colors, and which slot attachments are visible.
Multiple skeletons can use the same SkeletonData (which includes all animations, skins, and attachments).

        */
        export class Skeleton extends cc.Node {
            /**
            * 
The skeleton of Spine.
            */
            constructor();
            /**
            * &amp;lt;static&amp;gt;
{sp.Skeleton}
sp.Skeleton.create(skeletonDataFile, atlasFile, scale)
Creates a skeleton object.
Parameters:
{spine.SkeletonData|String} skeletonDataFile
{String|spine.Atlas|spine.SkeletonData} atlasFile
atlas filename or atlas data or owns SkeletonData
{Number} scale
Optional
scale can be specified on the JSON or binary loader which will scale the bone positions, image sizes, and animation translations.
Deprecated:
since v3.0, please use new sp.Skeleton(skeletonDataFile, atlasFile, scale) instead.
Returns:
{sp.Skeleton}

            */
            static create(skeletonDataFile?: any, atlasFile?: any, scale?: number): sp.Skeleton;
            /**
            * ctor(skeletonDataFile, atlasFile, scale)
The constructor of sp.Skeleton. override it to extend the construction behavior, remember to call &quot;this._super()&quot; in the extended &quot;ctor&quot; function.
Parameters:
skeletonDataFile
atlasFile
scale

            */
            ctor();
            /**
            * {spine.Bone}
findBone(boneName)
Finds a bone by name. This does a string comparison for every bone.
Parameters:
{String} boneName
Returns:
{spine.Bone}

            */
            findBone(boneName?: string): spine.Bone;
            /**
            * {spine.Slot}
findSlot(slotName)
Finds a slot by name. This does a string comparison for every slot.
Parameters:
{String} slotName
Returns:
{spine.Slot}

            */
            findSlot(slotName?: string): spine.Slot;
            /**
            * {spine.RegionAttachment|spine.BoundingBoxAttachment}
getAttachment(slotName, attachmentName)
Returns the attachment for the slot and attachment name. The skeleton looks first in its skin, then in the skeleton data’s default skin.
Parameters:
{String} slotName
{String} attachmentName
Returns:
{spine.RegionAttachment|spine.BoundingBoxAttachment}

            */
            getAttachment(slotName?: string, attachmentName?: string): any;
            /**
            * {cc.BlendFunc}
getBlendFunc()
Returns the blendFunc of sp.Skeleton.
Returns:
{cc.BlendFunc}

            */
            getBlendFunc(): cc.BlendFunc;
            /**
            * {cc.Rect}
getBoundingBox()
Returns the bounding box of sp.Skeleton.
Returns:
{cc.Rect}

            */
            getBoundingBox(): cc.Rect;
            /**
            * {cc.Node}
getTextureAtlas(regionAttachment)
Return the renderer of attachment.
Parameters:
{spine.RegionAttachment|spine.BoundingBoxAttachment} regionAttachment
Returns:
{cc.Node}

            */
            getTextureAtlas(regionAttachment?: any): cc.Node;
            /**
            * init()
Initializes a sp.Skeleton. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.

            */
            init();
            /**
            * initWithArgs(skeletonDataFile, atlasFile, scale)
Initializes sp.Skeleton with Data.
Parameters:
{spine.SkeletonData|String} skeletonDataFile
{String|spine.Atlas|spine.SkeletonData} atlasFile
atlas filename or atlas data or owns SkeletonData
{Number} scale
Optional
scale can be specified on the JSON or binary loader which will scale the bone positions, image sizes, and animation translations.

            */
            initWithArgs(skeletonDataFile?: any, atlasFile?: any, scale?: number);
            /**
            * {boolean}
isOpacityModifyRGB()
Returns whether to enable premultiplied alpha.
Returns:
{boolean}

            */
            isOpacityModifyRGB(): boolean;
            /**
            * setAttachment(slotName, attachmentName)
Sets the attachment for the slot and attachment name. The skeleton looks first in its skin, then in the skeleton data’s default skin.
Parameters:
{String} slotName
{String} attachmentName

            */
            setAttachment(slotName?: string, attachmentName?: string);
            /**
            * setBlendFunc(src, dst)
Sets the blendFunc of sp.Skeleton.
Parameters:
{cc.BlendFunc|Number} src
{Number} dst
Optional

            */
            setBlendFunc(src?: any, dst?: number);
            /**
            * setBonesToSetupPose()
Sets the bones to the setup pose, using the values from the `BoneData` list in the `SkeletonData`.

            */
            setBonesToSetupPose();
            /**
            * setDebugBones(enable)
Sets whether open debug bones.
Parameters:
{boolean} enable

            */
            setDebugBones(enable?: boolean);
            /**
            * setDebugSolots(enable)
Sets whether open debug solots.
Parameters:
{boolean} enable
true to open, false to close.

            */
            setDebugSolots(enable?: boolean);
            /**
            * setOpacityModifyRGB(alpha)
Sets the premultiplied alpha value to sp.Skeleton.
Parameters:
{Number} alpha

            */
            setOpacityModifyRGB(alpha?: number);
            /**
            * setSkeletonData(skeletonData, ownsSkeletonData)
Sets skeleton data to sp.Skeleton.
Parameters:
{spine.SkeletonData} skeletonData
{spine.SkeletonData} ownsSkeletonData

            */
            setSkeletonData(skeletonData?: spine.SkeletonData, ownsSkeletonData?: spine.SkeletonData);
            /**
            * {spine.Skin}
setSkin(skinName)
Finds a skin by name and makes it the active skin. This does a string comparison for every skin. Note that setting the skin does not change which attachments are visible.
Parameters:
{string} skinName
Returns:
{spine.Skin}

            */
            setSkin(skinName?: string): spine.Skin;
            /**
            * setSlotsToSetupPose()
Sets the slots to the setup pose, using the values from the `SlotData` list in the `SkeletonData`.

            */
            setSlotsToSetupPose();
            /**
            * setTimeScale(v)
Sets the time scale of sp.Skeleton.
Parameters:
{Number} v

            */
            setTimeScale(v?: number);
            /**
            * setToSetupPose()
Sets the bones and slots to the setup pose.

            */
            setToSetupPose();
            /**
            * update(dt)
Update will be called automatically every frame if &quot;scheduleUpdate&quot; is called when the node is &quot;live&quot;.
Parameters:
{Number} dt
Delta time since last update

            */
            update(dt?: number);
            /**
            * updateWorldTransform()
Computes the world SRT from the local SRT for each bone.

            */
            updateWorldTransform();
        }
    }
declare module sp {
        /**
        * 
The skeleton animation of spine. It updates animation&#39;s state and skeleton&#39;s world transform.

        */
        export class SkeletonAnimation extends sp.Skeleton {
            /**
            * The skeleton animation of spine.
            */
            constructor();
            /**
            * {spine.TrackEntry|null}
addAnimation(trackIndex, name, loop, delay)
Adds an animation to be played delay seconds after the current or last queued animation.
Parameters:
{Number} trackIndex
{String} name
{Boolean} loop
{Number} delay
Returns:
{spine.TrackEntry|null}

            */
            addAnimation(trackIndex?: number, name?: string, loop?: boolean, delay?: number): any;
            /**
            * clearTrack(trackIndex)
Clears track of animation state by trackIndex.
Parameters:
{Number} trackIndex

            */
            clearTrack(trackIndex?: number);
            /**
            * clearTracks()
Clears all tracks of animation state.

            */
            clearTracks();
            /**
            * &amp;lt;static&amp;gt;
{sp.Skeleton}
sp.SkeletonAnimation.create(skeletonDataFile, atlasFile, scale)
Creates a skeleton animation object.
Parameters:
{spine.SkeletonData|String} skeletonDataFile
{String|spine.Atlas|spine.SkeletonData} atlasFile
atlas filename or atlas data or owns SkeletonData
{Number} scale
Optional
scale can be specified on the JSON or binary loader which will scale the bone positions, image sizes, and animation translations.
Deprecated:
since v3.0, please use new sp.SkeletonAnimation(skeletonDataFile, atlasFile, scale) instead.
Returns:
{sp.Skeleton}

            */
            static create(skeletonDataFile?: any, atlasFile?: any, scale?: number): sp.Skeleton;
            /**
            * {spine.TrackEntry|null}
getCurrent(trackIndex)
Returns track entry by trackIndex.
Parameters:
trackIndex
Returns:
{spine.TrackEntry|null}

            */
            getCurrent(): any;
            /**
            * init()
Initializes a sp.SkeletonAnimation. please do not call this function by yourself, you should pass the parameters to constructor to initialize it.

            */
            init();
            /**
            * {spine.TrackEntry|null}
setAnimation(trackIndex, name, loop)
Set the current animation. Any queued animations are cleared.
Parameters:
{Number} trackIndex
{String} name
{Boolean} loop
Returns:
{spine.TrackEntry|null}

            */
            setAnimation(trackIndex?: number, name?: string, loop?: boolean): any;
            /**
            * setAnimationListener(target, callback)
Sets event listener of sp.SkeletonAnimation.
Parameters:
{Object} target
{Function} callback

            */
            setAnimationListener(target?: Object, callback?: Function);
            /**
            * setAnimationStateData(stateData)
Sets animation state data to sp.SkeletonAnimation.
Parameters:
{spine.AnimationStateData} stateData

            */
            setAnimationStateData(stateData?: spine.AnimationStateData);
            /**
            * setMix(fromAnimation, toAnimation, duration)
Mix applies all keyframe values, interpolated for the specified time and mixed with the current values.
Parameters:
{String} fromAnimation
{String} toAnimation
{Number} duration

            */
            setMix(fromAnimation?: string, toAnimation?: string, duration?: number);
            /**
            * update(dt)
Update will be called automatically every frame if &quot;scheduleUpdate&quot; is called when the node is &quot;live&quot;.
It updates animation&#39;s state and skeleton&#39;s world transform.
Parameters:
{Number} dt
Delta time since last update

            */
            update(dt?: number);
        }
}

declare module cc {
    /**
     * Canvas of render type
     * @constant
     * @type {Number}
     */
    var _RENDER_TYPE_CANVAS: number;

    /**
     * WebGL of render type
     * @constant
     * @type {Number}
     */
    var _RENDER_TYPE_WEBGL: number;

    /**
     * Device oriented vertically, home button on the bottom
     * @constant
     * @type {Number}
     */
    var ORIENTATION_PORTRAIT: number;

    /**
     * Device oriented vertically, home button on the top
     * @constant
     * @type {Number}
     */
    var ORIENTATION_PORTRAIT_UPSIDE_DOWN: number;

    /**
     * Device oriented horizontally, home button on the right
     * @constant
     * @type {Number}
     */
    var ORIENTATION_LANDSCAPE_LEFT: number;

    /**
     * Device oriented horizontally, home button on the left
     * @constant
     * @type {Number}
     */
    var ORIENTATION_LANDSCAPE_RIGHT: number;

    /**
     * @constant
     * @type Number
     */
    var MENU_STATE_WAITING: number;
    /**
     * @constant
     * @type Number
     */
    var MENU_STATE_TRACKING_TOUCH: number;
    /**
     * @constant
     * @type Number
     */
    var MENU_HANDLER_PRIORITY: number;
    /**
     * @constant
     * @type Number
     */
    var DEFAULT_PADDING: number;

    /**
     * drawing primitive of game engine
     * @type {cc.DrawingPrimitive}
     */
    var _drawingUtil;

    /**
     * main Canvas 2D/3D Context of game engine
     * @type {CanvasRenderingContext2D|WebGLRenderingContext}
     */
    var _renderContext;

    /**
     * main Canvas of game engine
     * @type {HTMLCanvasElement}
     */
    var _canvas;

    /**
     * This Div element contain all game canvas
     * @type {HTMLDivElement}
     */
    var _gameDiv;

    var _rendererInitialized: boolean;

    /**
     * @type {cc.Director}
     * @name cc.director
     */
    var director: cc.Director;
    /**
     * @type {cc.Size}
     * @name cc.winSize
     * cc.winSize is the alias object for the size of the current game window.
     */
    var winSize: cc.Size;
}
declare module cc {
    interface color {
        white: cc.Color;
        yellow: cc.Color;
        blue: cc.Color;
        green: cc.Color;
        red: cc.Color;
        magenta: cc.Color;
        black: cc.Color;
        orange: cc.Color;
        gray: cc.Color;
    }
}
declare module cc {
    var _isNodeJs: boolean;

    function newElement(x?);
    function _addEventListener(element?, type?, listener?, useCapture?);

    function each(obj?, iterator?, context?);
    function extend(target?);

    function isFunction(obj): boolean;
    function isNumber(obj): boolean;
    function isString(obj): boolean;
    function isArray(obj): boolean;
    function isUndefined(obj): boolean;
    function isObject(obj): boolean;
    function isCrossOrigin(url): boolean;
}
declare module cc {
    function log(message?);
    function warn(message?);
    function error(message?);
    function assert(message?);
}
declare module cc {
    /**
     * An interval action is an action that takes place within a certain period of time.
     * @function
     * @param {Number} d duration in seconds
     * @return {cc.ActionInterval}
     * @example
     * // example
     * var actionInterval = cc.actionInterval(3);
     */
    function actionInterval(d?: number): cc.ActionInterval;

    /** helper constructor to create an array of sequenceable actions
 * @function
 * @param {Array|cc.FiniteTimeAction} tempArray
 * @return {cc.Sequence}
 * @example
 * // example
 * // create sequence with actions
 * var seq = cc.sequence(act1, act2);
 *
 * // create sequence with array
 * var seq = cc.sequence(actArray);
 * todo: It should be use new
 */
    function sequence(/*Multiple Arguments*/tempArray?, t1?, t2?, t3?, t4?, t5?, t6?, t7?, t8?): cc.Sequence;


    /**
     * Creates a Repeat action. Times is an unsigned integer between 1 and pow(2,30)
     * @function
     * @param {cc.FiniteTimeAction} action
     * @param {Number} times
     * @return {cc.Repeat}
     * @example
     * // example
     * var rep = cc.repeat(cc.sequence(jump2, jump1), 5);
     */
    function repeat(action?: cc.FiniteTimeAction, times?: number): cc.Repeat;


    /**
     * Create a acton which repeat forever
     * @function
     * @param {cc.FiniteTimeAction} action
     * @return {cc.RepeatForever}
     * @example
     * // example
     * var repeat = cc.repeatForever(cc.rotateBy(1.0, 360));
     */
    function repeatForever(action?: cc.FiniteTimeAction): cc.RepeatForever;


    /**
     * Create a spawn action which runs several actions in parallel.
     * @function
     * @param {Array|cc.FiniteTimeAction}tempArray
     * @return {cc.FiniteTimeAction}
     * @example
     * // example
     * var action = cc.spawn(cc.jumpBy(2, cc.p(300, 0), 50, 4), cc.rotateBy(2, 720));
     * todo:It should be the direct use new
     */
    function spawn(/*Multiple Arguments*/tempArray?, t1?, t2?, t3?, t4?, t5?, t6?, t7?, t8?): cc.FiniteTimeAction;

    /**
     * Creates a RotateTo action with separate rotation angles.
     * To specify the angle of rotation.
     * @function
     * @param {Number} duration duration in seconds
     * @param {Number} deltaAngleX deltaAngleX in degrees.
     * @param {Number} [deltaAngleY] deltaAngleY in degrees.
     * @return {cc.RotateTo}
     * @example
     * // example
     * var rotateTo = cc.rotateTo(2, 61.0);
     */
    function rotateTo(duration?: number, deltaAngleX?: number, deltaAngleY?: number): cc.RotateTo;


    /**
     * Rotates a cc.Node object clockwise a number of degrees by modifying it's rotation attribute.
     * Relative to its properties to modify.
     * @function
     * @param {Number} duration duration in seconds
     * @param {Number} deltaAngleX deltaAngleX in degrees
     * @param {Number} [deltaAngleY] deltaAngleY in degrees
     * @return {cc.RotateBy}
     * @example
     * // example
     * var actionBy = cc.rotateBy(2, 360);
     */
    function rotateBy(duration?: number, deltaAngleX?: number, deltaAngleY?: number): cc.RotateBy;
    /**
     * Create the action.
     * Relative to its coordinate moves a certain distance.
     * @function
     * @param {Number} duration duration in seconds
     * @param {cc.Point|Number} deltaPos
     * @param {Number} deltaY
     * @return {cc.MoveBy}
     * @example
     * // example
     * var actionTo = cc.moveBy(2, cc.p(windowSize.width - 40, windowSize.height - 40));
     */
    function moveBy(duration?: number, deltaPos?: any, deltaY?: number): cc.MoveBy;

    /**
     * Create new action.
     * Moving to the specified coordinates.
     * @function
     * @param {Number} duration duration in seconds
     * @param {cc.Point} position
     * @param {Number} y
     * @return {cc.MoveBy}
     * @example
     * // example
     * var actionBy = cc.moveTo(2, cc.p(80, 80));
     */
    function moveTo(duration?: number, position?: cc.Point, y?: number): cc.MoveTo;

    /**
     * Create new action.
     * Skews a cc.Node object to given angles by modifying it's skewX and skewY attributes.
     * Changes to the specified value.
     * @function
     * @param {Number} t time in seconds
     * @param {Number} sx
     * @param {Number} sy
     * @return {cc.SkewTo}
     * @example
     * // example
     * var actionTo = cc.skewTo(2, 37.2, -37.2);
     */
    function skewTo(t?: number, sx?: number, sy?: number): cc.SkewTo;

    /**
     * Skews a cc.Node object by skewX and skewY degrees. <br />
     * Relative to its attribute modification.
     * @function
     * @param {Number} t time in seconds
     * @param {Number} sx sx skew in degrees for X axis
     * @param {Number} sy sy skew in degrees for Y axis
     * @return {cc.SkewBy}
     * @example
     * // example
     * var actionBy = cc.skewBy(2, 0, -90);
     */
    function skewBy(t?: number, sx?: number, sy?: number): cc.SkewBy;

    /**
     * Moves a cc.Node object simulating a parabolic jump movement by modifying it's position attribute.
     * Relative to its movement.
     * @function
     * @param {Number} duration
     * @param {cc.Point|Number} position
     * @param {Number} [y]
     * @param {Number} height
     * @param {Number} jumps
     * @return {cc.JumpBy}
     * @example
     * // example
     * var actionBy = cc.jumpBy(2, cc.p(300, 0), 50, 4);
     * var actionBy = cc.jumpBy(2, 300, 0, 50, 4);
     */
    function jumpBy(duration?: number, position?: any, y?: number, height?: number, jumps?: number): cc.JumpBy;

    /**
     * Moves a cc.Node object to a parabolic position simulating a jump movement by modifying it's position attribute. <br />
     * Jump to the specified location.
     * @function
     * @param {Number} duration
     * @param {cc.Point|Number} position
     * @param {Number} [y]
     * @param {Number} height
     * @param {Number} jumps
     * @return {cc.JumpTo}
     * @example
     * // example
     * var actionTo = cc.jumpTo(2, cc.p(300, 300), 50, 4);
     * var actionTo = cc.jumpTo(2, 300, 300, 50, 4);
     */
    function jumpTo(duration?: number, position?: any, y?: number, height?: number, jumps?: number): cc.JumpTo;

    /**
     * An action that moves the target with a cubic Bezier curve by a certain distance.
     * Relative to its movement.
     * @function
     * @param {Number} t time in seconds
     * @param {Array} c Array of points
     * @return {cc.BezierBy}
     * @example
     * // example
     * var bezier = [cc.p(0, windowSize.height / 2), cc.p(300, -windowSize.height / 2), cc.p(300, 100)];
     * var bezierForward = cc.bezierBy(3, bezier);
     */
    function bezierBy(t?: number, c?: Array<any>): cc.BezierBy;
    /**
     * An action that moves the target with a cubic Bezier curve to a destination point.
     * @function
     * @param {Number} t
     * @param {Array} c array of points
     * @return {cc.BezierTo}
     * @example
     * // example
     * var bezier = [cc.p(0, windowSize.height / 2), cc.p(300, -windowSize.height / 2), cc.p(300, 100)];
     * var bezierTo = cc.bezierTo(2, bezier);
     */
    function bezierTo(t?: number, c?: Array<any>): cc.BezierTo;
    /**
     * Scales a cc.Node object to a zoom factor by modifying it's scale attribute.
     * @function
     * @param {Number} duration
     * @param {Number} sx  scale parameter in X
     * @param {Number} [sy] scale parameter in Y, if Null equal to sx
     * @return {cc.ScaleTo}
     * @example
     * // example
     * // It scales to 0.5 in both X and Y.
     * var actionTo = cc.scaleTo(2, 0.5);
     *
     * // It scales to 0.5 in x and 2 in Y
     * var actionTo = cc.scaleTo(2, 0.5, 2);
     */
    function scaleTo(duration?: number, sx?: number, sy?: number): cc.ScaleTo;
    /**
     * Scales a cc.Node object a zoom factor by modifying it's scale attribute.
     * Relative to its changes.
     * @function
     * @param {Number} duration duration in seconds
     * @param {Number} sx sx  scale parameter in X
     * @param {Number|Null} [sy=] sy scale parameter in Y, if Null equal to sx
     * @return {cc.ScaleBy}
     * @example
     * // example without sy, it scales by 2 both in X and Y
     * var actionBy = cc.scaleBy(2, 2);
     *
     * //example with sy, it scales by 0.25 in X and 4.5 in Y
     * var actionBy2 = cc.scaleBy(2, 0.25, 4.5);
     */
    function scaleBy(duration?: number, sx?: number, sy?: number): cc.ScaleBy;
    /**
     * Blinks a cc.Node object by modifying it's visible attribute.
     * @function
     * @param {Number} duration  duration in seconds
     * @param blinks blinks in times
     * @return {cc.Blink}
     * @example
     * // example
     * var action = cc.blink(2, 10);
     */
    function blink(duration?: number, blinks?: any): cc.Blink;
    /**
     * Fades an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from the current value to a custom one.
     * @function
     * @param {Number} duration
     * @param {Number} opacity 0-255, 0 is transparent
     * @return {cc.FadeTo}
     * @example
     * // example
     * var action = cc.fadeTo(1.0, 0);
     */
    function fadeTo(duration?: number, opacity?: number): cc.FadeTo;

    /**
     * Fades In an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from 0 to 255.
     * @function
     * @param {Number} duration duration in seconds
     * @return {cc.FadeIn}
     * @example
     * //example
     * var action = cc.fadeIn(1.0);
     */
    function fadeIn(duration?: number): cc.FadeIn;

    /**
     * Fades Out an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from 255 to 0.
     * @function
     * @param {Number} d  duration in seconds
     * @return {cc.FadeOut}
     * @example
     * // example
     * var action = cc.fadeOut(1.0);
     */
    function fadeOut(d?: number): cc.FadeOut;

    /**
     * Tints a cc.Node that implements the cc.NodeRGB protocol from current tint to a custom one.
     * @function
     * @param {Number} duration
     * @param {Number} red 0-255
     * @param {Number} green  0-255
     * @param {Number} blue 0-255
     * @return {cc.TintTo}
     * @example
     * // example
     * var action = cc.tintTo(2, 255, 0, 255);
     */
    function tintTo(duration?: number, red?: number, green?: number, blue?: number): cc.TintTo;

    /**
     * Tints a cc.Node that implements the cc.NodeRGB protocol from current tint to a custom one.
     * Relative to their own color change.
     * @function
     * @param {Number} duration  duration in seconds
     * @param {Number} deltaRed
     * @param {Number} deltaGreen
     * @param {Number} deltaBlue
     * @return {cc.TintBy}
     * @example
     * // example
     * var action = cc.tintBy(2, -127, -255, -127);
     */
    function tintBy(duration?: number, deltaRed?: number, deltaGreen?: number, deltaBlue?: number): cc.TintBy;

    /**
     * Delays the action a certain amount of seconds
     * @function
     * @param {Number} d duration in seconds
     * @return {cc.DelayTime}
     * @example
     * // example
     * var delay = cc.delayTime(1);
     */
    function delayTime(d?: number): cc.DelayTime;

    /**
     * Executes an action in reverse order, from time=duration to time=0.
     * @function
     * @param {cc.FiniteTimeAction} action
     * @return {cc.ReverseTime}
     * @example
     * // example
     *  var reverse = cc.reverseTime(this);
     */
    function reverseTime(action): cc.ReverseTime;

    /**
     * create the animate with animation
     * @function
     * @param {cc.Animation} animation
     * @return {cc.Animate}
     * @example
     * // example
     * // create the animation with animation
     * var anim = cc.animate(dance_grey);
     */
    function animate(animation): cc.Animate;

    /**
     * Create an action with the specified action and forced target
     * @function
     * @param {cc.Node} target
     * @param {cc.FiniteTimeAction} action
     * @return {cc.TargetedAction}
     */
    function targetedAction(target?: cc.Node, action?: cc.FiniteTimeAction): cc.TargetedAction;
}
declare module cc {
    interface Point {
        x: number;
        y: number;
    }

    /**
     * Helper function that creates a cc.Point.
     * @function
     * @param {Number|cc.Point} x a Number or a size object
     * @param {Number} y
     * @return {cc.Point}
     * @example
     * var point1 = cc.p();
     * var point2 = cc.p(100, 100);
     * var point3 = cc.p(point2);
     * var point4 = cc.p({x: 100, y: 100});
     */
    function p(x?: any, y?: number): cc.Point;

    /**
     * Check whether a point's value equals to another
     * @function
     * @param {cc.Point} point1
     * @param {cc.Point} point2
     * @return {Boolean}
     */
    function pointEqualToPoint(point1?: cc.Point, point2?: cc.Point): boolean;

    interface Size {
        width: number;
        height: number;
    }

    /**
     * Helper function that creates a cc.Size.
     * @function
     * @param {Number|cc.Size} w width or a size object
     * @param {Number} h height
     * @return {cc.Size}
     * @example
     * var size1 = cc.size();
     * var size2 = cc.size(100,100);
     * var size3 = cc.size(size2);
     * var size4 = cc.size({width: 100, height: 100});
     */
    function size(w?: any, h?: number): cc.Size;

    /**
     * Check whether a point's value equals to another
     * @function
     * @param {cc.Size} size1
     * @param {cc.Size} size2
     * @return {Boolean}
     */
    function sizeEqualToSize(size1?: cc.Size, size2?: cc.Size): boolean;

    interface Rect {
        x: number;
        y: number;
        width: number;
        height: number;
    }

    /**
     * Helper function that creates a cc.Rect.
     * @function
     * @param {Number|cc.Rect} x a number or a rect object
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     * @returns {cc.Rect}
     * @example
     * var rect1 = cc.rect();
     * var rect2 = cc.rect(100,100,100,100);
     * var rect3 = cc.rect(rect2);
     * var rect4 = cc.rect({x: 100, y: 100, width: 100, height: 100});
     */
    function rect(x?: any, y?: number, w?: number, h?: number): cc.Rect;

    /**
     * Check whether a rect's value equals to another
     * @function
     * @param {cc.Rect} rect1
     * @param {cc.Rect} rect2
     * @return {Boolean}
     */
    function rectEqualToRect(rect1?: cc.Rect, rect2?: cc.Rect): boolean;

    function _rectEqualToZero(rect?: cc.Rect): boolean;

    /**
     * Check whether the rect1 contains rect2
     * @function
     * @param {cc.Rect} rect1
     * @param {cc.Rect} rect2
     * @return {Boolean}
     */
    function rectContainsRect(rect1?: cc.Rect, rect2?: cc.Rect): boolean;

    /**
     * Returns the rightmost x-value of a rect
     * @function
     * @param {cc.Rect} rect
     * @return {Number} The rightmost x value
     */
    function rectGetMaxX(rect?: cc.Rect): number;

    /**
     * Return the midpoint x-value of a rect
     * @function
     * @param {cc.Rect} rect
     * @return {Number} The midpoint x value
     */
    function rectGetMidX(rect?: cc.Rect): number;
    /**
     * Returns the leftmost x-value of a rect
     * @function
     * @param {cc.Rect} rect
     * @return {Number} The leftmost x value
     */
    function rectGetMinX(rect?: cc.Rect): number;

    /**
     * Return the topmost y-value of a rect
     * @function
     * @param {cc.Rect} rect
     * @return {Number} The topmost y value
     */
    function rectGetMaxY(rect?: cc.Rect): number;

    /**
     * Return the midpoint y-value of `rect'
     * @function
     * @param {cc.Rect} rect
     * @return {Number} The midpoint y value
     */
    function rectGetMidY(rect?: cc.Rect): number;

    /**
     * Return the bottommost y-value of a rect
     * @function
     * @param {cc.Rect} rect
     * @return {Number} The bottommost y value
     */
    function rectGetMinY(rect?: cc.Rect): number;

    /**
     * Check whether a rect contains a point
     * @function
     * @param {cc.Rect} rect
     * @param {cc.Point} point
     * @return {Boolean}
     */
    function rectContainsPoint(rect?: cc.Rect, point?: cc.Point): boolean;

    /**
     * Check whether a rect intersect with another
     * @function
     * @param {cc.Rect} rectA
     * @param {cc.Rect} rectB
     * @return {Boolean}
     */
    function rectIntersectsRect(ra?: cc.Rect, rb?: cc.Rect): boolean;

    /**
     * Check whether a rect overlaps another
     * @function
     * @param {cc.Rect} rectA
     * @param {cc.Rect} rectB
     * @return {Boolean}
     */
    function rectOverlapsRect(rectA?: cc.Rect, rectB?: cc.Rect): boolean;

    /**
     * Returns the smallest rectangle that contains the two source rectangles.
     * @function
     * @param {cc.Rect} rectA
     * @param {cc.Rect} rectB
     * @return {cc.Rect}
     */
    function rectUnion(rectA?: cc.Rect, rectB?: cc.Rect): cc.Rect;

    /**
     * Returns the overlapping portion of 2 rectangles
     * @function
     * @param {cc.Rect} rectA
     * @param {cc.Rect} rectB
     * @return {cc.Rect}
     */
    function rectIntersection(rectA?: cc.Rect, rectB?: cc.Rect): cc.Rect;
}
declare module cc {
    interface Color {
        r: number;
        g: number;
        b: number;
        a: number;
    }

    /**
     * Generate a color object based on multiple forms of parameters
     * @example
     *
     * // 1. All channels seperately as parameters
     * var color1 = cc.color(255, 255, 255, 255);
     *
     * // 2. Convert a hex string to a color
     * var color2 = cc.color("#000000");
     *
     * // 3. An color object as parameter
     * var color3 = cc.color({r: 255, g: 255, b: 255, a: 255});
     *
     * Alpha channel is optional. Default value is 255
     *
     * @param {Number|String|cc.Color} r
     * @param {Number} g
     * @param {Number} b
     * @param {Number} [a=255]
     * @return {cc.Color}
     */
    function color(r?: number, g?: number, b?: number, a?: number): cc.Color;
    /**
     * returns true if both ccColor3B are equal. Otherwise it returns false.
     * @function
     * @param {cc.Color} color1
     * @param {cc.Color} color2
     * @return {Boolean}  true if both ccColor3B are equal. Otherwise it returns false.
     */
    function colorEqual(color1?: cc.Color, color2?: cc.Color): boolean;

    interface Vertex2F {
        x: number;
        y: number;
    }

    /**
     * Helper macro that creates an Vertex2F type composed of 2 floats: x, y
     * @function
     * @param {Number} x
     * @param {Number} y
     * @return {cc.Vertex2F}
     */
    function vertex2(x?: number, y?: number): cc.Vertex2F;

    interface Vertex3F {
        x: number;
        y: number;
        z: number;
    }

    /**
     * Helper macro that creates an Vertex3F type composed of 3 floats: x, y, z
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @return {cc.Vertex3F}
     */
    function vertex3(x?: number, y?: number, z?: number): cc.Vertex3F;

    interface Tex2F {
        u: number;
        v: number;
    }

    /**
     * Helper macro that creates an Tex2F type: A texcoord composed of 2 floats: u, y
     * @function
     * @param {Number} u
     * @param {Number} v
     * @return {cc.Tex2F}
     */
    function tex2(u?: number, v?: number): cc.Tex2F;

    /**
     * @function
     * @returns {cc.BlendFunc}
     */
    function blendFuncDisable();

    /**
     * convert a string of color for style to Color.
     * e.g. "#ff06ff"  to : cc.color(255,6,255)
     * @function
     * @param {String} hex
     * @return {cc.Color}
     */
    function hexToColor(hex?: string): cc.Color;

    /**
     * convert Color to a string of color for style.
     * e.g.  cc.color(255,6,255)  to : "#ff06ff"
     * @function
     * @param {cc.Color} color
     * @return {String}
     */
    function colorToHex(color?: cc.Color): string;

    /**
     * text alignment : left
     * @constant
     * @type Number
     */
    var TEXT_ALIGNMENT_LEFT: number;

    /**
     * text alignment : center
     * @constant
     * @type Number
     */
    var TEXT_ALIGNMENT_CENTER: number;

    /**
     * text alignment : right
     * @constant
     * @type Number
     */
    var TEXT_ALIGNMENT_RIGHT: number;

    /**
     * text alignment : top
     * @constant
     * @type Number
     */
    var VERTICAL_TEXT_ALIGNMENT_TOP: number;

    /**
     * text alignment : center
     * @constant
     * @type Number
     */
    var VERTICAL_TEXT_ALIGNMENT_CENTER: number;

    /**
     * text alignment : bottom
     * @constant
     * @type Number
     */
    var VERTICAL_TEXT_ALIGNMENT_BOTTOM: number;
}

declare module cc {
    interface IMEKeyboardNotificationInfo {
    }
    interface DirectorDelegate {
    }
    interface BlendFunc {
    }
    interface Image {
    }
    interface Quad3 {
    }
    interface ScrollViewDelegate {
    }
    interface SkeletonData {
    }
    interface TableViewDataSource {
    }
    interface TableViewDelegate {
    }
    interface EventListenerAssetsManager {
    }
    interface V3F_C4B_T2F_Quad {
    }
    interface ActionFrame { }
    interface AssetsManager { }
    interface ColliderFilter { }
}
declare module ccs {
    interface DataInfo {
    }
    interface Shape {
    }
    interface DisplayManager {
    }
    interface objectFactory {
    }
    interface TweenType { }
}
declare module ccui {
    interface Text { }
    interface TextAtlas { }
    interface TextBMFont { }
}
declare module spine {
    interface Skin {
    }
    interface Slot {
    }
    interface SkeletonData {
    }
    interface Bone {
    }
    interface AnimationStateData {
    }
}
