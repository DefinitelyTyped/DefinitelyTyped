// Generated by typings
// Based on examination of
// Example: https://github.com/typed-typings/env-node/blob/master/0.12/node.d.ts
// Source: https://raw.githubusercontent.com/phreed/typed-npm-webgme/master/webgme.d.ts
// Documentation: https://editor.webgme.org/docs/source/index.html

/**
Describe plugins
*/
declare namespace Core {

    export type ISO8601 = string;
    export type ErrorStr = string;
    export type MetadataHash = string;
    export type MetadataHashArray = string[];
    export type ArtifactHash = string;
    export type Name = string;

    export type Metadata = {}
    export type Node = {}
    export type DataObject = {}
    export type Buffer = GLbyte[];
    export type Payload = string | Buffer | Buffer[];
    export type Content = DataObject | Buffer | Buffer[];
    export type ContentString = string;
    export type Primitive = string | number;
    export type OutAttr = DataObject | Primitive | undefined | null;
    export type InAttr = DataObject | Primitive | null;
    export type OutPath = string | undefined | null;

    export type VoidFn = () => void;

    export type MetadataHashCallback = (err: Error, result: MetadataHash) => void;
    export type MetadataHashArrayCallback = (err: Error, result: MetadataHashArray) => void;
    export type MetadataCallback = (err: Error, result: Metadata) => void;
    export type ArtifactCallback = (err: Error, result: Artifact) => void;
    export type ObjectCallback = (err: Error, result: DataObject) => void;
    export type ObjectArrayCallback = (err: Error, result: DataObject[]) => void;
    export type JSONCallback = (err: Error, result: JSON) => void;

    export interface ResultCallback {
        (err: Error | null, result: Result): void;
    }

    export interface Message {
        msg: string;
    }

    export interface Artifact {
        name: Name;
        blobClient: BlobClient;
        descriptor: Blob.BlobMetadata;

        constructor(name: Name, blobClient: BlobClient, descriptor: Blob.BlobMetadata): void;

        /** Adds content to the artifact as a file. */
        addFile: {
            (name: Name, content: Blob.ObjectBlob, callback: MetadataHashCallback): void;
            (name: Name, content: Blob.ObjectBlob): Promise<MetadataHash>;
        }
        /** Adds files as soft-link. */
        addFileAsSoftLink: {
            (name: Name, content: Blob.ObjectBlob, callback: MetadataHashCallback): void;
            (name: Name, content: Blob.ObjectBlob): Promise<MetadataHash>;
        }
        /** Adds multiple files. */
        addFiles: {
            (files: { [name: string]: Blob.ObjectBlob }, callback: MetadataHashArrayCallback): void;
            (files: { [name: string]: Blob.ObjectBlob }): Promise<MetadataHashArray> | Promise<string>;
        }
        /** Adds multiple files as soft-links. */
        addFilesAsSoftLinks: {
            (files: { [name: string]: Blob.ObjectBlob }, callback: MetadataHashArrayCallback): void;
            (files: { [name: string]: Blob.ObjectBlob }): Promise<MetadataHashArray>;
        }
        /** Adds a metadataHash to the artifact using the given file path. */
        addMetadataHash: {
            (name: Name, metadataHash: MetadataHash, size: number, callback: MetadataHashCallback): void;
            (name: Name, metadataHash: MetadataHash, size?: number): Promise<MetadataHash>;

            (objectHashes: { [name: string]: string }, callback: MetadataHashCallback): void;
            (objectHashes: { [name: string]: string }): Promise<MetadataHash>;
        }
        /** Adds metadataHashes to the artifact using the given file paths. */
        addMetadataHashes: {
            (name: Name, metadataHash: MetadataHash, size: number, callback: MetadataHashArrayCallback): void;
            (name: Name, metadataHash: MetadataHash, size?: number): Promise<MetadataHashArray>;

            (objectHashes: { [name: string]: string }, callback: MetadataHashArrayCallback): void;
            (objectHashes: { [name: string]: string }): Promise<MetadataHashArray>;
        }
        /** Adds a metadataHash to the artifact using the given file path. */
        addObjectHash: {
            (name: Name, metadataHash: MetadataHash, callback: MetadataHashCallback): void;
            (name: Name, metadataHash: MetadataHash): Promise<MetadataHash>;
        }
        /** Adds metadataHashes to the artifact using the given file paths. */
        addObjectHashes: {
            (objectHashes: { [name: string]: string }, callback: MetadataHashArrayCallback): void;
            (objectHashes: { [name: string]: string }): Promise<MetadataHashArray>;
        }
        /** Saves this artifact and uploads the metadata to the server's storage. */
        save: {
            (callback: MetadataHashCallback): void;
            (message?: string): Promise<MetadataHash>;
        }
    }
    /**
     commitHash - metadataHash of the commit.
     status - storage.constants./SYNCED/FORKED/MERGED
    */
    export interface Commit {
        commitHash: MetadataHash;
        status: string;
        branchName: string;
    }

    export interface Result {
        success: boolean;
        messages: string[]; // array of PluginMessages
        artifacts: ArtifactHash[]; // array of hashes
        pluginName: string;
        startTime: Date;
        finishTime: Date;
        error: Error;
        projectId: any;
        commits: any[];

        /**
        * Gets the success flag of this result object
        */
        getSuccess(): boolean;
        /**
        * Sets the success flag of this result.
        */
        setSuccess(value: boolean): void;
        /**
        * Returns with the plugin messages.
        */
        getMessages(): Message[];
        /**
        * Adds a new plugin message to the messages list.
        */
        addMessage(pluginMessage: Message): void;
        /**
        * Returns the plugin artifacts.
        */
        getArtifacts(): Artifact[];
        /**
        * Adds a saved artifact to the result - linked via its metadataHash.
        * Takes the metadataHash of saved artifact.
        */
        addArtifact(metadataHash: MetadataHash): void;
        /**
        * Adds a commit to the commit container.
        */
        addCommit(commitData: Commit): void;
        /**
        * Gets the name of the plugin to which the result object belongs.
        */
        getPluginName(): string;
        //------------------------------------------
        // Methods used by the plugin manager
        //-----------------------------------------
        /**
        * Sets the name of the plugin to which the result object belongs to.
        */
        setPluginName(pluginName: string): string;
        /**
        * Sets the name of the projectId the result was generated from.
        */
        setProjectId(projectId: string): void;
        /**
        * Gets the ISO 8601 representation of the time when the plugin started its execution.
        */
        getStartTime(): ISO8601;
        /**
        * Sets the ISO 8601 representation of the time when the plugin started its execution.
        */
        setStartTime(time: ISO8601): void;
        /**
        * Gets the ISO 8601 representation of the time when the plugin finished its execution.
        */
        getFinishTime(): ISO8601;
        /**
        * Sets the ISO 8601 representation of the time when the plugin finished its execution.
        */
        setFinishTime(time: ISO8601): void;
        /**
        * Gets error if any error occured during execution.
        * FIXME: should this return an Error object?
        */
        getError(): ErrorStr;
        /**
        * Sets the error string if any error occured during execution.
        */
        setError(error: ErrorStr | Error): void;
        /**
        * Serializes this object to a JSON representation.
        */
        serialize(): { success: boolean, messages: Message[], pluginName: string, finishTime: string };
    }


    export interface BlobMetadataDescriptor { }

    export interface BlobClient {
        createArtifact(name: Name): Artifact;
        getArtifact: {
            (metadataHash: MetadataHash, callback: ArtifactCallback): void;
            (metadataHash: MetadataHash): Promise<Artifact>;
        }
        getMetadataURL(metadataHash: MetadataHash): string;
        getRelativeMetadataURL(metadataHash: MetadataHash): string;
        getViewURL(metadataHash: MetadataHash, subpath: string): string;
        getDownloadURL(metadataHash: MetadataHash, subpath: string): string;
        getRelativeDownloadURL(metadataHash: MetadataHash, subpath: string): string;
        getCreateURL(filename: Name, isMetadata: boolean): string;
        getRelativeCreateURL(filename: Name, isMetadata: boolean): string;
        getSubObject: {
            (metadataHash: MetadataHash, subpath: string, callback: ObjectCallback): void;
            (metadataHash: MetadataHash, subpath: string): Promise<DataObject>;
        }
        getObject: {
            (metadataHash: MetadataHash, callback: ObjectCallback, subpath: string): Content;
            (metadataHash: MetadataHash, subpath: string): Promise<Content>;
        }
        getObjectAsString: {
            (metadataHash: MetadataHash, callback: MetadataHashCallback): ContentString;
            (metadataHash: MetadataHash): Promise<ContentString>;
        }
        getObjectAsJSON: {
            (metadataHash: MetadataHash, callback: JSONCallback): void;
            (metadataHash: MetadataHash): Promise<JSON>;
        }
        getMetadata: {
            (metadataHash: MetadataHash, callback: MetadataCallback): Metadata;
            (metadataHash: MetadataHash): Promise<Metadata>;
        }
        getHumanSize(bytes: number, si: boolean): string;
        putFile: {
            (name: Name, data: Payload, callback: MetadataHashCallback): void;
            (name: Name, data: Payload): Promise<MetadataHash>;
        }
        putMetadata: {
            (metadataDescriptor: BlobMetadataDescriptor, callback: MetadataHashCallback): void;
            (metadataDescriptor: BlobMetadataDescriptor): Promise<MetadataHash>;
        }
        putFiles: {
            (o: { [name: string]: Payload }, callback: MetadataHashArrayCallback): void;
            (o: { [name: string]: Payload }): Promise<MetadataHashArray>;
        }
        saveAllArtifacts: {
            (callback: MetadataHashArrayCallback): void;
            (): Promise<MetadataHashArray>;
        }
    }

    export interface RelationRule {
        /** The minimum amount of target necessary for the relationship (if not present or '-1' then there is no minimum rule that applies) */
        min?: number;
        /** The maximum amount of target necessary for the relationship (if not present or '-1' then there is no maximum rule that applies) */
        max?: number;
        absolutePathOfTarget?: {
            min?: number;
            max?: number;
        }
    }

    export interface Constraint {
        script: string;
        info: string;
        priority: string;
    }

    export interface MixinViolation {
        severity?: string;
        type?: string;
        ruleName?: string | undefined;
        targetInfo?: string | undefined;
        targetNode?: Node | undefined;
        collisionPaths?: string[];
        collisionNodes?: Node[];
        message?: string;
        hint?: string;
    }
    export interface GmePersisted { rootHash: MetadataHash }
    export enum TraversalOrder { 'BFS', 'DFS' }
    export type GUID = string;

    export interface NodeParameters {
        parent: Node | null;
        base: Node | null;
        relid?: string;
        guid?: GUID;
    }
    export interface LibraryInfo {
        projectId: string;
        branchName: string;
        commitHash: string;
    }
    export interface MetaNodeParameters {
        object: { node: Node, children: Node[] };
        sensitive: boolean;
        multiplicity: boolean;
        aspect: string;
    }
    export interface MetaRule {
        type: string | number | boolean;
        enum: string[];
    }

    export interface TraversalOptions {
        excludeRoot?: boolean;
        order?: TraversalOrder;
        maxParallelLoad?: number;
        stopOnError?: boolean;
    }

    export interface Core {

        addLibrary: {
            (node: Node, name: Name, libraryRootHash: string,
                libraryInfo: LibraryInfo, callback: ObjectCallback): void;
            (node: Node, name: Name, libraryRootHash: string,
                libraryInfo: LibraryInfo): Promise<DataObject>;
        }
        addMember(node: Node, name: Name, member: Node): undefined | Error;
        addMixin(node: Node, mixinPath: string): undefined | Error;
        applyResolution(conflict: {}): {};
        applyTreeDiff: {
            (root: Node, patch: DataObject, callback: ObjectCallback): void;
            (root: Node, patch: DataObject): Promise<DataObject>;
        }
        canSetAsMixin(node: Node, mixinPath: string): boolean | string;
        clearMetaRules(node: Node): undefined | Error;
        clearMixins(node: Node): undefined | Error;
        copyNode(node: Node, parent: Node): Node | Error;
        copyNodes(nodes: Node[], parent: Node): Node[] | Error;
        createNode(parameters: NodeParameters): Node | Error;
        createSet(node: Node, name: Name): undefined | Error;
        delAspectMeta(node: Node, name: Name): undefined | Error;
        delAspectMetaTarget(node: Node, name: Name, targetPath: string): undefined | Error;
        delAttribute(node: Node, name: Name): undefined | Error;
        delAttributeMeta(node: Node, name: Name): undefined | Error;
        delChildMeta(node: Node, childPath: string): undefined | Error;
        delConstraint(node: Node, name: Name): undefined | Error;
        deleteNode(node: Node): undefined | Error;
        deletePointer(node: Node, name: Name): undefined | Error;
        deleteSet(node: Node, name: Name): undefined | Error;
        delMember(node: Node, name: Name, path: string): undefined | Error;
        delMemberAttribute(node: Node, setName: string, memberPath: string, attrName: string): undefined | Error;
        delMemberRegistry(node: Node, setName: string, memberPath: string, regName: string): undefined | Error;
        delMixin(node: Node, mixinPath: string): undefined | Error;
        delPointerMeta(node: Node, name: Name): undefined | Error;
        delPointerMetaTarget(node: Node, name: Name, targetPath: string): undefined | Error;
        delRegistry(node: Node, name: Name): undefined | Error;
        generateTreeDiff: {
            (sourceRoot: Node, targetRoot: Node, callBack: ObjectCallback): void;
            (sourceRoot: Node, targetRoot: Node): Promise<DataObject>;
        }
        getAllMetaNodes(node: Node): { [name: string]: Node };
        getAspectMeta(node: Node, name: Name): string[];
        /**
        * Retrieves the value of the given attribute of the given node.
        * @param node - the node in question.
        * @param name - the name of the attribute.
        *
        * @return The function returns the value of the attribute of the node.
        * The retrieved attribute should not be modified as is - it should be copied first!
        * The value can be an object or any primitive type.
        * If the return value is undefined; the node does not have such attribute defined.
        * If the node is undefined the returned value is null.
        */
        getAttribute(node: Node | undefined, name: Name): OutAttr;
        getAttributeMeta(node: Node, name: Name): {};
        /** Get the defined attribute names */
        getAttributeNames(node: Node): string[];
        /** Get the base node */
        getBase(node: Node): Node; // null
        /** Get the base node at the top of the inheritance chain (typically the fco). */
        getBaseRoot(node: Node): Node;
        /** Get the most specific meta node. */
        getBaseType(node: Node): Node; // null
        getChild(node: Node, relativeId: string): Node;
        getChildrenHashes(node: Node): { [name: string]: MetadataHash };
        getChildrenMeta(node: Node): RelationRule;
        /** The children paths are available from the node. */
        getChildrenPaths(parent: Node): string[];
        getChildrenRelids(parent: Node): string[];
        getCollectionNames(node: Node): string[];
        getCollectionPaths(node: Node, name: Name): string[];
        getConstraint(node: Node, name: Name): Constraint; // null
        getConstraintNames(node: Node): string[];
        getFCO(node: Node): Node;
        getFullyQualifiedName(node: Node): string;
        getGuid(node: Node): GUID;
        getHash(node: Node): MetadataHash;
        getJsonMeta(node: Node): {};
        getLibraryGuid(node: Node, name: Name): GUID | Error;
        getLibraryInfo(node: Node, name: Name): LibraryInfo;
        getLibraryMetaNodes(node: Node, name: Name, onlyOwn?: boolean): Node[];
        getLibraryNames(node: Node): string[];
        getLibraryRoot(node: Node, name: Name): Node; // null
        getMemberAttribute(node: Node, setName: string, memberPath: string, attrName: string): OutAttr;
        getMemberAttributeNames(node: Node, name: Name, memberPath: string): string[];
        getMemberOwnAttributeNames(node: Node, name: Name, memberPath: string): string[];
        getMemberOwnRegistry(node: Node, name: Name, memberPath: string): string[];
        getMemberPaths(node: Node, name: Name): string[];
        getMemberRegistry(node: Node, setName: string, memberPath: string, regName: string): OutAttr;
        getMemberRegistryNames(node: Node, name: Name, memberpath: string): string[];
        getMixinErrors(node: Node): MixinViolation[];
        getMixinNodes(node: Node): { [name: string]: Node };
        getMixinPaths(node: Node): string[];
        getNamespace(node: Node): string;
        getOwnAttribute(node: Node, name: Name): OutAttr;
        getOwnAttributeNames(node: Node): string[];
        getOwnChildrenPaths(parent: Node): string[];
        getOwnChildrenRelids(parent: Node): string[];
        getOwnConstraintNames(node: Node): string[];
        getOwnJsonMeta(node: Node): DataObject;
        getOwnMemberPaths(node: Node, name: Name): string[];
        getOwnMixinNodes(node: Node): { [name: string]: Node };
        getOwnMixinPaths(node: Node): string[];
        getOwnPointerNames(node: Node): string[];
        getOwnPointerPath(node: Node, name: Name): OutPath;
        getOwnRegistry(node: Node, name: Name): OutAttr;
        getOwnRegistryNames(node: Node): string[];
        getOwnValidAspectNames(node: Node): string[];
        getOwnValidAttributeNames(node: Node): string[];
        /** The parent paths are available from the node. */
        getParent(node: Node): Node;
        /**  Get the path/id */
        getPath(node: Node): string;
        getPointerMeta(node: Node, name: Name): RelationRule;
        getPointerNames(node: Node): string[];
        getPointerPath(node: Node, name: Name): OutPath;
        /** Get the assigned registry */
        getRegistry(node: Node, name: Name): OutAttr;
        /** Get the defined registry names */
        getRegistryNames(node: Node): string[];
        /** Get the relative id */
        getRelid(node: Node): string;
        getRoot(node: Node): Node;
        getSetNames(node: Node): string[];
        getTypeRoot(node: Node): Node;
        getValidAspectNames(node: Node): string[];
        getValidAttributeNames(node: Node): string[];
        getValidChildrenMetaNodes(parameters: MetaNodeParameters): Node[];
        getValidChildrenPaths(node: Node): string[];
        getValidPointerNames(node: Node): string[];
        getValidSetMetaNodes(parameters: MetaNodeParameters): Node[];
        getValidSetNames(node: Node): string[];
        isAbstract(node: Node): boolean;
        /** Connections are just nodes with two pointers named "src" and "dst". */
        isConnection(node: Node): boolean;
        isEmpty(node: Node): boolean;
        isFullyOverriddenMember(node: Node, setName: string, memberPath: string): boolean;
        isInstanceOf(node: Node, name: Name): boolean;
        isLibraryElement(node: Node): boolean;
        isLibraryRoot(node: Node): boolean;
        isMemberOf(node: Node): DataObject;
        isMetaNode(node: Node): boolean;
        isTypeOf(node: Node, type: Node): boolean;
        isValidAttributeValueOf(node: Node, name: Name, value: InAttr): boolean;
        isValidChildOf(node: Node, parent: Node): boolean;
        isValidTargetOf(node: Node, source: Node, name: Name): boolean;
        loadByPath: {
            (startNode: Node, relativePath: string, callback: ObjectCallback): void;
            (startNode: Node, relativePath: string): Promise<DataObject>;
        };
        loadChild: {
            (parent: Node, relativeId: string, callback: ObjectCallback): void;
            (parent: Node, relativeId: string): Promise<DataObject>;
        };
        /** Loading the children however requires data that is not (necessarily) available */
        loadChildren: {
            (parent: Node, callback: ObjectArrayCallback): void;
            (parent: Node): Promise<DataObject>;
        }
        loadCollection: {
            (target: Node, pointerName: string, callback: ObjectCallback): void;
            (target: Node, pointerName: string): Promise<DataObject>;
        };
        loadOwnSubTree: {
            (node: Node, callback: ObjectCallback): void;
            (node: Node): Promise<DataObject>;
        };
        loadPointer: {
            (node: Node, pointerName: string, callback: ObjectCallback): void;
            (node: Node, pointerName: string): Promise<DataObject>;
        };
        loadRoot: {
            (metadataHash: MetadataHash, callback: ObjectCallback): void;
            (metadataHash: MetadataHash): Promise<DataObject>;
        };
        loadSubTree: {
            (node: Node, callback: ObjectCallback): void;
            (node: Node): Promise<DataObject>;
        };
        loadTree: {
            (rootHash: MetadataHash, callback: ObjectCallback): void;
            (rootHash: MetadataHash): Promise<DataObject>;
        };
        moveNode(node: Node, parent: Node): Node | Error;
        persist(node: Node): GmePersisted;
        removeLibrary(node: Node, name: Name): void;
        renameLibrary(node: Node, oldName: string, newName: string): void;
        setAspectMetaTarget(node: Node, name: Name, target: Node): undefined | Error;
        setAttribute(node: Node, name: Name, value: InAttr): undefined | Error;
        setAttributeMeta(node: Node, name: Name, rule: MetaRule): undefined | Error;
        setBase(node: Node, base: Node): undefined | Error;
        setChildMeta(node: Node, child: Node, min?: number, max?: number): undefined | Error;
        setChildrenMetaLimits(node: Node, min?: number, max?: number): undefined | Error;
        setConstraint(node: Node, name: Name, constraint: Constraint): undefined | Error;
        setGuid: {
            (node: Node, guid: GUID, callback: ObjectCallback): undefined | Error;
            (node: Node, guid: GUID): Promise<DataObject>;
        };
        setMemberAttribute: {
            (node: Node, setName: string, memberPath: string,
                SVGPathSegLinetoHorizontalAbsme: string,
                value?: InAttr): undefined | Error;
        };
        setMemberRegistry(node: Node, setName: string, memberPath: string, regName: string,
            value?: InAttr): undefined | Error;
        setPointer(node: Node, name: Name, target: Node | null): undefined | Error;
        setPointerMetaLimits(node: Node, memberPath: string,
            min?: number, max?: number): undefined | Error;
        setPointerMetaTarget(node: Node, name: Name, target: Node, min?: number, max?: number): undefined | Error;
        /** Get the assigned registry */
        setRegistry(node: Node, name: Name, value: InAttr): undefined | Error;

        /**
         * the visitation function will be called for
         * every node in the sub-tree, the second parameter of the function
         * is a callback that should be called to
         * note to the traversal function that the visitation for a given node is finished.
         */
        traverse: {
            // takes a callback & returning *no* promise
            (node: Node,
                options: TraversalOptions,
                visitFn: (node: Node, finished: VoidFn) => void,
                callback: ObjectCallback)
                : void;
            // takes *no* callback & returns a promise
            (node: Node,
                options: TraversalOptions,
                visitFn: (node: Node, finished: VoidFn) => void)
                : Promise<void>;
        }
        tryToConcatChanges(mine: DataObject, theirs: DataObject): DataObject;
        updateLibrary: {
            (node: Node, name: Name, libraryRootHash: MetadataHash,
                libraryInfo: LibraryInfo, callback: ObjectCallback): void;
            (node: Node, name: Name, libraryRootHash: MetadataHash,
                libraryInfo: LibraryInfo): Promise<DataObject>;
        }
    }

    export interface Dictionary {
        // allow any number of 'other' properties.
        [propName: string]: any;
    }


    /**
    Logs debug messages
    https://editor.webgme.org/docs/source/global.html#GmeLogger
    */
    export interface GmeLogger {
        debug(fmt: string, msg?: string | undefined): void;
        info(fmt: string, msg?: string | undefined): void;
        warn(fmt: string, msg?: string | undefined): void;
        error(fmt: string, msg?: string | undefined): void;
        /**
        Creates a new logger with the same settings
        and a name that is an augmentation of this logger and the
        provided string.
        If the second argument is true
        - the provided name will be used as is.
        */
        fork(fmt: string, reuse: boolean): GmeLogger;
    }
    export interface ProjectInterface {

    }


    export interface ThenCallback {
        (): void;
    }
    export interface CatchCallback {
        (err: Error): void;
    }

    export interface Promisable {
        then(callback: ThenCallback): Promisable;
        catch(callback: CatchCallback): Promisable;
    }

    /**
    The base plugin object from which all plugins should inherit.
    */
    export interface Base {

        activeNode: Node;
        activeSelection: Node[];
        blobClient: BlobClient;
        core: Core;
        gmeConfig: Config.GmeConfig;
        isConfigured: boolean;
        logger: GmeLogger;
        /**
         * The resolved META nodes based on the active namespace. Index by the fully qualified meta node names
         * with the namespace stripped off at the start.
         *
         * For example, if a project has a library A with a library B. If the project and the libraries all have
         * two meta nodes named a and b. Depending on the namespace the META will have the following keys:
         *
         * 1) namespace = '' -> ['a', 'b', 'A.a', 'A.b', 'A.B.a', 'A.B.b']
         * 2) namespace = 'A' -> ['a', 'b', 'B.a', 'B.b']
         * 3) namespace = 'A.B' -> ['a', 'b']
         *
         * (N.B. 'a' and 'b' in example 3) are pointing to the meta nodes defined in A.B.)
         */
        META: any;
        /**
         * The namespace the META nodes are coming from (set by invoker).
         * The default is the full meta, i.e. the empty string namespace.
         * For example, if a project has a library A with a library B. The possible namespaces are:
         * '', 'A' and 'A.B'.
         */
        namespace: string;
        notificationHandlers: any[];
        pluginMetadata: Metadata;
        project: ProjectInterface;
        result: Result;
        rootNode: Node;

        addCommitToResult(status: string): void;
        baseIsMeta(node: any): boolean;

        configure(config: Config.GmeConfig): void;
        createMessage(node: any, message: string, serverity: string): void;
        /**
         * Gets the configuration structure for the plugin.
         * The ConfigurationStructure defines the configuration for the plugin
         * and will be used to populate the GUI when invoking the plugin from webGME.
         */
        getConfigStructure(): Config.ConfigItem[];
        getCurrentConfig(): Config.GmeConfig;
        getDefaultConfig(): Config.GmeConfig;
        /**
         * Gets the description of the plugin.
         */
        getDescription(): string;
        getMetadata(): any;
        getMetaType(node: any): any;
        /**
         * Gets the name of the plugin.
         */
        getName(): string;
        /**
         * Gets the semantic version (semver.org) of the plugin.
         */
        getVersion(): string;
        initialize(logger: GmeLogger, blobClient: BlobClient, gmeConfig: Config.GmeConfig): void;
        isInvalidActiveNode(pluginId: any): any;
        isMetaTypeOf(node: any, metaNode: any): boolean;
        /**
          Main function for the plugin to execute.
          Notes:
          - Always log with the provided logger.[error,warning,info,debug].
          - Do NOT put any user interaction logic UI, etc. inside this method.
          - handler always has to be called even if error happened.
    
          When this runs the core api is used to extract the essential
          meta-model and the model-instance, these are then written to the mega-model.
          The mega-model contains all of the models used to describe the target system.
    
          https://github.com/ptaoussanis/sente
          and https://github.com/cognitect/transit-format
          will be used to connect to the
          graph database (immortals) where the mega-model is stored.
    
          @param {function(string, plugin.PluginResult)} handler - the result handler
         */
        main(callback: ResultCallback): void;
        save(message?: string): Promisable; // returns a promise?
        sendNotification: {
            (message: string, callback: ObjectCallback): void;
            (message: string): Promise<DataObject>;
        }
        setCurrentConfig(newConfig: Config.GmeConfig): void;
        updateMeta(generatedMeta: any): void;
        updateSuccess(value: boolean, message: TemplateStringsArray): void;
    }

    class PluginBase implements Base {
        constructor();

        activeNode: Node;
        activeSelection: Node[];
        blobClient: Core.BlobClient;
        core: Core.Core;
        gmeConfig: Config.GmeConfig;
        isConfigured: boolean;
        logger: Core.GmeLogger;
        META: any;
        namespace: string;
        notificationHandlers: any[];
        pluginMetadata: Core.Metadata;
        project: Core.ProjectInterface;
        result: Core.Result;
        rootNode: Node;

        addCommitToResult(status: string): void;
        baseIsMeta(node: any): boolean;
        configure(config: Config.GmeConfig): void;
        createMessage(node: any, message: string, serverity: string): void;
        getConfigStructure(): any;
        getCurrentConfig(): Config.GmeConfig;
        getDefaultConfig(): Config.GmeConfig;
        getDescription(): string;
        getMetadata(): any;
        getMetaType(node: any): any;
        getName(): string;
        getVersion(): string;
        initialize(logger: GmeLogger, blobClient: BlobClient, gmeConfig: Config.GmeConfig): void;
        isInvalidActiveNode(pluginId: any): any;
        isMetaTypeOf(node: any, metaNode: any): boolean;
        main(callback: Core.ResultCallback): void;
        save(message?: string): Core.Promisable;
        sendNotification: {
            (message: string, callback: Core.ResultCallback): void;
            (message: string): Promise<DataObject>;
        }
        setCurrentConfig(newConfig: Config.GmeConfig): void;
        updateMeta(generatedMeta: any): void;
        updateSuccess(value: boolean, message: TemplateStringsArray): void;
    }

}
