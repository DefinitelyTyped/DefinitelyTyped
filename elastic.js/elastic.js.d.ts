// Type definitions for elastic.js v1.2.0
// Project: https://www.npmjs.com/package/elastic.js
// Definitions by: Oleksii Trekhleb <https://ua.linkedin.com/in/trekhleb>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

declare module elasticjs {

  export interface Facet {}
  export interface Geo {}
  export interface Suggest {}
  export interface Generator {}
  export interface Query {}
  export interface Filter {}
  export interface Aggregation {}
  export interface ScoreFunction {}

  export class AggregationMixin implements Aggregation {

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): AggregationMixin;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): AggregationMixin;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A container Filter that allows Boolean AND composition of Filters.
   */
  export class AndFilter implements Filter {

    /*
     A container Filter that allows Boolean AND composition of Filters.
     */
    constructor(f: Filter | Filter[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): AndFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): AndFilter;

    /*
     Sets the filters for the filter.  If fltr is a single
     Filter, it is added to the current filters.  If fltr is an array
     of Filters, then they replace all existing filters.
     */
    filters(fltr: Filter | Filter[]): AndFilter;

    /*
     Sets the filter name.
     */
    name(name: string): AndFilter;

    /*
     Returns the filter object.
     */
    toJSON(): AndFilter;

  }


  /*
   A single-value metrics aggregation that computes the average of numeric
   values that are extracted from the aggregated documents. These values can be
   extracted either from specific numeric fields in the documents, or be
   generated by a provided script.
   */
  export class AvgAggregation implements Aggregation {

    /*
     Aggregation that computes the average of numeric values that are extracted
     from the aggregated documents.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the field to operate on.
     */
    field(field: string): AvgAggregation;

    /*
     The script language being used.
     */
    lang(language: string): AvgAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): AvgAggregation;

    /*
     Allows you generate or modify the terms/values using a script.
     */
    script(scriptCode: string): AvgAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): AvgAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A BoolFilter allows you to build Boolean filter constructs
   from individual filters. Similar in concept to Boolean query, except that
   the clauses are other filters. Can be placed within queries that accept a
   filter.
   */
  export class BoolFilter implements Filter {

    /*
     A Filter that matches documents matching boolean combinations of other
     filters.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): BoolFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): BoolFilter;

    /*
     Adds filter to boolean container. Given filter "must" appear in
     matching documents.  If passed a single Filter it is added to the
     list of existing filters.  If passed an array of Filters, they
     replace all existing filters.
     */
    must(oFilter: Filter | Filter[]): BoolFilter;

    /*
     Adds filter to boolean container. Given filter "must not" appear
     in matching documents. If passed a single Filter it is added to
     the list of existing filters.  If passed an array of Filters,
     they replace all existing filters.
     */
    mustNot(oFilter: Filter | Filter[]): BoolFilter;

    /*
     Sets the filter name.
     */
    name(name: string): BoolFilter;

    /*
     Adds filter to boolean container. Given filter "should" appear in
     matching documents. If passed a single Filter it is added to
     the list of existing filters.  If passed an array of Filters,
     they replace all existing filters.
     */
    should(oFilter: Filter | Filter[]): BoolFilter;

    /*
     Returns the filter object.
     */
    toJSON(): BoolFilter;

  }


  /*
   A boolQuery allows you to build Boolean query constructs
   from individual term or phrase queries. For example you might want to search
   for documents containing the terms javascript and python.
   */
  export class BoolQuery implements Query {

    /*
     A Query that matches documents matching boolean combinations of other
     queries, e.g. termQuerys, phraseQuerys or other boolQuerys.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets if the Query should be enhanced with a
     MatchAllQuery in order to act as a pure exclude when
     only negative (mustNot) clauses exist. Default: true.
     */
    adjustPureNegative(trueFalse: string): BoolQuery;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): BoolQuery;

    /*
     Enables or disables similarity coordinate scoring of documents
     matching the Query. Default: false.
     */
    disableCoord(trueFalse: string): BoolQuery;

    /*
     Sets the number of optional clauses that must match.

     By default no optional clauses are necessary for a match
     (unless there are no required clauses).  If this method is used,
     then the specified number of clauses is required.

     Use of this method is totally independent of specifying that
     any specific clauses are required (or prohibited).  This number will
     only be compared against the number of matching optional clauses.
     */
    minimumNumberShouldMatch(minMatch: number): BoolQuery;

    /*
     Adds query to boolean container. Given query "must" appear in matching documents.
     */
    must(oQuery: Object): BoolQuery;

    /*
     Adds query to boolean container. Given query "must not" appear in matching documents.
     */
    mustNot(oQuery: Object): BoolQuery;

    /*
     Adds query to boolean container. Given query "should" appear in matching documents.
     */
    should(oQuery: Object): BoolQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   The boost_factor score allows you to multiply the score by the provided
   boost_factor. This can sometimes be desired since boost value set on specific
   queries gets normalized, while for this score function it does not.
   */
  export class BoostFactorScoreFunction implements ScoreFunction {

    /*
     Multiply the score by the provided boost_factor.
     */
    constructor(boostVal: number);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost factor.
     */
    boost(b: number): BoostFactorScoreFunction;

    /*
     Adds a filter whose matching documents will have the score function applied.
     */
    filter(oFilter: Filter): BoostFactorScoreFunction;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   The boosting query can be used to effectively demote results that match
   a given query. Unlike the “NOT” clause in bool query, this still selects
   documents that contain undesirable terms, but reduces their overall
   score.
   */
  export class BoostingQuery implements Query {

    /*
     Constructs a query that can demote search results.  A negative boost.
     */
    constructor(positiveQry: Object, negativeQry: Object, negativeBoost: number);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): BoostingQuery;

    /*
     Sets the query used to match documents in the positive
     query that will be negatively boosted.
     */
    negative(oQuery: Object): BoostingQuery;

    /*
     Sets the negative boost value.
     */
    negativeBoost(boost: number): BoostingQuery;

    /*
     Sets the "master" query that determines which results are returned.
     */
    positive(oQuery: Object): BoostingQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A single-value metrics aggregation that calculates an approximate count of
   distinct values. Values can be extracted either from specific fields in the
   document or generated by a script.
   */
  export class CardinalityAggregation implements Aggregation {

    /*
     Aggregation that calculates an approximate count of distinct values.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the field to operate on.
     */
    field(field: string): CardinalityAggregation;

    /*
     The script language being used.
     */
    lang(language: string): CardinalityAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): CardinalityAggregation;

    /*
     Allows to trade memory for accuracy, and defines a unique count below which
     counts are expected to be close to accurate. Above this value, counts might
     become a bit more fuzzy. The maximum supported value is 40000, thresholds
     above this number will have the same effect as a threshold of 40000.
     Default value depends on the number of parent aggregations that multiple
     create buckets (such as terms or histograms).
     */
    precisionThreshold(num: number): CardinalityAggregation;

    /*
     Set to false to disable rehashing of values.  You must have computed a hash
     on the client-side and stored it into your documents if you disable this.
     */
    rehash(trueFalse: boolean): CardinalityAggregation;

    /*
     Allows you generate or modify the terms/values using a script.
     */
    script(scriptCode: string): CardinalityAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A query that executes high-frequency terms in a optional sub-query to
   prevent slow queries due to "common" terms like stopwords.

   This query basically builds two queries out of the terms in the query
   string where low-frequency terms are added to a required boolean clause and
   high-frequency terms are added to an optional boolean clause. The optional
   clause is only executed if the required "low-frequency' clause matches.

   CommonTermsQuery has several advantages over stopword
   filtering at index or query time since a term can be "classified" based on
   the actual document frequency in the index and can prevent slow queries even
   across domains without specialized stopword files.
   */
  export class CommonTermsQuery implements Query {

    /*
     A query that executes high-frequency terms in a optional sub-query.
     */
    constructor(field: string, qstr: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the analyzer name used to analyze the Query object.
     */
    analyzer(analyzer: string): CommonTermsQuery;

    /*
     Sets the boost value for documents commoning the Query.
     */
    boost(boost: Number): CommonTermsQuery;

    /*
     Sets the maximum threshold/frequency to be considered a low
     frequency term.  Set to a value between 0 and 1.
     */
    cutoffFrequency(freq: Number): CommonTermsQuery;

    /*
     Enables or disables similarity coordinate scoring of documents
     commoning the Query. Default: false.
     */
    disableCoord(trueFalse: string): CommonTermsQuery;

    /*
     Sets the field to query against.
     */
    field(f: string): CommonTermsQuery;

    /*
     Sets the boolean operator to be used for high frequency terms.
     Default: AND
     */
    highFreqOperator(op: string): CommonTermsQuery;

    /*
     Sets the boolean operator to be used for low frequency terms.
     Default: AND
     */
    lowFreqOperator(op: string): CommonTermsQuery;

    /*
     Sets the minimum number of low freq matches that need to match in
     a document before that document is returned in the results.
     */
    minimumShouldMatch(min: number): CommonTermsQuery;

    /*
     Sets the minimum number of high freq matches that need to match in
     a document before that document is returned in the results.
     */
    minimumShouldMatchHighFreq(min: number): CommonTermsQuery;

    /*
     Sets the minimum number of low freq matches that need to match in
     a document before that document is returned in the results.
     */
    minimumShouldMatchLowFreq(min: number): CommonTermsQuery;

    /*
     Sets the query string.
     */
    query(qstr: string): CommonTermsQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }

  export class CompletionSuggester implements Suggest {

    /*
     A suggester that allows basic auto-complete functionality.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets analyzer used to analyze the suggest text.
     */
    analyzer(analyzer: string): CompletionSuggester;

    /*
     Maximum edit distance (fuzziness), defaults to 1.  Automatically
     enables fuzzy suggestions when set to any value.
     */
    editDistance(d: number): CompletionSuggester;

    /*
     Sets the field used to generate suggestions from.
     */
    field(field: string): CompletionSuggester;

    /*
     Enable fuzzy completions which means a can spell a word
     incorrectly and still get a suggestion.
     */
    fuzzy(trueFalse: boolean): CompletionSuggester;

    /*
     Minimum length of the input before fuzzy suggestions are returned, defaults
     to 3.  Automatically enables fuzzy suggestions when set to any value.
     */
    minLength(m: number): CompletionSuggester;

    /*
     Minimum length of the input, which is not checked for fuzzy alternatives, defaults
     to 1.  Automatically enables fuzzy suggestions when set to any value.
     */
    prefixLength(l: number): CompletionSuggester;

    /*
     Sets the maximum number of suggestions to be retrieved from
     each individual shard.
     */
    shardSize(s: number): CompletionSuggester;

    /*
     Sets the number of suggestions returned for each token.
     */
    size(s: number): CompletionSuggester;

    /*
     Sets the text to get suggestions for.  If not set, the global
     suggestion text will be used.
     */
    text(txt: string): CompletionSuggester;

    /*
     Retrieves the internal suggest object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets if transpositions should be counted as one or two changes, defaults
     to true when fuzzy is enabled.  Automatically enables fuzzy suggestions
     when set to any value.
     */
    transpositions(trueFalse: boolean): CompletionSuggester;

    /*
     Sets all are measurements (like edit distance, transpositions and lengths)
     in unicode code points (actual letters) instead of bytes.  Automatically
     enables fuzzy suggestions when set to any value.
     */
    unicodeAware(trueFalse: boolean): CompletionSuggester;

  }


  /*
   A constant score query wraps another Query or
   Filter and returns a constant score for each
   result that is equal to the query boost.

   Note that lucene's query normalization (queryNorm) attempts
   to make scores between different queries comparable.  It does not
   change the relevance of your query, but it might confuse you when
   you look at the score of your documents and they are not equal to
   the query boost value as expected.  The scores were normalized by
   queryNorm, but maintain the same relevance.
   */
  export class ConstantScoreQuery implements Query {

    /*
     Constructs a query where each documents returned by the internal
     query or filter have a constant score equal to the boost factor.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): ConstantScoreQuery;

    /*
     Enables caching of the filter.
     */
    cache(trueFalse: boolean): ConstantScoreQuery;

    /*
     Set the cache key.
     */
    cacheKey(k: string): ConstantScoreQuery;

    /*
     Adds the filter to apply a constant score to.
     */
    filter(oFilter: Object): ConstantScoreQuery;

    /*
     Adds the query to apply a constant score to.
     */
    query(oQuery: Object): ConstantScoreQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A multi-bucket aggregation similar to the histogram except it can only be
   applied on date values. Since dates are represented in elasticsearch
   internally as long values, it is possible to use the normal histogram on
   dates as well, though accuracy will be compromised. The reason for this is
   in the fact that time based intervals are not fixed (think of leap years and
   on the number of days in a month). For this reason, we need a special
   support for time based data. From a functionality perspective, this
   histogram supports the same features as the normal histogram. The main
   difference is that the interval can be specified by date/time expressions.
   */
  export class DateHistogramAggregation implements Aggregation {

    /*
     Aggregation similar to the histogram except it can only be applied on
     date values.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): DateHistogramAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): DateHistogramAggregation;

    /*
     Set's the range/bounds for the histogram aggregation.  Useful when you
     want to include buckets that might be outside the bounds of indexed
     documents.
     */
    extendedBounds(min: string | number, max: string | number): DateHistogramAggregation;

    /*
     Sets the field to gather terms from.
     */
    field(field: string): DateHistogramAggregation;

    /*
     Sets the format expression for the terms.  Use for number or date
     formatting
     */
    format(f: string): DateHistogramAggregation;

    /*
     Sets the histogram interval.  Buckets are generated based on this interval
     value.
     */
    interval(i: string): DateHistogramAggregation;

    /*
     Enable the response to be returned as a keyed object where the key is the
     bucket interval.
     */
    keyed(trueFalse: boolean): DateHistogramAggregation;

    /*
     The script language being used.
     */
    lang(language: string): DateHistogramAggregation;

    /*
     Only return terms that match more than a configured number of hits.
     */
    minDocCount(num: number): DateHistogramAggregation;

    /*
     Sets order for the aggregated values.
     */
    order(order: string, direction: string): DateHistogramAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): DateHistogramAggregation;

    /*
     Set the post-rouding offset.
     */
    postOffset(offset: string): DateHistogramAggregation;

    /*
     Set the post-rouding date time zone.
     */
    postZone(tz: string): DateHistogramAggregation;

    /*
     Set the pre-rouding offset.
     */
    preOffset(offset: string): DateHistogramAggregation;

    /*
     Set the pre-rouding date time zone.
     */
    preZone(tz: string): DateHistogramAggregation;

    /*
     Set to true to apply interval adjusts to day and above intervals.
     */
    preZoneAdjustLargeInterval(trueFalse: boolean): DateHistogramAggregation;

    /*
     Allows you generate or modify the terms using a script.
     */
    script(scriptCode: string): DateHistogramAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): DateHistogramAggregation;

    /*
     Set the date time zone.
     */
    timeZone(tz: string): DateHistogramAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   The DateHistogram facet works with time-based values by building a histogram across time
   intervals of the value field. Each value is rounded into an interval (or
   placed in a bucket), and statistics are provided per interval/bucket (count and total).

   Facets are similar to SQL GROUP BY statements but perform much
   better. You can also construct several "groups" at once by simply
   specifying multiple facets.



   Tip:
   For more information on faceted navigation, see
   this
   Wikipedia article on Faceted Classification.


   */
  export class DateHistogramFacet implements Facet {

    /*
     A facet which returns the N most frequent terms within a collection
     or set of collections.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enables caching of the facetFilter
     */
    cacheFilter(trueFalse: boolean): DateHistogramFacet;

    /*
     Allows you to reduce the documents used for computing facet results.
     */
    facetFilter(oFilter: Object): DateHistogramFacet;

    /*
     The date histogram works on numeric values (since time is stored
     in milliseconds since the epoch in UTC).

     But, sometimes, systems will store a different resolution (like seconds since UTC)
     in a numeric field. The factor parameter can be used to change the value in the field
     to milliseconds to actual do the relevant rounding, and then be applied again to get to
     the original unit.

     For example, when storing in a numeric field seconds resolution,
     the factor can be set to 1000.
     */
    factor(f: number): DateHistogramFacet;

    /*
     Sets the field to be used to construct the this facet.
     */
    field(fieldName: string): DateHistogramFacet;

    /*
     Computes values across the entire index
     */
    global(trueFalse: boolean): DateHistogramFacet;

    /*
     Sets the bucket interval used to calculate the distribution.
     */
    interval(timeInterval: string): DateHistogramFacet;

    /*
     Allows you to specify a different key field to be used to group intervals.
     */
    keyField(fieldName: string): DateHistogramFacet;

    /*
     The script language being used. Currently supported values are
     javascript, groovy, and mvel.
     */
    lang(language: string): DateHistogramFacet;

    /*
     Sets the mode the facet will use.


     collector
     post

     */
    mode(m: string): DateHistogramFacet;

    /*
     Sets the path to the nested document if faceting against a
     nested field.
     */
    nested(path: string): DateHistogramFacet;

    /*
     Sets the type of ordering that will be performed on the date
     buckets.  Valid values are:


     time - the default, sort by the buckets start time in milliseconds.
     count - sort by the number of items in the bucket
     total - sort by the sum/total of the items in the bucket

     */
    order(o: string): DateHistogramFacet;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): DateHistogramFacet;

    /*
     Set's a specific post-rounding offset.  Format is 1d, 1h, etc.
     */
    postOffset(offset: string): DateHistogramFacet;

    /*
     By default, time values are stored in UTC format.

     This method allows users to set a time zone value that is then used to compute
     intervals after rounding on the interval value.  The value is an offset from UTC.
     The tz offset value is simply added to the resulting bucket's date value.

     For example, to use EST you would set the value to -5.
     */
    postZone(tz: number): DateHistogramFacet;

    /*
     Set's a specific pre-rounding offset.  Format is 1d, 1h, etc.
     */
    preOffset(offset: string): DateHistogramFacet;

    /*
     By default, time values are stored in UTC format.

     This method allows users to set a time zone value that is then used to
     compute intervals before rounding on the interval value.  The value is an
     offset from UTC.

     For example, to use EST you would set the value to -5.
     */
    preZone(tz: number): DateHistogramFacet;

    /*
     Enables large date interval conversions (day and up).

     Set to true to enable and then set the interval to an
     interval greater than a day.
     */
    preZoneAdjustLargeInterval(trueFalse: boolean): DateHistogramFacet;

    /*
     Computes values across the the specified scope
     */
    scope(scope: string): DateHistogramFacet;

    /*
     By default, time values are stored in UTC format.

     This method allows users to set a time zone value that is then used
     to compute intervals before rounding on the interval value. Equalivent to
     preZone.  Use preZone if possible. The
     value is an offset from UTC.

     For example, to use EST you would set the value to -5.
     */
    timeZone(tz: number): DateHistogramFacet;

    /*
     Retrieves the internal facet object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Allows you to specify a different value field to aggrerate over.
     */
    valueField(fieldName: string): DateHistogramFacet;

    /*
     Allows you modify the value field using a script. The modified value
     is then used to compute the statistical data.
     */
    valueScript(scriptCode: string): DateHistogramFacet;

  }


  /*
   A range aggregation that is dedicated for date values. The main difference
   between this aggregation and the normal range aggregation is that the from
   and to values can be expressed in Date Math expressions, and it is also
   possible to specify a date format by which the from and to response fields
   will be returned. Note that this aggregration includes the from value and
   excludes the to value for each range.

   Note that this aggregration includes the from value and excludes the to
   value for each range.
   */
  export class DateRangeAggregation implements Aggregation {

    /*
     Aggregation that is dedicated for date value ranges.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): DateRangeAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): DateRangeAggregation;

    /*
     Sets the field to gather terms from.
     */
    field(field: string): DateRangeAggregation;

    /*
     Sets the date format expression.
     */
    format(f: string): DateRangeAggregation;

    /*
     Enable the response to be returned as a keyed object where the key is the
     bucket interval.
     */
    keyed(trueFalse: boolean): DateRangeAggregation;

    /*
     The script language being used.
     */
    lang(language: string): DateRangeAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): DateRangeAggregation;

    /*
     Adds a range to the list of exsiting range expressions.
     */
    range(from: string, to: string, key: string): DateRangeAggregation;

    /*
     Allows you generate or modify the terms using a script.
     */
    script(scriptCode: string): DateRangeAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): DateRangeAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Decay functions score a document with a function that decays depending on
   the distance of a numeric field value of the document from a user given
   origin. This is similar to a range query, but with smooth edges instead of
   boxes.

   Supported decay functions are: linear, exp, and gauss.
   */
  export class DecayScoreFunction  implements ScoreFunction {

    /*
     Score a document with a function that decays depending on the distance
     of a numeric field value of the document from given origin.
     */
    constructor(field: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the decay value which defines how documents are scored at the distance
     given at scale.
     */
    decay(d: number): DecayScoreFunction;

    /*
     Use the exp decay function. Exponential decay.
     */
    exp(): DecayScoreFunction;

    /*
     Sets the fields to run the decay function against.
     */
    field(f: string): DecayScoreFunction;

    /*
     Adds a filter whose matching documents will have the score function applied.
     */
    filter(oFilter: Filter): DecayScoreFunction;

    /*
     Use the gauss decay function. Normal decay.
     */
    gauss(): DecayScoreFunction;

    /*
     Use the linear decay function. Linear decay.
     */
    linear(): DecayScoreFunction;

    /*
     Sets the decay offset.  The decay function will only compute a the decay
     function for documents with a distance greater that the defined offset.
     The default is 0.
     */
    offset(o: string): DecayScoreFunction;

    /*
     Sets the origin which is the “central point” from which the distance is
     calculated.
     */
    origin(o: string): DecayScoreFunction;

    /*
     Sets the scale/rate of decay.
     */
    scale(s: string): DecayScoreFunction;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   DirectGenerator is a candidate generator for PhraseSuggester.
   It generates terms based on edit distance and operators much like the
   TermSuggester.
   */
  export class DirectGenerator implements Generator {

    /*
     A candidate generator that generates terms based on edit distance.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the accuracy.  How similar the suggested terms at least
     need to be compared to the original suggest text.
     */
    accuracy(a: number): DirectGenerator;

    /*
     Sets the field used to generate suggestions from.
     */
    field(field: string): DirectGenerator;

    /*
     Sets the maximum edit distance candidate suggestions can have
     in order to be considered as a suggestion.
     */
    maxEdits(max: number): DirectGenerator;

    /*
     The factor that is used to multiply with the size in order
     to inspect more candidate suggestions.
     */
    maxInspections(max: number): DirectGenerator;

    /*
     Sets a maximum threshold in number of documents a suggest text
     token can exist in order to be corrected.
     */
    maxTermFreq(max: number): DirectGenerator;

    /*
     Sets a minimal threshold of the number of documents a suggested
     term should appear in.
     */
    minDocFreq(min: number): DirectGenerator;

    /*
     Sets the minimum length a suggest text term must have in order
     to be corrected.
     */
    minWordLen(len: number): DirectGenerator;

    /*
     Sets an analyzer that is applied to each of the generated tokens
     before they are passed to the actual phrase scorer.
     */
    postFilter(analyzer: string): DirectGenerator;

    /*
     Sets an analyzer that is applied to each of the tokens passed to
     this generator.  The analyzer is applied to the original tokens,
     not the generated tokens.
     */
    preFilter(analyzer: string): DirectGenerator;

    /*
     Sets the number of suggestions returned for each token.
     */
    size(s: number): DirectGenerator;

    /*
     Sets the sort mode.  Valid values are:


     score - Sort by score first, then document frequency, and then the term itself
     frequency - Sort by document frequency first, then simlarity score and then the term itself

     */
    sort(s: string): DirectGenerator;

    /*
     Sets what string distance implementation to use for comparing
     how similar suggested terms are.  Valid values are:


     internal - based on damerau_levenshtein but but highly optimized for comparing string distance for terms inside the index
     damerau_levenshtein - String distance algorithm based on Damerau-Levenshtein algorithm
     levenstein - String distance algorithm based on Levenstein edit distance algorithm
     jarowinkler - String distance algorithm based on Jaro-Winkler algorithm
     ngram - String distance algorithm based on character n-grams

     */
    stringDistance(s: string): DirectGenerator;

    /*
     Sets the suggest mode.  Valid values are:


     missing - Only suggest terms in the suggest text that aren't in the index
     popular - Only suggest suggestions that occur in more docs then the original suggest text term
     always - Suggest any matching suggestions based on terms in the suggest text

     */
    suggestMode(m: string): DirectGenerator;

    /*
     Retrieves the internal generator object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }

  export class DirectSettingsMixin {


    /*
     Sets the accuracy.  How similar the suggested terms at least
     need to be compared to the original suggest text.
     */
    accuracy(a: number): DirectSettingsMixin;

    /*
     Sets the maximum edit distance candidate suggestions can have
     in order to be considered as a suggestion.
     */
    maxEdits(max: number): DirectSettingsMixin;

    /*
     The factor that is used to multiply with the size in order
     to inspect more candidate suggestions.
     */
    maxInspections(max: number): DirectSettingsMixin;

    /*
     Sets a maximum threshold in number of documents a suggest text
     token can exist in order to be corrected.
     */
    maxTermFreq(max: number): DirectSettingsMixin;

    /*
     Sets a minimal threshold of the number of documents a suggested
     term should appear in.
     */
    minDocFreq(min: number): DirectSettingsMixin;

    /*
     Sets the minimum length a suggest text term must have in order
     to be corrected.
     */
    minWordLen(len: number): DirectSettingsMixin;

    /*
     Sets the number of minimal prefix characters that must match in
     order be a candidate suggestion.
     */
    prefixLen(len: number): DirectSettingsMixin;

    /*
     Sets the sort mode.  Valid values are:


     score - Sort by score first, then document frequency, and then the term itself
     frequency - Sort by document frequency first, then simlarity score and then the term itself

     */
    sort(s: string): DirectSettingsMixin;

    /*
     Sets what string distance implementation to use for comparing
     how similar suggested terms are.  Valid values are:


     internal - based on damerau_levenshtein but but highly optimized for comparing string distance for terms inside the index
     damerau_levenshtein - String distance algorithm based on Damerau-Levenshtein algorithm
     levenstein - String distance algorithm based on Levenstein edit distance algorithm
     jarowinkler - String distance algorithm based on Jaro-Winkler algorithm
     ngram - String distance algorithm based on character n-grams

     */
    stringDistance(s: string): DirectSettingsMixin;

    /*
     Sets the suggest mode.  Valid values are:


     missing - Only suggest terms in the suggest text that aren't in the index
     popular - Only suggest suggestions that occur in more docs then the original suggest text term
     always - Suggest any matching suggestions based on terms in the suggest text

     */
    suggestMode(m: string): DirectSettingsMixin;

  }


  /*
   A query that generates the union of documents produced by its subqueries, and
   that scores each document with the maximum score for that document as produced
   by any subquery, plus a tie breaking increment for any additional matching
   subqueries.
   */
  export class DisMaxQuery implements Query {

    /*
     A query that generates the union of documents produced by its subqueries such
     as termQuerys, phraseQuerys, boolQuerys, etc.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): DisMaxQuery;

    /*
     Updates the queries.  If passed a single Query, it is added to the
     list of existing queries.  If passed an array of Queries, it
     replaces all existing values.
     */
    queries(qs: Query | Query[]): DisMaxQuery;

    /*
     The tie breaker value.

     The tie breaker capability allows results that include the same term in multiple
     fields to be judged better than results that include this term in only the best of those
     multiple fields, without confusing this with the better case of two different terms in
     the multiple fields.

     Default: 0.0.
     */
    tieBreaker(tieBreaker: number): DisMaxQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   An existsFilter matches documents where the specified field is present
   and the field contains a legitimate value.
   */
  export class ExistsFilter implements Filter {

    /*
     Filters documents where a specified field exists and contains a value.
     */
    constructor(fieldName: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): ExistsFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): ExistsFilter;

    /*
     Sets the field to check for missing values.
     */
    field(name: string): ExistsFilter;

    /*
     Sets the filter name.
     */
    name(name: string): ExistsFilter;

    /*
     Returns the filter object.
     */
    toJSON(): ExistsFilter;

  }


  /*
   A multi-value metrics aggregation that computes stats over numeric values
   extracted from the aggregated documents. These values can be extracted either
   from specific numeric fields in the documents, or be generated by a provided
   script.

   The extended_stats aggregations is an extended version of the
   StatsAggregation, where additional metrics are added such as
   sum_of_squares, variance and std_deviation.
   */
  export class ExtendedStatsAggregation implements Aggregation {

    /*
     Aggregation that computes extra stats over numeric values extracted from
     the aggregated documents.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the field to operate on.
     */
    field(field: string): ExtendedStatsAggregation;

    /*
     The script language being used.
     */
    lang(language: string): ExtendedStatsAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): ExtendedStatsAggregation;

    /*
     Allows you generate or modify the terms/values using a script.
     */
    script(scriptCode: string): ExtendedStatsAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): ExtendedStatsAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }

  export class FacetMixin {


    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enables caching of the facetFilter
     */
    cacheFilter(trueFalse: boolean): FacetMixin;

    /*
     Allows you to reduce the documents used for computing facet results.
     */
    facetFilter(oFilter: Object): FacetMixin;

    /*
     Computes values across the entire index
     */
    global(trueFalse: boolean): FacetMixin;

    /*
     Sets the mode the facet will use.


     collector
     post

     */
    mode(m: string): FacetMixin;

    /*
     Sets the path to the nested document if faceting against a
     nested field.
     */
    nested(path: string): FacetMixin;

    /*
     Computes values across the the specified scope
     */
    scope(scope: string): FacetMixin;

    /*
     Retrieves the internal facet object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Wrapper to allow SpanQuery objects participate in composite single-field
   SpanQueries by 'lying' about their search field. That is, the masked
   SpanQuery will function as normal, but when asked for the field it
   queries against, it will return the value specified as the masked field vs.
   the real field used in the wrapped span query.
   */
  export class FieldMaskingSpanQuery implements Query {

    /*
     Wraps a SpanQuery and hides the real field being searched across.
     */
    constructor(spanQry: Query, field: number);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): FieldMaskingSpanQuery;

    /*
     Sets the value of the "masked" field.
     */
    field(f: string): FieldMaskingSpanQuery;

    /*
     Sets the span query to wrap.
     */
    query(spanQuery: Query): FieldMaskingSpanQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Defines a single bucket of all the documents in the current document set
   context that match a specified filter. Often this will be used to narrow down
   the current aggregation context to a specific set of documents.
   */
  export class FilterAggregation implements Aggregation {

    /*
     Defines a single bucket of all the documents that match a given filter.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): FilterAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): FilterAggregation;

    /*
     Sets the filter to be used for this aggregation.
     */
    filter(oFilter: Filter): FilterAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Filter queries allow you to restrict the results returned by a query. There are
   several different types of filters that can be applied
   (see filter module). A filterQuery
   takes a Query and a Filter object as arguments and constructs
   a new Query that is then used for the search.
   */
  export class FilteredQuery implements Query {

    /*
     A query that applies a filter to the results of another query.
     */
    constructor(someQuery: Object, someFilter: Object);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): FilteredQuery;

    /*
     Enables caching of the filter.
     */
    cache(trueFalse: boolean): FilteredQuery;

    /*
     Set the cache key.
     */
    cacheKey(k: string): FilteredQuery;

    /*
     Adds the filter to apply a constant score to.
     */
    filter(oFilter: Object): FilteredQuery;

    /*
     Adds the query to apply a constant score to.
     */
    query(oQuery: Object): FilteredQuery;

    /*
     Sets the filter strategy.

     The strategy defines how the filter is applied during document collection.
     Valid values are:


     query_first - advance query scorer first then filter
     random_access_random - random access filter
     leap_frog - query scorer and filter "leap-frog", query goes first
     leap_frog_filter_first - same as leap_frog, but filter goes first
     random_access_N - replace N with integer, same as random access
     except you can specify a custom threshold


     This is an advanced setting, use with care.
     */
    strategy(strategy: string): FilteredQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   The FilterFacet allows you to specify any valid Filter and
   have the number of matching hits returned as the value.

   Facets are similar to SQL GROUP BY statements but perform much
   better. You can also construct several "groups" at once by simply
   specifying multiple facets.



   Tip:
   For more information on faceted navigation, see
   this
   Wikipedia article on Faceted Classification.


   */
  export class FilterFacet implements Facet {

    /*
     A facet that return a count of the hits matching the given filter.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enables caching of the facetFilter
     */
    cacheFilter(trueFalse: boolean): FilterFacet;

    /*
     Allows you to reduce the documents used for computing facet results.
     */
    facetFilter(oFilter: Object): FilterFacet;

    /*
     Sets the filter to be used for this facet.
     */
    filter(oFilter: Object): FilterFacet;

    /*
     Computes values across the entire index
     */
    global(trueFalse: boolean): FilterFacet;

    /*
     Sets the mode the facet will use.


     collector
     post

     */
    mode(m: string): FilterFacet;

    /*
     Sets the path to the nested document if faceting against a
     nested field.
     */
    nested(path: string): FilterFacet;

    /*
     Computes values across the the specified scope
     */
    scope(scope: string): FilterFacet;

    /*
     Retrieves the internal facet object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }

  export class FilterMixin {


    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): FilterMixin;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): FilterMixin;

    /*
     Sets the filter name.
     */
    name(name: string): FilterMixin;

    /*
     Returns the filter object.
     */
    toJSON(): FilterMixin;

  }


  /*
   The function_score allows you to modify the score of documents that are
   retrieved by a query. This can be useful if, for example, a score function is
   computationally expensive and it is sufficient to compute the score on a
   filtered set of documents.
   */
  export class FunctionScoreQuery implements Query {

    /*
     A query that allows you to modify the score of matching documents.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): FunctionScoreQuery;

    /*
     Set the setermines how the new calculated score is combined with the
     score from the original query. Valid values are: multiply, replace, sum,
     avg, max, and min.
     */
    boostMode(mode: string): FunctionScoreQuery;

    /*
     Set the source filter.
     */
    filter(oFilter: Filter): FunctionScoreQuery;

    /*
     Add a single score function to the list of existing functions.
     */
    //function (func: ScoreFunction): FunctionScoreQuery;

    /*
     Sets the score functions.  Replaces any existing score functions.
     */
    functions(funcs: ScoreFunction[]): FunctionScoreQuery;

    /*
     Set the source query.
     */
    query(oQuery: Query): FunctionScoreQuery;

    /*
     Set the scoring mode which specifies how the computed scores are combined.
     Valid values are: avg, max, min, sum, multiply, and first.
     */
    scoreMode(mode: string): FunctionScoreQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   The fuzzy_like_this_field query is the same as the fuzzy_like_this
   query, except that it runs against a single field. It provides nicer query
   DSL over the generic fuzzy_like_this query, and support typed fields
   query (automatically wraps typed fields with type filter to match only on
   the specific type).

   Fuzzifies ALL terms provided as strings and then picks the best n
   differentiating terms. In effect this mixes the behaviour of FuzzyQuery and
   MoreLikeThis but with special consideration of fuzzy scoring factors. This
   generally produces good results for queries where users may provide details
   in a number of fields and have no knowledge of boolean query syntax and
   also want a degree of fuzzy matching and a fast query.

   For each source term the fuzzy variants are held in a BooleanQuery with
   no coord factor (because we are not looking for matches on multiple variants
   in any one doc). Additionally, a specialized TermQuery is used for variants
   and does not use that variant term’s IDF because this would favour rarer
   terms eg misspellings. Instead, all variants use the same IDF
   ranking (the one for the source query term) and this is factored into the
   variant’s boost. If the source query term does not exist in the index the
   average IDF of the variants is used.
   */
  export class FuzzyLikeThisFieldQuery implements Query {

    /*
     Constructs a query where each documents returned are “like” provided text
     */
    constructor(field: string, likeText: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     The analyzer that will be used to analyze the text. Defaults to the
     analyzer associated with the field.
     */
    analyzer(analyzerName: string): FuzzyLikeThisFieldQuery;

    /*
     Sets the boost value of the Query.
     */
    boost(boost: number): FuzzyLikeThisFieldQuery;

    /*
     Should the Query fail when an unsupported field
     is specified. Defaults to true.
     */
    failOnUnsupportedField(trueFalse: boolean): FuzzyLikeThisFieldQuery;

    /*
     The field to run the query against.
     */
    field(f: string): FuzzyLikeThisFieldQuery;

    /*
     Should term frequency be ignored. Defaults to false.
     */
    ignoreTf(trueFalse: boolean): FuzzyLikeThisFieldQuery;

    /*
     The text to find documents like
     */
    likeText(s: string): FuzzyLikeThisFieldQuery;

    /*
     The maximum number of query terms that will be included in any
     generated query. Defaults to 25.
     */
    maxQueryTerms(max: number): FuzzyLikeThisFieldQuery;

    /*
     The minimum similarity of the term variants. Defaults to 0.5.
     */
    minSimilarity(min: number): FuzzyLikeThisFieldQuery;

    /*
     Length of required common prefix on variant terms. Defaults to 0..
     */
    prefixLength(len: number): FuzzyLikeThisFieldQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Fuzzy like this query find documents that are “like” provided text by
   running it against one or more fields.

   Fuzzifies ALL terms provided as strings and then picks the best n
   differentiating terms. In effect this mixes the behaviour of FuzzyQuery and
   MoreLikeThis but with special consideration of fuzzy scoring factors. This
   generally produces good results for queries where users may provide details
   in a number of fields and have no knowledge of boolean query syntax and
   also want a degree of fuzzy matching and a fast query.

   For each source term the fuzzy variants are held in a BooleanQuery with
   no coord factor (because we are not looking for matches on multiple variants
   in any one doc). Additionally, a specialized TermQuery is used for variants
   and does not use that variant term’s IDF because this would favour rarer
   terms eg misspellings. Instead, all variants use the same IDF
   ranking (the one for the source query term) and this is factored into the
   variant’s boost. If the source query term does not exist in the index the
   average IDF of the variants is used.
   */
  export class FuzzyLikeThisQuery implements Query {

    /*
     Constructs a query where each documents returned are “like” provided text
     */
    constructor(likeText: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     The analyzer that will be used to analyze the text. Defaults to the
     analyzer associated with the field.
     */
    analyzer(analyzerName: string): FuzzyLikeThisQuery;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): FuzzyLikeThisQuery;

    /*
     Should the Query fail when an unsupported field
     is specified. Defaults to true.
     */
    failOnUnsupportedField(trueFalse: boolean): FuzzyLikeThisQuery;

    /*
     The fields to run the query against.  If you call with a single field,
     it is added to the existing list of fields.  If called with an array
     of field names, it replaces any existing values with the new array.
     */
    fields(f: string | string[]): FuzzyLikeThisQuery;

    /*
     Should term frequency be ignored. Defaults to false.
     */
    ignoreTf(trueFalse: boolean): FuzzyLikeThisQuery;

    /*
     The text to find documents like
     */
    likeText(s: string): FuzzyLikeThisQuery;

    /*
     The maximum number of query terms that will be included in any
     generated query. Defaults to 25.
     */
    maxQueryTerms(max: number): FuzzyLikeThisQuery;

    /*
     The minimum similarity of the term variants. Defaults to 0.5.
     */
    minSimilarity(min: number): FuzzyLikeThisQuery;

    /*
     Length of required common prefix on variant terms. Defaults to 0..
     */
    prefixLength(len: number): FuzzyLikeThisQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A fuzzy search query based on the Damerau-Levenshtein (optimal string
   alignment) algorithm, though you can explicitly choose classic Levenshtein
   by passing false to the transpositions parameter./p>

   fuzzy query on a numeric field will result in a range query “around”
   the value using the min_similarity value. As an example, if you perform a
   fuzzy query against a field value of "12" with a min similarity setting
   of "2", the query will search for values between "10" and "14".
   */
  export class FuzzyQuery implements Query {

    /*
     Constructs a query where each documents returned are “like” provided text
     */
    constructor(field: string, value: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value of the Query.
     */
    boost(boost: number): FuzzyQuery;

    /*
     The field to run the query against.
     */
    field(f: string): FuzzyQuery;

    /*
     The maximum number of query terms that will be included in any
     generated query. Defaults to 50.
     */
    maxExpansions(max: number): FuzzyQuery;

    /*
     The minimum similarity of the term variants. Defaults to 0.5.
     */
    minSimilarity(min: number): FuzzyQuery;

    /*
     Length of required common prefix on variant terms. Defaults to 0.
     */
    prefixLength(len: number): FuzzyQuery;

    /*
     Sets rewrite method.  Valid values are:


     constant_score_auto - tries to pick the best constant-score rewrite
     method based on term and document counts from the query

     scoring_boolean - translates each term into boolean should and
     keeps the scores as computed by the query

     constant_score_boolean - same as scoring_boolean, expect no scores
     are computed.

     constant_score_filter - first creates a private Filter, by visiting
     each term in sequence and marking all docs for that term

     top_terms_boost_N - first translates each term into boolean should
     and scores are only computed as the boost using the top N
     scoring terms.  Replace N with an integer value.

     top_terms_N - first translates each term into boolean should
     and keeps the scores as computed by the query. Only the top N
     scoring terms are used.  Replace N with an integer value.


     Default is constant_score_auto.

     This is an advanced option, use with care.
     */
    rewrite(m: string): FuzzyQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Set to false to use classic Levenshtein edit distance.
     */
    transpositions(trueFalse: boolean): FuzzyQuery;

    /*
     The query text to fuzzify.
     */
    value(s: string): FuzzyQuery;

  }


  /*
   A filter that restricts matched results/docs to a geographic bounding box described by
   the specified lon and lat coordinates. The format conforms with the GeoJSON specification.
   */
  export class GeoBboxFilter implements Filter {

    /*
     Filter results to those which are contained within the defined bounding box.
     */
    constructor(fieldName: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the bottom-right coordinate of the bounding box
     */
    bottomRight(p: GeoPoint): GeoBboxFilter;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): GeoBboxFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): GeoBboxFilter;

    /*
     Sets the fields to filter against.
     */
    field(f: string): GeoBboxFilter;

    /*
     Sets the filter name.
     */
    name(name: string): GeoBboxFilter;

    /*
     If the lat/long points should be normalized to lie within their
     respective normalized ranges.

     Normalized ranges are:
     lon = -180 (exclusive) to 180 (inclusive) range
     lat = -90 to 90 (both inclusive) range
     */
    normalize(trueFalse: string): GeoBboxFilter;

    /*
     Returns the filter object.
     */
    toJSON(): GeoBboxFilter;

    /*
     Sets the top-left coordinate of the bounding box
     */
    topLeft(p: GeoPoint): GeoBboxFilter;

    /*
     Sets the type of the bounding box execution. Valid values are
     "memory" and "indexed".  Default is memory.
     */
    type(type: string): GeoBboxFilter;

  }


  /*
   A multi-bucket aggregation that works on geo_point fields and conceptually
   works very similar to the range aggregation. The user can define a point of
   origin and a set of distance range buckets. The aggregation evaluate the
   distance of each document value from the origin point and determines the
   buckets it belongs to based on the ranges (a document belongs to a bucket
   if the distance between the document and the origin falls within the distance
   range of the bucket).
   */
  export class GeoDistanceAggregation implements Aggregation {

    /*
     Aggregation that works on geo_point fields and conceptually works very
     similar to the range aggregation.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): GeoDistanceAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): GeoDistanceAggregation;

    /*
     Sets the point of origin from where distances will be measured. Same as
     origin.
     */
    center(p: GeoPoint): GeoDistanceAggregation;

    /*
     How to compute the distance. Valid values are:
     plane, arc, sloppy_arc, and factor.
     */
    distanceType(type: string): GeoDistanceAggregation;

    /*
     Sets the field to gather terms from.
     */
    field(field: string): GeoDistanceAggregation;

    /*
     Enable the response to be returned as a keyed object where the key is the
     bucket interval.
     */
    keyed(trueFalse: boolean): GeoDistanceAggregation;

    /*
     Sets the point of origin from where distances will be measured.
     */
    origin(p: GeoPoint): GeoDistanceAggregation;

    /*
     Sets the point of origin from where distances will be measured. Same as
     origin.
     */
    point(p: GeoPoint): GeoDistanceAggregation;

    /*
     Adds a range to the list of exsiting range expressions.
     */
    range(from: string, to: string, key: string): GeoDistanceAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the distance unit.  Valid values are:
     in, yd, ft, km, NM, mm, cm, mi, and m.
     */
    unit(unit: Number): GeoDistanceAggregation;

  }


  /*
   The geoDistanceFacet facet provides information over a range of distances from a
   provided point. This includes the number of hits that fall within each range,
   along with aggregate information (like total).

   Facets are similar to SQL GROUP BY statements but perform much
   better. You can also construct several "groups" at once by simply
   specifying multiple facets.



   Tip:
   For more information on faceted navigation, see
   this
   Wikipedia article on Faceted Classification.


   */
  export class GeoDistanceFacet implements Facet {

    /*
     A facet which provides information over a range of distances from a provided point.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Adds a new bounded range.
     */
    addRange(from: Number, to: Number): GeoDistanceFacet;

    /*
     Adds a new unbounded lower limit.
     */
    addUnboundedFrom(from: Number): GeoDistanceFacet;

    /*
     Adds a new unbounded upper limit.
     */
    addUnboundedTo(to: Number): GeoDistanceFacet;

    /*
     Enables caching of the facetFilter
     */
    cacheFilter(trueFalse: boolean): GeoDistanceFacet;

    /*
     How to compute the distance. Can either be arc (better precision)
     or plane (faster). Defaults to arc.
     */
    distanceType(type: string): GeoDistanceFacet;

    /*
     Allows you to reduce the documents used for computing facet results.
     */
    facetFilter(oFilter: Object): GeoDistanceFacet;

    /*
     Sets the document field containing the geo-coordinate to be used
     to calculate the distance.  Defaults to "location".
     */
    field(fieldName: string): GeoDistanceFacet;

    /*
     Computes values across the entire index
     */
    global(trueFalse: boolean): GeoDistanceFacet;

    /*
     The script language being used. Currently supported values are
     javascript, groovy, and mvel.
     */
    lang(language: string): GeoDistanceFacet;

    /*
     Sets the mode the facet will use.


     collector
     post

     */
    mode(m: string): GeoDistanceFacet;

    /*
     Sets the path to the nested document if faceting against a
     nested field.
     */
    nested(path: string): GeoDistanceFacet;

    /*
     If the lat/long points should be normalized to lie within their
     respective normalized ranges.

     Normalized ranges are:
     lon = -180 (exclusive) to 180 (inclusive) range
     lat = -90 to 90 (both inclusive) range
     */
    normalize(trueFalse: string): GeoDistanceFacet;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): GeoDistanceFacet;

    /*
     Sets the point of origin from where distances will be measured.
     */
    point(p: GeoPoint): GeoDistanceFacet;

    /*
     Computes values across the the specified scope
     */
    scope(scope: string): GeoDistanceFacet;

    /*
     Retrieves the internal facet object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the distance unit.  Valid values are "mi" for miles or "km"
     for kilometers. Defaults to "km".
     */
    unit(unit: Number): GeoDistanceFacet;

    /*
     Allows you to specify a different value field to aggrerate over.
     */
    valueField(fieldName: string): GeoDistanceFacet;

    /*
     Allows you modify the value field using a script. The modified value
     is then used to compute the statistical data.
     */
    valueScript(scriptCode: string): GeoDistanceFacet;

  }


  /*
   A filter that restricts matched results/docs to a given distance from the
   point of origin. The format conforms with the GeoJSON specification.
   */
  export class GeoDistanceFilter implements Filter {

    /*
     Filter results to those which fall within the given distance of the point of origin.
     */
    constructor(fieldName: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): GeoDistanceFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): GeoDistanceFilter;

    /*
     Sets the numeric distance to be used.  The distance can be a
     numeric value, and then the unit (either mi or km can be set)
     controlling the unit. Or a single string with the unit as well.
     */
    distance(numericDistance: Number): GeoDistanceFilter;

    /*
     How to compute the distance. Can either be arc (better precision)
     or plane (faster). Defaults to arc.
     */
    distanceType(type: string): GeoDistanceFilter;

    /*
     Sets the fields to filter against.
     */
    field(f: string): GeoDistanceFilter;

    /*
     Sets the filter name.
     */
    name(name: string): GeoDistanceFilter;

    /*
     If the lat/long points should be normalized to lie within their
     respective normalized ranges.

     Normalized ranges are:
     lon = -180 (exclusive) to 180 (inclusive) range
     lat = -90 to 90 (both inclusive) range
     */
    normalize(trueFalse: string): GeoDistanceFilter;

    /*
     Will an optimization of using first a bounding box check will be
     used. Defaults to memory which will do in memory checks. Can also
     have values of indexed to use indexed value check, or none which
     disables bounding box optimization.
     */
    optimizeBbox(t: string): GeoDistanceFilter;

    /*
     Sets the point of origin in which distance will be measured from
     */
    point(p: GeoPoint): GeoDistanceFilter;

    /*
     Returns the filter object.
     */
    toJSON(): GeoDistanceFilter;

    /*
     Sets the distance unit.  Valid values are "mi" for miles or "km"
     for kilometers. Defaults to "km".
     */
    unit(unit: Number): GeoDistanceFilter;

  }


  /*
   A filter that restricts matched results/docs to a given distance range from the
   point of origin. The format conforms with the GeoJSON specification.
   */
  export class GeoDistanceRangeFilter implements Filter {

    /*
     Filter results to those which fall within the given distance range of the point of origin.
     */
    constructor(fieldName: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): GeoDistanceRangeFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): GeoDistanceRangeFilter;

    /*
     How to compute the distance. Can either be arc (better precision)
     or plane (faster). Defaults to arc.
     */
    distanceType(type: string): GeoDistanceRangeFilter;

    /*
     Sets the fields to filter against.
     */
    field(f: string): GeoDistanceRangeFilter;

    /*
     Sets the start point of the distance range
     */
    from(numericDistance: Number): GeoDistanceRangeFilter;

    /*
     Greater than value.  Same as setting from to the value, and
     include_lower to false,
     */
    gt(val: Number): GeoDistanceRangeFilter;

    /*
     Greater than or equal to value.  Same as setting from to the value,
     and include_lower to true.
     */
    gte(val: Number): GeoDistanceRangeFilter;

    /*
     Should the first from (if set) be inclusive or not.
     Defaults to true
     */
    includeLower(trueFalse: boolean): GeoDistanceRangeFilter;

    /*
     Should the last to (if set) be inclusive or not. Defaults to true.
     */
    includeUpper(trueFalse: boolean): GeoDistanceRangeFilter;

    /*
     Less than value.  Same as setting to to the value, and include_upper
     to false.
     */
    lt(val: Number): GeoDistanceRangeFilter;

    /*
     Less than or equal to value.  Same as setting to to the value,
     and include_upper to true.
     */
    lte(val: Number): GeoDistanceRangeFilter;

    /*
     Sets the filter name.
     */
    name(name: string): GeoDistanceRangeFilter;

    /*
     If the lat/long points should be normalized to lie within their
     respective normalized ranges.

     Normalized ranges are:
     lon = -180 (exclusive) to 180 (inclusive) range
     lat = -90 to 90 (both inclusive) range
     */
    normalize(trueFalse: string): GeoDistanceRangeFilter;

    /*
     Will an optimization of using first a bounding box check will be
     used. Defaults to memory which will do in memory checks. Can also
     have values of indexed to use indexed value check, or none which
     disables bounding box optimization.
     */
    optimizeBbox(t: string): GeoDistanceRangeFilter;

    /*
     Sets the point of origin in which distance will be measured from
     */
    point(p: GeoPoint): GeoDistanceRangeFilter;

    /*
     Sets the end point of the distance range
     */
    to(numericDistance: Number): GeoDistanceRangeFilter;

    /*
     Returns the filter object.
     */
    toJSON(): GeoDistanceRangeFilter;

    /*
     Sets the distance unit.  Valid values are "mi" for miles or "km"
     for kilometers. Defaults to "km".
     */
    unit(unit: Number): GeoDistanceRangeFilter;

  }


  /*
   A multi-bucket aggregation that works on geo_point fields and groups points
   into buckets that represent cells in a grid. The resulting grid can be sparse
   and only contains cells that have matching data. Each cell is labeled using a
   geohash which is of user-definable precision.
   */
  export class GeoHashGridAggregation implements Aggregation {

    /*
     Aggregation that works on geo_point fields and groups points into buckets
     that represent cells in a grid.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): GeoHashGridAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): GeoHashGridAggregation;

    /*
     Sets the geo field to perform calculations from.
     */
    field(field: string): GeoHashGridAggregation;

    /*
     Sets the Geo Hash precision.  The precision value can be between 1 and 12
     where 12 is the highest precision.
     */
    precision(p: number): GeoHashGridAggregation;

    /*
     Determines how many geohash_grid the coordinating node will request from
     each shard.
     */
    shardSize(shardSize: number): GeoHashGridAggregation;

    /*
     Sets the number of aggregation entries that will be returned.
     */
    size(size: number): GeoHashGridAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A GeoPoint object that can be used in queries and filters that
   take a GeoPoint.  GeoPoint supports various input formats.

   See http://www.elasticsearch.org/guide/reference/mapping/geo-point-type.html
   */
  export class GeoPoint implements Geo {

    /*
     Defines a point
     */
    constructor(p: any[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the GeoPoint from an array point.  The array must contain only
     2 values.  The first value is the lat and the 2nd value is the lon.

     Example:
     [41.12, -71.34]
     */
    array(a: any[]): GeoPoint;

    /*
     Sets the GeoPoint as a GeoHash.  The hash is a string of
     alpha-numeric characters with a precision length that defaults to 12.

     Example:
     "drm3btev3e86"
     */
    geohash(hash: string, precision: number): GeoPoint;

    /*
     Sets the GeoPoint as properties on an object.  The object must have
     a 'lat' and 'lon' or a 'geohash' property.

     Example:
     {lat: 41.12, lon: -71.34} or {geohash: "drm3btev3e86"}
     */
    properties(obj: Object): GeoPoint;

    /*
     Sets the GeoPoint as a string.  The format is "lat,lon".

     Example:

     "41.12,-71.34"
     */
    string(s: string): GeoPoint;

    /*
     Retrieves the internal script object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A filter for locating documents that fall within a polygon of points. Simply provide a lon/lat
   for each document as a Geo Point type. The format conforms with the GeoJSON specification.
   */
  export class GeoPolygonFilter {

    /*
     Filter results to those which are contained within the polygon of points.
     */
    constructor(fieldName: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): GeoPolygonFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): GeoPolygonFilter;

    /*
     Sets the fields to filter against.
     */
    field(f: string): GeoPolygonFilter;

    /*
     Sets the filter name.
     */
    name(name: string): GeoPolygonFilter;

    /*
     If the lat/long points should be normalized to lie within their
     respective normalized ranges.

     Normalized ranges are:
     lon = -180 (exclusive) to 180 (inclusive) range
     lat = -90 to 90 (both inclusive) range
     */
    normalize(trueFalse: string): GeoPolygonFilter;

    /*
     Sets a series of points that represent a polygon.  If passed a
     single GeoPoint object, it is added to the current
     list of points.  If passed an array of GeoPoint
     objects it replaces all current values.
     */
    points(pointsArray: any[]): GeoPolygonFilter;

    /*
     Returns the filter object.
     */
    toJSON(): GeoPolygonFilter;

  }


  /*
   Efficient filtering of documents containing shapes indexed using the
   geo_shape type.

   Much like the geo_shape type, the geo_shape filter uses a grid square
   representation of the filter shape to find those documents which have shapes
   that relate to the filter shape in a specified way. In order to do this, the
   field being queried must be of geo_shape type. The filter will use the same
   PrefixTree configuration as defined for the field.
   */
  export class GeoShapeFilter implements Filter {

    /*
     A Filter to find documents with a geo_shapes matching a specific shape.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): GeoShapeFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): GeoShapeFilter;

    /*
     Sets the field to filter against.
     */
    field(f: string): GeoShapeFilter;

    /*
     Sets the indexed shape.  Use this if you already have shape definitions
     already indexed.
     */
    indexedShape(indexedShape: string): GeoShapeFilter;

    /*
     Sets the filter name.
     */
    name(name: string): GeoShapeFilter;

    /*
     Sets the shape relation type.  A relationship between a Query Shape
     and indexed Shapes that will be used to determine if a Document
     should be matched or not.  Valid values are:  intersects, disjoint,
     and within.
     */
    relation(indexedShape: string): GeoShapeFilter;

    /*
     Sets the shape
     */
    shape(shape: string): GeoShapeFilter;

    /*
     Sets the spatial strategy.
     Valid values are:


     recursive - default, recursively traverse nodes in
     the spatial prefix tree.  This strategy has support for
     searching non-point shapes.
     term - uses a large TermsFilter on each node
     in the spatial prefix tree.  It only supports the search of
     indexed Point shapes.


     This is an advanced setting, use with care.
     */
    strategy(strategy: string): GeoShapeFilter;

    /*
     Returns the filter object.
     */
    toJSON(): GeoShapeFilter;

  }


  /*
   Efficient querying of documents containing shapes indexed using the
   geo_shape type.

   Much like the geo_shape type, the geo_shape query uses a grid square
   representation of the query shape to find those documents which have shapes
   that relate to the query shape in a specified way. In order to do this, the
   field being queried must be of geo_shape type. The query will use the same
   PrefixTree configuration as defined for the field.
   */
  export class GeoShapeQuery implements Query {

    /*
     A Query to find documents with a geo_shapes matching a specific shape.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: Number): GeoShapeQuery;

    /*
     Sets the field to query against.
     */
    field(f: string): GeoShapeQuery;

    /*
     Sets the indexed shape.  Use this if you already have shape definitions
     already indexed.
     */
    indexedShape(indexedShape: string): GeoShapeQuery;

    /*
     Sets the shape relation type.  A relationship between a Query Shape
     and indexed Shapes that will be used to determine if a Document
     should be matched or not.  Valid values are:  intersects, disjoint,
     and within.
     */
    relation(indexedShape: string): GeoShapeQuery;

    /*
     Sets the shape
     */
    shape(shape: string): GeoShapeQuery;

    /*
     Sets the spatial strategy.
     Valid values are:


     recursive - default, recursively traverse nodes in
     the spatial prefix tree.  This strategy has support for
     searching non-point shapes.
     term - uses a large TermsFilter on each node
     in the spatial prefix tree.  It only supports the search of
     indexed Point shapes.


     This is an advanced setting, use with care.
     */
    strategy(strategy: string): GeoShapeQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Defines a single bucket of all the documents within the search execution
   context. This context is defined by the indices and the document types you’re
   searching on, but is not influenced by the search query itself.
   */
  export class GlobalAggregation implements Aggregation {

    /*
     Defines a single bucket of all the documents within the search context.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): GlobalAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): GlobalAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   The has_child filter results in parent documents that have child docs
   matching the query being returned.
   */
  export class HasChildFilter implements Filter {

    /*
     Returns results that have child documents matching the filter.
     */
    constructor(qry: Object, type: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): HasChildFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): HasChildFilter;

    /*
     Sets the filter
     */
    filter(f: Query): HasChildFilter;

    /*
     Sets the filter name.
     */
    name(name: string): HasChildFilter;

    /*
     Sets the query
     */
    query(q: Query): HasChildFilter;

    /*
     Sets the scope of the filter.  A scope allows to run facets on the
     same scope name that will work against the child documents.
     */
    scope(s: string): HasChildFilter;

    /*
     Sets the cutoff value to short circuit processing.
     */
    shortCircuitCutoff(cutoff: number): HasChildFilter;

    /*
     Returns the filter object.
     */
    toJSON(): HasChildFilter;

    /*
     Sets the child document type to search against
     */
    type(t: string): HasChildFilter;

  }


  /*
   The has_child query works the same as the has_child filter,
   by automatically wrapping the filter with a constant_score. Results in
   parent documents that have child docs matching the query being returned.
   */
  export class HasChildQuery implements Query {

    /*
     Returns results that have child documents matching the query.
     */
    constructor(qry: Object, type: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): HasChildQuery;

    /*
     Sets the query
     */
    query(q: Object): HasChildQuery;

    /*
     Sets the scope of the query.  A scope allows to run facets on the
     same scope name that will work against the child documents.
     */
    scope(s: string): HasChildQuery;

    /*
     Sets the scoring method.  Valid values are:

     none - the default, no scoring
     max - the highest score of all matched child documents is used
     sum - the sum the all the matched child documents is used
     avg - the average of all matched child documents is used
     */
    scoreMode(s: string): HasChildQuery;

    /*
     Sets the scoring method.  Valid values are:

     none - the default, no scoring
     max - the highest score of all matched child documents is used
     sum - the sum the all the matched child documents is used
     avg - the average of all matched child documents is used
     */
    scoreType(s: string): HasChildQuery;

    /*
     Sets the cutoff value to short circuit processing.
     */
    shortCircuitCutoff(cutoff: number): HasChildQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the child document type to search against
     */
    type(t: string): HasChildQuery;

  }


  /*
   The has_parent results in child documents that have parent docs matching
   the query being returned.
   */
  export class HasParentFilter implements Filter {

    /*
     Returns results that have parent documents matching the filter.
     */
    constructor(qry: Object, parentType: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): HasParentFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): HasParentFilter;

    /*
     Sets the filter
     */
    filter(f: Object): HasParentFilter;

    /*
     Sets the filter name.
     */
    name(name: string): HasParentFilter;

    /*
     Sets the child document type to search against
     */
    parentType(t: string): HasParentFilter;

    /*
     Sets the query
     */
    query(q: Object): HasParentFilter;

    /*
     Sets the scope of the filter.  A scope allows to run facets on the
     same scope name that will work against the parent documents.
     */
    scope(s: string): HasParentFilter;

    /*
     Returns the filter object.
     */
    toJSON(): HasParentFilter;

  }


  /*
   The has_parent query works the same as the has_parent filter, by
   automatically wrapping the filter with a constant_score. Results in
   child documents that have parent docs matching the query being returned.
   */
  export class HasParentQuery implements Query {

    /*
     Returns results that have parent documents matching the query.
     */
    constructor(qry: Object, parentType: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): HasParentQuery;

    /*
     Sets the child document type to search against
     */
    parentType(t: string): HasParentQuery;

    /*
     Sets the query
     */
    query(q: Object): HasParentQuery;

    /*
     Sets the scope of the query.  A scope allows to run facets on the
     same scope name that will work against the parent documents.
     */
    scope(s: string): HasParentQuery;

    /*
     Sets the scoring method.  Valid values are:

     none - the default, no scoring
     score - the score of the parent is used in all child documents.
     */
    scoreMode(s: string): HasParentQuery;

    /*
     Sets the scoring method.  Valid values are:

     none - the default, no scoring
     score - the score of the parent is used in all child documents.
     */
    scoreType(s: string): HasParentQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Allows to highlight search results on one or more fields.  In order to
   perform highlighting, the actual content of the field is required. If the
   field in question is stored (has store set to yes in the mapping), it will
   be used, otherwise, the actual _source will be loaded and the relevant
   field will be extracted from it.

   If no term_vector information is provided (by setting it to
   with_positions_offsets in the mapping), then the plain highlighter will be
   used. If it is provided, then the fast vector highlighter will be used.
   When term vectors are available, highlighting will be performed faster at
   the cost of bigger index size.

   See http://www.elasticsearch.org/guide/reference/api/search/highlighting.html
   */
  export class Highlight {

    /*
     Allows to highlight search results on one or more fields.
     */
    constructor(fields: string | string[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Set's the boundary characters.  When highlighting a field that is
     mapped with term vectors, boundary_chars can be configured to
     define what constitutes a boundary for highlighting. It’s a single
     string with each boundary character defined in it. You can apply
     the option to a specific field by passing the field name in to
     the oField parameter. It defaults to ".,!? \t\n".
     */
    boundaryChars(charStr: string, oField: string): Highlight;

    /*
     Sets the max number of characters to scan while looking for the
     start of a boundary character. You can apply the option to a
     specific field by passing the field name in to the
     oField parameter. Default:  20
     */
    boundaryMaxScan(cnt: number, oField: string): Highlight;

    /*
     Sets highlight encoder.  Valid values are:

     default - the default, no encoding
     html - to encode html characters if you use html tags
     */
    encoder(e: string): Highlight;

    /*
     Allows you to set the fields that will be highlighted.  You can
     specify a single field or an array of fields.  All fields are
     added to the current list of fields.
     */
    fields(vals: string | string[]): Highlight;

    /*
     Sets the fragmenter type.  You can apply the option
     to a specific field by passing the field name in to the
     oField parameter.  Valid values for order are:

     simple - breaks text up into same-size fragments with no concerns
     over spotting sentence boundaries.
     span - breaks text up into same-size fragments but does not split
     up Spans.
     */
    fragmenter(f: string, oField: string): Highlight;

    /*
     Sets the size of each highlight fragment in characters.
     You can apply the option to a specific field by passing the field
     name in to the oField parameter. Default:  100
     */
    fragmentSize(size: number, oField: string): Highlight;

    /*
     Enables highlights in documents matched by a filter.
     You can apply the option to a specific field by passing the field
     name in to the oField parameter.  Defaults to false.
     */
    highlightFilter(trueFalse: boolean, oField: string): Highlight;

    /*
     Sets the number of highlight fragments.
     You can apply the option to a specific field by passing the field
     name in to the oField parameter. Default:  5
     */
    numberOfFragments(cnt: number, oField: string): Highlight;

    /*
     Sets arbitrary options that can be passed to the highlighter
     implementation in use.
     */
    options(opts: string, oField: string): Highlight;

    /*
     Sets the order of highlight fragments.  You can apply the option
     to a specific field by passing the field name in to the
     oField parameter.  Valid values for order are:

     score - the score calculated by Lucene's highlighting framework.
     */
    order(o: string, oField: string): Highlight;

    /*
     Sets the post tags for highlighted fragments.  You can apply the
     tags to a specific field by passing the field name in to the
     oField parameter.
     */
    postTags(tags: string | string[], oField: string): Highlight;

    /*
     Sets the pre tags for highlighted fragments.  You can apply the
     tags to a specific field by passing the field name in to the
     oField parameter.
     */
    preTags(tags: string | string[], oField: string): Highlight;

    /*
     When enabled it will cause a field to be highlighted only if a
     query matched that field. false means that terms are highlighted
     on all requested fields regardless if the query matches
     specifically on them.  You can apply the option to a specific
     field by passing the field name in to the oField
     parameter.  Defaults to false.
     */
    requireFieldMatch(trueFalse: boolean, oField: string): Highlight;

    /*
     Sets the schema to be used for the tags. Valid values are:

     styled - 10  pre tags with css class of hltN, where N is 1-10
     */
    tagsSchema(s: string): Highlight;

    /*
     Retrieves the internal script object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the highligher type.  You can apply the option
     to a specific field by passing the field name in to the
     oField parameter.  Valid values for order are:

     fast-vector-highlighter - the fast vector based highligher
     highlighter - the slower plain highligher
     */
    type(t: string, oField: string): Highlight;

  }


  /*
   A multi-bucket values source based aggregation that can be applied on
   numeric values extracted from the documents. It dynamically builds fixed
   size (a.k.a. interval) buckets over the values.
   */
  export class HistogramAggregation implements Aggregation {

    /*
     Aggregation that can be applied on numeric values extracted from the
     documents.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): HistogramAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): HistogramAggregation;

    /*
     Set's the range/bounds for the histogram aggregation.  Useful when you
     want to include buckets that might be outside the bounds of indexed
     documents.
     */
    extendedBounds(min: number, max: number): HistogramAggregation;

    /*
     Sets the field to gather terms from.
     */
    field(field: string): HistogramAggregation;

    /*
     Sets the format expression for the terms.  Use for number or date
     formatting
     */
    format(f: string): HistogramAggregation;

    /*
     Sets the histogram interval.  Buckets are generated based on this interval
     value.
     */
    interval(i: number): HistogramAggregation;

    /*
     Enable the response to be returned as a keyed object where the key is the
     bucket interval.
     */
    keyed(trueFalse: boolean): HistogramAggregation;

    /*
     The script language being used.
     */
    lang(language: string): HistogramAggregation;

    /*
     Only return terms that match more than a configured number of hits.
     */
    minDocCount(num: number): HistogramAggregation;

    /*
     Sets order for the aggregated values.
     */
    order(order: string, direction: string): HistogramAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): HistogramAggregation;

    /*
     Allows you generate or modify the terms using a script.
     */
    script(scriptCode: string): HistogramAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): HistogramAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   The histogram facet works with numeric data by building a histogram across intervals
   of the field values. Each value is rounded into an interval (or placed in a
   bucket), and statistics are provided per interval/bucket (count and total).

   Facets are similar to SQL GROUP BY statements but perform much
   better. You can also construct several "groups" at once by simply
   specifying multiple facets.



   Tip:
   For more information on faceted navigation, see
   this
   Wikipedia article on Faceted Classification.


   */
  export class HistogramFacet implements Facet {

    /*
     A facet which returns the N most frequent terms within a collection
     or set of collections.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enables caching of the facetFilter
     */
    cacheFilter(trueFalse: boolean): HistogramFacet;

    /*
     Allows you to reduce the documents used for computing facet results.
     */
    facetFilter(oFilter: Object): HistogramFacet;

    /*
     Sets the field to be used to construct the this facet.
     */
    field(fieldName: string): HistogramFacet;

    /*
     Sets the "from", "start", or lower bounds bucket.  For example if
     you have a value of 1023, an interval of 100, and a from value of
     1500, it will be placed into the 1500 bucket vs. the normal bucket
     of 1000.
     */
    from(from: Number): HistogramFacet;

    /*
     Computes values across the entire index
     */
    global(trueFalse: boolean): HistogramFacet;

    /*
     Sets the bucket interval used to calculate the distribution.
     */
    interval(numericInterval: Number): HistogramFacet;

    /*
     Allows you to specify a different key field to be used to group intervals.
     */
    keyField(fieldName: string): HistogramFacet;

    /*
     Allows you modify the key field using a script. The modified value
     is then used to generate the interval.
     */
    keyScript(scriptCode: string): HistogramFacet;

    /*
     The script language being used. Currently supported values are
     javascript, groovy, and mvel.
     */
    lang(language: string): HistogramFacet;

    /*
     Sets the mode the facet will use.


     collector
     post

     */
    mode(m: string): HistogramFacet;

    /*
     Sets the path to the nested document if faceting against a
     nested field.
     */
    nested(path: string): HistogramFacet;

    /*
     Sets the type of ordering that will be performed on the date
     buckets.  Valid values are:

     key - the default, sort by the bucket's key value
     count - sort by the number of items in the bucket
     total - sort by the sum/total of the items in the bucket
     */
    order(o: string): HistogramFacet;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): HistogramFacet;

    /*
     Computes values across the the specified scope
     */
    scope(scope: string): HistogramFacet;

    /*
     Sets the bucket interval used to calculate the distribution based
     on a time value such as "1d", "1w", etc.
     */
    timeInterval(timeInterval: Number): HistogramFacet;

    /*
     Sets the "to", "end", or upper bounds bucket.  For example if
     you have a value of 1023, an interval of 100, and a to value of
     900, it will be placed into the 900 bucket vs. the normal bucket
     of 1000.
     */
    to(to: Number): HistogramFacet;

    /*
     Retrieves the internal facet object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Allows you to specify a different value field to aggrerate over.
     */
    valueField(fieldName: string): HistogramFacet;

    /*
     Allows you modify the value field using a script. The modified value
     is then used to compute the statistical data.
     */
    valueScript(scriptCode: string): HistogramFacet;

  }


  /*
   Filters documents that only have the provided ids. Note, this filter
   does not require the _id field to be indexed since it works using the
   _uid field.
   */
  export class IdsFilter implements Filter {

    /*
     Matches documents with the specified id(s).
     */
    constructor(ids: string | string[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): IdsFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): IdsFilter;

    /*
     Sets the filter name.
     */
    name(name: string): IdsFilter;

    /*
     Returns the filter object.
     */
    toJSON(): IdsFilter;

    /*
     Sets the type as a single type or an array of types.  If type is a
     string, it is added to the list of existing types.  If type is an
     array, it is set as the types and overwrites an existing types. This
     parameter is optional.
     */
    type(type: string | string[]): IdsFilter;

    /*
     Sets the values array or adds a new value. if val is a string, it
     is added to the list of existing document ids.  If val is an
     array it is set as the document values and replaces any existing values.
     */
    values(val: string | string[]): IdsFilter;

  }


  /*
   Filters documents that only have the provided ids. Note, this filter
   does not require the _id field to be indexed since it works using the
   _uid field.
   */
  export class IdsQuery implements Query {

    /*
     Matches documents with the specified id(s).
     */
    constructor(ids: string | string[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): IdsQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the type as a single type or an array of types.  If type is a
     string, it is added to the list of existing types.  If type is an
     array, it is set as the types and overwrites an existing types. This
     parameter is optional.
     */
    type(type: string | string[]): IdsQuery;

    /*
     Sets the values array or adds a new value. if val is a string, it
     is added to the list of existing document ids.  If val is an
     array it is set as the document values and replaces any existing values.
     */
    values(val: string | string[]): IdsQuery;

  }


  /*
   A shape which has already been indexed in another index and/or index
   type. This is particularly useful for when you have a pre-defined list of
   shapes which are useful to your application and you want to reference this
   using a logical name (for example ‘New Zealand’) rather than having to
   provide their coordinates each time.
   */
  export class IndexedShape implements Geo {

    /*
     Defines a shape that already exists in an index/type.
     */
    constructor(type: string, id: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the document id of the indexed shape.
     */
    id(id: string): IndexedShape;

    /*
     Sets the index which the shape is indexed under.
     Defaults to "shapes".
     */
    index(idx: string): IndexedShape;

    /*
     Sets the field name containing the indexed shape.
     Defaults to "shape".
     */
    shapeFieldName(field: string): IndexedShape;

    /*
     Retrieves the internal script object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the type which the shape is indexed under.
     */
    type(t: string): IndexedShape;

  }


  /*
   The indices filter can be used when executed across multiple indices,
   allowing to have a filter that executes only when executed on an index that
   matches a specific list of indices, and another filter that executes when it
   is executed on an index that does not match the listed indices.
   */
  export class IndicesFilter implements Filter {

    /*
     A configurable filter that is dependent on the index name.
     */
    constructor(fltr: Object, indices: string | string[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): IndicesFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): IndicesFilter;

    /*
     Sets the filter to be used when executing on one of the indicies
     specified.
     */
    filter(f: Object): IndicesFilter;

    /*
     Sets the indicies the filter should match.  When passed a string,
     the index name is added to the current list of indices.  When passed
     an array, it overwites all current indices.
     */
    indices(i: string | string[]): IndicesFilter;

    /*
     Sets the filter name.
     */
    name(name: string): IndicesFilter;

    /*
     Sets the filter to be used on an index that does not match an index
     name in the indices list.  Can also be set to "none" to not match any
     documents or "all" to match all documents.
     */
    noMatchFilter(f: Filter | string): IndicesFilter;

    /*
     Returns the filter object.
     */
    toJSON(): IndicesFilter;

  }


  /*
   The indices query can be used when executed across multiple indices,
   allowing to have a query that executes only when executed on an index that
   matches a specific list of indices, and another query that executes when it
   is executed on an index that does not match the listed indices.
   */
  export class IndicesQuery implements Query {

    /*
     A configurable query that is dependent on the index name.
     */
    constructor(qry: Query, indices: string | string[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): IndicesQuery;

    /*
     Sets the indicies the query should match.  When passed a string,
     the index name is added to the current list of indices.  When passed
     an array, it overwites all current indices.
     */
    indices(i: string | string[]): IndicesQuery;

    /*
     Sets the query to be used on an index that does not match an index
     name in the indices list.  Can also be set to "none" to not match any
     documents or "all" to match all documents.
     */
    noMatchQuery(q: Query | string): IndicesQuery;

    /*
     Sets the query to be executed against the indices specified.
     */
    query(q: Query): IndicesQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A dedicated range aggregation for IPv4 typed fields.

   Note that this aggregration includes the from value and excludes the to
   value for each range.
   */
  export class IPv4RangeAggregation implements Aggregation {

    /*
     A dedicated range aggregation for IPv4 typed fields.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): IPv4RangeAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): IPv4RangeAggregation;

    /*
     Sets the field to gather terms from.
     */
    field(field: string): IPv4RangeAggregation;

    /*
     Enable the response to be returned as a keyed object where the key is the
     bucket interval.
     */
    keyed(trueFalse: boolean): IPv4RangeAggregation;

    /*
     The script language being used.
     */
    lang(language: string): IPv4RangeAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): IPv4RangeAggregation;

    /*
     Adds a range to the list of exsiting range expressions.
     */
    range(from: string, to: string, key: string): IPv4RangeAggregation;

    /*
     Allows you generate or modify the terms using a script.
     */
    script(scriptCode: string): IPv4RangeAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): IPv4RangeAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A limit filter limits the number of documents (per shard) to execute on.
   */
  export class LimitFilter implements Filter {

    /*
     Limits the number of documents to execute on.
     */
    constructor(limit: number);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): LimitFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): LimitFilter;

    /*
     Sets the filter name.
     */
    name(name: string): LimitFilter;

    /*
     Returns the filter object.
     */
    toJSON(): LimitFilter;

    /*
     Sets the limit value.
     */
    value(val: number): LimitFilter;

  }


  /*
   This filter can be used to match on all the documents
   in a given set of collections and/or types.
   */
  export class MatchAllFilter implements Filter {

    /*
     A filter that matches on all documents
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): MatchAllFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): MatchAllFilter;

    /*
     Sets the filter name.
     */
    name(name: string): MatchAllFilter;

    /*
     Returns the filter object.
     */
    toJSON(): MatchAllFilter;

  }


  /*
   This query can be used to match all the documents
   in a given set of collections and/or types.
   */
  export class MatchAllQuery implements Query {

    /*
     A query that returns all documents.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): MatchAllQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A MatchQuery is a type of Query that accepts
   text/numerics/dates, analyzes it, generates a query based on the
   MatchQuery type.
   */
  export class MatchQuery implements Query {

    /*
     A Query that appects text, analyzes it, generates internal query based
     on the MatchQuery type.
     */
    constructor(field: string, qstr: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the analyzer name used to analyze the Query object.
     */
    analyzer(analyzer: string): MatchQuery;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: Number): MatchQuery;

    /*
     Sets the maximum threshold/frequency to be considered a low
     frequency term in a CommonTermsQuery.
     Set to a value between 0 and 1.
     */
    cutoffFrequency(freq: Number): MatchQuery;

    /*
     Sets the fuzziness value for the Query.
     */
    fuzziness(fuzz: number): MatchQuery;

    /*
     Sets fuzzy rewrite method.  Valid values are:

     constant_score_auto - tries to pick the best constant-score rewrite
     method based on term and document counts from the query

     scoring_boolean - translates each term into boolean should and
     keeps the scores as computed by the query

     constant_score_boolean - same as scoring_boolean, expect no scores
     are computed.

     constant_score_filter - first creates a private Filter, by visiting
     each term in sequence and marking all docs for that term

     top_terms_boost_N - first translates each term into boolean should
     and scores are only computed as the boost using the top N
     scoring terms.  Replace N with an integer value.

     top_terms_N -   first translates each term into boolean should
     and keeps the scores as computed by the query. Only the top N
     scoring terms are used.  Replace N with an integer value.

     Default is constant_score_auto.

     This is an advanced option, use with care.
     */
    fuzzyRewrite(m: string): MatchQuery;

    /*
     Set to false to use classic Levenshtein edit distance in the
     fuzzy query.
     */
    fuzzyTranspositions(trueFalse: boolean): MatchQuery;

    /*
     Enables lenient parsing of the query string.
     */
    lenient(trueFalse: boolean): MatchQuery;

    /*
     Sets the max expansions of a fuzzy MatchQuery.
     */
    maxExpansions(e: number): MatchQuery;

    /*
     Sets a percent value controlling how many "should" clauses in the
     resulting Query should match.
     */
    minimumShouldMatch(minMatch: number): MatchQuery;

    /*
     Sets default operator of the Query.  Default: or.
     */
    operator(op: string): MatchQuery;

    /*
     Sets the prefix length for a fuzzy prefix MatchQuery.
     */
    prefixLength(l: number): MatchQuery;

    /*
     Sets the query string for the Query.
     */
    query(qstr: string): MatchQuery;

    /*
     Sets rewrite method.  Valid values are:

     constant_score_auto - tries to pick the best constant-score rewrite
     method based on term and document counts from the query

     scoring_boolean - translates each term into boolean should and
     keeps the scores as computed by the query

     constant_score_boolean - same as scoring_boolean, expect no scores
     are computed.

     constant_score_filter - first creates a private Filter, by visiting
     each term in sequence and marking all docs for that term

     top_terms_boost_N - first translates each term into boolean should
     and scores are only computed as the boost using the top N
     scoring terms.  Replace N with an integer value.

     top_terms_N -   first translates each term into boolean should
     and keeps the scores as computed by the query. Only the top N
     scoring terms are used.  Replace N with an integer value.

     Default is constant_score_auto.

     This is an advanced option, use with care.
     */
    rewrite(m: string): MatchQuery;

    /*
     Sets the default slop for phrases. If zero, then exact phrase matches
     are required.  Default: 0.
     */
    slop(slop: number): MatchQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the type of the MatchQuery.  Valid values are
     boolean, phrase, and phrase_prefix.
     */
    type(type: string): MatchQuery;

    /*
     Sets what happens when no terms match.  Valid values are
     "all" or "none".
     */
    zeroTermsQuery(q: string): MatchQuery;

  }


  /*
   A single-value metrics aggregation that keeps track and returns the
   maximum value among the numeric values extracted from the aggregated
   documents. These values can be extracted either from specific numeric fields
   in the documents, or be generated by a provided script.
   */
  export class MaxAggregation implements Aggregation {

    /*
     Aggregation that keeps track and returns the maximum value among the
     numeric values extracted from the aggregated documents.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the field to operate on.
     */
    field(field: string): MaxAggregation;

    /*
     The script language being used.
     */
    lang(language: string): MaxAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): MaxAggregation;

    /*
     Allows you generate or modify the terms/values using a script.
     */
    script(scriptCode: string): MaxAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): MaxAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }

  export class MetricsAggregationMixin implements Aggregation {


    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the field to operate on.
     */
    field(field: string): MetricsAggregationMixin;

    /*
     The script language being used.
     */
    lang(language: string): MetricsAggregationMixin;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): MetricsAggregationMixin;

    /*
     Allows you generate or modify the terms/values using a script.
     */
    script(scriptCode: string): MetricsAggregationMixin;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): MetricsAggregationMixin;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A single-value metrics aggregation that keeps track and returns the
   minimum value among numeric values extracted from the aggregated documents.
   These values can be extracted either from specific numeric fields in the
   documents, or be generated by a provided script.
   */
  export class MinAggregation implements Aggregation {

    /*
     Aggregation that keeps track and returns the minimum value among numeric
     values extracted from the aggregated documents.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the field to operate on.
     */
    field(field: string): MinAggregation;

    /*
     The script language being used.
     */
    lang(language: string): MinAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): MinAggregation;

    /*
     Allows you generate or modify the terms/values using a script.
     */
    script(scriptCode: string): MinAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): MinAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A field data based single bucket aggregation, that creates a bucket of all
   documents in the current document set context that are missing a field value
   (effectively, missing a field or having the configured NULL value set).
   */
  export class MissingAggregation implements Aggregation {

    /*
     Defines a bucket of all documents that are missing a field value.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): MissingAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): MissingAggregation;

    /*
     Sets the field to gather missing terms from.
     */
    field(field: string): MissingAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   An missingFilter matches documents where the specified field contains no legitimate value.
   */
  export class MissingFilter implements Filter {

    /*
     Filters documents where a specific field has no value present.
     */
    constructor(fieldName: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): MissingFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): MissingFilter;

    /*
     Checks if the field doesn't exist.
     */
    existence(trueFalse: boolean): MissingFilter;

    /*
     Sets the field to check for missing values.
     */
    field(name: string): MissingFilter;

    /*
     Sets the filter name.
     */
    name(name: string): MissingFilter;

    /*
     Checks if the field has null values.
     */
    nullValue(trueFalse: boolean): MissingFilter;

    /*
     Returns the filter object.
     */
    toJSON(): MissingFilter;

  }


  /*
   The more_like_this_field query is the same as the more_like_this query,
   except it runs against a single field.
   */
  export class MoreLikeThisFieldQuery implements Query {

    /*
     Constructs a query where each documents returned are “like” provided text
     */
    constructor(field: string, likeText: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     The analyzer that will be used to analyze the text. Defaults to the
     analyzer associated with the field.
     */
    analyzer(analyzerName: string): MoreLikeThisFieldQuery;

    /*
     Sets the boost value of the Query.
     */
    boost(boost: number): MoreLikeThisFieldQuery;

    /*
     Sets the boost factor to use when boosting terms.
     Defaults to 1.
     */
    boostTerms(boost: number): MoreLikeThisFieldQuery;

    /*
     Should the Query fail when an unsupported field
     is specified. Defaults to true.
     */
    failOnUnsupportedField(trueFalse: boolean): MoreLikeThisFieldQuery;

    /*
     The field to run the query against.
     */
    field(f: string): MoreLikeThisFieldQuery;

    /*
     The text to find documents like
     */
    likeText(s: string): MoreLikeThisFieldQuery;

    /*
     The maximum frequency in which words may still appear. Words that
     appear in more than this many docs will be ignored.
     Defaults to unbounded.
     */
    maxDocFreq(max: number): MoreLikeThisFieldQuery;

    /*
     The maximum number of query terms that will be included in any
     generated query. Defaults to 25.
     */
    maxQueryTerms(max: number): MoreLikeThisFieldQuery;

    /*
     The maximum word length above which words will be ignored.
     Defaults to unbounded (0).
     */
    maxWordLen(len: number): MoreLikeThisFieldQuery;

    /*
     The frequency at which words will be ignored which do not occur in
     at least this many docs. Defaults to 5.
     */
    minDocFreq(min: number): MoreLikeThisFieldQuery;

    /*
     The frequency below which terms will be ignored in the source doc.
     The default frequency is 2.
     */
    minTermFreq(freq: number): MoreLikeThisFieldQuery;

    /*
     The minimum word length below which words will be ignored.
     Defaults to 0.
     */
    minWordLen(len: number): MoreLikeThisFieldQuery;

    /*
     The percentage of terms to match on (float value).
     Defaults to 0.3 (30 percent).
     */
    percentTermsToMatch(percent: number): MoreLikeThisFieldQuery;

    /*
     An array of stop words. Any word in this set is considered
     “uninteresting” and ignored. Even if your Analyzer allows stopwords,
     you might want to tell the MoreLikeThis code to ignore them, as for
     the purposes of document similarity it seems reasonable to assume
     that “a stop word is never interesting”.
     */
    stopWords(stopWords: any[]): MoreLikeThisFieldQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   More like this query find documents that are “like” provided text by
   running it against one or more fields.
   */
  export class MoreLikeThisQuery implements Query {

    /*
     Constructs a query where each documents returned are “like” provided text
     */
    constructor(fields: string | string[], likeText: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     The analyzer that will be used to analyze the text. Defaults to the
     analyzer associated with the field.
     */
    analyzer(analyzerName: string): MoreLikeThisQuery;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): MoreLikeThisQuery;

    /*
     Sets the boost factor to use when boosting terms.
     Defaults to 1.
     */
    boostTerms(boost: number): MoreLikeThisQuery;

    /*
     Should the Query fail when an unsupported field
     is specified. Defaults to true.
     */
    failOnUnsupportedField(trueFalse: boolean): MoreLikeThisQuery;

    /*
     The fields to run the query against.  If you call with a single field,
     it is added to the existing list of fields.  If called with an array
     of field names, it replaces any existing values with the new array.
     */
    fields(f: string | string[]): MoreLikeThisQuery;

    /*
     The text to find documents like
     */
    likeText(s: string): MoreLikeThisQuery;

    /*
     The maximum frequency in which words may still appear. Words that
     appear in more than this many docs will be ignored.
     Defaults to unbounded.
     */
    maxDocFreq(max: number): MoreLikeThisQuery;

    /*
     The maximum number of query terms that will be included in any
     generated query. Defaults to 25.
     */
    maxQueryTerms(max: number): MoreLikeThisQuery;

    /*
     The maximum word length above which words will be ignored.
     Defaults to unbounded (0).
     */
    maxWordLen(len: number): MoreLikeThisQuery;

    /*
     The frequency at which words will be ignored which do not occur in
     at least this many docs. Defaults to 5.
     */
    minDocFreq(min: number): MoreLikeThisQuery;

    /*
     The frequency below which terms will be ignored in the source doc.
     The default frequency is 2.
     */
    minTermFreq(freq: number): MoreLikeThisQuery;

    /*
     The minimum word length below which words will be ignored.
     Defaults to 0.
     */
    minWordLen(len: number): MoreLikeThisQuery;

    /*
     The percentage of terms to match on (float value).
     Defaults to 0.3 (30 percent).
     */
    percentTermsToMatch(percent: number): MoreLikeThisQuery;

    /*
     An array of stop words. Any word in this set is considered
     “uninteresting” and ignored. Even if your Analyzer allows stopwords,
     you might want to tell the MoreLikeThis code to ignore them, as for
     the purposes of document similarity it seems reasonable to assume
     that “a stop word is never interesting”.
     */
    stopWords(stopWords: any[]): MoreLikeThisQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A MultiMatchQuery query builds further on top of the
   MatchQuery by allowing multiple fields to be specified.
   The idea here is to allow to more easily build a concise match type query
   over multiple fields instead of using a relatively more expressive query
   by using multiple match queries within a bool query.
   */
  export class MultiMatchQuery implements Query {

    /*
     A Query that allow to more easily build a MatchQuery
     over multiple fields
     */
    constructor(fields: string | string[], qstr: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the analyzer name used to analyze the Query object.
     */
    analyzer(analyzer: string): MultiMatchQuery;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): MultiMatchQuery;

    /*
     Sets the maximum threshold/frequency to be considered a low
     frequency term in a CommonTermsQuery.
     Set to a value between 0 and 1.
     */
    cutoffFrequency(freq: Number): MultiMatchQuery;

    /*
     Sets the fields to search across.  If passed a single value it is
     added to the existing list of fields.  If passed an array of
     values, they overwite all existing values.
     */
    fields(f: string | string[]): MultiMatchQuery;

    /*
     Sets the fuzziness value for the Query.
     */
    fuzziness(fuzz: number): MultiMatchQuery;

    /*
     Sets fuzzy rewrite method.  Valid values are:

     constant_score_auto - tries to pick the best constant-score rewrite
     method based on term and document counts from the query

     scoring_boolean - translates each term into boolean should and
     keeps the scores as computed by the query

     constant_score_boolean - same as scoring_boolean, expect no scores
     are computed.

     constant_score_filter - first creates a private Filter, by visiting
     each term in sequence and marking all docs for that term

     top_terms_boost_N - first translates each term into boolean should
     and scores are only computed as the boost using the top N
     scoring terms.  Replace N with an integer value.

     top_terms_N -   first translates each term into boolean should
     and keeps the scores as computed by the query. Only the top N
     scoring terms are used.  Replace N with an integer value.

     Default is constant_score_auto.

     This is an advanced option, use with care.
     */
    fuzzyRewrite(m: string): MultiMatchQuery;

    /*
     Enables lenient parsing of the query string.
     */
    lenient(trueFalse: boolean): MultiMatchQuery;

    /*
     Sets the max expansions of a fuzzy Query.
     */
    maxExpansions(e: number): MultiMatchQuery;

    /*
     Sets a percent value controlling how many "should" clauses in the
     resulting Query should match.
     */
    minimumShouldMatch(minMatch: number): MultiMatchQuery;

    /*
     Sets default operator of the Query.  Default: or.
     */
    operator(op: string): MultiMatchQuery;

    /*
     Sets the prefix length for a fuzzy prefix Query.
     */
    prefixLength(l: number): MultiMatchQuery;

    /*
     Sets the query string for the Query.
     */
    query(qstr: string): MultiMatchQuery;

    /*
     Sets rewrite method.  Valid values are:

     constant_score_auto - tries to pick the best constant-score rewrite
     method based on term and document counts from the query

     scoring_boolean - translates each term into boolean should and
     keeps the scores as computed by the query

     constant_score_boolean - same as scoring_boolean, expect no scores
     are computed.

     constant_score_filter - first creates a private Filter, by visiting
     each term in sequence and marking all docs for that term

     top_terms_boost_N - first translates each term into boolean should
     and scores are only computed as the boost using the top N
     scoring terms.  Replace N with an integer value.

     top_terms_N -   first translates each term into boolean should
     and keeps the scores as computed by the query. Only the top N
     scoring terms are used.  Replace N with an integer value.

     Default is constant_score_auto.

     This is an advanced option, use with care.
     */
    rewrite(m: string): MultiMatchQuery;

    /*
     Sets the default slop for phrases. If zero, then exact phrase matches
     are required.  Default: 0.
     */
    slop(slop: number): MultiMatchQuery;

    /*
     The tie breaker value.  The tie breaker capability allows results
     that include the same term in multiple fields to be judged better than
     results that include this term in only the best of those multiple
     fields, without confusing this with the better case of two different
     terms in the multiple fields.  Default: 0.0.
     */
    tieBreaker(tieBreaker: number): MultiMatchQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the type of the MultiMatchQuery.  Valid values are
     boolean, phrase, and phrase_prefix or phrasePrefix.
     */
    type(type: string): MultiMatchQuery;

    /*
     Sets whether or not queries against multiple fields should be combined using Lucene's

     DisjunctionMaxQuery
     */
    useDisMax(trueFalse: string): MultiMatchQuery;

    /*
     Sets what happens when no terms match.  Valid values are
     "all" or "none".
     */
    zeroTermsQuery(q: string): MultiMatchQuery;

  }


  /*
   A special single bucket aggregation that enables aggregating nested
   documents.
   */
  export class NestedAggregation implements Aggregation {

    /*
     A special single bucket aggregation that enables aggregating nested
     documents.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): NestedAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): NestedAggregation;

    /*
     Sets the nested path.
     */
    path(path: string): NestedAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Nested filters allow you to search against content within objects that are
   embedded inside of other objects. It is similar to XPath
   expressions in XML both conceptually and syntactically.


   The filter is executed against the nested objects / docs as if they were
   indexed as separate docs and resulting in the root
   parent doc (or parent nested mapping).
   */
  export class NestedFilter implements Filter {

    /*
     Constructs a filter that is capable of executing a filter against objects
     nested within a document.
     */
    constructor(path: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value of the nested Query.
     */
    boost(boost: number): NestedFilter;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): NestedFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): NestedFilter;

    /*
     Sets the nested filter to be executed.
     */
    filter(oFilter: Object): NestedFilter;

    /*
     If the nested query should be "joined" with the parent document.
     Defaults to false.
     */
    join(trueFalse: boolean): NestedFilter;

    /*
     Sets the filter name.
     */
    name(name: string): NestedFilter;

    /*
     Sets the root context for the nested filter.
     */
    path(p: string): NestedFilter;

    /*
     Sets the nested query to be executed.
     */
    query(oQuery: Query): NestedFilter;

    /*
     Sets the scope of the filter.  A scope allows to run facets on the
     same scope name that will work against the nested documents.
     */
    scope(s: string): NestedFilter;

    /*
     Returns the filter object.
     */
    toJSON(): NestedFilter;

  }


  /*
   Nested queries allow you to search against content within objects that are
   embedded inside of other objects. It is similar to XPath expressions
   in XML both conceptually and syntactically.

   The query is executed against the nested objects / docs as if they were
   indexed as separate docs and resulting in the rootparent doc (or parent
   nested mapping).
   */
  export class NestedQuery implements Query {

    /*
     Constructs a query that is capable of executing a search against objects
     nested within a document.
     */
    constructor(path: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): NestedQuery;

    /*
     Sets the nested filter to be executed.
     */
    filter(oFilter: Object): NestedQuery;

    /*
     Sets the root context for the nested query.
     */
    path(path: string): NestedQuery;

    /*
     Sets the nested query to be executed.
     */
    query(oQuery: Object): NestedQuery;

    /*
     Sets the scope of the query.  A scope allows to run facets on the
     same scope name that will work against the nested documents.
     */
    scope(s: string): NestedQuery;

    /*
     Sets how the inner (nested) matches affect scoring on the parent document.
     */
    scoreMode(mode: string): NestedQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A container Filter that excludes the documents matched by the
   contained filter.
   */
  export class NotFilter implements Filter {

    /*
     Container filter that excludes the matched documents of the contained filter.
     */
    constructor(oFilter: Object);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): NotFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): NotFilter;

    /*
     Sets the filter
     */
    filter(fltr: Object): NotFilter;

    /*
     Sets the filter name.
     */
    name(name: string): NotFilter;

    /*
     Returns the filter object.
     */
    toJSON(): NotFilter;

  }


  /*
   Filters documents with fields that have values within a certain numeric
   range. Similar to range filter, except that it works only with numeric
   values, and the filter execution works differently.

   The numeric range filter works by loading all the relevant field values
   into memory, and checking for the relevant docs if they satisfy the range
   requirements. This requires more memory since the numeric range data are
   loaded to memory, but can provide a significant increase in performance.

   Note, if the relevant field values have already been loaded to memory,
   for example because it was used in facets or was sorted on, then this
   filter should be used.
   */
  export class NumericRangeFilter implements Filter {

    /*
     A Filter that only accepts numeric values within a specified range.
     */
    constructor(fieldName: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): NumericRangeFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): NumericRangeFilter;

    /*
     Returns the field name used to create this object.
     */
    field(field: string): NumericRangeFilter;

    /*
     Sets the endpoint for the current range.
     */
    from(startPoint: Number): NumericRangeFilter;

    /*
     Greater than value.  Same as setting from to the value, and
     include_lower to false,
     */
    gt(val: any): NumericRangeFilter;

    /*
     Greater than or equal to value.  Same as setting from to the value,
     and include_lower to true.
     */
    gte(val: any): NumericRangeFilter;

    /*
     Should the first from (if set) be inclusive or not.
     Defaults to true
     */
    includeLower(trueFalse: boolean): NumericRangeFilter;

    /*
     Should the last to (if set) be inclusive or not. Defaults to true.
     */
    includeUpper(trueFalse: boolean): NumericRangeFilter;

    /*
     Less than value.  Same as setting to to the value, and include_upper
     to false.
     */
    lt(val: any): NumericRangeFilter;

    /*
     Less than or equal to value.  Same as setting to to the value,
     and include_upper to true.
     */
    lte(val: any): NumericRangeFilter;

    /*
     Sets the filter name.
     */
    name(name: string): NumericRangeFilter;

    /*
     Sets the endpoint for the current range.
     */
    to(endPoint: Number): NumericRangeFilter;

    /*
     Returns the filter object.
     */
    toJSON(): NumericRangeFilter;

  }


  /*
   A container filter that allows Boolean OR composition of filters.
   */
  export class OrFilter implements Filter {

    /*
     A container Filter that allows Boolean OR composition of filters.
     */
    constructor(filters: Filter | Filter[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): OrFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): OrFilter;

    /*
     Updates the filters.  If passed a single Filter it is added to
     the existing filters.  If passed an array of Filters, they
     replace all existing Filters.
     */
    filters(fltr: Filter | Filter[]): OrFilter;

    /*
     Sets the filter name.
     */
    name(name: string): OrFilter;

    /*
     Returns the filter object.
     */
    toJSON(): OrFilter;

  }


  /*
   A multi-value metrics aggregation that calculates one or more percentiles
   over numeric values extracted from the aggregated documents. These values can
   be extracted either from specific numeric fields in the documents, or be
   generated by a provided script.
   */
  export class PercentilesAggregation implements Aggregation {

    /*
     Aggregation that calculates one or more percentiles over numeric values
     extracted from the aggregated documents.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Compression controls memory usage and approximation error. The compression
     value limits the maximum number of nodes to 100 * compression.  By
     increasing the compression value, you can increase the accuracy of your
     percentiles at the cost of more memory. Larger compression values also make
     the algorithm slower since the underlying tree data structure grows in
     size, resulting in more expensive operations. The default compression
     value is 100.
     */
    compression(c: number): PercentilesAggregation;

    /*
     Sets the field to operate on.
     */
    field(field: string): PercentilesAggregation;

    /*
     Enable the response to be returned as a keyed object where the key is the
     bucket interval.
     */
    keyed(trueFalse: boolean): PercentilesAggregation;

    /*
     The script language being used.
     */
    lang(language: string): PercentilesAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): PercentilesAggregation;

    /*
     Add a single percentile to the current list of percentiles.
     */
    percent(percentile: number): PercentilesAggregation;

    /*
     Sets the percentile bucket array.  Overwrites all existing values.
     */
    percents(percents: number[]): PercentilesAggregation;

    /*
     Allows you generate or modify the terms/values using a script.
     */
    script(scriptCode: string): PercentilesAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): PercentilesAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   PhraseSuggester extends the PhraseSuggester and suggests
   entire corrected phrases instead of individual tokens.  The individual
   phrase suggestions are weighted based on ngram-langugage models. In practice
   it will be able to make better decision about which tokens to pick based on
   co-occurence and frequencies.
   */
  export class PhraseSuggester implements Suggest {

    /*
     A suggester that suggests entire corrected phrases.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets analyzer used to analyze the suggest text.
     */
    analyzer(analyzer: string): PhraseSuggester;

    /*
     Sets the confidence level defines a factor applied to the input
     phrases score which is used as a threshold for other suggest
     candidates. Only candidates that score higher than the threshold
     will be included in the result.
     */
    confidence(c: number): PhraseSuggester;

    /*
     Adds a direct generator. If passed a single Generator
     it is added to the list of existing generators.  If passed an
     array of Generators, they replace all existing generators.
     */
    directGenerator(oGenerator: Generator | Generator[]): PhraseSuggester;

    /*
     Sets the field used to generate suggestions from.
     */
    field(field: string): PhraseSuggester;

    /*
     Forces the use of unigrams.
     */
    forceUnigrams(trueFalse: boolean): PhraseSuggester;

    /*
     Sets the max size of the n-grams (shingles) in the field. If
     the field doesn't contain n-grams (shingles) this should be
     omitted or set to 1.
     */
    gramSize(s: number): PhraseSuggester;

    /*
     Enables highlighting of suggestions
     */
    highlight(preTag: string, postTag: string): PhraseSuggester;

    /*
     A smoothing model that uses an additive smoothing model where a
     constant (typically 1.0 or smaller) is added to all counts to
     balance weights, The default alpha is 0.5.
     */
    laplaceSmoothing(alpha: number): PhraseSuggester;

    /*
     A smoothing model that takes the weighted mean of the unigrams,
     bigrams and trigrams based on user supplied weights (lambdas). The
     sum of tl, bl, and ul must equal 1.
     */
    linearSmoothing(tl: number, bl: number, ul: number): PhraseSuggester;

    /*
     Sets the maximum percentage of the terms that at most
     considered to be misspellings in order to form a correction.
     */
    maxErrors(c: number): PhraseSuggester;

    /*
     Sets the likelihood of a term being a misspelled even if the
     term exists in the dictionary. The default it 0.95 corresponding
     to 5% or the real words are misspelled.
     */
    realWordErrorLikelihood(l: number): PhraseSuggester;

    /*
     Sets the separator that is used to separate terms in the bigram
     field. If not set the whitespce character is used as a
     separator.
     */
    separator(sep: string): PhraseSuggester;

    /*
     Sets the maximum number of suggestions to be retrieved from
     each individual shard.
     */
    shardSize(s: number): PhraseSuggester;

    /*
     Sets the number of suggestions returned for each token.
     */
    size(s: number): PhraseSuggester;

    /*
     A simple backoff model that backs off to lower order n-gram
     models if the higher order count is 0 and discounts the lower
     order n-gram model by a constant factor. The default discount is
     0.4.
     */
    stupidBackoffSmoothing(discount: number): PhraseSuggester;

    /*
     Sets the text to get suggestions for.  If not set, the global
     suggestion text will be used.
     */
    text(txt: string): PhraseSuggester;

    /*
     Retrieves the internal suggest object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the token limit.
     */
    tokenLimit(l: number): PhraseSuggester;

  }


  /*
   Filters documents that have fields containing terms with a specified prefix (not analyzed). Similar
   to phrase query, except that it acts as a filter. Can be placed within queries that accept a filter.
   */
  export class PrefixFilter implements Filter {

    /*
     Filters documents that have fields containing terms with a specified prefix.
     */
    constructor(fieldName: string, prefix: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): PrefixFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): PrefixFilter;

    /*
     Returns the field name used to create this object.
     */
    field(field: string): PrefixFilter;

    /*
     Sets the filter name.
     */
    name(name: string): PrefixFilter;

    /*
     Sets the prefix to search for.
     */
    prefix(value: string): PrefixFilter;

    /*
     Returns the filter object.
     */
    toJSON(): PrefixFilter;

  }


  /*
   Matches documents that have fields containing terms with a specified
   prefix (not analyzed). The prefix query maps to Lucene PrefixQuery.
   */
  export class PrefixQuery implements Query {

    /*
     Matches documents containing the specified un-analyzed prefix.
     */
    constructor(field: string, value: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value of the Query.
     */
    boost(boost: number): PrefixQuery;

    /*
     The field to run the query against.
     */
    field(f: string): PrefixQuery;

    /*
     Sets rewrite method.  Valid values are:

     constant_score_auto - tries to pick the best constant-score rewrite
     method based on term and document counts from the query

     scoring_boolean - translates each term into boolean should and
     keeps the scores as computed by the query

     constant_score_boolean - same as scoring_boolean, expect no scores
     are computed.

     constant_score_filter - first creates a private Filter, by visiting
     each term in sequence and marking all docs for that term

     top_terms_boost_N - first translates each term into boolean should
     and scores are only computed as the boost using the top N
     scoring terms.  Replace N with an integer value.

     top_terms_N -   first translates each term into boolean should
     and keeps the scores as computed by the query. Only the top N
     scoring terms are used.  Replace N with an integer value.

     Default is constant_score_auto.

     This is an advanced option, use with care.
     */
    rewrite(m: string): PrefixQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     The prefix value.
     */
    value(p: string): PrefixQuery;

  }


  /*
   The QueryFacet facet allows you to specify any valid Query and
   have the number of matching hits returned as the value.

   Facets are similar to SQL GROUP BY statements but perform much
   better. You can also construct several "groups" at once by simply
   specifying multiple facets.



   Tip:
   For more information on faceted navigation, see
   this
   Wikipedia article on Faceted Classification.


   */
  export class QueryFacet implements Facet {

    /*
     A facet that return a count of the hits matching the given query.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enables caching of the facetFilter
     */
    cacheFilter(trueFalse: boolean): QueryFacet;

    /*
     Allows you to reduce the documents used for computing facet results.
     */
    facetFilter(oFilter: Object): QueryFacet;

    /*
     Computes values across the entire index
     */
    global(trueFalse: boolean): QueryFacet;

    /*
     Sets the mode the facet will use.


     collector
     post

     */
    mode(m: string): QueryFacet;

    /*
     Sets the path to the nested document if faceting against a
     nested field.
     */
    nested(path: string): QueryFacet;

    /*
     Sets the query to be used for this facet.
     */
    query(oQuery: Object): QueryFacet;

    /*
     Computes values across the the specified scope
     */
    scope(scope: string): QueryFacet;

    /*
     Retrieves the internal facet object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Wraps any query to be used as a filter. Can be placed within queries
   that accept a filter.

   The result of the filter is not cached by default.  Set the cache
   parameter to true to cache the result of the filter. This is handy when the
   same query is used on several (many) other queries.

   Note, the process of caching the first execution is higher when not
   caching (since it needs to satisfy different queries).
   */
  export class QueryFilter implements Filter {

    /*
     Filters documents matching the wrapped query.
     */
    constructor(qry: Object);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): QueryFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): QueryFilter;

    /*
     Sets the filter name.
     */
    name(name: string): QueryFilter;

    /*
     Sets the query
     */
    query(q: Object): QueryFilter;

    /*
     Returns the filter object.
     */
    toJSON(): QueryFilter;

  }

  export class QueryMixin {


    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): QueryMixin;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A query that is parsed using Lucene's default query parser. Although Lucene provides the
   ability to create your own queries through its API, it also provides a rich query language
   through the Query Parser, a lexer which interprets a string into a Lucene Query.

   See the Lucene Query Parser Syntax
   for more information.
   */
  export class QueryStringQuery implements Query {

    /*
     A query that is parsed using Lucene's default query parser.
     */
    constructor(qstr: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets whether or not wildcard characters (* and ?) are allowed as the
     first character of the Query.  Default: true.
     */
    allowLeadingWildcard(trueFalse: boolean): QueryStringQuery;

    /*
     Sets the analyzer name used to analyze the Query object.
     */
    analyzer(analyzer: string): QueryStringQuery;

    /*
     Sets whether or not we should attempt to analyzed wilcard terms in the
     Query. By default, wildcard terms are not analyzed.
     Analysis of wildcard characters is not perfect.  Default: false.
     */
    analyzeWildcard(trueFalse: boolean): QueryStringQuery;

    /*
     Sets whether or not we should auto generate phrase queries *if* the
     analyzer returns more than one term. Default: false.
     */
    autoGeneratePhraseQueries(trueFalse: boolean): QueryStringQuery;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): QueryStringQuery;

    /*
     Sets the default field/property this query should execute against.
     */
    defaultField(fieldName: string): QueryStringQuery;

    /*
     Set the default Boolean operator. This operator is used to join individual query
     terms when no operator is explicity used in the query string (i.e., this AND that).
     Defaults to OR.
     */
    defaultOperator(op: string): QueryStringQuery;

    /*
     Sets whether or not position increments will be used in the
     Query. Default: true.
     */
    enablePositionIncrements(trueFalse: boolean): QueryStringQuery;

    /*
     If they query string should be escaped or not.
     */
    escape(trueFalse: boolean): QueryStringQuery;

    /*
     A set of fields/properties this query should execute against.
     Pass a single value to add to the existing list of fields and
     pass an array to overwrite all existing fields.  For each field,
     you can apply a field specific boost by appending a ^boost to the
     field name.  For example, title^10, to give the title field a
     boost of 10.
     */
    fields(fieldNames: any[]): QueryStringQuery;

    /*
     Sets the max number of term expansions for fuzzy queries.
     */
    fuzzyMaxExpansions(max: number): QueryStringQuery;

    /*
     Set the minimum similarity for fuzzy queries.  Default: 0.5.
     */
    fuzzyMinSim(minSim: number): QueryStringQuery;

    /*
     Sets the prefix length for fuzzy queries.  Default: 0.
     */
    fuzzyPrefixLength(fuzzLen: number): QueryStringQuery;

    /*
     Sets fuzzy rewrite method.  Valid values are:

     constant_score_auto - tries to pick the best constant-score rewrite
     method based on term and document counts from the query

     scoring_boolean - translates each term into boolean should and
     keeps the scores as computed by the query

     constant_score_boolean - same as scoring_boolean, expect no scores
     are computed.

     constant_score_filter - first creates a private Filter, by visiting
     each term in sequence and marking all docs for that term

     top_terms_boost_N - first translates each term into boolean should
     and scores are only computed as the boost using the top N
     scoring terms.  Replace N with an integer value.

     top_terms_N -   first translates each term into boolean should
     and keeps the scores as computed by the query. Only the top N
     scoring terms are used.  Replace N with an integer value.

     Default is constant_score_auto.

     This is an advanced option, use with care.
     */
    fuzzyRewrite(m: string): QueryStringQuery;

    /*
     Enables lenient parsing of the query string.
     */
    lenient(trueFalse: boolean): QueryStringQuery;

    /*
     Sets whether or not terms from wildcard, prefix, fuzzy, and
     range queries should automatically be lowercased in the Query
     since they are not analyzed.  Default: true.
     */
    lowercaseExpandedTerms(trueFalse: boolean): QueryStringQuery;

    /*
     Sets a percent value controlling how many "should" clauses in the
     resulting Query should match.
     */
    minimumShouldMatch(minMatch: number): QueryStringQuery;

    /*
     Sets the default slop for phrases. If zero, then exact phrase matches
     are required.  Default: 0.
     */
    phraseSlop(slop: number): QueryStringQuery;

    /*
     Sets the query string on this Query object.
     */
    query(qstr: string): QueryStringQuery;

    /*
     Sets the quote analyzer name used to analyze the query
     when in quoted text.
     */
    quoteAnalyzer(analyzer: string): QueryStringQuery;

    /*
     Sets the suffix to automatically add to the field name when
     performing a quoted search.
     */
    quoteFieldSuffix(s: string): QueryStringQuery;

    /*
     Sets rewrite method.  Valid values are:

     constant_score_auto - tries to pick the best constant-score rewrite
     method based on term and document counts from the query

     scoring_boolean - translates each term into boolean should and
     keeps the scores as computed by the query

     constant_score_boolean - same as scoring_boolean, expect no scores
     are computed.

     constant_score_filter - first creates a private Filter, by visiting
     each term in sequence and marking all docs for that term

     top_terms_boost_N - first translates each term into boolean should
     and scores are only computed as the boost using the top N
     scoring terms.  Replace N with an integer value.

     top_terms_N -   first translates each term into boolean should
     and keeps the scores as computed by the query. Only the top N
     scoring terms are used.  Replace N with an integer value.

     Default is constant_score_auto.

     This is an advanced option, use with care.
     */
    rewrite(m: string): QueryStringQuery;

    /*
     Sets the tie breaker value for a Query using
     DisMax.  The tie breaker capability allows results
     that include the same term in multiple fields to be judged better than
     results that include this term in only the best of those multiple
     fields, without confusing this with the better case of two different
     terms in the multiple fields.  Default: 0.0.
     */
    tieBreaker(tieBreaker: number): QueryStringQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets whether or not queries against multiple fields should be combined using Lucene's

     DisjunctionMaxQuery
     */
    useDisMax(trueFalse: string): QueryStringQuery;

  }


  /*
   The random_score generates scores via a pseudo random number algorithm
   that is initialized with a seed.
   */
  export class RandomScoreFunction  implements ScoreFunction {

    /*
     Randomly score documents.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Adds a filter whose matching documents will have the score function applied.
     */
    filter(oFilter: Filter): RandomScoreFunction;

    /*
     Sets random seed value.
     */
    seed(s: number): RandomScoreFunction;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A multi-bucket value source based aggregation that enables the user to
   define a set of ranges - each representing a bucket. During the aggregation
   process, the values extracted from each document will be checked against each
   bucket range and "bucket" the relevant/matching document.

   Note that this aggregration includes the from value and excludes the to
   value for each range.
   */
  export class RangeAggregation implements Aggregation {

    /*
     Aggregation that enables the user to define a set of ranges that each
     represent a bucket.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): RangeAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): RangeAggregation;

    /*
     Sets the field to gather terms from.
     */
    field(field: string): RangeAggregation;

    /*
     Enable the response to be returned as a keyed object where the key is the
     bucket interval.
     */
    keyed(trueFalse: boolean): RangeAggregation;

    /*
     The script language being used.
     */
    lang(language: string): RangeAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): RangeAggregation;

    /*
     Adds a range to the list of exsiting range expressions.
     */
    range(from: number, to?: number, key?: string): RangeAggregation;

    /*
     Allows you generate or modify the terms using a script.
     */
    script(scriptCode: string): RangeAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): RangeAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A RangeFacet allows you to specify a set of ranges and get both the number of docs (count) that
   fall within each range, and aggregated data based on the field, or another specified field.

   Facets are similar to SQL GROUP BY statements but perform much
   better. You can also construct several "groups" at once by simply
   specifying multiple facets.



   Tip:
   For more information on faceted navigation, see
   this
   Wikipedia article on Faceted Classification.


   */
  export class RangeFacet implements Facet {

    /*
     A facet which provides information over a range of numeric intervals.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Adds a new bounded range.
     */
    addRange(from: Number, to: Number): RangeFacet;

    /*
     Adds a new unbounded lower limit.
     */
    addUnboundedFrom(from: Number): RangeFacet;

    /*
     Adds a new unbounded upper limit.
     */
    addUnboundedTo(to: Number): RangeFacet;

    /*
     Enables caching of the facetFilter
     */
    cacheFilter(trueFalse: boolean): RangeFacet;

    /*
     Allows you to reduce the documents used for computing facet results.
     */
    facetFilter(oFilter: Object): RangeFacet;

    /*
     Sets the document field to be used for the facet.
     */
    field(fieldName: string): RangeFacet;

    /*
     Computes values across the entire index
     */
    global(trueFalse: boolean): RangeFacet;

    /*
     Allows you to specify an alternate key field to be used to compute the interval.
     */
    keyField(fieldName: string): RangeFacet;

    /*
     Allows you modify the key field using a script. The modified value
     is then used to generate the interval.
     */
    keyScript(scriptCode: string): RangeFacet;

    /*
     The script language being used. Currently supported values are
     javascript, groovy, and mvel.
     */
    lang(language: string): RangeFacet;

    /*
     Sets the mode the facet will use.


     collector
     post

     */
    mode(m: string): RangeFacet;

    /*
     Sets the path to the nested document if faceting against a
     nested field.
     */
    nested(path: string): RangeFacet;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): RangeFacet;

    /*
     Computes values across the the specified scope
     */
    scope(scope: string): RangeFacet;

    /*
     Retrieves the internal facet object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Allows you to specify an alternate value field to be used to compute statistical information.
     */
    valueField(fieldName: string): RangeFacet;

    /*
     Allows you modify the value field using a script. The modified value
     is then used to compute the statistical data.
     */
    valueScript(scriptCode: string): RangeFacet;

  }


  /*
   Matches documents with fields that have terms within a certain range.
   */
  export class RangeFilter implements Filter {

    /*
     Filters documents with fields that have terms within a certain range.
     */
    constructor(field: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): RangeFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): RangeFilter;

    /*
     The field to run the filter against.
     */
    field(f: string): RangeFilter;

    /*
     The lower bound. Defaults to start from the first.
     */
    from(f: any): RangeFilter;

    /*
     Greater than value.  Same as setting from to the value, and
     include_lower to false,
     */
    gt(val: any): RangeFilter;

    /*
     Greater than or equal to value.  Same as setting from to the value,
     and include_lower to true.
     */
    gte(val: any): RangeFilter;

    /*
     Should the first from (if set) be inclusive or not.
     Defaults to true
     */
    includeLower(trueFalse: boolean): RangeFilter;

    /*
     Should the last to (if set) be inclusive or not. Defaults to true.
     */
    includeUpper(trueFalse: boolean): RangeFilter;

    /*
     Less than value.  Same as setting to to the value, and include_upper
     to false.
     */
    lt(val: any): RangeFilter;

    /*
     Less than or equal to value.  Same as setting to to the value,
     and include_upper to true.
     */
    lte(val: any): RangeFilter;

    /*
     Sets the filter name.
     */
    name(name: string): RangeFilter;

    /*
     The upper bound. Defaults to unbounded.
     */
    to(t: any): RangeFilter;

    /*
     Returns the filter object.
     */
    toJSON(): RangeFilter;

  }


  /*
   Matches documents with fields that have terms within a certain range.
   The type of the Lucene query depends on the field type, for string fields,
   the TermRangeQuery, while for number/date fields, the query is a
   NumericRangeQuery.
   */
  export class RangeQuery implements Query {

    /*
     Matches documents with fields that have terms within a certain range.
     */
    constructor(field: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value of the Query.
     */
    boost(boost: number): RangeQuery;

    /*
     The field to run the query against.
     */
    field(f: string): RangeQuery;

    /*
     The lower bound. Defaults to start from the first.
     */
    from(f: any): RangeQuery;

    /*
     Greater than value.  Same as setting from to the value, and
     include_lower to false,
     */
    gt(val: any): RangeQuery;

    /*
     Greater than or equal to value.  Same as setting from to the value,
     and include_lower to true.
     */
    gte(val: any): RangeQuery;

    /*
     Should the first from (if set) be inclusive or not.
     Defaults to true
     */
    includeLower(trueFalse: boolean): RangeQuery;

    /*
     Should the last to (if set) be inclusive or not. Defaults to true.
     */
    includeUpper(trueFalse: boolean): RangeQuery;

    /*
     Less than value.  Same as setting to to the value, and include_upper
     to false.
     */
    lt(val: any): RangeQuery;

    /*
     Less than or equal to value.  Same as setting to to the value,
     and include_upper to true.
     */
    lte(val: any): RangeQuery;

    /*
     The upper bound. Defaults to unbounded.
     */
    to(t: any): RangeQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Filters documents that have a field value matching a regular expression.
   Based on Lucene 4.0 RegexpFilter which uses automaton to efficiently iterate
   over index terms.
   */
  export class RegexpFilter implements Filter {

    /*
     Matches documents that have fields matching a regular expression.
     */
    constructor(field: string, value: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): RegexpFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): RegexpFilter;

    /*
     The field to run the filter against.
     */
    field(f: string): RegexpFilter;

    /*
     The regex flags to use.  Valid flags are:

     INTERSECTION - Support for intersection notation
     COMPLEMENT - Support for complement notation
     EMPTY - Support for the empty language symbol: #
     ANYSTRING - Support for the any string symbol: @
     INTERVAL - Support for numerical interval notation:
     NONE - Disable support for all syntax options
     ALL - Enables support for all syntax options

     Use multiple flags by separating with a "|" character.  Example:

     INTERSECTION|COMPLEMENT|EMPTY
     */
    flags(f: string): RegexpFilter;

    /*
     The regex flags to use as a numeric value.  Advanced use only,
     it is probably better to stick with the flags option.
     */
    flagsValue(v: string): RegexpFilter;

    /*
     Sets the filter name.
     */
    name(name: string): RegexpFilter;

    /*
     Returns the filter object.
     */
    toJSON(): RegexpFilter;

    /*
     The regexp value.
     */
    value(p: string): RegexpFilter;

  }


  /*
   Matches documents that have fields matching a regular expression. Based
   on Lucene 4.0 RegexpQuery which uses automaton to efficiently iterate over
   index terms.
   */
  export class RegexpQuery implements Query {

    /*
     Matches documents that have fields matching a regular expression.
     */
    constructor(field: string, value: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value of the Query.
     */
    boost(boost: number): RegexpQuery;

    /*
     The field to run the query against.
     */
    field(f: string): RegexpQuery;

    /*
     The regex flags to use.  Valid flags are:

     INTERSECTION - Support for intersection notation
     COMPLEMENT - Support for complement notation
     EMPTY - Support for the empty language symbol: #
     ANYSTRING - Support for the any string symbol: @
     INTERVAL - Support for numerical interval notation:
     NONE - Disable support for all syntax options
     ALL - Enables support for all syntax options

     Use multiple flags by separating with a "|" character.  Example:

     INTERSECTION|COMPLEMENT|EMPTY
     */
    flags(f: string): RegexpQuery;

    /*
     The regex flags to use as a numeric value.  Advanced use only,
     it is probably better to stick with the flags option.
     */
    flagsValue(v: string): RegexpQuery;

    /*
     Sets rewrite method.  Valid values are:

     constant_score_auto - tries to pick the best constant-score rewrite
     method based on term and document counts from the query

     scoring_boolean - translates each term into boolean should and
     keeps the scores as computed by the query

     constant_score_boolean - same as scoring_boolean, expect no scores
     are computed.

     constant_score_filter - first creates a private Filter, by visiting
     each term in sequence and marking all docs for that term

     top_terms_boost_N - first translates each term into boolean should
     and scores are only computed as the boost using the top N
     scoring terms.  Replace N with an integer value.

     top_terms_N -   first translates each term into boolean should
     and keeps the scores as computed by the query. Only the top N
     scoring terms are used.  Replace N with an integer value.

     Default is constant_score_auto.

     This is an advanced option, use with care.
     */
    rewrite(m: string): RegexpQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     The regexp value.
     */
    value(p: string): RegexpQuery;

  }


  /*
   The Request object provides methods generating an elasticsearch request body.
   */
  export class Request {

    /*
     Provides methods for generating request bodies.
     */
    constructor(conf: Object);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add an aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations that will be executed
     at the same time as the search request.  Alias for the aggregation method.
     */
    agg(agg: Aggregation): Request;

    /*
     Add an aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations that will be executed
     at the same time as the search request.
     */
    aggregation(agg: Aggregation): Request;

    /*
     Enable/Disable explanation of score for each search result.
     */
    explain(trueFalse: boolean): Request;

    /*
     Allows you to set the specified facet on this request object. Multiple facets can
     be set, all of which will be returned when the search is executed.
     */
    facet(facet: Facet): Request;

    /*
     By default, searches return full documents, meaning every property or field.
     This method allows you to specify which fields you want returned.

     Pass a single field name and it is appended to the current list of
     fields.  Pass an array of fields and it replaces all existing
     fields.
     */
    fields(s: string | string[]): Request;

    /*
     Allows you to set a specified filter on this request object.
     */
    filter(filter: Object): Request;

    /*
     A search result set could be very large (think Google). Setting the
     from parameter allows you to page through the result set
     by making multiple request. This parameters specifies the starting
     result/document number point. Combine with size() to achieve paging.
     */
    from(f: number): Request;

    /*
     Performs highlighting based on the Highlight
     settings.
     */
    highlight(h: Highlight): Request;

    /*
     Boosts hits in the specified index by the given boost value.
     */
    indexBoost(index: string, boost: number): Request;

    /*
     Filters out search results will scores less than the specified minimum score.
     */
    minScore(min: number): Request;

    /*
     Allows you to set the specified query on this search object. This is the
     query that will be used when the search is executed.
     */
    query(someQuery: Query): Request;

    /*
     Once a query executes, you can use rescore to run a secondary, more
     expensive query to re-order the results.
     */
    rescore(r: Rescore): Request;

    /*
     Computes a document property dynamically based on the supplied ScriptField.
     */
    scriptField(oScriptField: ScriptField): Request;

    /*
     Sets the number of results/documents to be returned. This is set on a per page basis.
     */
    size(s: number): Request;

    /*
     Sets the sorting for the query.  This accepts many input formats.


     sort() - The current sorting values are returned.
     sort(fieldName) - Adds the field to the current list of sorting values.
     sort(fieldName, order) - Adds the field to the current list of
     sorting with the specified order.  Order must be asc or desc.
     sort(ejs.Sort) - Adds the Sort value to the current list of sorting values.
     sort(array) - Replaces all current sorting values with values
     from the array.  The array must contain only strings and Sort objects.


     Multi-level sorting is supported so the order in which sort fields
     are added to the query requests is relevant.

     It is recommended to use Sort objects when possible.
     */
    sort(fieldName?: string | any[] | Sort, order?: string): Request;

    /*
     Allows to control how the _source field is returned with every hit.
     By default operations return the contents of the _source field
     unless you have used the fields parameter or if the _source field
     is disabled.  Set the includes parameter to false to completely
     disable returning the source field.
     */
    source(includes: string | boolean | string[], excludes: string | string[]): Request;

    /*
     Allows you to set the specified suggester on this request object.
     Multiple suggesters can be set, all of which will be returned when
     the search is executed.  Global suggestion text can be set by
     passing in a string vs. a Suggest object.
     */
    suggest(s: string | Suggest): Request;

    /*
     A timeout, bounding the request to be executed within the
     specified time value and bail when expired. Defaults to no timeout.

     This option is valid during the following operations:
     search and delete by query
     */
    timeout(t: number): Request;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Enables score computation and tracking during sorting.  Be default,
     when sorting scores are not computed.
     */
    trackScores(trueFalse: boolean): Request;

    /*
     Enable/Disable returning version number for each search result.
     */
    version(trueFalse: boolean): Request;

  }


  /*
   A method that allows to rescore queries with a typically more expensive.
   */
  export class Rescore {

    /*
     Defines an operation that rescores a query with another query.
     */
    //constructor(windowSize: Number, windowSize: Query);
    constructor(windowSize: Number);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the weight assigned to the original query of the rescoring.
     */
    queryWeight(weight: Number): Rescore;

    /*
     Sets the query used by the rescoring.
     */
    rescoreQuery(someQuery: Query): Rescore;

    /*
     Sets the weight assigned to the query used to rescore the original query.
     */
    rescoreQueryWeight(weight: Number): Rescore;

    /*
     Sets the scoring mode.  Valid values are:

     total - default mode, the scores combined
     multiply - the scores multiplied
     min - the lowest of the scores
     max - the highest score
     avg - the average of the scores
     */
    scoreMode(s: string): Rescore;

    /*
     Retrieves the internal script object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the window_size parameter of the rescoring.
     */
    windowSize(size: Number): Rescore;

  }

  export class ScoreFunctionMixin  implements ScoreFunction {


    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Adds a filter whose matching documents will have the score function applied.
     */
    filter(oFilter: Filter): ScoreFunctionMixin;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   ScriptField's allow you create dynamic fields on stored documents at query
   time. For example, you might have a set of document thats containsthe fields
   price and quantity. At query time, you could define a computed
   property that dynamically creates a new field called totalin each document
   based on the calculation price * quantity.
   */
  export class ScriptField {

    /*
     Computes dynamic document properties based on information from other fields.
     */
    constructor(fieldName: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     If execeptions thrown from the script should be ignored or not.
     Default: false
     */
    ignoreFailure(trueFalse: boolean): ScriptField;

    /*
     The script language being used. Currently supported values are
     javascript and mvel.
     */
    lang(language: string): ScriptField;

    /*
     Allows you to set script parameters to be used during the execution of the script.
     */
    params(oParams: Object): ScriptField;

    /*
     Sets the script/code that will be used to perform the calculation.
     */
    script(expression: string): ScriptField;

    /*
     Retrieves the internal script object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A filter allowing to define scripts as filters
   */
  export class ScriptFilter implements Filter {

    /*
     A filter allowing to define scripts as filters.
     */
    constructor(script: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): ScriptFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): ScriptFilter;

    /*
     Sets the script language.
     */
    lang(lang: string): ScriptFilter;

    /*
     Sets the filter name.
     */
    name(name: string): ScriptFilter;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): ScriptFilter;

    /*
     Sets the script.
     */
    script(s: string): ScriptFilter;

    /*
     Returns the filter object.
     */
    toJSON(): ScriptFilter;

  }


  /*
   The script_score function allows you to wrap another query and customize
   the scoring of it optionally with a computation derived from other numeric
   field values in the doc using a script expression.
   */
  export class ScriptScoreFunction  implements ScoreFunction {

    /*
     Modify a documents score using a script.
     */
    constructor();

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Adds a filter whose matching documents will have the score function applied.
     */
    filter(oFilter: Filter): ScriptScoreFunction;

    /*
     The script language being used.
     */
    lang(language: string): ScriptScoreFunction;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): ScriptScoreFunction;

    /*
     Set the script that will modify the score.
     */
    script(scriptCode: string): ScriptScoreFunction;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A Shape object that can be used in queries and filters that
   take a Shape.  Shape uses the GeoJSON format.

   See http://www.geojson.org/
   */
  export class Shape implements Geo {

    /*
     Defines a shape
     */
    constructor(type: string, coords: any[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the coordinates for the shape definition.  Note, the coordinates
     are not validated in this api.  Please see GeoJSON and ElasticSearch
     documentation for correct coordinate definitions.
     */
    coordinates(c: any[]): Shape;

    /*
     Sets the radius for parsing a circle Shape.
     */
    radius(r: string): Shape;

    /*
     Retrieves the internal script object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the shape type.  Can be set to one of:  point, linestring, polygon,
     multipoint, envelope, or multipolygon.
     */
    type(t: string): Shape;

  }


  /*
   An aggregation that returns interesting or unusual occurrences of terms in
   a set.
   */
  export class SignificantTermsAggregation implements Aggregation {

    /*
     An aggregation that returns interesting or unusual occurrences of terms in
     a set.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): SignificantTermsAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): SignificantTermsAggregation;

    /*
     Allows you to filter out unwanted facet entries using a regular
     expression.  You can also optionally pass in a set of flags to apply
     to the regular expression.  Valid flags are: CASE_INSENSITIVE,
     MULTILINE, DOTALL, UNICODE_CASE, CANON_EQ, UNIX_LINES, LITERAL,
     COMMENTS, and UNICODE_CHAR_CLASS.  Separate multiple flags with a |
     character.
     */
    exclude(exclude: string, flags: string): SignificantTermsAggregation;

    /*
     Sets the execution hint determines how the aggregation is computed.
     Supported values are: map and ordinals.
     */
    executionHint(h: string): SignificantTermsAggregation;

    /*
     Sets the field to gather terms from.
     */
    field(field: string): SignificantTermsAggregation;

    /*
     Sets the format expression for the terms.  Use for number or date
     formatting.
     */
    format(f: string): SignificantTermsAggregation;

    /*
     Allows you to allow only specific entries using a regular
     expression.  You can also optionally pass in a set of flags to apply
     to the regular expression.  Valid flags are: CASE_INSENSITIVE,
     MULTILINE, DOTALL, UNICODE_CASE, CANON_EQ, UNIX_LINES, LITERAL,
     COMMENTS, and UNICODE_CHAR_CLASS.  Separate multiple flags with a |
     character.
     */
    include(include: string, flags: string): SignificantTermsAggregation;

    /*
     Only return terms that match more than a configured number of hits.
     */
    minDocCount(num: number): SignificantTermsAggregation;

    /*
     Determines how many terms the coordinating node will request from
     each shard.
     */
    shardSize(shardSize: number): SignificantTermsAggregation;

    /*
     Sets the number of aggregation entries that will be returned.
     */
    size(size: number): SignificantTermsAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A Sort object that can be used in on the Request object to specify
   various types of sorting.

   See http://www.elasticsearch.org/guide/reference/api/search/sort.html
   */
  export class Sort {

    /*
     Defines a sort value
     */
    constructor(fieldName: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the sort order to ascending (asc).  Same as calling
     order('asc').
     */
    asc(): Sort;

    /*
     Sets the sort order to descending (desc).  Same as calling
     order('desc').
     */
    desc(): Sort;

    /*
     How to compute the distance. Can either be arc (better precision)
     or plane (faster). Defaults to arc.

     Valid during sort types:  geo distance
     */
    distanceType(type: string): Sort;

    /*
     Set's the field to sort on
     */
    field(f: string): Sort;

    /*
     Enables sorting based on a distance from a GeoPoint
     */
    geoDistance(point: GeoPoint): Sort;

    /*
     Sets if the sort should ignore unmapped fields vs throwing an error.

     Valid during sort types:  field
     */
    ignoreUnmapped(trueFalse: boolean): Sort;

    /*
     Sets the script language.

     Valid during sort types:  script
     */
    lang(lang: string): Sort;

    /*
     Sets the value to use for missing fields.  Valid values are:

     _last - to put documents with the field missing last
     _first - to put documents with the field missing first
     {String} - any string value to use as the sort value.

     Valid during sort types:  field
     */
    missing(m: string): Sort;

    /*
     Sets the sort mode.  Valid values are:


     min - sort by lowest value
     max - sort by highest value
     sum - sort by the sum of all values
     avg - sort by the average of all values


     Valid during sort types:  field, geo distance
     */
    mode(m: string): Sort;

    /*
     Allows you to set a filter that nested objects must match
     in order to be considered during sorting.

     Valid during sort types: field, geo distance
     */
    nestedFilter(oFilter: Object): Sort;

    /*
     Sets the path of the nested object.

     Valid during sort types:  field, geo distance
     */
    nestedPath(path: string): Sort;

    /*
     If the lat/long points should be normalized to lie within their
     respective normalized ranges.

     Normalized ranges are:
     lon = -180 (exclusive) to 180 (inclusive) range
     lat = -90 to 90 (both inclusive) range

     Valid during sort types:  geo distance
     */
    normalize(trueFalse: string): Sort;

    /*
     Sets the sort order.  Valid values are:

     asc - for ascending order
     desc - for descending order

     Valid during sort types:  field, geo distance, and script
     */
    order(o: string): Sort;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.

     Valid during sort types:  script
     */
    params(p: Object): Sort;

    /*
     Sets the order with a boolean value.

     true = descending sort order
     false = ascending sort order

     Valid during sort types:  field, geo distance, and script
     */
    reverse(trueFalse: boolean): Sort;

    /*
     Enables sorting based on a script.
     */
    script(scriptCode: string): Sort;

    /*
     Retrieves the internal script object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the script sort type.  Valid values are:


     string - script return value is sorted as a string
     number - script return value is sorted as a number


     Valid during sort types:  script
     */
    type(type: string): Sort;

    /*
     Sets the distance unit.  Valid values are "mi" for miles or "km"
     for kilometers. Defaults to "km".

     Valid during sort types:  geo distance
     */
    unit(unit: Number): Sort;

  }


  /*
   Matches spans near the beginning of a field. The spanFirstQuery allows you to search
   for Spans that start and end within the first n positions of the document.
   The span first query maps to Lucene SpanFirstQuery.
   */
  export class SpanFirstQuery implements Query {

    /*
     Matches spans near the beginning of a field.
     */
    constructor(spanQry: Query, end: number);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): SpanFirstQuery;

    /*
     Sets the maximum end position permitted in a match.
     */
    end(position: Number): SpanFirstQuery;

    /*
     Sets the span query to match on.
     */
    match(spanQuery: Object): SpanFirstQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Wraps lucene MultiTermQueries as a SpanQuery so it can be used in the
   various Span* queries.  Examples of valid MultiTermQueries are
   Fuzzy, NumericRange, Prefix, Regex, Range, and Wildcard.
   */
  export class SpanMultiTermQuery implements Query {

    /*
     Use MultiTermQueries as a SpanQuery.
     */
    constructor(qry: Query);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): SpanMultiTermQuery;

    /*
     Sets the span query to match on.
     */
    match(mtQuery: Object): SpanMultiTermQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A spanNearQuery will look to find a number of spanQuerys within a given
   distance from each other.
   */
  export class SpanNearQuery implements Query {

    /*
     Matches spans which are near one another.
     */
    constructor(clauses: Query | Query[], slop: number);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): SpanNearQuery;

    /*
     Sets the clauses used.  If passed a single SpanQuery, it is added
     to the existing list of clauses.  If passed an array of
     SpanQueries, they replace any existing clauses.
     */
    clauses(clauses: Query | Query[]): SpanNearQuery;

    /*
     Sets whether or not payloads are being used. A payload is an arbitrary
     byte array stored at a specific position (i.e. token/term).
     */
    collectPayloads(trueFalse: boolean): SpanNearQuery;

    /*
     Sets whether or not matches are required to be in-order.
     */
    inOrder(trueFalse: boolean): SpanNearQuery;

    /*
     Sets the maximum number of intervening unmatched positions.
     */
    slop(distance: Number): SpanNearQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Removes matches which overlap with another span query.
   The span not query maps to Lucene SpanNotQuery.
   */
  export class SpanNotQuery implements Query {

    /*
     Removes matches which overlap with another span query.
     */
    constructor(includeQry: Query, excludeQry: Query);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): SpanNotQuery;

    /*
     Sets the span query whose matches must not overlap those returned.
     */
    exclude(spanQuery: Object): SpanNotQuery;

    /*
     Set the span query whose matches are filtered.
     */
    include(spanQuery: Object): SpanNotQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   The spanOrQuery takes an array of SpanQuerys and will match if any of the
   underlying SpanQueries match. The span or query maps to Lucene SpanOrQuery.
   */
  export class SpanOrQuery implements Query {

    /*
     Matches the union of its span clauses.
     */
    constructor(clauses: Object);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): SpanOrQuery;

    /*
     Sets the clauses used.  If passed a single SpanQuery, it is added
     to the existing list of clauses.  If passed an array of
     SpanQueries, they replace any existing clauses.
     */
    clauses(clauses: Query | Query[]): SpanOrQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A spanTermQuery is the basic unit of Lucene's Span Query which allows for nested,
   positional restrictions when matching documents. The spanTermQuery simply matches
   spans containing a term. It's essentially a termQuery with positional information asscoaited.
   */
  export class SpanTermQuery implements Query {

    /*
     Matches spans containing a term
     */
    constructor(field: string, value: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): SpanTermQuery;

    /*
     Sets the field to query against.
     */
    field(f: string): SpanTermQuery;

    /*
     Sets the term.
     */
    term(t: string): SpanTermQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A statistical facet allows you to compute statistical data over a numeric fields. Statistical data includes
   the count, total, sum of squares, mean (average), minimum, maximum, variance, and standard deviation.

   Facets are similar to SQL GROUP BY statements but perform much
   better. You can also construct several "groups" at once by simply
   specifying multiple facets.



   Tip:
   For more information on faceted navigation, see
   this
   Wikipedia article on Faceted Classification.


   */
  export class StatisticalFacet implements Facet {

    /*
     A facet which returns statistical information about a numeric field
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enables caching of the facetFilter
     */
    cacheFilter(trueFalse: boolean): StatisticalFacet;

    /*
     Allows you to reduce the documents used for computing facet results.
     */
    facetFilter(oFilter: Object): StatisticalFacet;

    /*
     Sets the field to be used to construct the this facet.
     */
    field(fieldName: string): StatisticalFacet;

    /*
     Aggregate statistical info across a set of fields.
     */
    fields(aFieldName: any[]): StatisticalFacet;

    /*
     Computes values across the entire index
     */
    global(trueFalse: boolean): StatisticalFacet;

    /*
     The script language being used. Currently supported values are
     javascript, groovy, and mvel.
     */
    lang(language: string): StatisticalFacet;

    /*
     Sets the mode the facet will use.


     collector
     post

     */
    mode(m: string): StatisticalFacet;

    /*
     Sets the path to the nested document if faceting against a
     nested field.
     */
    nested(path: string): StatisticalFacet;

    /*
     Allows you to set script parameters to be used during the execution of the script.
     */
    params(oParams: Object): StatisticalFacet;

    /*
     Computes values across the the specified scope
     */
    scope(scope: string): StatisticalFacet;

    /*
     Define a script to evaluate of which the result will be used to generate
     the statistical information.
     */
    script(code: string): StatisticalFacet;

    /*
     Retrieves the internal facet object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A multi-value metrics aggregation that computes stats over numeric values
   extracted from the aggregated documents. These values can be extracted either
   from specific numeric fields in the documents, or be generated by a provided
   script.

   The stats that are returned consist of: min, max, sum, count and avg.
   */
  export class StatsAggregation implements Aggregation {

    /*
     Aggregation that computes stats over numeric values extracted from the
     aggregated documents.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the field to operate on.
     */
    field(field: string): StatsAggregation;

    /*
     The script language being used.
     */
    lang(language: string): StatsAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): StatsAggregation;

    /*
     Allows you generate or modify the terms/values using a script.
     */
    script(scriptCode: string): StatsAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): StatsAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }

  export class SuggestContextMixin {


    /*
     Sets analyzer used to analyze the suggest text.
     */
    analyzer(analyzer: string): SuggestContextMixin;

    /*
     Sets the field used to generate suggestions from.
     */
    field(field: string): SuggestContextMixin;

    /*
     Sets the maximum number of suggestions to be retrieved from
     each individual shard.
     */
    shardSize(s: number): SuggestContextMixin;

    /*
     Sets the number of suggestions returned for each token.
     */
    size(s: number): SuggestContextMixin;

  }

  export class SuggesterMixin {


    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the text to get suggestions for.  If not set, the global
     suggestion text will be used.
     */
    text(txt: string): SuggesterMixin;

    /*
     Retrieves the internal suggest object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A single-value metrics aggregation that sums up numeric values that are
   extracted from the aggregated documents. These values can be extracted either
   from specific numeric fields in the documents, or be generated by a
   provided script.
   */
  export class SumAggregation implements Aggregation {

    /*
     Aggregation that sums up numeric values that are extracted from the
     aggregated documents.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the field to operate on.
     */
    field(field: string): SumAggregation;

    /*
     The script language being used.
     */
    lang(language: string): SumAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): SumAggregation;

    /*
     Allows you generate or modify the terms/values using a script.
     */
    script(scriptCode: string): SumAggregation;

    /*
     Set to true to assume script values are sorted.
     */
    scriptValuesSorted(trueFalse: boolean): SumAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Constructs a filter for docs matching any of the terms added to this
   object. Unlike a RangeFilter this can be used for filtering on multiple
   terms that are not necessarily in a sequence.
   */
  export class TermFilter implements Filter {

    /*
     Constructs a filter for docs matching the term added to this object.
     */
    constructor(fieldName: string, term: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): TermFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): TermFilter;

    /*
     Provides access to the filter fieldName used to construct the
     termFilter object.
     */
    field(f: string): TermFilter;

    /*
     Sets the filter name.
     */
    name(name: string): TermFilter;

    /*
     Provides access to the filter term used to construct the
     termFilter object.
     */
    term(): TermFilter;

    /*
     Returns the filter object.
     */
    toJSON(): TermFilter;

  }


  /*
   A TermQuery can be used to return documents containing a given
   keyword or term. For instance, you might want to retieve all the
   documents/objects that contain the term Javascript. Term filters
   often serve as the basis for more complex queries such as Boolean queries.
   */
  export class TermQuery implements Query {

    /*
     A Query that matches documents containing a term. This may be
     combined with other terms with a BooleanQuery.
     */
    constructor(field: string, term: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: Number): TermQuery;

    /*
     Sets the fields to query against.
     */
    field(f: string): TermQuery;

    /*
     Sets the term.
     */
    term(t: string): TermQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A multi-bucket value source based aggregation where buckets are dynamically
   built - one per unique value.
   */
  export class TermsAggregation implements Aggregation {

    /*
     Defines an aggregation of unique values/terms.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.  Alias for the
     aggregation method.
     */
    agg(agg: Aggregation): TermsAggregation;

    /*
     Add a nested aggregation.  This method can be called multiple times
     in order to set multiple nested aggregations what will be executed
     at the same time as the parent aggregation.
     */
    aggregation(agg: Aggregation): TermsAggregation;

    /*
     Allows you to filter out unwanted facet entries using a regular
     expression.  You can also optionally pass in a set of flags to apply
     to the regular expression.  Valid flags are: CASE_INSENSITIVE,
     MULTILINE, DOTALL, UNICODE_CASE, CANON_EQ, UNIX_LINES, LITERAL,
     COMMENTS, and UNICODE_CHAR_CLASS.  Separate multiple flags with a |
     character.
     */
    exclude(exclude: string, flags: string): TermsAggregation;

    /*
     Sets the execution hint determines how the aggregation is computed.
     Supported values are: map and ordinals.
     */
    executionHint(h: string): TermsAggregation;

    /*
     Sets the field to gather terms from.
     */
    field(field: string): TermsAggregation;

    /*
     Sets the format expression for the terms.  Use for number or date
     formatting
     */
    format(f: string): TermsAggregation;

    /*
     Allows you to allow only specific entries using a regular
     expression.  You can also optionally pass in a set of flags to apply
     to the regular expression.  Valid flags are: CASE_INSENSITIVE,
     MULTILINE, DOTALL, UNICODE_CASE, CANON_EQ, UNIX_LINES, LITERAL,
     COMMENTS, and UNICODE_CHAR_CLASS.  Separate multiple flags with a |
     character.
     */
    include(include: string, flags: string): TermsAggregation;

    /*
     The script language being used.
     */
    lang(language: string): TermsAggregation;

    /*
     Only return terms that match more than a configured number of hits.
     */
    minDocCount(num: number): TermsAggregation;

    /*
     Sets order for the aggregated values.
     */
    order(order: string, direction: string): TermsAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): TermsAggregation;

    /*
     Allows you generate or modify the terms using a script.
     */
    script(scriptCode: string): TermsAggregation;

    /*
     Set to true to assume script values are unique.
     */
    scriptValuesUnique(trueFalse: boolean): TermsAggregation;

    /*
     Determines how many terms the coordinating node will request from
     each shard.
     */
    shardSize(shardSize: number): TermsAggregation;

    /*
     Sets the number of aggregation entries that will be returned.
     */
    size(size: number): TermsAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the type of the field value for use in scripts.  Current values are:
     string, double, float, long, integer, short, and byte.
     */
    valueType(v: string): TermsAggregation;

  }


  /*
   A facet which returns the N most frequent terms within a collection
   or set of collections. Term facets are useful for building constructs
   which allow users to refine search results by filtering on terms returned
   by the facet.

   Facets are similar to SQL GROUP BY statements but perform much
   better. You can also construct several "groups" at once by simply
   specifying multiple facets.

   For more information on faceted navigation, see this Wikipedia article on
   Faceted Classification
   */
  export class TermsFacet implements Facet {

    /*
     A facet which returns the N most frequent terms within a collection
     or set of collections.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Allows you to return all terms, even if the frequency count is 0. This should not be
     used on fields that contain a large number of unique terms because it could cause
     out-of-memory errors.
     */
    allTerms(trueFalse: string): TermsFacet;

    /*
     Enables caching of the facetFilter
     */
    cacheFilter(trueFalse: boolean): TermsFacet;

    /*
     Allows you to filter out unwanted facet entries. When passed
     a single term, it is appended to the list of currently excluded
     terms.  If passed an array, it overwrites all existing values.
     */
    exclude(exclude: string | string[]): TermsFacet;

    /*
     Sets the execution hint determines how the facet is computed.
     Currently only supported value is "map".
     */
    executionHint(h: Object): TermsFacet;

    /*
     Allows you to reduce the documents used for computing facet results.
     */
    facetFilter(oFilter: Object): TermsFacet;

    /*
     Sets the field to be used to construct the this facet.  Set to
     _index to return a facet count of hits per _index the search was
     executed on.
     */
    field(fieldName: string): TermsFacet;

    /*
     Aggregate statistical info across a set of fields.
     */
    fields(aFieldName: any[]): TermsFacet;

    /*
     Computes values across the entire index
     */
    global(trueFalse: boolean): TermsFacet;

    /*
     The script language being used. Currently supported values are
     javascript, groovy, and mvel.
     */
    lang(language: string): TermsFacet;

    /*
     Sets the mode the facet will use.


     collector
     post

     */
    mode(m: string): TermsFacet;

    /*
     Sets the path to the nested document if faceting against a
     nested field.
     */
    nested(path: string): TermsFacet;

    /*
     Sets the type of ordering that will be performed on the date
     buckets.  Valid values are:

     count - default, sort by the number of items in the bucket
     term - sort by term value.
     reverse_count - reverse sort of the number of items in the bucket
     reverse_term - reverse sort of the term value.
     */
    order(o: string): TermsFacet;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): TermsFacet;

    /*
     Allows you to only include facet entries matching a specified regular expression.
     */
    regex(exp: string): TermsFacet;

    /*
     Allows you to set the regular expression flags to be used
     with the regex
     */
    regexFlags(flags: string): TermsFacet;

    /*
     Computes values across the the specified scope
     */
    scope(scope: string): TermsFacet;

    /*
     Allows you modify the term using a script. The modified value
     is then used in the facet collection.
     */
    script(scriptCode: string): TermsFacet;

    /*
     Sets a script that will provide the terms for a given document.
     */
    scriptField(script: string): TermsFacet;

    /*
     Determines how many terms the coordinating node will request from
     each shard.
     */
    shardSize(shardSize: number): TermsFacet;

    /*
     Sets the number of facet entries that will be returned for this facet. For instance, you
     might ask for only the top 5 authors although there might be hundreds of
     unique authors.
     */
    size(facetSize: number): TermsFacet;

    /*
     Retrieves the internal facet object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Filters documents that have fields that match any of the provided
   terms (not analyzed)
   */
  export class TermsFilter implements Filter {

    /*
     A Filter that matches documents containing provided terms.
     */
    constructor(field: string, terms: string | string[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): TermsFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): TermsFilter;

    /*
     Enable or disable caching of the lookup
     */
    cacheLookup(trueFalse: boolean): TermsFilter;

    /*
     Sets the way terms filter executes is by iterating over the terms
     provided and finding matches docs (loading into a bitset) and
     caching it.  Valid values are: plain, bool, bool_nocache, and,
     and_nocache, or, or_nocache.  Defaults to plain.
     */
    execution(e: string): TermsFilter;

    /*
     Sets the fields to filter against.
     */
    field(f: string): TermsFilter;

    /*
     Sets the document id of the document containing the terms to use
     when performing a terms lookup.
     */
    id(id: string): TermsFilter;

    /*
     Sets the index the document containing the terms is in when
     performing a terms lookup.  Defaults to the index currently
     being searched.
     */
    index(idx: string): TermsFilter;

    /*
     Sets the filter name.
     */
    name(name: string): TermsFilter;

    /*
     Sets the path/field name where the terms in the source document
     are located when performing a terms lookup.
     */
    path(path: string): TermsFilter;

    /*
     Sets the routing value for the source document when performing a
     terms lookup.
     */
    routing(path: string): TermsFilter;

    /*
     Sets the terms.  If t is a String, it is added to the existing
     list of terms.  If t is an array, the list of terms replaces the
     existing terms.
     */
    terms(t: string | string[]): TermsFilter;

    /*
     Returns the filter object.
     */
    toJSON(): TermsFilter;

    /*
     Sets the type the document containing the terms when performing a
     terms lookup.
     */
    type(type: string): TermsFilter;

  }


  /*
   A query that match on any (configurable) of the provided terms. This is
   a simpler syntax query for using a bool query with several term queries
   in the should clauses.
   */
  export class TermsQuery implements Query {

    /*
     A Query that matches documents containing provided terms.
     */
    constructor(field: string, terms: string | string[]);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): TermsQuery;

    /*
     Enables or disables similarity coordinate scoring of documents
     matching the Query. Default: false.
     */
    disableCoord(trueFalse: string): TermsQuery;

    /*
     Sets the fields to query against.
     */
    field(f: string): TermsQuery;

    /*
     Sets the minimum number of terms that need to match in a document
     before that document is returned in the results.
     */
    minimumShouldMatch(min: number): TermsQuery;

    /*
     Sets the terms.  If you t is a String, it is added to the existing
     list of terms.  If t is an array, the list of terms replaces the
     existing terms.
     */
    terms(t: string | string[]): TermsQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   A termsStatsFacet allows you to compute statistics over an aggregate key (term). Essentially this
   facet provides the functionality of what is often refered to as a pivot table.

   Facets are similar to SQL GROUP BY statements but perform much
   better. You can also construct several "groups" at once by simply
   specifying multiple facets.



   Tip:
   For more information on faceted navigation, see
   this
   Wikipedia article on Faceted Classification.


   */
  export class TermStatsFacet implements Facet {

    /*
     A facet which computes statistical data based on an aggregate key.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Allows you to return all terms, even if the frequency count is 0. This should not be
     used on fields that contain a large number of unique terms because it could cause
     out-of-memory errors.
     */
    allTerms(trueFalse: string): TermStatsFacet;

    /*
     Enables caching of the facetFilter
     */
    cacheFilter(trueFalse: boolean): TermStatsFacet;

    /*
     Allows you to reduce the documents used for computing facet results.
     */
    facetFilter(oFilter: Object): TermStatsFacet;

    /*
     Computes values across the entire index
     */
    global(trueFalse: boolean): TermStatsFacet;

    /*
     Sets the field which will be used to pivot on (group-by).
     */
    keyField(fieldName: string): TermStatsFacet;

    /*
     The script language being used. Currently supported values are
     javascript, groovy, and mvel.
     */
    lang(language: string): TermStatsFacet;

    /*
     Sets the mode the facet will use.


     collector
     post

     */
    mode(m: string): TermStatsFacet;

    /*
     Sets the path to the nested document if faceting against a
     nested field.
     */
    nested(path: string): TermStatsFacet;

    /*
     Sets the type of ordering that will be performed on the date
     buckets.  Valid values are:

     count - default, sort by the number of items in the bucket
     term - sort by term value.
     reverse_count - reverse sort of the number of items in the bucket
     reverse_term - reverse sort of the term value.
     total - sorts by the total value of the bucket contents
     reverse_total - reverse sort of the total value of bucket contents
     min - the minimum value in the bucket
     reverse_min - the reverse sort of the minimum value
     max - the maximum value in the bucket
     reverse_max - the reverse sort of the maximum value
     mean - the mean value of the bucket contents
     reverse_mean - the reverse sort of the mean value of bucket contents.
     */
    order(o: string): TermStatsFacet;

    /*
     Allows you to set script parameters to be used during the execution of the script.
     */
    params(oParams: Object): TermStatsFacet;

    /*
     Computes values across the the specified scope
     */
    scope(scope: string): TermStatsFacet;

    /*
     Sets a script that will provide the terms for a given document.
     */
    scriptField(script: string): TermStatsFacet;

    /*
     Sets the number of facet entries that will be returned for this facet. For instance, you
     might ask for only the top 5 aggregate keys although there might be hundreds of
     unique keys. Higher settings could cause memory strain.
     */
    size(facetSize: number): TermStatsFacet;

    /*
     Retrieves the internal facet object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the field for which statistical information will be generated.
     */
    valueField(fieldName: string): TermStatsFacet;

    /*
     Define a script to evaluate of which the result will be used to generate
     the statistical information.
     */
    valueScript(code: string): TermStatsFacet;

  }


  /*
   TermSuggester suggests terms based on edit distance. The provided suggest
   text is analyzed before terms are suggested. The suggested terms are
   provided per analyzed suggest text token.  This leaves the suggest-selection
   to the API consumer.  For a higher level suggester, please use the
   PhraseSuggester.
   */
  export class TermSuggester implements Suggest {

    /*
     A suggester that suggests terms based on edit distance.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the accuracy.  How similar the suggested terms at least
     need to be compared to the original suggest text.
     */
    accuracy(a: number): TermSuggester;

    /*
     Sets analyzer used to analyze the suggest text.
     */
    analyzer(analyzer: string): TermSuggester;

    /*
     Sets the field used to generate suggestions from.
     */
    field(field: string): TermSuggester;

    /*
     Sets the maximum edit distance candidate suggestions can have
     in order to be considered as a suggestion.
     */
    maxEdits(max: number): TermSuggester;

    /*
     The factor that is used to multiply with the size in order
     to inspect more candidate suggestions.
     */
    maxInspections(max: number): TermSuggester;

    /*
     Sets a maximum threshold in number of documents a suggest text
     token can exist in order to be corrected.
     */
    maxTermFreq(max: number): TermSuggester;

    /*
     Sets a minimal threshold of the number of documents a suggested
     term should appear in.
     */
    minDocFreq(min: number): TermSuggester;

    /*
     Sets the minimum length a suggest text term must have in order
     to be corrected.
     */
    minWordLen(len: number): TermSuggester;

    /*
     Sets the maximum number of suggestions to be retrieved from
     each individual shard.
     */
    shardSize(s: number): TermSuggester;

    /*
     Sets the number of suggestions returned for each token.
     */
    size(s: number): TermSuggester;

    /*
     Sets the sort mode.  Valid values are:


     score - Sort by score first, then document frequency, and then the term itself
     frequency - Sort by document frequency first, then simlarity score and then the term itself

     */
    sort(s: string): TermSuggester;

    /*
     Sets what string distance implementation to use for comparing
     how similar suggested terms are.  Valid values are:


     internal - based on damerau_levenshtein but but highly optimized for comparing string distance for terms inside the index
     damerau_levenshtein - String distance algorithm based on Damerau-Levenshtein algorithm
     levenstein - String distance algorithm based on Levenstein edit distance algorithm
     jarowinkler - String distance algorithm based on Jaro-Winkler algorithm
     ngram - String distance algorithm based on character n-grams

     */
    stringDistance(s: string): TermSuggester;

    /*
     Sets the suggest mode.  Valid values are:


     missing - Only suggest terms in the suggest text that aren't in the index
     popular - Only suggest suggestions that occur in more docs then the original suggest text term
     always - Suggest any matching suggestions based on terms in the suggest text

     */
    suggestMode(m: string): TermSuggester;

    /*
     Sets the text to get suggestions for.  If not set, the global
     suggestion text will be used.
     */
    text(txt: string): TermSuggester;

    /*
     Retrieves the internal suggest object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   TThe top_children query runs the child query with an estimated hits size,
   and out of the hit docs, aggregates it into parent docs. If there aren’t
   enough parent docs matching the requested from/size search request, then it
   is run again with a wider (more hits) search.

   The top_children also provide scoring capabilities, with the ability to
   specify max, sum or avg as the score type.
   */
  export class TopChildrenQuery implements Query {

    /*
     Returns child documents matching the query aggregated into the parent docs.
     */
    constructor(qry: Object, type: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: number): TopChildrenQuery;

    /*
     Sets the factor which is the number of hits that are asked for in
     the child query.  Defaults to 5.
     */
    factor(f: number): TopChildrenQuery;

    /*
     Sets the incremental factor.  The incremental factor is used when not
     enough child documents are returned so the factor is multiplied by
     the incremental factor to fetch more results.  Defaults to 52
     */
    incrementalFactor(f: number): TopChildrenQuery;

    /*
     Sets the query
     */
    query(q: Object): TopChildrenQuery;

    /*
     Sets the scope of the query.  A scope allows to run facets on the
     same scope name that will work against the child documents.
     */
    scope(s: string): TopChildrenQuery;

    /*
     Sets the scoring type.  Valid values are max, sum, or avg. If
     another value is passed it we silently ignore the value.
     */
    score(s: string): TopChildrenQuery;

    /*
     Sets the scoring type.  Valid values are max, sum, total, or avg.
     If another value is passed it we silently ignore the value.
     */
    scoreMode(s: string): TopChildrenQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the child document type to search against
     */
    type(t: string): TopChildrenQuery;

  }


  /*
   A Filter that filters results by a specified index type.
   */
  export class TypeFilter implements Filter {

    /*
     Filter results by a specified index type.
     */
    constructor(type: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Enable or disable caching of the filter
     */
    cache(trueFalse: boolean): TypeFilter;

    /*
     Sets the cache key.
     */
    cacheKey(key: string): TypeFilter;

    /*
     Sets the filter name.
     */
    name(name: string): TypeFilter;

    /*
     Returns the filter object.
     */
    toJSON(): TypeFilter;

    /*
     Sets the type
     */
    type(type: string): TypeFilter;

  }


  /*
   A single-value metrics aggregation that counts the number of values that
   are extracted from the aggregated documents. These values can be extracted
   either from specific fields in the documents, or be generated by a provided
   script. Typically, this aggregator will be used in conjunction with other
   single-value aggregations.
   */
  export class ValueCountAggregation implements Aggregation {

    /*
     Aggregation that counts the number of values that are extracted from the
     aggregated documents.
     */
    constructor(name: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the field to operate on.
     */
    field(field: string): ValueCountAggregation;

    /*
     The script language being used.
     */
    lang(language: string): ValueCountAggregation;

    /*
     Sets parameters that will be applied to the script.  Overwrites
     any existing params.
     */
    params(p: Object): ValueCountAggregation;

    /*
     Allows you generate or modify the terms/values using a script.
     */
    script(scriptCode: string): ValueCountAggregation;

    /*
     Set to true to assume script values are unique.
     */
    scriptValuesUnique(trueFalse: boolean): ValueCountAggregation;

    /*
     Retrieves the internal agg object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

  }


  /*
   Matches documents that have fields matching a wildcard expression
   (not analyzed). Supported wildcards are *, which matches any character
   sequence (including the empty one), and ?, which matches any single
   character. Note this query can be slow, as it needs to iterate over many
   wildcards. In order to prevent extremely slow wildcard queries, a wildcard
   wildcard should not start with one of the wildcards * or ?. The wildcard query
   maps to Lucene WildcardQuery.
   */
  export class WildcardQuery implements Query {

    /*
     A Query that matches documents containing a wildcard. This may be
     combined with other wildcards with a BooleanQuery.
     */
    constructor(field: string, value: string);

    /*
     The type of ejs object.  For internal use only.
     */
    _type(): string;

    /*
     Sets the boost value for documents matching the Query.
     */
    boost(boost: Number): WildcardQuery;

    /*
     Sets the fields to query against.
     */
    field(f: string): WildcardQuery;

    /*
     Sets rewrite method.  Valid values are:

     constant_score_auto - tries to pick the best constant-score rewrite
     method based on term and document counts from the query

     scoring_boolean - translates each term into boolean should and
     keeps the scores as computed by the query

     constant_score_boolean - same as scoring_boolean, expect no scores
     are computed.

     constant_score_filter - first creates a private Filter, by visiting
     each term in sequence and marking all docs for that term

     top_terms_boost_N - first translates each term into boolean should
     and scores are only computed as the boost using the top N
     scoring terms.  Replace N with an integer value.

     top_terms_N -   first translates each term into boolean should
     and keeps the scores as computed by the query. Only the top N
     scoring terms are used.  Replace N with an integer value.

     Default is constant_score_auto.

     This is an advanced option, use with care.
     */
    rewrite(m: string): WildcardQuery;

    /*
     Retrieves the internal query object. This is typically used by
     internal API functions so use with caution.
     */
    toJSON(): any;

    /*
     Sets the wildcard query value.
     */
    value(v: string): WildcardQuery;

  }

}
