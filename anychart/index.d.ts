// Type definitions for anychart
// Project: http://anychart.com/
// Definitions by: AnyChart <http://anychart.com>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
declare namespace anychart {
    const DEVELOP: boolean;
    const VERSION: string;
    function appendTheme(value: string | Object): void;
    function area(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function area3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function bar(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function bar3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function box(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function bubble(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function bubbleMap(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function bullet(data?: anychart.data.View | anychart.data.Set | Array<any> | string): anychart.charts.Bullet;
    function cartesian(): anychart.charts.Cartesian;
    function cartesian3d(barChartMode?: boolean): anychart.charts.Cartesian3d;
    function choropleth(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function column(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function column3d(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian3d;
    function connector(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function financial(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function fromJson(jsonConfig: Object | string): any;
    function fromJsonFile(url: string, onSuccessOrContainer?: string | (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function fromXml(xmlConfig: string | Node): any;
    function fromXmlFile(url: string, onSuccessOrContainer?: string | (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function funnel(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Funnel;
    function ganttProject(): anychart.charts.Gantt;
    function ganttResource(): anychart.charts.Gantt;
    function ganttToolbar(): anychart.ui.GanttToolbar;
    function heatMap(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.HeatMap;
    function licenseKey(value?: string): string;
    function line(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Cartesian;
    function map(): anychart.charts.Map;
    function marker(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function markerMap(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function onDocumentLoad(func: (() => void), scope?: any): void;
    function onDocumentReady(func: (() => void), scope?: any): void;
    function pert(): anychart.charts.Pert;
    function pie(data?: anychart.data.View | anychart.data.Set | Array<any> | string): anychart.charts.Pie;
    function pie3d(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Pie;
    function polar(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Polar;
    function pyramid(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Pyramid;
    function radar(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Radar;
    function scatter(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Scatter;
    function seatMap(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): anychart.charts.Map;
    function sparkline(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Sparkline;
    function stock(): anychart.charts.Stock;
    function theme(value?: string | Object | Array<(string|Object)>): string | Object | Array<(string|Object)>;
    function treeMap(data?: anychart.data.Tree | Array<Object>, fillMethod?: anychart.enums.TreeFillingMethod): anychart.charts.TreeMap;
    interface SignalEvent {
        targetBoundsChanged(): boolean;
        targetDataChanged(): boolean;
        targetMetaChanged(): boolean;
        targetNeedsReapplication(): boolean;
        targetNeedsRecalculation(): boolean;
        targetNeedsRedraw(): boolean;
    }
}

declare namespace anychart.axes {
    function linear(): anychart.axes.Linear;
    function polar(): anychart.axes.Polar;
    function radar(): anychart.axes.Radar;
    function radial(): anychart.axes.Radial;
    interface Polar extends anychart.core.axes.Polar {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.axes.Polar;
        draw(): anychart.axes.Polar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Polar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Polar;
        minorTicks(): anychart.core.axes.RadialTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Polar;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Polar;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.axes.Polar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.axes.Polar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.ScatterBase;
        scale(value?: anychart.scales.ScatterBase): anychart.core.axes.Polar;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.axes.Polar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Polar;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Polar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Linear extends anychart.core.axes.Linear {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.axes.Linear;
        draw(): anychart.axes.Linear;
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Linear;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Linear;
        orientation(): anychart.enums.Orientation;
        orientation(value?: string | anychart.enums.Orientation): anychart.core.axes.Linear;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Linear;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.axes.Linear;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.axes.Linear;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.axes.Linear;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.axes.Linear;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axes.Linear;
        staggerLines(): number;
        staggerLines(value?: number): anychart.core.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(value?: number): anychart.core.axes.Linear;
        staggerMode(): boolean;
        staggerMode(value?: boolean): anychart.core.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(value?: Object | boolean): anychart.core.axes.Linear;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.axes.Linear;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radial extends anychart.core.axes.Radial {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.axes.Radial;
        draw(): anychart.core.axes.Radial;
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Radial;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Radial;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Radial;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Radial;
        minorTicks(): anychart.core.axes.RadialTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Radial;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Radial;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.axes.Radial;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.axes.Radial;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axes.Radial;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.axes.Radial;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Radial;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Radial;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radar extends anychart.core.axes.Radar {
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.axes.Radar;
        draw(): anychart.axes.Radar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Radar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.axes.Radar;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.axes.Radar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axes.Radar;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.axes.Radar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Radar;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Radar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.axisMarkers {
    function line(): anychart.axisMarkers.Line;
    function range(): anychart.axisMarkers.Range;
    function text(): anychart.axisMarkers.Text;
    interface Text extends anychart.core.axisMarkers.Text {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.axisMarkers.Text;
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.axisMarkers.Text;
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.axisMarkers.Text;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        draw(): anychart.axisMarkers.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.axisMarkers.Text;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Text;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.axisMarkers.Text;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.axisMarkers.Text;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.axisMarkers.Text;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.axisMarkers.Text;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.axisMarkers.Text;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axisMarkers.Text;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.axisMarkers.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        value(): number;
        value(value?: number): anychart.core.axisMarkers.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.axisMarkers.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.axisMarkers.Line {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.axisMarkers.Line;
        draw(): anychart.axisMarkers.Line;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.axisMarkers.Line;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.axisMarkers.Line;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axisMarkers.Line;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.Line;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        value(): number;
        value(newValue?: number): anychart.core.axisMarkers.Line;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Range extends anychart.core.axisMarkers.Range {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.axisMarkers.Range;
        draw(): anychart.axisMarkers.Range;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.axisMarkers.Range;
        fill(color: string, opacity?: number): anychart.core.axisMarkers.Range;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axisMarkers.Range;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axisMarkers.Range;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axisMarkers.Range;
        from(): number;
        from(value?: number): anychart.core.axisMarkers.Range;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Range;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.axisMarkers.Range;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.axisMarkers.Range;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axisMarkers.Range;
        to(): number;
        to(value?: number): anychart.core.axisMarkers.Range;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.charts {
    interface TreeMap extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        colorRange(): anychart.core.ui.ColorRange;
        colorRange(value?: Object): anychart.charts.TreeMap;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(value?: anychart.scales.OrdinalColor | anychart.scales.LinearColor): anychart.scales.LinearColor;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.Tree;
        data(value?: anychart.data.Tree | Array<Object>, fillMethod?: anychart.enums.TreeFillingMethod | string): anychart.charts.TreeMap;
        draw(async?: boolean): anychart.core.Chart;
        drillTo(target: anychart.data.Tree.DataItem | Array<any> | string): void;
        drillUp(): void;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.charts.TreeMap;
        fill(fillFunction?: (() => void)): anychart.charts.TreeMap;
        fill(color: string, opacity?: number): anychart.charts.TreeMap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.TreeMap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.TreeMap;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.TreeMap;
        getDrilldownPath(): Array<any>;
        getPixelBounds(): anychart.math.Rect;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.TreeMap;
        headers(): anychart.core.ui.LabelsFactory;
        headers(value?: Object | boolean): anychart.charts.TreeMap;
        headersDisplayMode(): string | anychart.enums.LabelsDisplayMode;
        headersDisplayMode(value?: string | anychart.enums.LabelsDisplayMode): anychart.charts.TreeMap;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hintDepth(): number;
        hintDepth(value?: number): anychart.charts.TreeMap;
        hintOpacity(): number;
        hintOpacity(value?: number): anychart.charts.TreeMap;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value: anychart.graphics.vector.Fill): anychart.charts.TreeMap;
        hoverFill(fillFunction?: (() => void)): anychart.charts.TreeMap;
        hoverFill(color: string, opacity?: number): anychart.charts.TreeMap;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.TreeMap;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.TreeMap;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.TreeMap;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.TreeMap;
        hoverHeaders(): anychart.core.ui.LabelsFactory;
        hoverHeaders(value?: Object | boolean): anychart.charts.TreeMap;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.charts.TreeMap;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.charts.TreeMap;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(strokeFunction?: anychart.graphics.vector.Stroke | (() => void)): anychart.charts.TreeMap;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.TreeMap;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.TreeMap;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.charts.TreeMap;
        maxDepth(): number;
        maxDepth(value?: number): anychart.charts.TreeMap;
        maxHeadersHeight(): number | string;
        maxHeadersHeight(value?: number | string): anychart.charts.TreeMap;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(value: anychart.graphics.vector.Fill): anychart.charts.TreeMap;
        selectFill(fillFunction?: (() => void)): anychart.charts.TreeMap;
        selectFill(color: string, opacity?: number): anychart.charts.TreeMap;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.TreeMap;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.TreeMap;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.TreeMap;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.TreeMap;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.charts.TreeMap;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.charts.TreeMap;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(strokeFunction?: (() => void)): anychart.charts.TreeMap;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.TreeMap;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.charts.TreeMap;
        sort(): anychart.enums.Sort;
        sort(value?: anychart.enums.Sort | string): anychart.charts.TreeMap;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(fillFunction?: (() => void)): anychart.charts.TreeMap;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.TreeMap;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Cartesian extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.cartesian.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.charts.Cartesian;
        animation(enabled: boolean, duration: number): anychart.charts.Cartesian;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Cartesian;
        area(data: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Area;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.charts.Cartesian;
        bar(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Bar;
        barGroupsPadding(): number;
        barGroupsPadding(value?: number): anychart.charts.Cartesian;
        barsPadding(): number;
        barsPadding(value?: number): anychart.charts.Cartesian;
        bottom(): number | string;
        bottom(value?: number | string): anychart.charts.Cartesian;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        box(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Box;
        bubble(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Bubble;
        candlestick(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Candlestick;
        column(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Column;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.charts.Cartesian;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(value?: Object | boolean): anychart.charts.Cartesian;
        data(): anychart.data.View;
        data(value?: anychart.data.Set | anychart.data.TableData | Array<any>): anychart.charts.Cartesian;
        defaultSeriesType(): string | anychart.enums.CartesianSeriesType;
        defaultSeriesType(value?: string | anychart.enums.CartesianSeriesType): anychart.charts.Cartesian;
        draw(): anychart.charts.Cartesian;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.cartesian.series.Base;
        getSeriesAt(index: number): anychart.core.cartesian.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        getXAxesCount(): number;
        getYAxesCount(): number;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        grid(index?: number): anychart.core.grids.Linear;
        grid(value?: Object | boolean): anychart.charts.Cartesian;
        grid(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Cartesian;
        height(): number | string;
        height(value?: number | string): anychart.charts.Cartesian;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.charts.Cartesian;
        label(index?: string | number, value?: boolean | Object | string): anychart.charts.Cartesian;
        left(): number | string;
        left(value?: number | string): anychart.charts.Cartesian;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.charts.Cartesian;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Line;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(value?: Object | boolean): anychart.charts.Cartesian;
        lineMarker(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.charts.Cartesian;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Cartesian;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Cartesian;
        maxBubbleSize(): number | string;
        maxBubbleSize(value?: number | string): anychart.charts.Cartesian;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.charts.Cartesian;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.charts.Cartesian;
        minBubbleSize(): number | string;
        minBubbleSize(value?: number | string): anychart.charts.Cartesian;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.charts.Cartesian;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.charts.Cartesian;
        minorGrid(index?: number): anychart.core.grids.Linear;
        minorGrid(value?: Object | boolean): anychart.charts.Cartesian;
        minorGrid(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        ohlc(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.OHLC;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.charts.Cartesian;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.charts.Cartesian;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Cartesian;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeArea(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.RangeArea;
        rangeBar(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.RangeBar;
        rangeColumn(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.RangeColumn;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(value?: Object | boolean): anychart.charts.Cartesian;
        rangeMarker(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        rangeSplineArea(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.RangeSplineArea;
        rangeStepArea(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.RangeStepArea;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Cartesian;
        removeSeries(id: number | string): anychart.charts.Cartesian;
        removeSeriesAt(index: number): anychart.charts.Cartesian;
        right(): number | string;
        right(value?: number | string): anychart.charts.Cartesian;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number): void;
        saveAsPng(width?: number, height?: number, quality?: number): void;
        saveAsSvg(paperSize?: string, landscape?: boolean): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        spline(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Spline;
        splineArea(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.SplineArea;
        stepArea(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.StepArea;
        stepLine(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.StepLine;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(value?: Object | boolean): anychart.charts.Cartesian;
        textMarker(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.charts.Cartesian;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.charts.Cartesian;
        top(): number | string;
        top(value?: number | string): anychart.charts.Cartesian;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.charts.Cartesian;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(value?: Object | boolean): anychart.charts.Cartesian;
        xAxis(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Cartesian;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(value?: Object | boolean): anychart.charts.Cartesian;
        xZoom(): anychart.core.utils.OrdinalZoom;
        xZoom(value?: number | boolean | Object): anychart.charts.Cartesian;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.charts.Cartesian;
        yAxis(index?: number, value?: Object | boolean): anychart.charts.Cartesian;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Cartesian;
        zIndex(): number;
        zIndex(value?: number): anychart.charts.Cartesian;
    }
    interface Bullet extends anychart.core.Chart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        axis(): anychart.core.axes.Linear;
        axis(value?: Object | boolean): anychart.charts.Bullet;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Bullet;
        draw(): anychart.charts.Bullet;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        isHorizontal(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        layout(): anychart.enums.Layout | string;
        layout(value?: string | anychart.enums.Layout): anychart.charts.Bullet;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: Array<anychart.enums.MarkerType> | Object | anychart.palettes.Markers): anychart.charts.Bullet;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        range(index?: number): anychart.core.axisMarkers.Range;
        range(value?: Object | boolean): anychart.charts.Bullet;
        range(index?: number, value?: Object | boolean): anychart.charts.Bullet;
        rangePalette(): anychart.palettes.DistinctColors;
        rangePalette(value?: anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Bullet;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base | anychart.enums.ScaleTypes | string): anychart.charts.Bullet;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Polar extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.polar.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        area(data: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.polar.series.Area;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        defaultSeriesType(): string;
        defaultSeriesType(value?: string | anychart.enums.PolarSeriesType): anychart.charts.Polar;
        draw(async?: boolean): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.polar.series.Base;
        getSeriesAt(index: number): anychart.core.polar.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        grid(index?: number): anychart.core.grids.Polar;
        grid(value?: Object | boolean): anychart.charts.Polar;
        grid(index?: number, value?: Object | boolean): anychart.charts.Polar;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Polar;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.polar.series.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.polar.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Polar;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        minorGrid(index?: number): anychart.core.grids.Polar;
        minorGrid(value?: Object | boolean): anychart.charts.Polar;
        minorGrid(index?: number, value?: Object | boolean): anychart.charts.Polar;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Polar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Polar;
        removeSeries(id: number | string): anychart.charts.Polar;
        removeSeriesAt(index: number): anychart.charts.Polar;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.charts.Polar;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(): anychart.core.axes.Radar;
        xAxis(value?: Object | boolean): anychart.charts.Radar;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase): anychart.charts.Polar;
        yAxis(): anychart.core.axes.Radial;
        yAxis(value?: Object | boolean): anychart.charts.Polar;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase): anychart.charts.Polar;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Pert extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        criticalPath(): anychart.core.pert.CriticalPath;
        criticalPath(value?: Object): anychart.charts.Pert;
        data(): anychart.data.Tree;
        data(data?: anychart.data.Tree | Array<Object>, fillMethod?: anychart.enums.TreeFillingMethod | string, deps?: Array<anychart.data.Tree.Dependency>): anychart.charts.Pert;
        draw(async?: boolean): anychart.core.Chart;
        expectedTimeCalculator(): (() => void);
        expectedTimeCalculator(value?: (() => void)): anychart.charts.Pert;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        horizontalSpacing(): string | number;
        horizontalSpacing(value?: number | string): anychart.charts.Pert;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        milestones(): anychart.core.pert.Milestones;
        milestones(value?: Object): anychart.charts.Pert;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        tasks(): anychart.core.pert.Tasks;
        tasks(value?: Object): anychart.charts.Pert;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticalSpacing(): string | number;
        verticalSpacing(value?: number | string): anychart.charts.Pert;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Scatter extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.scatter.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.charts.Scatter;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        bubble(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.scatter.series.Bubble;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        crosshair(): anychart.core.ui.Crosshair;
        crosshair(value?: Object | boolean): anychart.charts.Scatter;
        defaultSeriesType(): string;
        defaultSeriesType(value?: string): anychart.charts.Scatter;
        draw(async?: boolean): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.scatter.series.Base;
        getSeriesAt(index: number): anychart.core.scatter.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        grid(index?: number): anychart.core.grids.Linear;
        grid(value?: Object | boolean): anychart.charts.Scatter;
        grid(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Scatter;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.scatter.series.Line;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(value?: Object | boolean): anychart.charts.Scatter;
        lineMarker(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.scatter.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Scatter;
        maxBubbleSize(): number | string;
        maxBubbleSize(value?: number | string): anychart.charts.Scatter;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minBubbleSize(): number | string;
        minBubbleSize(value?: number | string): anychart.charts.Scatter;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        minorGrid(index?: number): anychart.core.grids.Linear;
        minorGrid(value?: Object | boolean): anychart.charts.Scatter;
        minorGrid(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Scatter;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(value?: Object | boolean): anychart.charts.Scatter;
        rangeMarker(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Scatter;
        removeSeries(id: number | string): anychart.charts.Scatter;
        removeSeriesAt(index: number): anychart.charts.Scatter;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(value?: Object | boolean): anychart.charts.Scatter;
        textMarker(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(value?: Object | boolean): anychart.charts.Scatter;
        xAxis(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase): anychart.charts.Scatter;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.charts.Scatter;
        yAxis(index?: number, value?: Object | boolean): anychart.charts.Scatter;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase): anychart.charts.Scatter;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Cartesian3d extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        area(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Area3d;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bar(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Bar3d;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        column(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.cartesian.series.Column3d;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.Set | Array<any> | anychart.data.TableData): anychart.charts.Cartesian3d;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zAngle(): number;
        zAngle(value?: number): anychart.charts.Cartesian3d;
        zAspect(): number | string;
        zAspect(value?: number | string): anychart.charts.Cartesian3d;
        zDistribution(): boolean;
        zDistribution(value?: boolean): anychart.charts.Cartesian3d;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
        zPadding(): number;
        zPadding(value?: number): anychart.charts.Cartesian3d;
    }
    interface Stock extends anychart.core.Chart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        annotations(): anychart.core.annotations.ChartController;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        draw(async?: boolean): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        grouping(): anychart.core.stock.Grouping;
        grouping(value?: boolean | Array<(string|anychart.core.stock.Grouping.Level)> | Object): anychart.charts.Stock;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        plot(index?: number): anychart.core.stock.Plot;
        plot(value?: Object | boolean): anychart.charts.Stock;
        plot(index?: number, value?: Object | boolean): anychart.charts.Stock;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        scroller(): anychart.core.stock.Scroller;
        scroller(value?: Object | boolean): anychart.charts.Stock;
        scrollerGrouping(): anychart.core.stock.Grouping;
        scrollerGrouping(value?: boolean | Array<(string|anychart.core.stock.Grouping.Level)> | Object): anychart.charts.Stock;
        selectRange(start: number | string | Date, end: number | string | Date): anychart.charts.Stock;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.StockScatterDateTime;
        xScale(value?: string): anychart.charts.Stock;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Sparkline extends anychart.core.Chart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: anychart.math.Rect): anychart.charts.Sparkline;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.charts.Sparkline;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Sparkline;
        draw(async?: boolean): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        fill(color: string, opacity?: number): anychart.charts.Sparkline;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        firstFill(): anychart.graphics.vector.Fill;
        firstFill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        firstFill(color: string, opacity?: number): anychart.charts.Sparkline;
        firstFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        firstFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        firstFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        firstHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        firstHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        firstLabels(): anychart.core.ui.LabelsFactory.Label;
        firstLabels(value?: Object | boolean): anychart.charts.Sparkline;
        firstMarkers(): anychart.core.ui.MarkersFactory.Marker;
        firstMarkers(value?: Object | boolean): anychart.charts.Sparkline;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory.Label;
        labels(value?: Object | boolean): anychart.charts.Sparkline;
        lastFill(): anychart.graphics.vector.Fill;
        lastFill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        lastFill(color: string, opacity?: number): anychart.charts.Sparkline;
        lastFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        lastFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        lastFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        lastHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        lastHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        lastLabels(): anychart.core.ui.LabelsFactory.Label;
        lastLabels(value?: Object | boolean): anychart.charts.Sparkline;
        lastMarkers(): anychart.core.ui.MarkersFactory.Marker;
        lastMarkers(value?: Object | boolean): anychart.charts.Sparkline;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        lineMarker(index?: number): anychart.core.axisMarkers.Line;
        lineMarker(value?: Object | boolean): anychart.charts.Sparkline;
        lineMarker(index?: number, value?: Object | boolean): anychart.charts.Sparkline;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markers(): anychart.core.ui.MarkersFactory.Marker;
        markers(value?: Object | boolean): anychart.charts.Sparkline;
        maxFill(): anychart.graphics.vector.Fill;
        maxFill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        maxFill(color: string, opacity?: number): anychart.charts.Sparkline;
        maxFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        maxFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        maxFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        maxHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        maxHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxLabels(): anychart.core.ui.LabelsFactory.Label;
        maxLabels(value?: Object | boolean): anychart.charts.Sparkline;
        maxMarkers(): anychart.core.ui.MarkersFactory.Marker;
        maxMarkers(value?: Object | boolean): anychart.charts.Sparkline;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minFill(): anychart.graphics.vector.Fill;
        minFill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        minFill(color: string, opacity?: number): anychart.charts.Sparkline;
        minFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        minFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        minFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        minHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        minHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minLabels(): anychart.core.ui.LabelsFactory.Label;
        minLabels(value?: Object | boolean): anychart.charts.Sparkline;
        minMarkers(): anychart.core.ui.MarkersFactory.Marker;
        minMarkers(value?: Object | boolean): anychart.charts.Sparkline;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(value: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        negativeFill(color: string, opacity?: number): anychart.charts.Sparkline;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Sparkline;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Sparkline;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Sparkline;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.charts.Sparkline;
        negativeLabels(): anychart.core.ui.LabelsFactory.Label;
        negativeLabels(value?: Object | boolean): anychart.charts.Sparkline;
        negativeMarkers(): anychart.core.ui.MarkersFactory.Marker;
        negativeMarkers(value?: Object | boolean): anychart.charts.Sparkline;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.charts.Sparkline;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeMarker(index?: number): anychart.core.axisMarkers.Range;
        rangeMarker(value?: Object | boolean): anychart.charts.Sparkline;
        rangeMarker(index?: number, value?: Object | boolean): anychart.charts.Sparkline;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeOrFill?: (() => void)): anychart.charts.Sparkline;
        stroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Sparkline;
        textMarker(index?: number): anychart.core.axisMarkers.Text;
        textMarker(value?: Object | boolean): anychart.charts.Sparkline;
        textMarker(index?: number, value?: Object | boolean): anychart.charts.Sparkline;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        type(): string | anychart.enums.SparklineSeriesType;
        type(type?: string | anychart.enums.SparklineSeriesType): anychart.charts.Sparkline;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Sparkline;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.enums.ScaleTypes | anychart.scales.Base): anychart.charts.Sparkline;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radar extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.radar.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        area(data: anychart.data.View | anychart.data.Set | Array<any>, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.radar.series.Area;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        defaultSeriesType(): string | anychart.enums.RadarSeriesType;
        defaultSeriesType(value?: string | anychart.enums.RadarSeriesType): anychart.charts.Radar;
        draw(async?: boolean): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.radar.series.Base;
        getSeriesAt(index: number): anychart.core.radar.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        grid(index?: number): anychart.core.grids.Radar;
        grid(value?: Object | boolean): anychart.charts.Radar;
        grid(index?: number, value?: Object | boolean): anychart.charts.Radar;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        line(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.radar.series.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.radar.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Radar;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        minorGrid(index?: number): anychart.core.grids.Radar;
        minorGrid(value?: Object | boolean): anychart.charts.Radar;
        minorGrid(index?: number, value?: Object | boolean): anychart.charts.Radar;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Radar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Radar;
        removeSeries(id: number | string): anychart.charts.Radar;
        removeSeriesAt(index: number): anychart.charts.Radar;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.charts.Radar;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(): anychart.core.axes.Radar;
        xAxis(value?: Object | boolean): anychart.charts.Radar;
        xScale(): anychart.scales.Ordinal;
        xScale(value?: anychart.scales.Ordinal): anychart.charts.Radar;
        yAxis(): anychart.core.axes.Radar;
        yAxis(value?: Object | boolean): anychart.charts.Radar;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base | anychart.enums.ScaleTypes): anychart.charts.Radar;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface LinearGauge extends anychart.core.SeparateChart {
        addPointer(...var_args: (number)[]): Array<anychart.core.linearGauge.pointers.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        axis(index?: number): anychart.core.axes.LinearGauge;
        axis(value?: Object | boolean): anychart.charts.LinearGauge;
        axis(index?: number, value?: Object | boolean): anychart.charts.LinearGauge;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bar(dataIndex: number): anychart.core.linearGauge.pointers.Bar;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.LinearGauge;
        defaultPointerType(): anychart.enums.LinearGaugePointerType | string;
        defaultPointerType(value?: string | anychart.enums.LinearGaugePointerType): anychart.charts.LinearGauge;
        draw(async?: boolean): anychart.core.Chart;
        getPixelBounds(): anychart.math.Rect;
        getPointer(id: number | string): anychart.core.linearGauge.pointers.Base;
        getPointerAt(index: number): anychart.core.linearGauge.pointers.Base;
        getPointersCount(): number;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalOffset(): string | number;
        globalOffset(value?: string | number): anychart.charts.LinearGauge;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.LinearGauge;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        isVertical(): boolean;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        layout(): anychart.enums.Layout | string;
        layout(value?: string | anychart.enums.Layout): anychart.charts.LinearGauge;
        led(dataIndex: number): anychart.core.linearGauge.pointers.Led;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(dataIndex: number): anychart.core.linearGauge.pointers.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.LinearGauge;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.LinearGauge;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeBar(dataIndex: number): anychart.core.linearGauge.pointers.RangeBar;
        removeAllListeners(type?: string): number;
        removeAllPointers(): anychart.charts.LinearGauge;
        removePointer(id: number | string): anychart.charts.LinearGauge;
        removePointerAt(index: number): anychart.charts.LinearGauge;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        scale(): anychart.scales.Base;
        scale(value?: anychart.enums.ScaleTypes | string | anychart.scales.Base): anychart.charts.LinearGauge;
        scaleBar(index?: number): anychart.core.linearGauge.ScaleBar;
        scaleBar(value?: Object | boolean): anychart.charts.LinearGauge;
        scaleBar(index?: number, value?: Object | boolean): anychart.charts.LinearGauge;
        tank(dataIndex: number): anychart.core.linearGauge.pointers.Tank;
        thermometer(dataIndex: number): anychart.core.linearGauge.pointers.Thermometer;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface HeatMap extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        colorScale(): anychart.scales.OrdinalColor;
        colorScale(value?: anychart.scales.OrdinalColor): anychart.charts.HeatMap;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string | anychart.data.TableData, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.HeatMap;
        draw(async?: boolean): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.charts.HeatMap;
        fill(fillFunction?: (() => void)): anychart.charts.HeatMap;
        fill(color: string, opacity?: number): anychart.charts.HeatMap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.HeatMap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.HeatMap;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.HeatMap;
        getPixelBounds(): anychart.math.Rect;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        grid(index?: number): anychart.core.grids.Linear;
        grid(value?: Object | boolean): anychart.charts.HeatMap;
        grid(index?: number, value?: Object | boolean): anychart.charts.HeatMap;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.HeatMap;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(indexOrIndexes?: number | Array<number>): anychart.charts.HeatMap;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value: anychart.graphics.vector.Fill): anychart.charts.HeatMap;
        hoverFill(fillFunction?: (() => void)): anychart.charts.HeatMap;
        hoverFill(color: string, opacity?: number): anychart.charts.HeatMap;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.HeatMap;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.HeatMap;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.HeatMap;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.HeatMap;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.charts.HeatMap;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.charts.HeatMap;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(value?: (() => void)): anychart.charts.HeatMap;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.HeatMap;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.HeatMap;
        labelsDisplayMode(): string | anychart.enums.LabelsDisplayMode;
        labelsDisplayMode(value?: string | anychart.enums.LabelsDisplayMode): anychart.charts.HeatMap;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.charts.HeatMap;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        select(indexOrIndexes?: number | Array<number>): anychart.charts.HeatMap;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(value: anychart.graphics.vector.Fill): anychart.charts.HeatMap;
        selectFill(fillFunction?: (() => void)): anychart.charts.HeatMap;
        selectFill(color: string, opacity?: number): anychart.charts.HeatMap;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.HeatMap;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.HeatMap;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.HeatMap;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.HeatMap;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.charts.HeatMap;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.charts.HeatMap;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.charts.HeatMap;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.HeatMap;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: (() => void)): anychart.charts.HeatMap;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.HeatMap;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(index?: number): anychart.core.axes.Linear;
        xAxis(value?: Object | boolean): anychart.charts.HeatMap;
        xAxis(index?: number, value?: Object | boolean): anychart.charts.HeatMap;
        xScale(): anychart.scales.Ordinal;
        xScale(value?: anychart.enums.ScaleTypes | anychart.scales.Ordinal): anychart.charts.HeatMap;
        xScroller(): anychart.core.ui.ChartScroller;
        xScroller(value?: Object | boolean): anychart.charts.HeatMap;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.charts.HeatMap;
        yAxis(index?: number, value?: Object | boolean): anychart.charts.HeatMap;
        yScale(): anychart.scales.Ordinal;
        yScale(value?: anychart.enums.ScaleTypes | anychart.scales.Ordinal): anychart.charts.HeatMap;
        yScroller(): anychart.core.ui.ChartScroller;
        yScroller(value?: Object | boolean): anychart.charts.HeatMap;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Gantt extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        collapseAll(): anychart.charts.Gantt;
        collapseTask(taskId: string): anychart.charts.Gantt;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.charts.Gantt;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.Tree;
        data(value?: anychart.data.Tree | Array<Object>, fillMethod?: anychart.enums.TreeFillingMethod | string): anychart.charts.Gantt;
        dataGrid(): anychart.core.ui.DataGrid;
        dataGrid(enabled?: boolean): anychart.charts.Gantt;
        draw(): anychart.charts.Gantt;
        editing(): boolean;
        editing(value?: boolean): anychart.charts.Gantt;
        expandAll(): anychart.charts.Gantt;
        expandTask(taskId: string): anychart.charts.Gantt;
        fitAll(): anychart.charts.Gantt;
        fitToTask(taskId: string): anychart.charts.Gantt;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getTimeline(): anychart.core.ui.Timeline;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        headerHeight(): number | string;
        headerHeight(value?: number | string): anychart.charts.Gantt;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.charts.Gantt;
        rowHoverFill(color: string, opacity?: number): anychart.charts.Gantt;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Gantt;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Gantt;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.charts.Gantt;
        rowSelectedFill(color: string, opacity?: number): anychart.charts.Gantt;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Gantt;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Gantt;
        rowStroke(): string | anychart.graphics.vector.Stroke;
        rowStroke(value?: anychart.graphics.vector.Stroke | string): anychart.charts.Gantt;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        scrollTo(pxOffset: number): anychart.charts.Gantt;
        scrollToEnd(index?: number): anychart.charts.Gantt;
        scrollToRow(rowIndex: number): anychart.charts.Gantt;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
        zoomIn(zoomFactor?: number): anychart.charts.Gantt;
        zoomOut(zoomFactor?: number): anychart.charts.Gantt;
        zoomTo(startDate: number, endDate?: number): anychart.charts.Gantt;
    }
    interface CircularGauge extends anychart.core.Chart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        axis(): anychart.core.axes.Circular;
        axis(value?: Object | boolean): anychart.charts.CircularGauge;
        axis(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bar(index?: number): anychart.core.gauge.pointers.Bar;
        bar(value?: Object | boolean): anychart.charts.CircularGauge;
        bar(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cap(): anychart.core.gauge.Cap;
        cap(value?: Object | boolean): anychart.charts.CircularGauge;
        circularPadding(): string;
        circularPadding(value?: number | string): anychart.charts.CircularGauge;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.CircularGauge;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        encloseWithStraightLine(): boolean;
        encloseWithStraightLine(value?: boolean): anychart.charts.CircularGauge;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.charts.CircularGauge;
        fill(color: string, opacity?: number): anychart.charts.CircularGauge;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.CircularGauge;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.CircularGauge;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.CircularGauge;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        knob(index?: number): anychart.core.gauge.pointers.Knob;
        knob(value?: Object | boolean): anychart.charts.CircularGauge;
        knob(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(index?: number): anychart.core.gauge.pointers.Marker;
        marker(value?: Object | boolean): anychart.charts.CircularGauge;
        marker(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        needle(index?: number): anychart.core.gauge.pointers.Needle;
        needle(value?: Object | boolean): anychart.charts.CircularGauge;
        needle(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        range(index?: number): anychart.core.axisMarkers.CircularRange;
        range(value?: Object | boolean): anychart.charts.CircularGauge;
        range(index?: number, value?: Object | boolean): anychart.charts.CircularGauge;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        startAngle(): number;
        startAngle(value?: string | number): anychart.charts.CircularGauge;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.CircularGauge;
        sweepAngle(): number;
        sweepAngle(value?: string | number): anychart.charts.CircularGauge;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Pie extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        connectorLength(): number | string;
        connectorLength(value?: number | string): anychart.charts.Pie;
        connectorStroke(): anychart.graphics.vector.Stroke;
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pie;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | anychart.data.TableData | Array<any>, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Pie;
        draw(async?: boolean): anychart.core.Chart;
        explode(): string | number;
        explode(value?: string | number): anychart.charts.Pie;
        explodeSlice(index: number, explode?: boolean): anychart.charts.Pie;
        explodeSlices(value: boolean): anychart.charts.Pie;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(fillFunction?: (() => void)): anychart.charts.Pie;
        fill(value: anychart.graphics.vector.Fill): anychart.charts.Pie;
        fill(color: string, opacity?: number): anychart.charts.Pie;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pie;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pie;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pie;
        forceHoverLabels(): boolean;
        forceHoverLabels(value?: boolean): anychart.charts.Pie;
        getCenterPoint(): anychart.math.Coordinate;
        getPixelBounds(): anychart.math.Rect;
        getPixelExplode(): number;
        getPixelInnerRadius(): number;
        getPixelRadius(): number;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        group(): (() => void);
        group(value?: string | (() => void)): anychart.charts.Pie;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Pie;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Pie;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(index?: number): anychart.charts.Pie;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(fillFunction?: anychart.graphics.vector.Fill | (() => void)): anychart.charts.Pie;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.charts.Pie;
        hoverFill(color: string, opacity?: number): anychart.charts.Pie;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pie;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pie;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pie;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Pie;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.charts.Pie;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(strokeFunction?: (() => void)): anychart.charts.Pie;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pie;
        innerRadius(): string | number | (() => void);
        innerRadius(value?: string | number | (() => void)): anychart.charts.Pie;
        insideLabelsOffset(): number | string;
        insideLabelsOffset(value?: number | string): anychart.charts.Pie;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Pie;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        outsideLabelsCriticalAngle(): number | string;
        outsideLabelsCriticalAngle(value?: number | string): anychart.charts.Pie;
        outsideLabelsSpace(): number | string;
        outsideLabelsSpace(value?: number | string): anychart.charts.Pie;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.charts.Pie;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Pie;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        radius(): string | number;
        radius(value?: string | number): anychart.charts.Pie;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        sort(): anychart.enums.Sort;
        sort(value?: anychart.enums.Sort | string): anychart.charts.Pie;
        startAngle(): string | number;
        startAngle(value?: string | number): anychart.charts.Pie;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(fillFunction?: (() => void)): anychart.charts.Pie;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pie;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.charts.Pie;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(): anychart.charts.Pie;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Funnel extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        baseWidth(): string | number;
        baseWidth(value?: string | number): anychart.charts.Funnel;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        connectorLength(): number | string;
        connectorLength(value?: number | string): anychart.charts.Funnel;
        connectorStroke(): anychart.graphics.vector.Stroke | (() => void);
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Funnel;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | Array<any> | string | anychart.data.TableData, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Funnel;
        draw(async?: boolean): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(fillFunction?: (() => void)): anychart.charts.Funnel;
        fill(value: anychart.graphics.vector.Fill): anychart.charts.Funnel;
        fill(color: string, opacity?: number): anychart.charts.Funnel;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Funnel;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Funnel;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Funnel;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Funnel;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Funnel;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(index?: number): anychart.charts.Funnel;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value?: anychart.graphics.vector.Fill | (() => void)): anychart.charts.Funnel;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.charts.Funnel;
        hoverFill(color: string, opacity?: number): anychart.charts.Funnel;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Funnel;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Funnel;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Funnel;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Funnel;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.charts.Funnel;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.charts.Funnel;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.charts.Funnel;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Funnel;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Funnel;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Funnel;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.charts.Funnel;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        neckHeight(): string | number;
        neckHeight(value?: string | number): anychart.charts.Funnel;
        neckWidth(): string | number;
        neckWidth(value?: string | number): anychart.charts.Funnel;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.charts.Funnel;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Funnel;
        pointsPadding(): string | number;
        pointsPadding(value?: string | number): anychart.charts.Funnel;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        select(index?: number): anychart.charts.Funnel;
        select(indexes?: Array<number>): anychart.charts.Funnel;
        select(): anychart.charts.Funnel;
        select(): anychart.charts.Pyramid;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(func?: (() => void)): anychart.charts.Funnel;
        selectFill(value: anychart.graphics.vector.Fill): anychart.charts.Funnel;
        selectFill(color: string, opacity?: number): anychart.charts.Funnel;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Funnel;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Funnel;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Funnel;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Funnel;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.charts.Funnel;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.charts.Funnel;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(func?: (() => void)): anychart.charts.Funnel;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Funnel;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.charts.Funnel;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Funnel;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.charts.Funnel;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(): anychart.charts.Funnel;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.charts.Funnel;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Map extends anychart.core.SeparateChart {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.map.series.Base>;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        bubble(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.map.series.Bubble;
        choropleth(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.map.series.Choropleth;
        colorRange(): anychart.core.ui.ColorRange;
        colorRange(value?: Object): anychart.charts.Map;
        connector(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.map.series.Connector;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        crs(value?: Object | (() => void) | anychart.enums.MapProjections | string): void;
        crsAnimation(): anychart.core.utils.Animation;
        crsAnimation(value?: boolean | Object, duration?: number): anychart.charts.Map;
        defaultSeriesType(): anychart.enums.MapSeriesType | string;
        defaultSeriesType(value?: string | anychart.enums.MapSeriesType): anychart.charts.Map;
        draw(async?: boolean): anychart.core.Chart;
        drillDownMap(value?: {[prop: string]: (Object|anychart.charts.Map)}): Object;
        drillTo(id: string, map?: anychart.charts.Map): anychart.charts.Map;
        drillUp(): anychart.charts.Map;
        featureCrs(id: string): string;
        featureCrs(id: string, crs?: string): anychart.charts.Map;
        featureScaleFactor(id: string): number;
        featureScaleFactor(id: string, ratio?: number): anychart.charts.Map;
        featureTranslation(id: string): Array<number>;
        featureTranslation(id: string, dx?: number, dy?: number): anychart.charts.Map;
        geoData(): Node | string | Object;
        geoData(data?: Node | string | Object): Node | string | Object;
        geoIdField(): string;
        geoIdField(value?: string): anychart.charts.Map;
        getDrilldownPath(): Array<anychart.core.MapPoint>;
        getPixelBounds(): anychart.math.Rect;
        getPlotBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getSeries(id: number | string): anychart.core.map.series.Base;
        getSeriesAt(index: number): anychart.core.map.series.Base;
        getSeriesCount(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Map;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        inverseTransform(x: number, y: number): {[prop: string]: number};
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        marker(data: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.map.series.Marker;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Map;
        maxBubbleSize(): number | string;
        maxBubbleSize(value?: number | string): anychart.charts.Map;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minBubbleSize(): number | string;
        minBubbleSize(value?: number | string): anychart.charts.Map;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        move(dx: number, dy: number): anychart.charts.Map;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.charts.Map;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Map;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.charts.Map;
        removeSeries(id: number | string): anychart.charts.Map;
        removeSeriesAt(index: number): anychart.charts.Map;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toGeoJSON(): Object;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transform(xLong: number, yLat: number): {[prop: string]: number};
        translateFeature(id: string, dx: number, dy: number): anychart.charts.Map;
        unboundRegions(): anychart.core.utils.UnboundRegionsSettings | anychart.enums.MapUnboundRegionsMode;
        unboundRegions(value?: Object | anychart.enums.MapUnboundRegionsMode | string | boolean): anychart.charts.Map;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
        zoom(value: number, cx?: number, cy?: number): anychart.charts.Map;
        zoomTo(value: number, cx?: number, cy?: number): anychart.charts.Map;
        zoomToFeature(id: string): void;
    }
    interface Pyramid extends anychart.core.SeparateChart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        baseWidth(): string | number;
        baseWidth(value?: string | number): anychart.charts.Pyramid;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        connectorLength(): number | string;
        connectorLength(value?: number | string): anychart.charts.Pyramid;
        connectorStroke(): anychart.graphics.vector.Stroke | (() => void);
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pyramid;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Mapping | anychart.data.Set | Array<any> | string | anychart.data.TableData, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.Pyramid;
        draw(async?: boolean): anychart.core.Chart;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value?: anychart.graphics.vector.Fill | (() => void)): anychart.charts.Pyramid;
        fill(value: anychart.graphics.vector.Fill): anychart.charts.Pyramid;
        fill(color: string, opacity?: number): anychart.charts.Pyramid;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pyramid;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pyramid;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pyramid;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getType(): string;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Pyramid;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.charts.Pyramid;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(index?: number): anychart.charts.Pyramid;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value?: anychart.graphics.vector.Fill | (() => void)): anychart.charts.Pyramid;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.charts.Pyramid;
        hoverFill(color: string, opacity?: number): anychart.charts.Pyramid;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pyramid;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pyramid;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pyramid;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Pyramid;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.charts.Pyramid;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.charts.Pyramid;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(strokeFunction?: anychart.graphics.vector.Stroke | (() => void)): anychart.charts.Pyramid;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pyramid;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.charts.Pyramid;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        markerPalette(): anychart.palettes.Markers;
        markerPalette(value?: anychart.palettes.Markers | Object | Array<anychart.enums.MarkerType>): anychart.charts.Pyramid;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.charts.Pyramid;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.charts.Pyramid;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.charts.Pyramid;
        pointsPadding(): string | number;
        pointsPadding(value?: string | number): anychart.charts.Pyramid;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        reversed(): boolean;
        reversed(value?: boolean): anychart.charts.Pyramid;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        select(index?: number): anychart.charts.Pyramid;
        select(indexes?: Array<number>): anychart.charts.Pyramid;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(func?: (() => void)): anychart.charts.Pyramid;
        selectFill(value: anychart.graphics.vector.Fill): anychart.charts.Pyramid;
        selectFill(color: string, opacity?: number): anychart.charts.Pyramid;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.charts.Pyramid;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.charts.Pyramid;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.charts.Pyramid;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.charts.Pyramid;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.charts.Pyramid;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.charts.Pyramid;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(func?: (() => void)): anychart.charts.Pyramid;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pyramid;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.charts.Pyramid;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.charts.Pyramid;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.charts.Pyramid;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(): anychart.charts.Pyramid;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.charts.Pyramid;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.color {
    function bipolarHueProgression(color1?: string, color2?: string, count?: number): Array<string>;
    function blend(rgb1: Array<number>, rgb2: Array<number>, factor: number): Array<number>;
    function blendedHueProgression(color1?: string, color2?: string, count?: number): Array<string>;
    function darken(fillOrStroke: anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke, factor?: number): string | anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke;
    function lighten(fillOrStroke: anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke, factor?: number): string | anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke;
    function singleHueProgression(color?: string, count?: number, startOrTargetLightness?: number, endLightness?: number): Array<string>;
}

declare namespace anychart.core {
    interface MouseEvent {
        altKey: boolean;
        button: number;
        charCode: number;
        clientX: number;
        clientY: number;
        ctrlKey: boolean;
        currentTarget: anychart.core.VisualBase | anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        domTarget: anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        keyCode: number;
        metaKey: boolean;
        offsetX: number;
        offsetY: number;
        platformModifierKey: boolean;
        relatedDomTarget: anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        relatedTarget: anychart.core.VisualBase | anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        screenX: number;
        screenY: number;
        shiftKey: boolean;
        target: anychart.core.VisualBase | anychart.graphics.vector.Element | anychart.graphics.vector.Stage | Node;
        type: anychart.graphics.events.EventType;
    }
    interface VisualBase extends anychart.core.Base {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.Point;
        selected(): boolean;
        selected(value?: boolean): anychart.core.Point;
        set(field: string, value: any): anychart.core.Point;
    }
    interface Base {
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface SeparateChart extends anychart.core.ChartWithCredits {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        interactivity(): anychart.core.utils.Interactivity;
        interactivity(value?: Object | anychart.enums.HoverMode): anychart.core.SeparateChart;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.Chart;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Chart extends anychart.core.VisualBaseWithBounds {
        a11y(): anychart.core.utils.ChartA11y;
        a11y(value?: boolean | Object): anychart.core.Chart;
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getJpgBase64String(onSuccess: (() => void), onError?: (() => void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccess: (() => void), onError?: (() => void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccess: (() => void), onError?: (() => void), width?: number, height?: number, quality?: number): void;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        getSvgBase64String(onSuccess: (() => void), onError?: (() => void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        shareAsJpg(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toA11yTable(title?: string, asString?: boolean): Element | string;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toHtmlTable(title?: string, asString?: boolean): Element | string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ChartWithCredits extends anychart.core.Chart {
        animation(): anychart.core.utils.Animation;
        animation(value?: boolean | Object): anychart.core.Chart;
        animation(enabled: boolean, duration: number): anychart.core.Chart;
        background(): anychart.core.ui.Background;
        background(value?: Object): anychart.core.Chart;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        container(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage | string | Element): anychart.core.Chart;
        contextMenu(): anychart.ui.ContextMenu;
        contextMenu(value?: Object | boolean): anychart.core.Chart;
        credits(): anychart.core.ui.ChartCredits;
        credits(value?: Object | boolean): anychart.core.Chart;
        draw(async?: boolean): anychart.core.Chart;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getSelectedPoints(): Array<anychart.core.Point>;
        getStat(key: string | anychart.enums.Statistics): any;
        globalToLocal(xCoord: number, yCoord: number): {[prop: string]: number};
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        label(index?: string | number): anychart.core.ui.Label;
        label(value?: boolean | Object | string): anychart.core.Chart;
        label(index?: string | number, value?: boolean | Object | string): anychart.core.Chart;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        localToGlobal(xCoord: number, yCoord: number): {[prop: string]: number};
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object): anychart.core.Chart;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.Chart;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.Chart;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        saveAsCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}, filename?: string): void;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsJson(includeTheme?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        saveAsXlsx(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, filename?: string): void;
        saveAsXml(includeTheme?: boolean, filename?: string): void;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.Chart;
        toCsv(chartDataExportMode?: string | anychart.enums.ChartDataExportMode, csvSettings?: {[prop: string]: (string|boolean)}): string;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        tooltip(): anychart.core.ui.ChartTooltip | anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.Chart;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface SeriesPoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getSeries(): anychart.core.SeriesBase;
        getStackValue(): number;
        getStackZero(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.SeriesPoint;
        selected(): boolean;
        selected(value?: boolean): anychart.core.SeriesPoint;
        set(field: string, value: any): anychart.core.Point;
    }
    interface SeriesBase extends anychart.core.VisualBaseWithBounds {
        a11y(): anychart.core.utils.SeriesA11y;
        a11y(value?: boolean | Object): anychart.core.SeriesBase;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Text extends anychart.core.VisualBase {
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface TreeMapPoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getNode(): anychart.data.Tree.DataItem;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.TreeMapPoint;
        selected(): boolean;
        selected(value?: boolean): anychart.core.TreeMapPoint;
        set(field: string, value: any): anychart.core.TreeMapPoint;
    }
    interface VisualBaseWithBounds extends anychart.core.VisualBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ChoroplethPoint extends anychart.core.SeriesPoint {
        crs(): string;
        crs(crs?: string): anychart.core.ChoroplethPoint;
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getFeatureBounds(): anychart.math.Rect;
        getFeatureProp(): Object;
        getIndex(): number;
        getSeries(): anychart.core.SeriesBase;
        getStackValue(): number;
        getStackZero(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.SeriesPoint;
        middleX(): number;
        middleX(value?: number): anychart.core.ChoroplethPoint;
        middleY(): number;
        middleY(value?: number): anychart.core.ChoroplethPoint;
        scaleFactor(): number;
        scaleFactor(scale?: number): anychart.core.ChoroplethPoint;
        selected(): boolean;
        selected(value?: boolean): anychart.core.SeriesPoint;
        set(field: string, value: any): anychart.core.Point;
        translate(dx: number, dy: number): anychart.core.ChoroplethPoint;
        translation(): Array<number>;
        translation(dx?: number, dy?: number): anychart.core.ChoroplethPoint;
    }
    interface PiePoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getEndAngle(): number;
        getIndex(): number;
        getStartAngle(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.Point;
        selected(): boolean;
        selected(value?: boolean): anychart.core.PiePoint;
        set(field: string, value: any): anychart.core.Point;
    }
    interface BubblePoint extends anychart.core.SeriesPoint {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getIndex(): number;
        getPixelRadius(): number;
        getSeries(): anychart.core.SeriesBase;
        getStackValue(): number;
        getStackZero(): number;
        getStat(key: string | anychart.enums.Statistics): any;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.SeriesPoint;
        selected(): boolean;
        selected(value?: boolean): anychart.core.SeriesPoint;
        set(field: string, value: any): anychart.core.Point;
    }
    interface MapPoint extends anychart.core.Point {
        exists(): boolean;
        get(field: string): any;
        getChart(): anychart.core.SeparateChart;
        getCurrentChart(): anychart.core.SeparateChart;
        getId(): string;
        getIndex(): number;
        getParentChart(): anychart.core.SeparateChart;
        getProperties(): Object;
        hovered(): boolean;
        hovered(value?: boolean): anychart.core.Point;
        selected(): boolean;
        selected(value?: boolean): anychart.core.Point;
        set(field: string, value: any): anychart.core.Point;
    }
}

declare namespace anychart.core.annotations {
    interface AnnotationJSONFormat {
        allowEdit: boolean;
        anchor: anychart.enums.Anchor;
        color: anychart.graphics.vector.AnyColor;
        fill: anychart.graphics.vector.Fill | (() => void);
        grid: anychart.graphics.vector.Stroke | (() => void);
        hatchFill: anychart.graphics.vector.PatternFill | (() => void);
        hoverFill: anychart.graphics.vector.Fill | (() => void);
        hoverGap: number;
        hoverGrid: anychart.graphics.vector.Stroke | (() => void);
        hoverHatchFill: anychart.graphics.vector.PatternFill | (() => void);
        hoverSize: number;
        hoverStroke: anychart.graphics.vector.Stroke | (() => void);
        hoverTrend: anychart.graphics.vector.Stroke | (() => void);
        markerType: anychart.enums.MarkerType;
        offsetX: number;
        offsetY: number;
        secondValueAnchor: number;
        secondXAnchor: number;
        selectFill: anychart.graphics.vector.Fill | (() => void);
        selectGrid: anychart.graphics.vector.Stroke | (() => void);
        selectHatchFill: anychart.graphics.vector.PatternFill | (() => void);
        selectSize: number;
        selectStroke: anychart.graphics.vector.Stroke | (() => void);
        selectTrend: anychart.graphics.vector.Stroke | (() => void);
        size: number;
        stroke: anychart.graphics.vector.Stroke | (() => void);
        thirdValueAnchor: number;
        thirdXAnchor: number;
        trend: anychart.graphics.vector.Stroke | (() => void);
        valueAnchor: number;
        xAnchor: number;
    }
    interface Ray extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.Ray;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Ray;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.Ray;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Ray;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.Ray;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Ray;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Ray;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Ray;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Ray;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Ray;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface InfiniteLine extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.InfiniteLine;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.InfiniteLine;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.InfiniteLine;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.InfiniteLine;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.InfiniteLine;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.InfiniteLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.InfiniteLine;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.InfiniteLine;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.InfiniteLine;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.InfiniteLine;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface FibonacciFan extends anychart.core.annotations.FibonacciBase {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        grid(): anychart.graphics.vector.Stroke;
        grid(gridFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        grid(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverGrid(): anychart.graphics.vector.Stroke;
        hoverGrid(gridFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        hoverGrid(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        hoverTrend(): anychart.graphics.vector.Stroke;
        hoverTrend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        hoverTrend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        levels(): Array<number>;
        levels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciFan;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciFan;
        selectGrid(): anychart.graphics.vector.Stroke;
        selectGrid(gridFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        selectGrid(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        selectTrend(): anychart.graphics.vector.Stroke;
        selectTrend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        selectTrend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        timeLevels(): Array<number>;
        timeLevels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciFan;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciFan;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciFan;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciFan;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface Rectangle extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Rectangle;
        fill(fillFunction?: (() => void)): anychart.core.annotations.Rectangle;
        fill(color: string, opacity?: number): anychart.core.annotations.Rectangle;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Rectangle;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Rectangle;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Rectangle;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Rectangle;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Rectangle;
        hoverFill(fillFunction?: (() => void)): anychart.core.annotations.Rectangle;
        hoverFill(color: string, opacity?: number): anychart.core.annotations.Rectangle;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Rectangle;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Rectangle;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Rectangle;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Rectangle;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.Rectangle;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Rectangle;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(value: any): anychart.core.annotations.Rectangle;
        secondXAnchor(): any;
        secondXAnchor(value: any): anychart.core.annotations.Rectangle;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Rectangle;
        selectFill(fillFunction?: (() => void)): anychart.core.annotations.Rectangle;
        selectFill(color: string, opacity?: number): anychart.core.annotations.Rectangle;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Rectangle;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Rectangle;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Rectangle;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Rectangle;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.Rectangle;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Rectangle;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Rectangle;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Rectangle;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Rectangle;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Rectangle;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface AndrewsPitchfork extends anychart.core.annotations.Base {
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.AndrewsPitchfork;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.AndrewsPitchfork;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.AndrewsPitchfork;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.AndrewsPitchfork;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.AndrewsPitchfork;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.AndrewsPitchfork;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.AndrewsPitchfork;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.AndrewsPitchfork;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.AndrewsPitchfork;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.AndrewsPitchfork;
        thirdValueAnchor(): any;
        thirdValueAnchor(Third: any): anychart.core.annotations.AndrewsPitchfork;
        thirdXAnchor(): any;
        thirdXAnchor(Third: any): anychart.core.annotations.AndrewsPitchfork;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.AndrewsPitchfork;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.AndrewsPitchfork;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface Base extends anychart.core.VisualBaseWithBounds {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getChart(): anychart.core.SeparateChart;
        getPixelBounds(): anychart.math.Rect;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface PlotController extends anychart.core.VisualBase {
        add(annotationTypeOrConfig: anychart.enums.AnnotationTypes | anychart.core.annotations.AnnotationJSONFormat): anychart.core.annotations.Base;
        andrewsPitchfork(config?: Object): anychart.core.annotations.AndrewsPitchfork;
        cancelDrawing(): void;
        ellipse(config?: Object): anychart.core.annotations.Ellipse;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fibonacciArc(config?: Object): anychart.core.annotations.FibonacciArc;
        fibonacciFan(config?: Object): anychart.core.annotations.FibonacciFan;
        fibonacciRetracement(config?: Object): anychart.core.annotations.FibonacciRetracement;
        fibonacciTimezones(config?: Object): anychart.core.annotations.FibonacciTimezones;
        fromJson(config: Object | string): anychart.core.annotations.PlotController;
        fromXml(config: string | Node): anychart.core.annotations.PlotController;
        getAnnotationAt(index: number): anychart.core.annotations.Base;
        getAnnotationsCount(): number;
        getSelectedAnnotation(): anychart.core.annotations.Base;
        horizontalLine(config?: Object): anychart.core.annotations.HorizontalLine;
        infiniteLine(config?: Object): anychart.core.annotations.InfiniteLine;
        line(config?: Object): anychart.core.annotations.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        marker(config?: Object): anychart.core.annotations.Marker;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        ray(config?: Object): anychart.core.annotations.Ray;
        rectangle(config?: Object): anychart.core.annotations.Rectangle;
        removeAllAnnotations(): anychart.core.annotations.PlotController;
        removeAllListeners(type?: string): number;
        removeAnnotation(annotation: anychart.core.annotations.Base): anychart.core.annotations.PlotController;
        removeAnnotationAt(index: number): anychart.core.annotations.PlotController;
        select(annotation: anychart.core.annotations.Base): anychart.core.annotations.PlotController;
        startDrawing(annotationTypeOrConfig: anychart.enums.AnnotationTypes | anychart.core.annotations.AnnotationJSONFormat): anychart.core.annotations.Base;
        toJson(stringify?: boolean, includeTheme?: boolean): Object | string;
        toXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        trendChannel(config?: Object): anychart.core.annotations.TrendChannel;
        triangle(config?: Object): anychart.core.annotations.Triangle;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.annotations.PlotController;
        verticalLine(config?: Object): anychart.core.annotations.VerticalLine;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface FibonacciBase extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        hoverTrend(): anychart.graphics.vector.Stroke;
        hoverTrend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        hoverTrend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        levels(): Array<number>;
        levels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciBase;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        selectTrend(): anychart.graphics.vector.Stroke;
        selectTrend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        selectTrend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciBase;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciBase;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface Triangle extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Triangle;
        fill(fillFunction?: (() => void)): anychart.core.annotations.Triangle;
        fill(color: string, opacity?: number): anychart.core.annotations.Triangle;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Triangle;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Triangle;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Triangle;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Triangle;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Triangle;
        hoverFill(fillFunction?: (() => void)): anychart.core.annotations.Triangle;
        hoverFill(color: string, opacity?: number): anychart.core.annotations.Triangle;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Triangle;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Triangle;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Triangle;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Triangle;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.Triangle;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Triangle;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.Triangle;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Triangle;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Triangle;
        selectFill(fillFunction?: (() => void)): anychart.core.annotations.Triangle;
        selectFill(color: string, opacity?: number): anychart.core.annotations.Triangle;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Triangle;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Triangle;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Triangle;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Triangle;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.Triangle;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Triangle;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Triangle;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Triangle;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Triangle;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Triangle;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface FibonacciRetracement extends anychart.core.annotations.FibonacciBase {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        hoverTrend(): anychart.graphics.vector.Stroke;
        hoverTrend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        hoverTrend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        levels(): Array<number>;
        levels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciBase;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        selectTrend(): anychart.graphics.vector.Stroke;
        selectTrend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        selectTrend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciBase;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciBase;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciBase;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciBase;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface TrendChannel extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.annotations.TrendChannel;
        fill(fillFunction?: (() => void)): anychart.core.annotations.TrendChannel;
        fill(color: string, opacity?: number): anychart.core.annotations.TrendChannel;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.TrendChannel;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.TrendChannel;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.TrendChannel;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.TrendChannel;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.annotations.TrendChannel;
        hoverFill(fillFunction?: (() => void)): anychart.core.annotations.TrendChannel;
        hoverFill(color: string, opacity?: number): anychart.core.annotations.TrendChannel;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.TrendChannel;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.TrendChannel;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.TrendChannel;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.TrendChannel;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.TrendChannel;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.TrendChannel;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.TrendChannel;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.TrendChannel;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.annotations.TrendChannel;
        selectFill(fillFunction?: (() => void)): anychart.core.annotations.TrendChannel;
        selectFill(color: string, opacity?: number): anychart.core.annotations.TrendChannel;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.TrendChannel;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.TrendChannel;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.TrendChannel;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.TrendChannel;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.TrendChannel;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.TrendChannel;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.TrendChannel;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.TrendChannel;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.TrendChannel;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.TrendChannel;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface VerticalLine extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.VerticalLine;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.VerticalLine;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.VerticalLine;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.VerticalLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.VerticalLine;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.VerticalLine;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.VerticalLine;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface HorizontalLine extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.HorizontalLine;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.HorizontalLine;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.HorizontalLine;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.HorizontalLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.HorizontalLine;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.HorizontalLine;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.HorizontalLine;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface ChartController extends anychart.core.Base {
        cancelDrawing(): void;
        getSelectedAnnotation(): anychart.core.annotations.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllAnnotations(): anychart.core.annotations.ChartController;
        removeAllListeners(type?: string): number;
        removeAnnotation(annotation: anychart.core.annotations.Base): anychart.core.annotations.ChartController;
        select(annotation: anychart.core.annotations.Base): anychart.core.annotations.ChartController;
        startDrawing(annotationTypeOrConfig: anychart.enums.AnnotationTypes | anychart.core.annotations.AnnotationJSONFormat): anychart.core.annotations.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.annotations.ChartController;
    }
    interface FibonacciArc extends anychart.core.annotations.FibonacciBase {
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.FibonacciArc;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.FibonacciArc;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciArc;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciArc;
        hoverTrend(): anychart.graphics.vector.Stroke;
        hoverTrend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciArc;
        hoverTrend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciArc;
        levels(): Array<number>;
        levels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciArc;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciArc;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciArc;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciArc;
        selectTrend(): anychart.graphics.vector.Stroke;
        selectTrend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciArc;
        selectTrend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciArc;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciArc;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciArc;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciArc;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciArc;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciArc;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciArc;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface Line extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.Line;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Line;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.Line;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Line;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.Line;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Line;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Line;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Line;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Line;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Line;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface FibonacciTimezones extends anychart.core.annotations.FibonacciBase {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciTimezones;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciTimezones;
        hoverTrend(): anychart.graphics.vector.Stroke;
        hoverTrend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciTimezones;
        hoverTrend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciTimezones;
        levels(): Array<number>;
        levels(values?: Array<any>): anychart.core.annotations.FibonacciBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.FibonacciTimezones;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.FibonacciTimezones;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciTimezones;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciTimezones;
        selectTrend(): anychart.graphics.vector.Stroke;
        selectTrend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciTimezones;
        selectTrend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciTimezones;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.FibonacciTimezones;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciTimezones;
        trend(): anychart.graphics.vector.Stroke;
        trend(trendFunction?: (() => void)): anychart.core.annotations.FibonacciTimezones;
        trend(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.FibonacciTimezones;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.FibonacciTimezones;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.FibonacciTimezones;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface Ellipse extends anychart.core.annotations.Base {
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Ellipse;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Ellipse;
        fill(fillFunction?: (() => void)): anychart.core.annotations.Ellipse;
        fill(color: string, opacity?: number): anychart.core.annotations.Ellipse;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Ellipse;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Ellipse;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Ellipse;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Ellipse;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Ellipse;
        hoverFill(fillFunction?: (() => void)): anychart.core.annotations.Ellipse;
        hoverFill(color: string, opacity?: number): anychart.core.annotations.Ellipse;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Ellipse;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Ellipse;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Ellipse;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Ellipse;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Ellipse;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.Ellipse;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Ellipse;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        secondValueAnchor(): any;
        secondValueAnchor(Second: any): anychart.core.annotations.Ellipse;
        secondXAnchor(): any;
        secondXAnchor(Second: any): anychart.core.annotations.Ellipse;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Ellipse;
        selectFill(fillFunction?: (() => void)): anychart.core.annotations.Ellipse;
        selectFill(color: string, opacity?: number): anychart.core.annotations.Ellipse;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Ellipse;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Ellipse;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Ellipse;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Ellipse;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.Ellipse;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Ellipse;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Ellipse;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Ellipse;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Ellipse;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Ellipse;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
    interface Marker extends anychart.core.annotations.Base {
        allowEdit(): boolean;
        allowEdit(value: any): anychart.core.annotations.Base;
        anchor(): anychart.enums.Anchor | string;
        anchor(value: anychart.enums.Anchor | string): anychart.core.annotations.Marker;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.annotations.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Marker;
        fill(fillFunction?: (() => void)): anychart.core.annotations.Marker;
        fill(color: string, opacity?: number): anychart.core.annotations.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Marker;
        getChart(): anychart.core.SeparateChart;
        getPlot(): anychart.core.stock.Plot;
        getType(): anychart.enums.AnnotationTypes | string;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Marker;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Marker;
        hoverFill(fillFunction?: (() => void)): anychart.core.annotations.Marker;
        hoverFill(color: string, opacity?: number): anychart.core.annotations.Marker;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Marker;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Marker;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Marker;
        hoverGap(): number;
        hoverGap(value: any): anychart.core.annotations.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Marker;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        hoverSize(): number;
        hoverSize(value?: number): anychart.core.annotations.Marker;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.annotations.Marker;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Marker;
        hoverStroke(): anychart.graphics.vector.Stroke;
        markerType(): anychart.enums.MarkerType | string;
        markerType(value: anychart.enums.MarkerType | string): anychart.core.annotations.Marker;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.annotations.Base;
        offsetX(): number | string;
        offsetX(value: number | string): anychart.core.annotations.Marker;
        offsetY(): number | string;
        offsetY(value: number | string): anychart.core.annotations.Marker;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.annotations.Marker;
        selectFill(fillFunction?: (() => void)): anychart.core.annotations.Marker;
        selectFill(color: string, opacity?: number): anychart.core.annotations.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.annotations.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.annotations.Marker;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.annotations.Marker;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.annotations.Marker;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.annotations.Base;
        selectSize(): number;
        selectSize(value?: number): anychart.core.annotations.Marker;
        selectStroke(strokeFunction?: (() => void)): anychart.core.annotations.Marker;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Marker;
        size(): number;
        size(value?: number): anychart.core.annotations.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.annotations.Marker;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.annotations.Marker;
        valueAnchor(): any;
        valueAnchor(value: any): anychart.core.annotations.Marker;
        xAnchor(): any;
        xAnchor(value: any): anychart.core.annotations.Marker;
        xScale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        xScale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.annotations.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.annotations.Base;
    }
}

declare namespace anychart.core.axes {
    interface CircularTicks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.axes.CircularTicks;
        fill(color: string, opacity?: number): anychart.core.axes.CircularTicks;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axes.CircularTicks;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axes.CircularTicks;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axes.CircularTicks;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.axes.CircularTicks;
        length(): string;
        length(value?: number | string): anychart.core.axes.CircularTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.SidePosition | string;
        position(value?: anychart.enums.SidePosition | string): anychart.core.axes.CircularTicks;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.axes.CircularTicks;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.CircularTicks;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.axes.CircularTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Polar extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Polar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Polar;
        minorTicks(): anychart.core.axes.RadialTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Polar;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Polar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.ScatterBase;
        scale(value?: anychart.scales.ScatterBase): anychart.core.axes.Polar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Polar;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Polar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Linear extends anychart.core.VisualBase {
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Linear;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Linear;
        orientation(): anychart.enums.Orientation;
        orientation(value?: string | anychart.enums.Orientation): anychart.core.axes.Linear;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Linear;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axes.Linear;
        staggerLines(): number;
        staggerLines(value?: number): anychart.core.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(value?: number): anychart.core.axes.Linear;
        staggerMode(): boolean;
        staggerMode(value?: boolean): anychart.core.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(value?: Object | boolean): anychart.core.axes.Linear;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.axes.Linear;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StockTicks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke): anychart.core.axes.StockTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radial extends anychart.core.VisualBase {
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Radial;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Radial;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Radial;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Radial;
        minorTicks(): anychart.core.axes.RadialTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Radial;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Radial;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axes.Radial;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Radial;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Radial;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RadialTicks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        length(): number;
        length(value?: number): anychart.core.axes.RadialTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke): anychart.core.axes.RadialTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Ticks extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        length(): number;
        length(value?: number): anychart.core.axes.Ticks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.SidePosition | string;
        position(value?: anychart.enums.SidePosition | string): anychart.core.axes.Ticks;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke): anychart.core.axes.Ticks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Circular extends anychart.core.VisualBase {
        cornersRounding(): string;
        cornersRounding(value?: number | string): anychart.core.axes.Circular;
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Circular;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Circular;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.axes.Circular;
        fill(color: string, opacity?: number): anychart.core.axes.Circular;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axes.Circular;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axes.Circular;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axes.Circular;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Circular;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Circular;
        minorTicks(): anychart.core.axes.CircularTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Circular;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.axes.Circular;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        radius(): string;
        radius(value?: number | string): anychart.core.axes.Circular;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Linear | anychart.scales.Logarithmic;
        scale(value?: anychart.enums.GaugeScaleTypes | anychart.scales.Linear | anychart.scales.Logarithmic | string): anychart.core.axes.Circular;
        startAngle(): number;
        startAngle(value?: string | number): anychart.core.axes.Circular;
        sweepAngle(): number;
        sweepAngle(value?: string | number): anychart.core.axes.Circular;
        ticks(): anychart.core.axes.CircularTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Circular;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): string;
        width(value?: number | string): anychart.core.axes.Circular;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StockDateTime extends anychart.core.VisualBase {
        background(): anychart.core.ui.Background;
        background(value?: Object | boolean | string): anychart.core.axes.StockDateTime;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        height(): number;
        height(value?: number): anychart.core.axes.StockDateTime;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.StockDateTime;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.StockDateTime;
        minorTicks(): anychart.core.axes.StockTicks;
        minorTicks(value?: Object | boolean): anychart.core.axes.StockDateTime;
        overlapMode(): anychart.enums.StockLabelsOverlapMode;
        overlapMode(value?: anychart.enums.StockLabelsOverlapMode): anychart.core.axes.StockDateTime;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        showHelperLabel(): boolean;
        showHelperLabel(value?: boolean): anychart.core.axes.StockDateTime;
        ticks(): anychart.core.axes.StockTicks;
        ticks(value?: Object | boolean): anychart.core.axes.StockDateTime;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radar extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Radar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axes.Radar;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Radar;
        ticks(): anychart.core.axes.RadialTicks;
        ticks(value?: Object | boolean): anychart.core.axes.Radar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface LinearGauge extends anychart.core.axes.Linear {
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Linear;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Linear;
        offset(): string;
        offset(value?: string): anychart.core.axes.LinearGauge;
        orientation(): anychart.enums.Orientation;
        orientation(value?: string | anychart.enums.Orientation): anychart.core.axes.Linear;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Linear;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axes.Linear;
        staggerLines(): number;
        staggerLines(value?: number): anychart.core.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(value?: number): anychart.core.axes.Linear;
        staggerMode(): boolean;
        staggerMode(value?: boolean): anychart.core.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(value?: Object | boolean): anychart.core.axes.Linear;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.axes.Linear;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.axisMarkers {
    interface GanttLine extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.GanttLine;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: anychart.scales.GanttDateTime): anychart.core.axisMarkers.GanttLine;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.GanttLine;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        value(): number | anychart.enums.GanttDateTimeMarkers;
        value(value?: number | anychart.enums.GanttDateTimeMarkers | string): anychart.core.axisMarkers.GanttLine;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface GanttText extends anychart.core.Text {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.axisMarkers.GanttText;
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.axisMarkers.GanttText;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.axisMarkers.GanttText;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.GanttText;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.axisMarkers.GanttText;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.axisMarkers.GanttText;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.axisMarkers.GanttText;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: anychart.scales.GanttDateTime): anychart.core.axisMarkers.GanttText;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.axisMarkers.GanttText;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        value(): number | anychart.enums.GanttDateTimeMarkers | string;
        value(value?: number | anychart.enums.GanttDateTimeMarkers | string): anychart.core.axisMarkers.GanttText;
        width(): number | string;
        width(value?: number | string): anychart.core.axisMarkers.GanttText;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface GanttRange extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.axisMarkers.GanttRange;
        fill(color: string, opacity?: number): anychart.core.axisMarkers.GanttRange;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axisMarkers.GanttRange;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axisMarkers.GanttRange;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axisMarkers.GanttRange;
        from(): number | anychart.enums.GanttDateTimeMarkers | string;
        from(value?: number | anychart.enums.GanttDateTimeMarkers | string): anychart.core.axisMarkers.GanttRange;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.GanttRange;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.GanttDateTime;
        scale(value?: anychart.scales.GanttDateTime): anychart.core.axisMarkers.GanttRange;
        to(): number | anychart.enums.GanttDateTimeMarkers | string;
        to(value?: number | anychart.enums.GanttDateTimeMarkers | string): anychart.core.axisMarkers.GanttRange;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface CircularRange extends anychart.core.VisualBase {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.axisMarkers.CircularRange;
        cornersRounding(): string;
        cornersRounding(value?: number | string): anychart.core.axisMarkers.CircularRange;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endSize(): string;
        endSize(value?: number | string): anychart.core.axisMarkers.CircularRange;
        fill(): anychart.graphics.vector.Fill;
        fill(value?: anychart.graphics.vector.Fill): anychart.core.axisMarkers.CircularRange;
        from(): number;
        from(value?: number): anychart.core.axisMarkers.CircularRange;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.GaugeSidePosition | string;
        position(value?: anychart.enums.GaugeSidePosition | string): anychart.core.axisMarkers.CircularRange;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        radius(): string;
        radius(value?: number | string): anychart.core.axisMarkers.CircularRange;
        removeAllListeners(type?: string): number;
        startSize(): string;
        startSize(value?: number | string): anychart.core.axisMarkers.CircularRange;
        to(): number;
        to(value?: number): anychart.core.axisMarkers.CircularRange;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Text extends anychart.core.Text {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.axisMarkers.Text;
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.axisMarkers.Text;
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.axisMarkers.Text;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Text;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.axisMarkers.Text;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.axisMarkers.Text;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.axisMarkers.Text;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axisMarkers.Text;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.axisMarkers.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        value(): number;
        value(value?: number): anychart.core.axisMarkers.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.axisMarkers.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axisMarkers.Line;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axisMarkers.Line;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        value(): number;
        value(newValue?: number): anychart.core.axisMarkers.Line;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Range extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.axisMarkers.Line;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.axisMarkers.Range;
        fill(color: string, opacity?: number): anychart.core.axisMarkers.Range;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.axisMarkers.Range;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.axisMarkers.Range;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.axisMarkers.Range;
        from(): number;
        from(value?: number): anychart.core.axisMarkers.Range;
        isHorizontal(): boolean;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.axisMarkers.Range;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axisMarkers.Range;
        to(): number;
        to(value?: number): anychart.core.axisMarkers.Range;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.cartesian {
}

declare namespace anychart.core.cartesian.series {
    interface ContinuousBase extends anychart.core.cartesian.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Box extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Box;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Box;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Box;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Box;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Box;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Box;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Box;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Box;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Box;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.Box;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Box;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Box;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Box;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Box;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverMedianStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverMedianStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        hoverMedianStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        hoverOutlierMarkers(): anychart.core.ui.MarkersFactory;
        hoverOutlierMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.Box;
        hoverStemStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStemStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        hoverStemStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Box;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        hoverWhiskerStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverWhiskerStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        hoverWhiskerStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        hoverWhiskerWidth(): number | string;
        hoverWhiskerWidth(value?: number | string): anychart.core.cartesian.series.Box;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        medianStroke(): anychart.graphics.vector.Stroke | (() => void);
        medianStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        medianStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        outlierMarkers(): anychart.core.ui.MarkersFactory;
        outlierMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.Box;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Box;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Box;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.Box;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Box;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Box;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Box;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Box;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectMedianStroke(): anychart.graphics.vector.Stroke;
        selectMedianStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Box;
        selectMedianStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        selectOutlierMarkers(): anychart.core.ui.MarkersFactory;
        selectOutlierMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.Box;
        selectStemStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStemStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        selectStemStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Box;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        selectWhiskerStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectWhiskerStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        selectWhiskerStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        selectWhiskerWidth(): number | string;
        selectWhiskerWidth(value?: number | string): anychart.core.cartesian.series.Box;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stemStroke(): anychart.graphics.vector.Stroke | (() => void);
        stemStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        stemStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Box;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.Box;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        whiskerStroke(): anychart.graphics.vector.Stroke | (() => void);
        whiskerStroke(value?: (() => void)): anychart.core.cartesian.series.Box;
        whiskerStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Box;
        whiskerWidth(): number | string;
        whiskerWidth(value?: number | string): anychart.core.cartesian.series.Box;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface SplineArea extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.SplineArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.SplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.SplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.SplineArea;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.SplineArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.SplineArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.SplineArea;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.SplineArea;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.SplineArea;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Area;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.SplineArea;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.SplineArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.SplineArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.SplineArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.SplineArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.SplineArea;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.SplineArea;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.SplineArea;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.SplineArea;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.SplineArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Spline extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Spline;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Spline;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Spline;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Spline;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Spline;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Spline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface DiscreteBase extends anychart.core.cartesian.series.BaseWithMarkers {
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        unhover(): anychart.core.radar.series.Base;
        unhover(index?: number): anychart.core.radar.series.Base;
        unhover(indexes?: Array<number>): anychart.core.radar.series.Base;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
    }
    interface RangeStepArea extends anychart.core.cartesian.series.ContinuousRangeBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeStepArea;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeStepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeStepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeStepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeStepArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeStepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        highStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeStepArea;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeStepArea;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeStepArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeStepArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeStepArea;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeStepArea;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeStepArea;
        hoverHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverHighStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        hoverHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeStepArea;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverLowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        hoverLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeStepArea;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        lowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeStepArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeStepArea;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeStepArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeStepArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeStepArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeStepArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeStepArea;
        selectHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectHighStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        selectHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeStepArea;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectLowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeStepArea;
        selectLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeStepArea;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepArea extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepArea;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.StepArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.StepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.StepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepArea;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.StepArea;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.StepArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.StepArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.StepArea;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepArea;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.StepArea;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.StepArea;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.StepArea;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepArea;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.StepArea;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.StepArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.StepArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.StepArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.StepArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.StepArea;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.StepArea;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.StepArea;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.StepArea;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.StepArea;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.SeriesBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeBar extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeBar;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeBar;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeBar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeBar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeBar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeBar;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeBar;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeBar;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeBar;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeBar;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeBar;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeBar;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeBar;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeBar;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeBar;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeBar;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeBar;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeBar;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeBar;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeBar;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeBar;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeBar;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeBar;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeBar;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeBar;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeBar;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeBar;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Column3d extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ContinuousRangeBase extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousRangeBase;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        highStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.ContinuousRangeBase;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverHighStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverLowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.ContinuousRangeBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        lowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.ContinuousRangeBase;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousRangeBase;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.ContinuousRangeBase;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.ContinuousRangeBase;
        selectHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectHighStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        selectHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.ContinuousRangeBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectLowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.ContinuousRangeBase;
        selectLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.ContinuousRangeBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Area;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Area;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Area;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.Area;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Area;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Area;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Area;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Area;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Area;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Area;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.Area;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Area;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Area;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Area;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Area;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Area;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Area;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Area;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bubble extends anychart.core.cartesian.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        displayNegative(): boolean;
        displayNegative(value?: boolean): anychart.core.cartesian.series.Bubble;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Bubble;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bubble;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bubble;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bubble;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.Bubble;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bubble;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bubble;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bubble;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverNegativeFill(): anychart.graphics.vector.Fill;
        hoverNegativeFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        hoverNegativeFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        hoverNegativeFill(color: string, opacity?: number): anychart.core.cartesian.series.Bubble;
        hoverNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bubble;
        hoverNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bubble;
        hoverNegativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        hoverNegativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverNegativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bubble;
        hoverNegativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverNegativeStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        hoverNegativeStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bubble;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bubble;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        negativeFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        negativeFill(color: string, opacity?: number): anychart.core.cartesian.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bubble;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bubble;
        negativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        negativeStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        negativeStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bubble;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.Bubble;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bubble;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bubble;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bubble;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectNegativeFill(): anychart.graphics.vector.Fill;
        selectNegativeFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        selectNegativeFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        selectNegativeFill(color: string, opacity?: number): anychart.core.cartesian.series.Bubble;
        selectNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bubble;
        selectNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bubble;
        selectNegativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bubble;
        selectNegativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectNegativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bubble;
        selectNegativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectNegativeStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        selectNegativeStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bubble;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bubble;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bubble;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bubble;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bar extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bar;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Bar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bar;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bar;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.Bar;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bar;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bar;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bar;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bar;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bar;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Bar;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.Bar;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Bar;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Bar;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Bar;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Bar;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bar;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bar;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Bar;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Bar;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area3d extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface OHLC extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        fallingStroke(fillFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        fallingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverFallingStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        hoverFallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverRisingStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverRisingStroke(fillFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        hoverRisingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingStroke(): anychart.graphics.vector.Stroke | (() => void);
        risingStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        risingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectFallingStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        selectFallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectRisingStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectRisingStroke(fillFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        selectRisingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Candlestick extends anychart.core.cartesian.series.OHLC {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fallingFill(): anychart.graphics.vector.Fill;
        fallingFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        fallingFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Candlestick;
        fallingFill(color: string, opacity?: number): anychart.core.cartesian.series.Base;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Base;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Base;
        fallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Base;
        fallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        fallingStroke(fillFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        fallingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFallingFill(): anychart.graphics.vector.Fill;
        hoverFallingFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        hoverFallingFill(color: string, opacity?: number): anychart.core.cartesian.series.Base;
        hoverFallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Base;
        hoverFallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Base;
        hoverFallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        hoverFallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverFallingHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Base;
        hoverFallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverFallingStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        hoverFallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverRisingFill(): anychart.graphics.vector.Fill;
        hoverRisingFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        hoverRisingFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Candlestick;
        hoverRisingFill(color: string, opacity?: number): anychart.core.cartesian.series.Base;
        hoverRisingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Base;
        hoverRisingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Base;
        hoverRisingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        hoverRisingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverRisingHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Base;
        hoverRisingStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverRisingStroke(fillFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        hoverRisingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        risingFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Candlestick;
        risingFill(color: string, opacity?: number): anychart.core.cartesian.series.Base;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Base;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Base;
        risingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Base;
        risingStroke(): anychart.graphics.vector.Stroke | (() => void);
        risingStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        risingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFallingFill(): anychart.graphics.vector.Fill;
        selectFallingFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        selectFallingFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Candlestick;
        selectFallingFill(color: string, opacity?: number): anychart.core.cartesian.series.Base;
        selectFallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Base;
        selectFallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Base;
        selectFallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        selectFallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectFallingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Base;
        selectFallingStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectFallingStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        selectFallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectRisingFill(): anychart.graphics.vector.Fill;
        selectRisingFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        selectRisingFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Candlestick;
        selectRisingFill(color: string, opacity?: number): anychart.core.cartesian.series.Base;
        selectRisingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Base;
        selectRisingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Base;
        selectRisingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Base;
        selectRisingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectRisingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Base;
        selectRisingStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectRisingStroke(fillFunction?: (() => void)): anychart.core.cartesian.series.OHLC;
        selectRisingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.OHLC;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Column extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Column;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Column;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Column;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.Column;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Column;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Column;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Column;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Column;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Column;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Column;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.Column;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Column;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Column;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Column;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Column;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Column;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Column;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Column;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Column;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface WidthBased extends anychart.core.cartesian.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeArea extends anychart.core.cartesian.series.ContinuousRangeBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeArea;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        highStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeArea;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeArea;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeArea;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeArea;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeArea;
        hoverHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverHighStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        hoverHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeArea;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverLowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        hoverLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeArea;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        lowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeArea;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeArea;
        selectHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectHighStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        selectHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeArea;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectLowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeArea;
        selectLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeArea;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface BaseWithMarkers extends anychart.core.cartesian.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepLine extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.StepLine;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.StepLine;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.StepLine;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.StepLine;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.StepLine;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.StepLine;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.cartesian.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Line;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Line;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Line;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Line;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Line;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeColumn extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeColumn;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeColumn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeColumn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeColumn;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeColumn;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeColumn;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeColumn;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeColumn;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeColumn;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeColumn;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeColumn;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeColumn;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeColumn;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeColumn;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeColumn;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeColumn;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeColumn;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeColumn;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeColumn;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeColumn;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeColumn;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeColumn;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeColumn;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeColumn;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeColumn;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeColumn;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeSplineArea extends anychart.core.cartesian.series.ContinuousRangeBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.cartesian.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeSplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeSplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        highStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeSplineArea;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeSplineArea;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeSplineArea;
        hoverHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverHighStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        hoverHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeSplineArea;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverLowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        hoverLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeSplineArea;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        lowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeSplineArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.RangeSplineArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.RangeSplineArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.RangeSplineArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.RangeSplineArea;
        selectHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectHighStroke(fillFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        selectHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeSplineArea;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectLowStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.RangeSplineArea;
        selectLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.RangeSplineArea;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(): anychart.core.cartesian.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.cartesian.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Marker;
        fill(fillFunction?: (() => void)): anychart.core.cartesian.series.Marker;
        fill(color: string, opacity?: number): anychart.core.cartesian.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Marker;
        hoverFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Marker;
        hoverFill(color: string, opacity?: number): anychart.core.cartesian.series.Marker;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Marker;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Marker;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Marker;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Marker;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverSize(): number;
        hoverSize(value?: number): anychart.core.cartesian.series.Marker;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Marker;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Marker;
        hoverType(): string | anychart.enums.MarkerType | (() => void);
        hoverType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.cartesian.series.Marker;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Marker;
        selectFill(fillFunction?: (() => void)): anychart.core.cartesian.series.Marker;
        selectFill(color: string, opacity?: number): anychart.core.cartesian.series.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.cartesian.series.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.cartesian.series.Marker;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.cartesian.series.Marker;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.cartesian.series.Marker;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Marker;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Marker;
        selectType(): string | anychart.enums.MarkerType | (() => void);
        selectType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.cartesian.series.Marker;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        size(): number;
        size(value?: number): anychart.core.cartesian.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.cartesian.series.Marker;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.cartesian.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.cartesian.series.Marker;
        unhover(): anychart.core.cartesian.series.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bar3d extends anychart.core.cartesian.series.WidthBased {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.cartesian.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.cartesian.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPixelPointWidth(): number;
        getPoint(index: number): anychart.core.SeriesPoint;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.cartesian.series.WidthBased;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.cartesian.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        seriesType(): string;
        seriesType(value?: string): anychart.core.cartesian.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(value: any, subRangeRatio?: number): number;
        transformY(value: any, subRangeRatio?: number): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xPointPosition(): number;
        xPointPosition(position?: number): anychart.core.cartesian.series.Base;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.cartesian.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.gauge {
    interface Cap extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.Cap;
        fill(color: string, opacity?: number): anychart.core.gauge.Cap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.Cap;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.Cap;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.Cap;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.Cap;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        radius(): string;
        radius(value?: number | string): anychart.core.gauge.Cap;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.Cap;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.gauge.pointers {
    interface Needle extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endRadius(): string;
        endRadius(value?: number | string): anychart.core.gauge.pointers.Needle;
        endWidth(): string;
        endWidth(value?: number | string): anychart.core.gauge.pointers.Needle;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        middleRadius(): string;
        middleRadius(value?: number | string): anychart.core.gauge.pointers.Needle;
        middleWidth(): string;
        middleWidth(value?: number | string): anychart.core.gauge.pointers.Needle;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        startRadius(): string;
        startRadius(value?: number | string): anychart.core.gauge.pointers.Needle;
        startWidth(): string;
        startWidth(value?: number | string): anychart.core.gauge.pointers.Needle;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.gauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.VisualBase {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.gauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bar extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.GaugeSidePosition | string;
        position(value?: anychart.enums.GaugeSidePosition | string): anychart.core.gauge.pointers.Bar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        radius(): string;
        radius(value?: number | string): anychart.core.gauge.pointers.Bar;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.gauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): string;
        width(value?: number | string): anychart.core.gauge.pointers.Bar;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Knob extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        bottomRadius(): string;
        bottomRadius(value?: number | string): anychart.core.gauge.pointers.Knob;
        bottomRatio(): number;
        bottomRatio(value?: number): anychart.core.gauge.pointers.Knob;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.gauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        topRadius(): string;
        topRadius(value?: number | string): anychart.core.gauge.pointers.Knob;
        topRatio(): number;
        topRatio(value?: number): anychart.core.gauge.pointers.Knob;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticesCount(): number;
        verticesCount(value?: number): anychart.core.gauge.pointers.Knob;
        verticesCurvature(): number;
        verticesCurvature(value?: number): anychart.core.gauge.pointers.Knob;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.gauge.pointers.Base {
        axisIndex(): number;
        axisIndex(index?: number): anychart.core.gauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.gauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.gauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.gauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.gauge.pointers.Base;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | boolean;
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.gauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        position(): anychart.enums.GaugeSidePosition | string;
        position(value?: anychart.enums.GaugeSidePosition | string): anychart.core.gauge.pointers.Marker;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        radius(): string;
        radius(value?: number | string): anychart.core.gauge.pointers.Marker;
        removeAllListeners(type?: string): number;
        size(): string;
        size(value?: number | string): anychart.core.gauge.pointers.Marker;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.gauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.gauge.pointers.Base;
        type(): anychart.enums.MarkerType | (() => void);
        type(value?: anychart.enums.MarkerType | (() => void) | string): anychart.core.gauge.pointers.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.grids {
    interface Polar extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Polar | anychart.core.axes.Radial;
        axis(value?: anychart.core.axes.Polar | anychart.core.axes.Radial): anychart.core.grids.Polar;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Polar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        evenFill(): string | anychart.graphics.vector.Fill;
        evenFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        evenFill(color: string, opacity?: number): anychart.core.grids.Polar;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Polar;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Polar;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Polar;
        isRadial(): boolean;
        layout(): anychart.enums.RadialGridLayout;
        layout(value?: anychart.enums.RadialGridLayout | string): anychart.core.grids.Polar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        oddFill(): string | anychart.graphics.vector.Fill;
        oddFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        oddFill(color: string, opacity?: number): anychart.core.grids.Polar;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Polar;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Polar;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Polar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.grids.Polar;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Linear extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.grids.Linear;
        drawFirstLine(): boolean;
        drawFirstLine(value?: boolean): anychart.core.grids.Linear;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        evenFill(): string | anychart.graphics.vector.Fill;
        evenFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        evenFill(color: string, opacity?: number): anychart.core.grids.Linear;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Linear;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Linear;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        isHorizontal(): boolean;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Linear;
        layout(): anychart.enums.Layout;
        layout(value?: anychart.enums.Layout | string): anychart.core.grids.Linear;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        oddFill(): string | anychart.graphics.vector.Fill;
        oddFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        oddFill(color: string, opacity?: number): anychart.core.grids.Linear;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Linear;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Linear;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.grids.Linear;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Stock extends anychart.core.VisualBase {
        axis(): anychart.core.axes.StockDateTime | anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.StockDateTime | anychart.core.axes.Linear): anychart.core.grids.Stock;
        drawFirstLine(): boolean;
        drawFirstLine(value?: boolean): anychart.core.grids.Stock;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Stock;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        evenFill(): string | anychart.graphics.vector.Fill;
        evenFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Stock;
        evenFill(color: string, opacity?: number): anychart.core.grids.Stock;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Stock;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Stock;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Stock;
        isHorizontal(): boolean;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Stock;
        layout(): anychart.enums.Layout | string;
        layout(value?: anychart.enums.Layout | string): anychart.core.grids.Stock;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        oddFill(): anychart.graphics.vector.Fill;
        oddFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Stock;
        oddFill(color: string, opacity?: number): anychart.core.grids.Stock;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Stock;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Stock;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Stock;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base | anychart.scales.StockScatterDateTime;
        scale(value?: anychart.scales.Base | anychart.scales.StockScatterDateTime): anychart.core.grids.Stock;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Stock;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radar extends anychart.core.VisualBase {
        axis(): anychart.core.axes.Radar | anychart.core.axes.Radial;
        axis(value?: anychart.core.axes.Radar | anychart.core.axes.Radial): anychart.core.grids.Radar;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Radar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        evenFill(): string | anychart.graphics.vector.Fill;
        evenFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        evenFill(color: string, opacity?: number): anychart.core.grids.Radar;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Radar;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Radar;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Radar;
        isRadial(): boolean;
        layout(): anychart.enums.RadialGridLayout;
        layout(value?: anychart.enums.RadialGridLayout | string): anychart.core.grids.Radar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        oddFill(): string | anychart.graphics.vector.Fill;
        oddFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        oddFill(color: string, opacity?: number): anychart.core.grids.Radar;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Radar;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Radar;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Radar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xScale(): anychart.scales.Ordinal;
        yScale(): anychart.scales.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.linearGauge {
    interface ScaleBar extends anychart.core.VisualBase {
        colorScale(): anychart.scales.LinearColor | anychart.scales.OrdinalColor;
        colorScale(value?: anychart.scales.LinearColor | anychart.scales.OrdinalColor): anychart.core.linearGauge.ScaleBar;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.ScaleBar;
        fill(color: string, opacity?: number): anychart.core.linearGauge.ScaleBar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.ScaleBar;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.ScaleBar;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.ScaleBar;
        from(): string | number;
        from(value?: string | number): anychart.core.linearGauge.ScaleBar;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.ScaleBar;
        points(): Array<anychart.core.linearGauge.ScaleBar.ControlPoint>;
        points(value?: Array<anychart.core.linearGauge.ScaleBar.ControlPoint>): anychart.core.linearGauge.ScaleBar;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.scales.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.ScaleBar;
        to(): string | number;
        to(value?: string | number): anychart.core.linearGauge.ScaleBar;
        width(): string;
        width(value?: string): string | anychart.core.linearGauge.ScaleBar;
    }
    namespace ScaleBar {
    interface ControlPoint {
        height: number;
        left: number;
        right: number;
    }
    }
}

declare namespace anychart.core.linearGauge.pointers {
    interface Tank extends anychart.core.linearGauge.pointers.Base {
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        color(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hoverLabel(): anychart.core.ui.LabelsFactory;
        hoverLabel(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        selectLabel(): anychart.core.ui.LabelsFactory;
        selectLabel(value?: anychart.core.ui.LabelsFactory | Object): anychart.core.linearGauge.pointers.Base;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.VisualBase {
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        color(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hoverLabel(): anychart.core.ui.LabelsFactory;
        hoverLabel(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        selectLabel(): anychart.core.ui.LabelsFactory;
        selectLabel(value?: anychart.core.ui.LabelsFactory | Object): anychart.core.linearGauge.pointers.Base;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
    }
    interface RangeBar extends anychart.core.linearGauge.pointers.Bar {
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        color(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hoverLabel(): anychart.core.ui.LabelsFactory;
        hoverLabel(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        selectLabel(): anychart.core.ui.LabelsFactory;
        selectLabel(value?: anychart.core.ui.LabelsFactory | Object): anychart.core.linearGauge.pointers.Base;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bar extends anychart.core.linearGauge.pointers.Base {
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        color(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hoverLabel(): anychart.core.ui.LabelsFactory;
        hoverLabel(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        selectLabel(): anychart.core.ui.LabelsFactory;
        selectLabel(value?: anychart.core.ui.LabelsFactory | Object): anychart.core.linearGauge.pointers.Base;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Led extends anychart.core.linearGauge.pointers.Base {
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        color(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        colorScale(): anychart.core.linearGauge.pointers.Led;
        colorScale(value?: anychart.scales.LinearColor | anychart.scales.OrdinalColor): anychart.core.linearGauge.pointers.Led;
        count(): number;
        count(value?: number): anychart.core.linearGauge.pointers.Led;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        dimmer(): (() => void);
        dimmer(value?: (() => void)): anychart.core.linearGauge.pointers.Led;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        gap(): number | string;
        gap(value?: number | string): anychart.core.linearGauge.pointers.Led;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hoverLabel(): anychart.core.ui.LabelsFactory;
        hoverLabel(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        selectLabel(): anychart.core.ui.LabelsFactory;
        selectLabel(value?: anychart.core.ui.LabelsFactory | Object): anychart.core.linearGauge.pointers.Base;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        size(): number | string;
        size(value?: number | string): anychart.core.linearGauge.pointers.Led;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
    }
    interface Marker extends anychart.core.linearGauge.pointers.Base {
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        color(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hoverLabel(): anychart.core.ui.LabelsFactory;
        hoverLabel(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        selectLabel(): anychart.core.ui.LabelsFactory;
        selectLabel(value?: anychart.core.ui.LabelsFactory | Object): anychart.core.linearGauge.pointers.Base;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        type(): string;
        type(value?: string | anychart.enums.MarkerType): anychart.core.linearGauge.pointers.Marker;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
    }
    interface Thermometer extends anychart.core.linearGauge.pointers.Base {
        bulbPadding(): string | number;
        bulbPadding(value?: string | number): anychart.core.linearGauge.pointers.Thermometer;
        bulbRadius(): string;
        bulbRadius(value?: string): anychart.core.linearGauge.pointers.Thermometer;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        color(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        dataIndex(): number;
        dataIndex(index?: number): anychart.core.linearGauge.pointers.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        fill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        getGauge(): anychart.charts.LinearGauge;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hover(): anychart.core.linearGauge.pointers.Base;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        hoverLabel(): anychart.core.ui.LabelsFactory;
        hoverLabel(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        label(): anychart.core.ui.LabelsFactory;
        label(value?: anychart.core.ui.LabelsFactory | Object | boolean): anychart.core.linearGauge.pointers.Base;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.linearGauge.pointers.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        name(): string;
        name(value?: string): anychart.core.linearGauge.pointers.Base;
        offset(): string;
        offset(value?: string): anychart.core.linearGauge.pointers.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.linearGauge.pointers.Base;
        select(event?: anychart.core.MouseEvent): anychart.core.linearGauge.pointers.Base;
        selectFill(): anychart.graphics.vector.Fill | (() => void);
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectFill(color: string, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.linearGauge.pointers.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.linearGauge.pointers.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.linearGauge.pointers.Base;
        selectLabel(): anychart.core.ui.LabelsFactory;
        selectLabel(value?: anychart.core.ui.LabelsFactory | Object): anychart.core.linearGauge.pointers.Base;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(value?: anychart.graphics.vector.Stroke | (() => void)): anychart.core.linearGauge.pointers.Base;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.linearGauge.pointers.Base;
        unhover(): anychart.core.linearGauge.pointers.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.linearGauge.pointers.Base;
        width(): string;
        width(value?: string): anychart.core.linearGauge.pointers.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.map {
}

declare namespace anychart.core.map.scale {
    interface Geo {
        gap(): number;
        gap(value?: number): anychart.core.map.scale.Geo;
    }
}

declare namespace anychart.core.map.series {
    interface Base extends anychart.core.SeriesBase {
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Base;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        color(color: string, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        hoverFill(color: string, opacity?: number): anychart.core.map.series.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hoverHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.map.series.Base;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        hoverStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.map.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        selectFill(color: string, opacity?: number): anychart.core.map.series.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.map.series.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(fillFunction?: (() => void)): anychart.core.map.series.Base;
        selectStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Choropleth extends anychart.core.map.series.BaseWithMarkers {
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Base;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        color(color: string, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        colorScale(): anychart.scales.OrdinalColor | anychart.scales.LinearColor;
        colorScale(value?: anychart.scales.LinearColor | anychart.scales.OrdinalColor): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.map.series.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.map.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.map.series.Base;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bubble extends anychart.core.map.series.BaseWithMarkers {
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Base;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        color(color: string, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.map.series.Base;
        displayNegative(): boolean;
        displayNegative(value?: boolean): anychart.core.map.series.Bubble;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        hoverFill(color: string, opacity?: number): anychart.core.map.series.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hoverHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.map.series.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        hoverNegativeFill(): anychart.graphics.vector.Fill;
        hoverNegativeFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Bubble;
        hoverNegativeFill(color: string, opacity?: number): anychart.core.map.series.Bubble;
        hoverNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Bubble;
        hoverNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Bubble;
        hoverNegativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Bubble;
        hoverNegativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hoverNegativeHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Bubble;
        hoverNegativeStroke(): anychart.core.map.series.Bubble;
        hoverNegativeStroke(strokeFunction?: (() => void)): anychart.core.map.series.Bubble;
        hoverNegativeStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Bubble;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        hoverStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Bubble;
        negativeFill(color: string, opacity?: number): anychart.core.map.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Bubble;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Bubble;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        negativeHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Bubble;
        negativeStroke(): anychart.core.map.series.Bubble;
        negativeStroke(strokeFunction?: (() => void)): anychart.core.map.series.Bubble;
        negativeStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Bubble;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.map.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        selectFill(color: string, opacity?: number): anychart.core.map.series.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.map.series.Base;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        selectNegativeFill(): anychart.graphics.vector.Fill;
        selectNegativeFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Bubble;
        selectNegativeFill(color: string, opacity?: number): anychart.core.map.series.Bubble;
        selectNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Bubble;
        selectNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Bubble;
        selectNegativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Bubble;
        selectNegativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectNegativeHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Bubble;
        selectNegativeStroke(): anychart.core.map.series.Bubble;
        selectNegativeStroke(strokeFunction?: (() => void)): anychart.core.map.series.Bubble;
        selectNegativeStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Bubble;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        selectStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface BaseWithMarkers extends anychart.core.map.series.Base {
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Base;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        color(color: string, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        hoverFill(color: string, opacity?: number): anychart.core.map.series.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hoverHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.map.series.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        hoverStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        selectFill(color: string, opacity?: number): anychart.core.map.series.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.map.series.Base;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(fillFunction?: (() => void)): anychart.core.map.series.Base;
        selectStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Connector extends anychart.core.map.series.BaseWithMarkers {
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Base;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        color(color: string, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        curvature(): string | number;
        curvature(value?: number | string): anychart.core.map.series.Connector;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endSize(): string | number;
        endSize(value?: number | string): anychart.core.map.series.Connector;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        hoverFill(color: string, opacity?: number): anychart.core.map.series.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hoverHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.map.series.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        hoverStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.map.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        selectFill(color: string, opacity?: number): anychart.core.map.series.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.map.series.Base;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.map.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(fillFunction?: (() => void)): anychart.core.map.series.Base;
        selectStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        startSize(): number | string;
        startSize(value?: number | string): anychart.core.map.series.Connector;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.map.series.Base {
        allowPointsSelect(): boolean;
        allowPointsSelect(value?: boolean): anychart.core.map.series.Base;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        color(color: string, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.map.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        fill(color: string, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        geoIdField(): string;
        geoIdField(value?: string): anychart.core.map.series.Base;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        hoverFill(color: string, opacity?: number): anychart.core.map.series.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        hoverHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.map.series.Base;
        hoverSize(): number;
        hoverSize(value?: number): anychart.core.map.series.Marker;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        hoverStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        hoverType(): anychart.enums.MarkerType | string | (() => void);
        hoverType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.map.series.Marker;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.map.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.map.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        overlapMode(): anychart.enums.LabelsOverlapMode | string;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string | boolean): anychart.core.map.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        selectFill(color: string, opacity?: number): anychart.core.map.series.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.map.series.Base;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.map.series.Base;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.map.series.Base;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.map.series.Base;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.map.series.Base;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(fillFunction?: (() => void)): anychart.core.map.series.Base;
        selectStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        selectType(): anychart.enums.MarkerType | string | (() => void);
        selectType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.map.series.Marker;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        size(): number;
        size(value?: number): anychart.core.map.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.map.series.Base;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.map.series.Base;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.map.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xCoord: number, yCoord: number): {[prop: string]: number};
        type(): anychart.enums.MarkerType | string | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.map.series.Marker;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.pert {
    interface Tasks {
        color(): anychart.graphics.vector.Fill;
        color(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)> | (() => void), opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.math.Rect | Object, opacityOrMode?: number | anychart.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Tasks;
        dummyFill(): anychart.graphics.vector.Fill;
        dummyFill(fillFunction?: (() => void)): anychart.core.pert.Tasks;
        dummyFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.math.Rect | Object, opacityOrMode?: number | anychart.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Tasks;
        dummyStroke(): anychart.graphics.vector.Stroke;
        dummyStroke(strokeFunction?: (() => void)): anychart.core.pert.Tasks;
        dummyStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Tasks;
        fill(): anychart.graphics.vector.Fill;
        fill(fillFunction?: (() => void)): anychart.core.pert.Tasks;
        fill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.math.Rect | Object, opacityOrMode?: number | anychart.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Tasks;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(fillFunction?: (() => void)): anychart.core.pert.Tasks;
        hoverFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.math.Rect | Object, opacityOrMode?: number | anychart.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Tasks;
        hoverLowerLabels(): anychart.core.ui.LabelsFactory;
        hoverLowerLabels(value?: Object | boolean): anychart.core.pert.Tasks;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.pert.Tasks;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Tasks;
        hoverUpperLabels(): anychart.core.ui.LabelsFactory;
        hoverUpperLabels(value?: Object | boolean): anychart.core.pert.Tasks;
        lowerLabels(): anychart.core.ui.LabelsFactory;
        lowerLabels(value?: Object | boolean): anychart.core.pert.Tasks;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(fillFunction?: (() => void)): anychart.core.pert.Tasks;
        selectFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.math.Rect | Object, opacityOrMode?: number | anychart.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Tasks;
        selectLowerLabels(): anychart.core.ui.LabelsFactory;
        selectLowerLabels(value?: Object | boolean): anychart.core.pert.Tasks;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.pert.Tasks;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Tasks;
        selectUpperLabels(): anychart.core.ui.LabelsFactory;
        selectUpperLabels(value?: Object | boolean): anychart.core.pert.Tasks;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.pert.Tasks;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Tasks;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.pert.Milestones;
        upperLabels(): anychart.core.ui.LabelsFactory;
        upperLabels(value?: Object | boolean): anychart.core.pert.Tasks;
    }
    interface Milestones {
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.pert.Milestones;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.pert.Milestones;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Milestones;
        fill(): anychart.graphics.vector.Fill | (() => void);
        fill(value: anychart.graphics.vector.Fill): anychart.core.pert.Milestones;
        fill(fillFunction?: (() => void)): anychart.core.pert.Milestones;
        fill(color: string, opacity?: number): anychart.core.pert.Milestones;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.pert.Milestones;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Milestones;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.pert.Milestones;
        hoverFill(): anychart.graphics.vector.Fill | (() => void);
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.pert.Milestones;
        hoverFill(fillFunction?: (() => void)): anychart.core.pert.Milestones;
        hoverFill(color: string, opacity?: number): anychart.core.pert.Milestones;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.pert.Milestones;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Milestones;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.pert.Milestones;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.pert.Milestones;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.pert.Milestones;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Milestones;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.pert.Milestones;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.pert.Milestones;
        selectFill(fillFunction?: (() => void)): anychart.core.pert.Milestones;
        selectFill(color: string, opacity?: number): anychart.core.pert.Milestones;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.pert.Milestones;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.pert.Milestones;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.pert.Milestones;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.pert.Milestones;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.pert.Milestones;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Milestones;
        shape(): anychart.enums.MilestoneShape | string;
        shape(value?: anychart.enums.MilestoneShape | string): anychart.core.pert.Milestones;
        size(): number | string;
        size(value?: number | string): anychart.core.pert.Milestones;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.pert.Milestones;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.pert.Milestones;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.pert.Milestones;
    }
    interface CriticalPath extends anychart.core.Base {
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        milestones(): anychart.core.pert.Milestones;
        milestones(value?: Object): anychart.core.pert.CriticalPath;
        removeAllListeners(type?: string): number;
        tasks(): anychart.core.pert.Tasks;
        tasks(value?: Object): anychart.core.pert.CriticalPath;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.core.polar {
}

declare namespace anychart.core.polar.series {
    interface ContinuousBase extends anychart.core.polar.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        closed(): boolean;
        closed(value?: boolean): anychart.core.polar.series.ContinuousBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.polar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(): anychart.core.polar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.SeriesBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area extends anychart.core.polar.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        closed(): boolean;
        closed(value?: boolean): anychart.core.polar.series.ContinuousBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.polar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.Area;
        fill(fillFunction?: (() => void)): anychart.core.polar.series.Area;
        fill(color: string, opacity?: number): anychart.core.polar.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Area;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Area;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.Area;
        hoverFill(fillFunction?: (() => void)): anychart.core.polar.series.Area;
        hoverFill(color: string, opacity?: number): anychart.core.polar.series.Area;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Area;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Area;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Area;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Area;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(fillFunction?: (() => void)): anychart.core.polar.series.Area;
        hoverStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Area;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.Area;
        selectFill(fillFunction?: (() => void)): anychart.core.polar.series.Area;
        selectFill(color: string, opacity?: number): anychart.core.polar.series.Area;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Area;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Area;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Area;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Area;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.polar.series.Area;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Area;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(fillFunction?: (() => void)): anychart.core.polar.series.Area;
        stroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(): anychart.core.polar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.polar.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        closed(): boolean;
        closed(value?: boolean): anychart.core.polar.series.ContinuousBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.polar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.polar.series.Line;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Line;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.polar.series.ContinuousBase;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.polar.series.Line;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Line;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.polar.series.Line;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        unhover(): anychart.core.polar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.polar.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.Marker;
        fill(fillFunction?: (() => void)): anychart.core.polar.series.Marker;
        fill(color: string, opacity?: number): anychart.core.polar.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Marker;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.Marker;
        hoverFill(fillFunction?: (() => void)): anychart.core.polar.series.Marker;
        hoverFill(color: string, opacity?: number): anychart.core.polar.series.Marker;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Marker;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Marker;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Marker;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Marker;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverSize(): number;
        hoverSize(value?: number): anychart.core.polar.series.Marker;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(fillFunction?: (() => void)): anychart.core.polar.series.Marker;
        hoverStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Marker;
        hoverType(): string | anychart.enums.MarkerType | (() => void);
        hoverType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.polar.series.Marker;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.polar.series.Marker;
        selectFill(fillFunction?: (() => void)): anychart.core.polar.series.Marker;
        selectFill(color: string, opacity?: number): anychart.core.polar.series.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.polar.series.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.polar.series.Marker;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.polar.series.Marker;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.polar.series.Marker;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(fillFunction?: (() => void)): anychart.core.polar.series.Marker;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Marker;
        selectType(): string | anychart.enums.MarkerType | (() => void);
        selectType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.polar.series.Marker;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        size(): number;
        size(value?: number): anychart.core.polar.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(fillFunction?: (() => void)): anychart.core.polar.series.Marker;
        stroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.polar.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xValue: any, yValue: any): {[prop: string]: number};
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.polar.series.Marker;
        unhover(): anychart.core.polar.series.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.polar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.polar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.radar {
}

declare namespace anychart.core.radar.series {
    interface ContinuousBase extends anychart.core.radar.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Base;
        color(color: string, opacity?: number): anychart.core.radar.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Base;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.radar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.radar.series.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.radar.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.radar.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop: string]: number};
        unhover(): anychart.core.radar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.SeriesBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Base;
        color(color: string, opacity?: number): anychart.core.radar.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.radar.series.Base;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.radar.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.radar.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop: string]: number};
        unhover(): anychart.core.radar.series.Base;
        unhover(index?: number): anychart.core.radar.series.Base;
        unhover(indexes?: Array<number>): anychart.core.radar.series.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area extends anychart.core.radar.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Base;
        color(color: string, opacity?: number): anychart.core.radar.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Base;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.radar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Area;
        fill(fillFunction?: (() => void)): anychart.core.radar.series.Area;
        fill(color: string, opacity?: number): anychart.core.radar.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.radar.series.Area;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.radar.series.Area;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Area;
        hoverFill(fillFunction?: (() => void)): anychart.core.radar.series.Area;
        hoverFill(color: string, opacity?: number): anychart.core.radar.series.Area;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Area;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Area;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.radar.series.Area;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.radar.series.Area;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.radar.series.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.radar.series.Area;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Area;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.radar.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.radar.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Area;
        selectFill(fillFunction?: (() => void)): anychart.core.radar.series.Area;
        selectFill(color: string, opacity?: number): anychart.core.radar.series.Area;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Area;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Area;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.radar.series.Area;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.radar.series.Area;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.radar.series.Area;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Area;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.radar.series.Area;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Area;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop: string]: number};
        unhover(): anychart.core.radar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.radar.series.ContinuousBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Base;
        color(color: string, opacity?: number): anychart.core.radar.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Base;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.radar.series.ContinuousBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.radar.series.Base;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.radar.series.Line;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Line;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.radar.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.radar.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.radar.series.ContinuousBase;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.radar.series.Line;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Line;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(fillFunction?: (() => void)): anychart.core.radar.series.Line;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop: string]: number};
        unhover(): anychart.core.radar.series.ContinuousBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.radar.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Base;
        color(color: string, opacity?: number): anychart.core.radar.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Base;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Base;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.radar.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Marker;
        fill(fillFunction?: (() => void)): anychart.core.radar.series.Marker;
        fill(color: string, opacity?: number): anychart.core.radar.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.radar.series.Marker;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.radar.series.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.radar.series.Base;
        hover(index?: number): anychart.core.radar.series.Base;
        hover(indexes?: Array<number>): anychart.core.radar.series.Base;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Marker;
        hoverFill(fillFunction?: (() => void)): anychart.core.radar.series.Marker;
        hoverFill(color: string, opacity?: number): anychart.core.radar.series.Marker;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Marker;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Marker;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.radar.series.Marker;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.radar.series.Marker;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.radar.series.Base;
        hoverSize(): number;
        hoverSize(value?: number): anychart.core.radar.series.Marker;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.radar.series.Marker;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Marker;
        hoverType(): string | anychart.enums.MarkerType | (() => void);
        hoverType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.radar.series.Marker;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.radar.series.Base;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.radar.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any): anychart.core.radar.series.Base;
        meta(key?: string, value?: any): anychart.core.radar.series.Base;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.radar.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.radar.series.Marker;
        selectFill(fillFunction?: (() => void)): anychart.core.radar.series.Marker;
        selectFill(color: string, opacity?: number): anychart.core.radar.series.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.radar.series.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.radar.series.Marker;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.radar.series.Marker;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.radar.series.Marker;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.radar.series.Marker;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Marker;
        selectType(): string | anychart.enums.MarkerType | (() => void);
        selectType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.radar.series.Marker;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        size(): number;
        size(value?: number): anychart.core.radar.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.radar.series.Marker;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.radar.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.radar.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformXY(xVal: any, yVal: any, xSubRangeRatio?: number): {[prop: string]: number};
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.radar.series.Marker;
        unhover(): anychart.core.radar.series.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.radar.series.Base;
        yScale(): anychart.scales.Base;
        yScale(value?: anychart.scales.Base): anychart.core.radar.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.scatter {
}

declare namespace anychart.core.scatter.series {
    interface Base extends anychart.core.SeriesBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.scatter.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Bubble extends anychart.core.scatter.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        displayNegative(): boolean;
        displayNegative(value?: boolean): anychart.core.scatter.series.Bubble;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.scatter.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        fill(color: string, opacity?: number): anychart.core.scatter.series.Bubble;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Bubble;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Bubble;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Bubble;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        hoverFill(color: string, opacity?: number): anychart.core.scatter.series.Bubble;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Bubble;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Bubble;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Bubble;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        hoverNegativeFill(): anychart.graphics.vector.Fill;
        hoverNegativeFill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        hoverNegativeFill(color: string, opacity?: number): anychart.core.scatter.series.Bubble;
        hoverNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Bubble;
        hoverNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Bubble;
        hoverNegativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        hoverNegativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverNegativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Bubble;
        hoverNegativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverNegativeStroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Bubble;
        hoverNegativeStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Bubble;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Bubble;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Bubble;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        negativeFill(): anychart.graphics.vector.Fill;
        negativeFill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        negativeFill(color: string, opacity?: number): anychart.core.scatter.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Bubble;
        negativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Bubble;
        negativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        negativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        negativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Bubble;
        negativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        negativeStroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Bubble;
        negativeStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Bubble;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        selectFill(color: string, opacity?: number): anychart.core.scatter.series.Bubble;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Bubble;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Bubble;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Bubble;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        selectNegativeFill(): anychart.graphics.vector.Fill;
        selectNegativeFill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        selectNegativeFill(color: string, opacity?: number): anychart.core.scatter.series.Bubble;
        selectNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Bubble;
        selectNegativeFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Bubble;
        selectNegativeFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Bubble;
        selectNegativeHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectNegativeHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Bubble;
        selectNegativeStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectNegativeStroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Bubble;
        selectNegativeStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Bubble;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Bubble;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Bubble;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Bubble;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Bubble;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(): anychart.core.scatter.series.Bubble;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface BaseWithMarkers extends anychart.core.scatter.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.scatter.series.Base;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(indexOrIndexes?: number | Array<number>): anychart.core.SeriesBase;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.scatter.series.BaseWithMarkers {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        connectMissingPoints(): boolean;
        connectMissingPoints(value?: boolean): anychart.core.scatter.series.Line;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.scatter.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverMarkers(): anychart.core.ui.MarkersFactory;
        hoverMarkers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(StrokeFunction?: (() => void)): anychart.core.scatter.series.Line;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Line;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectMarkers(): anychart.core.ui.MarkersFactory;
        selectMarkers(value?: Object | boolean | string): anychart.core.scatter.series.BaseWithMarkers;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Line;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Line;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Line;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Line;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        unhover(): anychart.core.scatter.series.Line;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.scatter.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        clip(): boolean | anychart.math.Rect;
        clip(value?: boolean | anychart.math.Rect): anychart.core.scatter.series.Base;
        color(): anychart.graphics.vector.Fill;
        color(value: anychart.graphics.vector.Fill): anychart.core.SeriesBase;
        color(color: string, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.SeriesBase;
        color(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.SeriesBase;
        data(): anychart.data.View;
        data(value?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.core.SeriesBase;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        error(): anychart.core.utils.Error;
        error(value?: Object | boolean | string | number): anychart.core.scatter.series.Base;
        excludePoint(indexes: number | Array<number>): boolean;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Marker;
        fill(color: string, opacity?: number): anychart.core.scatter.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Marker;
        getExcludedPoints(): Array<anychart.core.Point>;
        getPixelBounds(): anychart.math.Rect;
        getPoint(index: number): anychart.core.SeriesPoint;
        getStat(key: string | anychart.enums.Statistics): any;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hover(): anychart.core.SeriesBase;
        hover(index?: number): anychart.core.SeriesBase;
        hover(indexes?: Array<number>): anychart.core.SeriesBase;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Marker;
        hoverFill(color: string, opacity?: number): anychart.core.scatter.series.Marker;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Marker;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Marker;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Marker;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Marker;
        hoverLabels(): anychart.core.ui.LabelsFactory;
        hoverLabels(value?: Object | boolean): anychart.core.SeriesBase;
        hoverSize(): number;
        hoverSize(value?: number): anychart.core.scatter.series.Marker;
        hoverStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverStroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Marker;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Marker;
        hoverType(): string | anychart.enums.MarkerType | (() => void);
        hoverType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.scatter.series.Marker;
        id(): string | number;
        id(value?: string | number): anychart.core.SeriesBase;
        includeAllPoints(): boolean;
        includePoint(indexes: number | Array<number>): boolean;
        keepOnlyPoints(indexes: number | Array<number>): void;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.SeriesBase;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.SeriesBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        meta(key?: any): any;
        meta(object?: any, value?: any): anychart.core.SeriesBase;
        meta(key?: any, value?: any): anychart.core.SeriesBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.SeriesBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        select(index?: number): anychart.core.SeriesBase;
        select(indexes?: number | Array<number>): anychart.core.SeriesBase;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.scatter.series.Marker;
        selectFill(color: string, opacity?: number): anychart.core.scatter.series.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.scatter.series.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.scatter.series.Marker;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.scatter.series.Marker;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.scatter.series.Marker;
        selectLabels(): anychart.core.ui.LabelsFactory;
        selectLabels(value?: Object | boolean): anychart.core.SeriesBase;
        selectStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectStroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Marker;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Marker;
        selectType(): string | anychart.enums.MarkerType | (() => void);
        selectType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.scatter.series.Marker;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.SeriesBase;
        size(): number;
        size(value?: number): anychart.core.scatter.series.Marker;
        stroke(): anychart.graphics.vector.Stroke | (() => void);
        stroke(strokeFunction?: (() => void)): anychart.core.scatter.series.Marker;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.scatter.series.Marker;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.SeriesBase;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        transformX(xValue: any): number;
        transformY(yValue: any): number;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.scatter.series.Marker;
        unhover(): anychart.core.scatter.series.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        unselect(): anychart.core.SeriesBase;
        unselect(index?: number): anychart.core.SeriesBase;
        unselect(indexes?: Array<number>): anychart.core.SeriesBase;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xScale(): anychart.scales.ScatterBase;
        xScale(value?: anychart.scales.Base): anychart.core.scatter.series.Base;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.scatter.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.stock {
    interface Scroller extends anychart.core.ui.Scroller {
        addSeries(...var_args: (anychart.data.View | anychart.data.Set | Array<any>)[]): Array<anychart.core.stock.scrollerSeries.Base>;
        allowRangeChange(): boolean;
        allowRangeChange(value?: boolean): anychart.core.ui.Scroller;
        area(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Area;
        autoHide(): boolean;
        autoHide(value?: boolean): anychart.core.ui.Scroller;
        candlestick(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Candlestick;
        column(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Column;
        defaultSeriesType(): string | anychart.enums.StockSeriesType;
        defaultSeriesType(value?: string | anychart.enums.StockSeriesType): anychart.core.stock.Scroller;
        ema(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.EMA;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        getSeries(id: number | string): anychart.core.stock.scrollerSeries.Base;
        getSeriesAt(index: number): anychart.core.stock.scrollerSeries.Base;
        getSeriesCount(): number;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Scroller;
        line(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        macd(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, signalPeriod?: number, macdSeriesType?: string | anychart.enums.StockSeriesType, signalSeriesType?: string | anychart.enums.StockSeriesType, histogramSeriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.MACD;
        marker(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Marker;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.Scroller;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.ui.Scroller;
        ohlc(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.OHLC;
        orientation(): anychart.enums.Orientation | string;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeArea;
        rangeColumn(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeColumn;
        rangeSplineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeSplineArea;
        rangeStepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.RangeStepArea;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.core.stock.Scroller;
        removeSeries(id: number | string): anychart.core.stock.Scroller;
        removeSeriesAt(index: number): anychart.core.stock.Scroller;
        roc(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RoC;
        rsi(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RSI;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        selectedFill(color: string, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        sma(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.SMA;
        spline(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Spline;
        splineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.SplineArea;
        stepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.StepArea;
        stepLine(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.StepLine;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(value?: boolean | Object): anychart.core.ui.Scroller;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xAxis(): anychart.core.axes.StockDateTime;
        xAxis(value?: Object | boolean): anychart.core.stock.Scroller;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase): anychart.core.stock.Scroller;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Plot extends anychart.core.VisualBaseWithBounds {
        addSeries(...var_args: (anychart.data.TableMapping)[]): Array<anychart.core.stock.series.Base>;
        annotations(): anychart.core.annotations.PlotController;
        annotations(annotationsList?: Array<any>): anychart.core.stock.Plot;
        area(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Area;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.stock.Plot;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        candlestick(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Candlestick;
        column(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Column;
        dateTimeHighlighter(): anychart.graphics.vector.Stroke;
        dateTimeHighlighter(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.Plot;
        defaultSeriesType(): string | anychart.enums.StockSeriesType;
        defaultSeriesType(value?: string | anychart.enums.StockSeriesType): anychart.core.stock.Plot;
        ema(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.EMA;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        getSeries(id: number | string): anychart.core.stock.series.Base;
        getSeriesAt(index: number): anychart.core.stock.series.Base;
        getSeriesCount(): number;
        grid(index?: number): anychart.core.grids.Stock;
        grid(value?: Object | boolean): anychart.core.stock.Plot;
        grid(index?: number, value?: Object | boolean): anychart.core.stock.Plot;
        hatchFillPalette(): anychart.palettes.HatchFills;
        hatchFillPalette(value?: Array<anychart.graphics.vector.HatchFill.HatchFillType> | Object | anychart.palettes.HatchFills): anychart.palettes.HatchFills | anychart.core.stock.Plot;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legend(): anychart.core.ui.Legend;
        legend(value?: Object | boolean): anychart.core.stock.Plot;
        line(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Line;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        macd(mapping: anychart.data.TableMapping, fastPeriod?: number, slowPeriod?: number, signalPeriod?: number, macdSeriesType?: string | anychart.enums.StockSeriesType, signalSeriesType?: string | anychart.enums.StockSeriesType, histogramSeriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.MACD;
        marker(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Marker;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        minorGrid(index?: number): anychart.core.grids.Stock;
        minorGrid(value?: Object | boolean): anychart.core.stock.Plot;
        minorGrid(indexOrValue?: number, value?: Object | boolean): anychart.core.stock.Plot;
        ohlc(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.OHLC;
        palette(): anychart.palettes.RangeColors | anychart.palettes.DistinctColors;
        palette(value?: anychart.palettes.RangeColors | anychart.palettes.DistinctColors | Object | Array<string>): anychart.core.stock.Plot;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        rangeArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.RangeArea;
        rangeColumn(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.RangeColumn;
        rangeSplineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.RangeSplineArea;
        rangeStepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.RangeStepArea;
        removeAllListeners(type?: string): number;
        removeAllSeries(): anychart.core.stock.Plot;
        removeSeries(id: number | string): anychart.core.stock.Plot;
        removeSeriesAt(index: number): anychart.core.stock.Plot;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        roc(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RoC;
        rsi(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RSI;
        sma(mapping: anychart.data.TableMapping, period?: number, seriesType?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.SMA;
        spline(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Spline;
        splineArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.SplineArea;
        stepArea(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.StepArea;
        stepLine(data?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.StepLine;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        xAxis(): anychart.core.axes.StockDateTime;
        xAxis(value?: Object | boolean): anychart.core.stock.Plot;
        yAxis(index?: number): anychart.core.axes.Linear;
        yAxis(value?: Object | boolean): anychart.core.stock.Plot;
        yAxis(index?: number, value?: Object | boolean): anychart.core.stock.Plot;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.enums.ScatterScaleTypes | anychart.scales.ScatterBase): anychart.core.stock.Plot;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Grouping extends anychart.core.Base {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.stock.Grouping;
        forced(): boolean;
        forced(value?: boolean): anychart.core.stock.Grouping;
        getCurrentDataInterval(): anychart.core.stock.Grouping.Level;
        isGrouped(): boolean;
        levels(): Array<anychart.core.stock.Grouping.Level>;
        levels(value?: Array<(anychart.core.stock.Grouping.Level|string)>): anychart.core.stock.Grouping;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxVisiblePoints(): number;
        maxVisiblePoints(value?: number): anychart.core.stock.Grouping;
        minPixPerPoint(): number;
        minPixPerPoint(value?: number): anychart.core.stock.Grouping;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Grouping {
    interface Level {
        count: number;
        unit: anychart.enums.Interval;
    }
    }
}

declare namespace anychart.core.stock.indicators {
    interface RoC {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.RoC;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RoC;
    }
    interface MACD {
        fastPeriod(): number;
        fastPeriod(value?: number): anychart.core.stock.indicators.MACD;
        histogramSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        histogramSeries(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.MACD;
        macdSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        macdSeries(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.MACD;
        signalPeriod(): number;
        signalPeriod(value?: number): anychart.core.stock.indicators.MACD;
        signalSeries(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        signalSeries(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.MACD;
        slowPeriod(): number;
        slowPeriod(value?: number): anychart.core.stock.indicators.MACD;
    }
    interface SMA {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.SMA;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.SMA;
    }
    interface RSI {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.RSI;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.RSI;
    }
    interface EMA {
        period(): number;
        period(value?: number): anychart.core.stock.indicators.EMA;
        series(): anychart.core.stock.series.Base | anychart.core.stock.scrollerSeries.Base;
        series(type?: string | anychart.enums.StockSeriesType): anychart.core.stock.indicators.EMA;
    }
}

declare namespace anychart.core.stock.scrollerSeries {
    interface SplineArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.SplineArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.SplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.SplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.SplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.SplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.SplineArea;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.SplineArea;
        selectFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.SplineArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.SplineArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.SplineArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.SplineArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.SplineArea;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.SplineArea;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.SplineArea;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.SplineArea;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.SplineArea;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Spline extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.Spline;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Spline;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.Spline;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Spline;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface DiscreteBase extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeStepArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeStepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        highStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeStepArea;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        lowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeStepArea;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeStepArea;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        selectFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeStepArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeStepArea;
        selectHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectHighStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        selectHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeStepArea;
        selectLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectLowStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeStepArea;
        selectLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeStepArea;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.StepArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.StepArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.StepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.StepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.StepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.StepArea;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.StepArea;
        selectFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.StepArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.StepArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.StepArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.StepArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.StepArea;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.StepArea;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.StepArea;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.StepArea;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.StepArea;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.VisualBaseWithBounds {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Area;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Area;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Area;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Area;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Area;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Area;
        selectFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Area;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Area;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Area;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Area;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Area;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.Area;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Area;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.Area;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Area;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface OHLC extends anychart.core.stock.scrollerSeries.DiscreteBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        selectFallingStroke(): anychart.graphics.vector.Stroke;
        selectFallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        selectRisingStroke(): anychart.graphics.vector.Stroke;
        selectRisingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Candlestick extends anychart.core.stock.scrollerSeries.OHLC {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fallingFill(): anychart.graphics.vector.Fill | (() => void);
        fallingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Candlestick;
        fallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Base;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Base;
        risingFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Candlestick;
        risingFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Base;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Base;
        risingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Candlestick;
        risingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Base;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        selectFallingFill(): anychart.graphics.vector.Fill;
        selectFallingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        selectFallingFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Candlestick;
        selectFallingFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        selectFallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        selectFallingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Candlestick;
        selectFallingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        selectFallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectFallingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Base;
        selectFallingStroke(): anychart.graphics.vector.Stroke;
        selectFallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        selectRisingFill(): anychart.graphics.vector.Fill;
        selectRisingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        selectRisingFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Candlestick;
        selectRisingFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        selectRisingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Candlestick;
        selectRisingFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Candlestick;
        selectRisingFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Candlestick;
        selectRisingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectRisingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Candlestick;
        selectRisingStroke(): anychart.graphics.vector.Stroke;
        selectRisingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.OHLC;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Column extends anychart.core.stock.scrollerSeries.DiscreteBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Column;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Column;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Column;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.scrollerSeries.DiscreteBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Column;
        selectFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Column;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Column;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Column;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Column;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Column;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Column;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Column;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        highStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeArea;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        lowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeArea;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeArea;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        selectFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeArea;
        selectHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectHighStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        selectHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeArea;
        selectLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectLowStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeArea;
        selectLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeArea;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepLine extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.StepLine;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.StepLine;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.StepLine;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.StepLine;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Line;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Line;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeColumn extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeColumn;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeColumn;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeColumn;
        selectFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeColumn;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeColumn;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeColumn;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeColumn;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeColumn;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeColumn;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeSplineArea extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeSplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        highStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeSplineArea;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        lowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeSplineArea;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selectFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selectHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectHighStroke(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selectHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selectLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectLowStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.RangeSplineArea;
        selectLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.RangeSplineArea;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.stock.scrollerSeries.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.scrollerSeries.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Marker;
        fill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Marker;
        fill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Marker;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Marker;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.scrollerSeries.Marker;
        selectFill(color: string, opacity?: number): anychart.core.stock.scrollerSeries.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.scrollerSeries.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.scrollerSeries.Marker;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.scrollerSeries.Marker;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.scrollerSeries.Marker;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.Marker;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Marker;
        selectType(): string | anychart.enums.MarkerType | (() => void);
        selectType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.stock.scrollerSeries.Marker;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.scrollerSeries.Base;
        size(): number;
        size(value?: number): anychart.core.stock.scrollerSeries.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.scrollerSeries.Marker;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.scrollerSeries.Marker;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.stock.scrollerSeries.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.scrollerSeries.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.stock.series {
    interface SplineArea extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.SplineArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.SplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.SplineArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.SplineArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.SplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.SplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.SplineArea;
        hoverFill(fillFunction?: (() => void)): anychart.core.stock.series.SplineArea;
        hoverFill(color: string, opacity?: number): anychart.core.stock.series.SplineArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.SplineArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.SplineArea;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.SplineArea;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.SplineArea;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.stock.series.SplineArea;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Area;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.SplineArea;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.series.SplineArea;
        selectFill(color: string, opacity?: number): anychart.core.stock.series.SplineArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.SplineArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.SplineArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.SplineArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.SplineArea;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.series.SplineArea;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.SplineArea;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.SplineArea;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.SplineArea;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Spline extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.stock.series.Spline;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Spline;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.series.Spline;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Spline;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.Spline;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Spline;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface DiscreteBase extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.DiscreteBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeStepArea extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeStepArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeStepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeStepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        highStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeStepArea;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeStepArea;
        hoverFill(fillFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        hoverFill(color: string, opacity?: number): anychart.core.stock.series.RangeStepArea;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeStepArea;
        hoverHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverHighStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        hoverHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeStepArea;
        hoverLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverLowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        hoverLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeStepArea;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        lowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeStepArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeStepArea;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        selectFill(color: string, opacity?: number): anychart.core.stock.series.RangeStepArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeStepArea;
        selectHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectHighStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        selectHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeStepArea;
        selectLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectLowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeStepArea;
        selectLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeStepArea;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepArea extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.StepArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.StepArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.StepArea;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.StepArea;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.StepArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.StepArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.StepArea;
        hoverFill(fillFunction?: (() => void)): anychart.core.stock.series.StepArea;
        hoverFill(color: string, opacity?: number): anychart.core.stock.series.StepArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.StepArea;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.StepArea;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.StepArea;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.StepArea;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.stock.series.StepArea;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.StepArea;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.StepArea;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.series.StepArea;
        selectFill(color: string, opacity?: number): anychart.core.stock.series.StepArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.StepArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.StepArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.StepArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.StepArea;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.series.StepArea;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.StepArea;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.StepArea;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.StepArea;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Base extends anychart.core.VisualBaseWithBounds {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Area extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Area;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.Area;
        fill(color: string, opacity?: number): anychart.core.stock.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.Area;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.Area;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.Area;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Area;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Area;
        hoverFill(fillFunction?: (() => void)): anychart.core.stock.series.Area;
        hoverFill(color: string, opacity?: number): anychart.core.stock.series.Area;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.Area;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.Area;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.Area;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Area;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.stock.series.Area;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Area;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Area;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.series.Area;
        selectFill(color: string, opacity?: number): anychart.core.stock.series.Area;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.Area;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.Area;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.Area;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Area;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.series.Area;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Area;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.Area;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Area;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface OHLC extends anychart.core.stock.series.DiscreteBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.OHLC;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverRisingStroke(fillFunction?: (() => void)): anychart.core.stock.series.OHLC;
        hoverRisingStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverRisingStroke(fillFunction?: (() => void)): anychart.core.stock.series.OHLC;
        hoverRisingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.OHLC;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.DiscreteBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.OHLC;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Candlestick extends anychart.core.stock.series.OHLC {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fallingFill(): anychart.graphics.vector.Fill;
        fallingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Base;
        fallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        fallingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Base;
        fallingStroke(): anychart.graphics.vector.Stroke;
        fallingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.OHLC;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverFallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverFallingHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Base;
        hoverRisingFill(): anychart.graphics.vector.Fill;
        hoverRisingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Base;
        hoverRisingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverRisingHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Base;
        hoverRisingStroke(fillFunction?: (() => void)): anychart.core.stock.series.OHLC;
        hoverRisingStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverRisingStroke(fillFunction?: (() => void)): anychart.core.stock.series.OHLC;
        hoverRisingStroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.OHLC;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.DiscreteBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        risingFill(): anychart.graphics.vector.Fill;
        risingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Base;
        risingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        risingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Base;
        risingStroke(): anychart.graphics.vector.Stroke;
        risingStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.OHLC;
        selectFallingFill(): anychart.graphics.vector.Fill;
        selectFallingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Base;
        selectFallingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectFallingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Base;
        selectRisingFill(): anychart.graphics.vector.Fill;
        selectRisingFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Base;
        selectRisingHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | boolean;
        selectRisingHatchFill(patternFillOrTypeOrState?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string | boolean, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Base;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Column extends anychart.core.stock.series.DiscreteBase {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Column;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.Column;
        fill(color: string, opacity?: number): anychart.core.stock.series.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.Column;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.Column;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.Column;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Column;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Column;
        hoverFill(fillFunction?: (() => void)): anychart.core.stock.series.Column;
        hoverFill(color: string, opacity?: number): anychart.core.stock.series.Column;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.Column;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.Column;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.Column;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Column;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.stock.series.Column;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Column;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        pointWidth(): string | number;
        pointWidth(value?: number | string): anychart.core.stock.series.DiscreteBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Column;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeArea extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        highStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeArea;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeArea;
        hoverFill(fillFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        hoverFill(color: string, opacity?: number): anychart.core.stock.series.RangeArea;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeArea;
        hoverHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverHighStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        hoverHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeArea;
        hoverLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverLowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        hoverLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeArea;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        lowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeArea;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        selectFill(color: string, opacity?: number): anychart.core.stock.series.RangeArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.RangeArea;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.RangeArea;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeArea;
        selectHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectHighStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        selectHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeArea;
        selectLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectLowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeArea;
        selectLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeArea;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface StepLine extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.stock.series.StepLine;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.StepLine;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.series.StepLine;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.StepLine;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.StepLine;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.StepLine;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Line extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getIndex(): number;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.stock.series.Line;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.stock.series.Line;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Line;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Line;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeColumn extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeColumn;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.RangeColumn;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeColumn;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeColumn;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeColumn;
        hoverFill(fillFunction?: (() => void)): anychart.core.stock.series.RangeColumn;
        hoverFill(color: string, opacity?: number): anychart.core.stock.series.RangeColumn;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeColumn;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeColumn;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeColumn;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeColumn;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.series.RangeColumn;
        selectFill(color: string, opacity?: number): anychart.core.stock.series.RangeColumn;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeColumn;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeColumn;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeColumn;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeColumn;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeColumn;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface RangeSplineArea extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeSplineArea;
        fill(fillFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        fill(color: string, opacity?: number): anychart.core.stock.series.RangeSplineArea;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeSplineArea;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        highStroke(): anychart.graphics.vector.Stroke | (() => void);
        highStroke(fillFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        highStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeSplineArea;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeSplineArea;
        hoverFill(fillFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        hoverFill(color: string, opacity?: number): anychart.core.stock.series.RangeSplineArea;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeSplineArea;
        hoverHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverHighStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        hoverHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeSplineArea;
        hoverLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        hoverLowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        hoverLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeSplineArea;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        lowStroke(): anychart.graphics.vector.Stroke | (() => void);
        lowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        lowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeSplineArea;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object | boolean | string): anychart.core.stock.series.Base;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.RangeSplineArea;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        selectFill(color: string, opacity?: number): anychart.core.stock.series.RangeSplineArea;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.RangeSplineArea;
        selectHighStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectHighStroke(fillFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        selectHighStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeSplineArea;
        selectLowStroke(): anychart.graphics.vector.Stroke | (() => void);
        selectLowStroke(strokeFunction?: (() => void)): anychart.core.stock.series.RangeSplineArea;
        selectLowStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.RangeSplineArea;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Marker extends anychart.core.stock.series.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        data(): anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string;
        data(value?: anychart.data.TableMapping | anychart.data.Table | Array<Array<any>> | string, mappingSettings?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}, csvSettings?: Object): anychart.core.stock.series.Base;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Marker;
        getPixelBounds(): anychart.math.Rect;
        hatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Marker;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Marker;
        hoverHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        hoverHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Marker;
        hoverSize(): number;
        hoverSize(value?: number): anychart.core.stock.series.Marker;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(strokeFunction?: (() => void)): anychart.core.stock.series.Marker;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Marker;
        hoverType(): string | anychart.enums.MarkerType | (() => void);
        hoverType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.stock.series.Marker;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        legendItem(): anychart.core.utils.LegendItemSettings;
        legendItem(value?: Object): anychart.core.stock.series.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        name(): string;
        name(value?: string): anychart.core.stock.series.Base;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        selectFill(): anychart.graphics.vector.Fill;
        selectFill(value: anychart.graphics.vector.Fill): anychart.core.stock.series.Marker;
        selectFill(fillFunction?: (() => void)): anychart.core.stock.series.Marker;
        selectFill(color: string, opacity?: number): anychart.core.stock.series.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.stock.series.Marker;
        selectFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.stock.series.Marker;
        selectFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.stock.series.Marker;
        selectHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        selectHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.stock.series.Marker;
        selectStroke(): anychart.graphics.vector.Stroke;
        selectStroke(strokeFunction?: (() => void)): anychart.core.stock.series.Marker;
        selectStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Marker;
        selectType(): string | anychart.enums.MarkerType | (() => void);
        selectType(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.stock.series.Marker;
        seriesType(): string;
        seriesType(value?: string): anychart.core.stock.series.Base;
        size(): number;
        size(value?: number): anychart.core.stock.series.Marker;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(strokeFunction?: (() => void)): anychart.core.stock.series.Marker;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.stock.series.Marker;
        tooltip(): anychart.core.ui.SeriesTooltip;
        tooltip(value?: Object | boolean): anychart.core.stock.series.Base;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.stock.series.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        yScale(): anychart.scales.ScatterBase;
        yScale(value?: anychart.scales.ScatterBase): anychart.core.stock.series.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.core.ui {
    interface Timeline {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(): anychart.graphics.vector.Fill | string;
        baseFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baseFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseStroke(): anychart.graphics.vector.Stroke | string;
        baseStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        baselineAbove(): boolean;
        baselineAbove(value?: boolean): anychart.core.ui.Timeline;
        baselineFill(): anychart.graphics.vector.Fill | string;
        baselineFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baselineFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineStroke(): anychart.graphics.vector.Stroke | string;
        baselineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.Timeline;
        connectorFill(): anychart.graphics.vector.Fill | string;
        connectorFill(value?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, cx?: number, cy?: number, opacityOrMode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        connectorPreviewStroke(): anychart.graphics.vector.Stroke | string;
        connectorPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        connectorStroke(): anychart.graphics.vector.Stroke | string;
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editConnectorThumbFill(): anychart.graphics.vector.Fill | string;
        editConnectorThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbStroke(): anychart.graphics.vector.Stroke | string;
        editConnectorThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editIntervalThumbFill(): anychart.graphics.vector.Fill | string;
        editIntervalThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbStroke(): anychart.graphics.vector.Stroke | string;
        editIntervalThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editPreviewFill(): anychart.graphics.vector.Fill | string;
        editPreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editPreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewStroke(): anychart.graphics.vector.Stroke | string;
        editPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editProgressFill(): anychart.graphics.vector.Fill | string;
        editProgressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editProgressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressStroke(): anychart.graphics.vector.Stroke | string;
        editProgressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewDashStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewDashStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewFill(): anychart.graphics.vector.Fill | string;
        editStructurePreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editing(): boolean;
        editing(value?: boolean): anychart.core.ui.Timeline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object): anychart.core.ui.Timeline;
        lineMarker(index?: number): anychart.core.axisMarkers.GanttLine;
        lineMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        lineMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object): anychart.core.ui.Timeline;
        maximumGap(): number;
        maximumGap(value: number): anychart.core.ui.Timeline;
        milestoneFill(): anychart.graphics.vector.Fill | string;
        milestoneFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        milestoneFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneStroke(): anychart.graphics.vector.Stroke | string;
        milestoneStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        minimumGap(): number;
        minimumGap(value: number): anychart.core.ui.Timeline;
        parentFill(): anychart.graphics.vector.Fill | string;
        parentFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        parentFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentStroke(): anychart.graphics.vector.Stroke | string;
        parentStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        progressFill(): anychart.graphics.vector.Fill | string;
        progressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        progressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressStroke(): anychart.graphics.vector.Stroke | string;
        progressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        rangeMarker(index?: number): anychart.core.axisMarkers.GanttRange;
        rangeMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        rangeMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(): anychart.graphics.vector.Fill | string;
        selectedElementFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        selectedElementFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementStroke(): anychart.graphics.vector.Stroke | string;
        selectedElementStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        textMarker(index?: number): anychart.core.axisMarkers.GanttText;
        textMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        textMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Timeline;
    }
    interface DataGrid extends anychart.core.VisualBaseWithBounds {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        column(index?: number): anychart.core.ui.DataGrid.Column;
        column(value?: anychart.core.ui.DataGrid.Column): anychart.core.ui.DataGrid;
        column(index?: number, value?: anychart.core.ui.DataGrid.Column): anychart.core.ui.DataGrid;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        data(): anychart.data.Tree;
        data(value?: anychart.data.Tree): anychart.core.ui.DataGrid;
        draw(): anychart.core.ui.DataGrid;
        editStructurePreviewDashStroke(): string | anychart.graphics.vector.Stroke;
        editStructurePreviewDashStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        editStructurePreviewFill(): anychart.graphics.vector.Fill | string;
        editStructurePreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        editStructurePreviewFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        editStructurePreviewStroke(): string | anychart.graphics.vector.Stroke;
        editStructurePreviewStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        editing(): boolean;
        editing(value?: boolean): anychart.ui.DataGrid;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endIndex(): number;
        endIndex(value?: number): anychart.core.ui.DataGrid;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        horizontalOffset(): number;
        horizontalOffset(value?: number): anychart.core.ui.DataGrid;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowHoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.DataGrid;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        startIndex(): number;
        startIndex(value?: number): anychart.core.ui.DataGrid;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.DataGrid;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticalOffset(): number;
        verticalOffset(value?: number): anychart.core.ui.DataGrid;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module DataGrid {
    interface Column extends anychart.core.VisualBase {
        cellTextSettings(): anychart.core.ui.LabelsFactory;
        cellTextSettings(value?: Object): anychart.core.ui.DataGrid.Column;
        cellTextSettingsOverrider(): (() => void);
        cellTextSettingsOverrider(value?: (() => void)): anychart.core.ui.DataGrid.Column;
        collapseExpandButtons(): boolean;
        collapseExpandButtons(value?: boolean): anychart.core.ui.DataGrid.Column;
        defaultWidth(): number;
        defaultWidth(value?: number): anychart.core.ui.DataGrid.Column;
        depthPaddingMultiplier(): number;
        depthPaddingMultiplier(value?: number): anychart.core.ui.DataGrid.Column;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.DataGrid.Column;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        setColumnFormat(fieldName: string, presetValue: anychart.enums.ColumnFormats): anychart.core.ui.DataGrid.Column;
        setColumnFormat(fieldName: string, settings: Object): anychart.core.ui.DataGrid.Column;
        textFormatter(value?: (() => void)): anychart.core.ui.DataGrid.Column;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.ui.DataGrid.Column;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.DataGrid.Column;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    }
    interface MarkersFactory extends anychart.core.VisualBase {
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.MarkersFactory;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.MarkersFactory;
        fill(): anychart.graphics.vector.Fill | string;
        fill(value?: anychart.graphics.vector.Fill | string): anychart.core.ui.MarkersFactory;
        fill(color: string, opacity?: number): anychart.core.ui.MarkersFactory;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.MarkersFactory;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.MarkersFactory;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.MarkersFactory;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.MarkersFactory;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.MarkersFactory;
        position(): string;
        position(value?: string): anychart.core.ui.MarkersFactory;
        positionFormatter(): (() => void);
        positionFormatter(value?: (() => void)): anychart.core.ui.MarkersFactory;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.MarkersFactory;
        size(): number;
        size(value?: number): anychart.core.ui.MarkersFactory;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.MarkersFactory;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.MarkersFactory;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.ui.MarkersFactory;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module MarkersFactory {
    interface Marker extends anychart.core.VisualBase {
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.MarkersFactory.Marker;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | string;
        fill(value?: anychart.graphics.vector.Fill | string): anychart.core.ui.MarkersFactory.Marker;
        fill(color: string, opacity?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.MarkersFactory.Marker;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.MarkersFactory.Marker;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.MarkersFactory.Marker;
        position(): anychart.enums.Position | string;
        position(value?: anychart.enums.Position | string): anychart.core.ui.MarkersFactory.Marker;
        positionFormatter(): any;
        positionFormatter(value?: any): any;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.MarkersFactory.Marker;
        size(): number;
        size(value?: number): anychart.core.ui.MarkersFactory.Marker;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.MarkersFactory.Marker;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.MarkersFactory.Marker;
        type(): anychart.enums.MarkerType | (() => void);
        type(value?: anychart.enums.MarkerType | (() => void)): anychart.core.ui.MarkersFactory.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    }
    interface Scroller extends anychart.core.VisualBase {
        allowRangeChange(): boolean;
        allowRangeChange(value?: boolean): anychart.core.ui.Scroller;
        autoHide(): boolean;
        autoHide(value?: boolean): anychart.core.ui.Scroller;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Scroller;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.Scroller;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.ui.Scroller;
        orientation(): anychart.enums.Orientation | string;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        selectedFill(color: string, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(value?: boolean | Object): anychart.core.ui.Scroller;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module Scroller {
    interface Thumbs {
        autoHide(): boolean;
        autoHide(value?: boolean): anychart.core.ui.Scroller.Thumbs;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.Scroller.Thumbs;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller.Thumbs;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller.Thumbs;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller.Thumbs;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller.Thumbs;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller.Thumbs;
        hoverFill(): anychart.graphics.vector.Fill;
        hoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller.Thumbs;
        hoverFill(color: string, opacity?: number): anychart.core.ui.Scroller.Thumbs;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller.Thumbs;
        hoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller.Thumbs;
        hoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller.Thumbs;
        hoverStroke(): anychart.graphics.vector.Stroke;
        hoverStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller.Thumbs;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller.Thumbs;
    }
    }
    interface ColorRange extends anychart.core.axes.Linear {
        align(): anychart.enums.Align;
        align(value?: anychart.enums.Align | string): anychart.core.ui.ColorRange;
        colorLineSize(): number;
        colorLineSize(value?: number): anychart.core.ui.ColorRange;
        drawFirstLabel(): boolean;
        drawFirstLabel(value?: boolean): anychart.core.axes.Linear;
        drawLastLabel(): boolean;
        drawLastLabel(value?: boolean): anychart.core.axes.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        getRemainingBounds(): anychart.math.Rect;
        isHorizontal(): boolean;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object | boolean): anychart.core.axes.Linear;
        length(): number | string;
        length(value?: string | number): anychart.core.ui.ColorRange;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        marker(): anychart.core.ui.MarkersFactory.Marker;
        marker(value?: anychart.core.ui.MarkersFactory.Marker | Object): anychart.core.ui.ColorRange;
        minorLabels(): anychart.core.ui.LabelsFactory;
        minorLabels(value?: Object | boolean): anychart.core.axes.Linear;
        minorTicks(): anychart.core.axes.Ticks;
        minorTicks(value?: Object | boolean): anychart.core.axes.Linear;
        orientation(): anychart.enums.Orientation;
        orientation(value?: string | anychart.enums.Orientation): anychart.core.axes.Linear;
        overlapMode(): anychart.enums.LabelsOverlapMode;
        overlapMode(value?: anychart.enums.LabelsOverlapMode | string): anychart.core.axes.Linear;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.axes.Linear;
        staggerLines(): number;
        staggerLines(value?: number): anychart.core.axes.Linear;
        staggerMaxLines(): number;
        staggerMaxLines(value?: number): anychart.core.axes.Linear;
        staggerMode(): boolean;
        staggerMode(value?: boolean): anychart.core.axes.Linear;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.axes.Linear;
        ticks(): anychart.core.axes.Ticks;
        ticks(value?: Object | boolean): anychart.core.axes.Linear;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.axes.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.axes.Linear;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Label extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.ui.Label;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.Label;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Label;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.Label;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.Label;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.Label;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.Label;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Label;
        position(): anychart.enums.Position;
        position(value?: anychart.enums.Position | string): anychart.core.ui.Label;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.ui.Label;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Label;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ChartTooltip extends anychart.core.Base {
        allowLeaveChart(): boolean;
        allowLeaveChart(value?: boolean): anychart.core.ui.ChartTooltip;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.ChartTooltip;
        background(): anychart.core.ui.Background;
        background(value?: boolean | Object | string): anychart.core.ui.ChartTooltip;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.ChartTooltip;
        displayMode(): anychart.enums.TooltipDisplayMode;
        displayMode(value?: anychart.enums.TooltipDisplayMode | string): anychart.core.ui.ChartTooltip;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.ChartTooltip;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.ChartTooltip;
        fontDecoration(): anychart.graphics.vector.Text.Decoration;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.ChartTooltip;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.ChartTooltip;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.ChartTooltip;
        fontSize(): number;
        fontSize(value?: number | string): anychart.core.ui.ChartTooltip;
        fontStyle(): anychart.graphics.vector.Text.FontStyle;
        fontStyle(value?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.ui.ChartTooltip;
        fontVariant(): anychart.graphics.vector.Text.FontVariant;
        fontVariant(value?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.ui.ChartTooltip;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.ChartTooltip;
        hAlign(): anychart.graphics.vector.Text.HAlign;
        hAlign(value?: string | anychart.graphics.vector.Text.HAlign): anychart.core.ui.ChartTooltip;
        hide(force?: boolean, event?: anychart.core.MouseEvent): void;
        hideDelay(): number;
        hideDelay(value?: number): anychart.core.ui.ChartTooltip;
        letterSpacing(): number;
        letterSpacing(value?: number): anychart.core.ui.ChartTooltip;
        lineHeight(): number | string;
        lineHeight(value?: number | string): anychart.core.ui.ChartTooltip;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number;
        offsetX(value?: number): anychart.core.ui.ChartTooltip;
        offsetY(): number;
        offsetY(value?: number): anychart.core.ui.ChartTooltip;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.ChartTooltip;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.ChartTooltip;
        position(): anychart.enums.Position | anychart.core.ui.ChartTooltip;
        position(value?: anychart.enums.Position | string): anychart.enums.Position | anychart.core.ui.ChartTooltip;
        positionMode(): string;
        positionMode(value?: string | anychart.enums.TooltipPositionMode): anychart.core.ui.ChartTooltip;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.ChartTooltip;
        separator(): anychart.core.ui.Separator;
        separator(value?: boolean | Object): anychart.core.ui.ChartTooltip;
        textDirection(): anychart.graphics.vector.Text.Direction;
        textDirection(value?: string | anychart.graphics.vector.Text.Direction): anychart.core.ui.ChartTooltip;
        textFormatter(): (() => void);
        textFormatter(value?: (() => void)): anychart.core.ui.ChartTooltip;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.ChartTooltip;
        textSettings(): number;
        textSettings(value?: Object): anychart.core.ui.ChartTooltip;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.ui.ChartTooltip;
        textWrap(): anychart.graphics.vector.Text.TextWrap;
        textWrap(value?: string | anychart.graphics.vector.Text.TextWrap): anychart.core.ui.ChartTooltip;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object): anychart.core.ui.ChartTooltip;
        titleFormatter(): (() => void);
        titleFormatter(value?: (() => void)): anychart.core.ui.ChartTooltip;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.ChartTooltip;
        vAlign(): anychart.graphics.vector.Text.VAlign;
        vAlign(value?: string | anychart.graphics.vector.Text.VAlign): anychart.core.ui.ChartTooltip;
    }
    interface CrosshairLabel {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.ui.CrosshairLabel;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.CrosshairLabel;
        axisIndex(): number;
        axisIndex(value?: number): anychart.core.ui.CrosshairLabel;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.CrosshairLabel;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.CrosshairLabel;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.CrosshairLabel;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.CrosshairLabel;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.CrosshairLabel;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.CrosshairLabel;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.CrosshairLabel;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.CrosshairLabel;
        textFormatter(): (() => void);
        textFormatter(value?: (() => void)): anychart.core.ui.CrosshairLabel;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.CrosshairLabel;
    }
    interface StageCredits {
        alt(): string;
        alt(value?: string): anychart.core.ui.StageCredits;
        logoSrc(): string;
        logoSrc(value?: string): anychart.core.ui.StageCredits;
        text(): string;
        text(value?: string): anychart.core.ui.StageCredits;
        url(): string;
        url(value?: string): anychart.core.ui.StageCredits;
    }
    interface SeriesTooltip extends anychart.core.VisualBase {
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.SeriesTooltip;
        background(): anychart.core.ui.Background;
        background(value?: boolean | Object | string): anychart.core.ui.SeriesTooltip;
        disablePointerEvents(): number;
        disablePointerEvents(value?: number): anychart.core.ui.SeriesTooltip;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.SeriesTooltip;
        fontDecoration(): anychart.graphics.vector.Text.Decoration;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.SeriesTooltip;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.SeriesTooltip;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.SeriesTooltip;
        fontSize(): number;
        fontSize(value?: number | string): anychart.core.ui.SeriesTooltip;
        fontStyle(): anychart.graphics.vector.Text.FontStyle;
        fontStyle(value?: string | anychart.graphics.vector.Text.FontStyle): anychart.core.ui.SeriesTooltip;
        fontVariant(): anychart.graphics.vector.Text.FontVariant;
        fontVariant(value?: string | anychart.graphics.vector.Text.FontVariant): anychart.core.ui.SeriesTooltip;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.SeriesTooltip;
        hAlign(): anychart.graphics.vector.Text.HAlign;
        hAlign(value?: string | anychart.graphics.vector.Text.HAlign): anychart.core.ui.SeriesTooltip;
        hide(force?: boolean, event?: anychart.core.MouseEvent): boolean;
        hideDelay(): number;
        hideDelay(value?: number): anychart.core.ui.SeriesTooltip;
        letterSpacing(): number;
        letterSpacing(value?: number): anychart.core.ui.SeriesTooltip;
        lineHeight(): number | string;
        lineHeight(value?: number | string): anychart.core.ui.SeriesTooltip;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number;
        offsetX(value?: number): anychart.core.ui.SeriesTooltip;
        offsetY(): number;
        offsetY(value?: number): anychart.core.ui.SeriesTooltip;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.SeriesTooltip;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.SeriesTooltip;
        position(): anychart.enums.Position;
        position(value?: anychart.enums.Position | string): anychart.core.ui.SeriesTooltip;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.SeriesTooltip;
        separator(): anychart.core.ui.Separator;
        separator(value?: boolean | Object): anychart.core.ui.SeriesTooltip;
        textDirection(): anychart.graphics.vector.Text.Direction;
        textDirection(value?: string | anychart.graphics.vector.Text.Direction): anychart.core.ui.SeriesTooltip;
        textFormatter(): (() => void) | string;
        textFormatter(value?: string): anychart.core.ui.SeriesTooltip;
        textFormatter(formatterFunction?: (() => void)): anychart.core.ui.SeriesTooltip;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.SeriesTooltip;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.SeriesTooltip | anychart.graphics.vector.Text.TextOverflow;
        textSettings(): number;
        textSettings(value?: Object): anychart.core.ui.SeriesTooltip;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.ui.SeriesTooltip;
        textWrap(): anychart.graphics.vector.Text.TextWrap;
        textWrap(value?: string | anychart.graphics.vector.Text.TextWrap): anychart.core.ui.SeriesTooltip;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object): anychart.core.ui.SeriesTooltip;
        titleFormatter(): (() => void);
        titleFormatter(value?: (() => void)): anychart.core.ui.SeriesTooltip;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.SeriesTooltip;
        vAlign(): anychart.graphics.vector.Text.VAlign;
        vAlign(value?: string | anychart.graphics.vector.Text.VAlign): anychart.core.ui.SeriesTooltip;
        valuePostfix(): string;
        valuePostfix(value?: string): anychart.core.ui.SeriesTooltip;
        valuePrefix(): string;
        valuePrefix(value?: string): anychart.core.ui.SeriesTooltip;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Tooltip extends anychart.core.Base {
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.Tooltip | anychart.enums.Anchor;
        background(value?: string | Object | boolean): anychart.core.ui.Background | anychart.core.ui.Tooltip;
        enabled(value?: boolean): anychart.core.ui.Tooltip | boolean;
        hide(force?: boolean): anychart.core.ui.Tooltip;
        hideDelay(value?: number): number | anychart.core.ui.Tooltip;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(value?: number): number | anychart.core.ui.Tooltip;
        offsetY(value?: number): number | anychart.core.ui.Tooltip;
        padding(value?: string | number | Array<(number|string)> | Object): anychart.core.utils.Padding | anychart.core.ui.Tooltip;
        removeAllListeners(type?: string): number;
        separator(value?: Object | boolean): anychart.core.ui.Separator | anychart.core.ui.Tooltip;
        textFormatter(): (() => void) | string;
        textFormatter(value?: (() => void) | string): anychart.core.ui.Tooltip;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.ui.Tooltip;
        titleFormatter(): (() => void);
        titleFormatter(value?: (() => void)): anychart.core.ui.Tooltip;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        valuePostfix(value?: string): string | anychart.core.ui.Tooltip;
        valuePrefix(value?: string): string | anychart.core.ui.Tooltip;
    }
    interface Background extends anychart.core.VisualBaseWithBounds {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cornerType(): anychart.enums.BackgroundCornersType;
        cornerType(value?: anychart.enums.BackgroundCornersType): anychart.core.ui.Background;
        corners(): Array<number>;
        corners(value?: number | string | Array<number>): anychart.core.ui.Background;
        corners(topLeft?: number | string, topRight?: number | string, bottomRight?: number | string, bottomLeft?: number | string): anychart.core.ui.Background;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Background;
        fill(color: string, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Background;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Legend extends anychart.core.Text {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.ui.Legend;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Legend;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Legend;
        hoverCursor(): anychart.enums.Cursor | string;
        hoverCursor(value?: anychart.enums.Cursor | string): anychart.core.ui.Legend;
        iconSize(): number;
        iconSize(value?: number | string): anychart.core.ui.Legend;
        iconTextSpacing(): number;
        iconTextSpacing(value?: string | number): anychart.core.ui.Legend;
        inverted(): boolean;
        inverted(value?: boolean): anychart.core.ui.Legend;
        items(): Array<anychart.core.ui.Legend.LegendItemProvider>;
        items(value?: Array<anychart.core.ui.Legend.LegendItemProvider>): anychart.core.ui.Legend;
        itemsFormatter(): (() => void);
        itemsFormatter(value?: (() => void)): anychart.core.ui.Legend;
        itemsLayout(): anychart.enums.Layout | string;
        itemsLayout(value?: string | anychart.enums.Layout): anychart.core.ui.Legend;
        itemsSourceMode(): string | anychart.enums.LegendItemsSourceMode;
        itemsSourceMode(value?: string | anychart.enums.LegendItemsSourceMode): anychart.core.ui.Legend;
        itemsSpacing(): string | number;
        itemsSpacing(value?: string | number): anychart.core.ui.Legend;
        itemsTextFormatter(): (() => void);
        itemsTextFormatter(value?: (() => void)): anychart.core.ui.Legend;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.Legend;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Legend;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.Legend;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Legend;
        paginator(): anychart.core.ui.Paginator;
        paginator(value?: Object | boolean): anychart.core.ui.Legend;
        position(): anychart.enums.Orientation | string;
        position(value?: anychart.enums.Orientation | string): anychart.core.ui.Legend;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.ui.Legend;
        titleFormatter(): (() => void);
        titleFormatter(value?: (() => void)): anychart.core.ui.Legend;
        titleSeparator(): anychart.core.ui.Separator;
        titleSeparator(value?: Object | boolean): anychart.core.ui.Legend;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Legend;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Legend;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    namespace Legend {
    interface LegendItemProvider {
        iconFill: anychart.graphics.vector.Fill;
        iconHatchFill: anychart.graphics.vector.HatchFill.HatchFillType | anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill;
        iconMarkerType: string;
        iconStroke: anychart.graphics.vector.Stroke;
        iconType: string;
        index: number;
        meta: Object;
        text: string;
    }
    }
    interface Separator extends anychart.core.VisualBase {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.graphics.math.Rect | Object, opacityOrMode?: number | anychart.graphics.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Fill | anychart.core.ui.Separator;
        getRemainingBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Separator;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(spaceOrTopOrTopAndBottom?: string | number | Array<(number|string)> | Object, rightOrRightAndLeft?: string | number, bottom?: string | number, left?: string | number): anychart.core.ui.Separator | anychart.core.utils.Margin;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Separator | anychart.enums.Orientation;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Separator | anychart.graphics.vector.Stroke;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Separator;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Title extends anychart.core.Text {
        align(): anychart.enums.Align;
        align(value?: anychart.enums.Align | string): anychart.core.ui.Title;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Title;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Title;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(): anychart.core.utils.Margin;
        margin(allValues?: string | number | Array<(number|string)> | Object): anychart.core.ui.Title;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Title;
        orientation(): anychart.enums.Orientation;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Title;
        padding(): anychart.core.utils.Padding;
        padding(value?: string | number | Array<(number|string)> | Object): anychart.core.ui.Title;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Title;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.Title;
        rotation(value?: number): anychart.core.ui.Title;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.ui.Title;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Title;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Paginator extends anychart.core.Text {
        background(value?: string | Object | boolean): anychart.core.ui.Paginator | anychart.core.ui.Background;
        currentPage(): number;
        currentPage(value?: number | string): anychart.core.ui.Paginator;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        layout(): anychart.enums.Layout;
        layout(value?: string | anychart.enums.Layout): anychart.core.ui.Paginator;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(spaceOrTopOrTopAndBottom?: string | number | Array<(number|string)> | Object, rightOrRightAndLeft?: string | number, bottom?: string | number, left?: string | number): anychart.core.ui.Paginator | anychart.core.utils.Margin;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Paginator | anychart.enums.Orientation;
        padding(spaceOrTopOrTopAndBottom?: string | number | Array<(number|string)> | Object, rightOrRightAndLeft?: string | number, bottom?: string | number, left?: string | number): anychart.core.ui.Paginator | anychart.core.utils.Padding;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ChartScroller extends anychart.core.ui.Scroller {
        allowRangeChange(): boolean;
        allowRangeChange(value?: boolean): anychart.core.ui.Scroller;
        autoHide(): boolean;
        autoHide(value?: boolean): anychart.core.ui.Scroller;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Scroller;
        inverted(): boolean;
        inverted(value?: boolean): anychart.core.ui.ChartScroller;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.Scroller;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.ui.Scroller;
        orientation(): anychart.enums.Orientation | string;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller;
        position(): anychart.enums.ChartScrollerPosition;
        position(value?: anychart.enums.ChartScrollerPosition | string): anychart.core.ui.ChartScroller;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        selectedFill(color: string, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(value?: boolean | Object): anychart.core.ui.Scroller;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface CircularLabelsFactory extends anychart.core.ui.LabelsFactory {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.LabelsFactory;
        autoRotate(): boolean;
        autoRotate(value?: boolean): anychart.core.ui.CircularLabelsFactory;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.LabelsFactory;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.LabelsFactory;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.LabelsFactory;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.LabelsFactory;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.LabelsFactory;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory;
        position(): string;
        position(value?: string): anychart.core.ui.LabelsFactory;
        positionFormatter(): (() => void);
        positionFormatter(value?: (() => void)): anychart.core.ui.LabelsFactory;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.LabelsFactory;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textFormatter(): (() => void) | string;
        textFormatter(value?: string): anychart.core.ui.LabelsFactory;
        textFormatter(value?: (() => void)): anychart.core.ui.LabelsFactory;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.LabelsFactory;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module CircularLabelsFactory {
    interface Label extends anychart.core.ui.LabelsFactory.Label {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory.Label;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory.Label;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.enums.Anchor;
        autoRotate(): boolean | anychart.core.ui.CircularLabelsFactory.Label;
        autoRotate(value?: boolean): boolean | anychart.core.ui.CircularLabelsFactory.Label;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.LabelsFactory.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.LabelsFactory.Label;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getIndex(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.LabelsFactory.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory.Label;
        position(): string;
        position(value?: string): anychart.core.ui.LabelsFactory.Label;
        positionFormatter(): any;
        positionFormatter(value?: any): any;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.LabelsFactory.Label;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textFormatter(): any;
        textFormatter(value?: any): any;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    }
    interface Crosshair extends anychart.core.VisualBase {
        displayMode(): anychart.enums.CrosshairDisplayMode;
        displayMode(value?: anychart.enums.CrosshairDisplayMode | string): anychart.core.ui.Crosshair;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xLabel(): anychart.core.ui.CrosshairLabel;
        xLabel(value?: Object | boolean): anychart.core.ui.Crosshair;
        xStroke(): anychart.graphics.vector.Stroke;
        xStroke(value?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Crosshair;
        yLabel(): anychart.core.ui.CrosshairLabel;
        yLabel(value?: Object | boolean): anychart.core.ui.Crosshair;
        yStroke(): anychart.graphics.vector.Stroke;
        yStroke(value?: anychart.graphics.vector.Stroke | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Crosshair;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Table extends anychart.core.VisualBaseWithBounds {
        border(): anychart.core.ui.table.Border;
        border(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Table;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cellBorder(): anychart.graphics.vector.Stroke;
        cellBorder(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Table;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        cellFill(color: string, opacity?: number): anychart.core.ui.Table;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(value?: Array<(number|string)> | Object): anychart.core.ui.Table;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Table;
        colsCount(): number;
        colsCount(value?: number): anychart.core.ui.Table;
        colsMaxWidth(): string | number;
        colsMaxWidth(value?: string | number): anychart.core.ui.Table;
        colsMinWidth(): string | number;
        colsMinWidth(value?: string | number): anychart.core.ui.Table;
        colsWidth(): string | number;
        colsWidth(value?: string | number): anychart.core.ui.Table;
        contents(): Array<Array<(anychart.core.VisualBase)>>;
        contents(tableValues?: Array<Array<(anychart.core.VisualBase|string|number)>>, demergeCells?: boolean): anychart.core.ui.Table;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.Table;
        draw(): anychart.core.ui.Table;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.Table;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Table;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.Table;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.Table;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.Table;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.Table;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.Table;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.Table;
        getCell(row: number, col: number): anychart.core.ui.table.Cell;
        getCol(col: number): anychart.core.ui.table.Column;
        getJpgBase64String(onSuccess: (() => void), onError?: (() => void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccess: (() => void), onError?: (() => void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPixelBounds(): anychart.math.Rect;
        getPngBase64String(onSuccess: (() => void), onError?: (() => void), width?: number, height?: number, quality?: number): void;
        getRow(row: number): anychart.core.ui.table.Row;
        getSvgBase64String(onSuccess: (() => void), onError?: (() => void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.Table;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.Table;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.Table;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rowEvenFill(): anychart.graphics.vector.Fill;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Table;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowOddFill(): anychart.graphics.vector.Fill;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Table;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowsCount(): number;
        rowsCount(value?: number): anychart.core.ui.Table;
        rowsHeight(): string | number;
        rowsHeight(value?: string | number): anychart.core.ui.Table;
        rowsMaxHeight(): string | number;
        rowsMaxHeight(value?: string | number): anychart.core.ui.Table;
        rowsMinHeight(): string | number;
        rowsMinHeight(value?: string | number): anychart.core.ui.Table;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number): void;
        saveAsPng(width?: number, height?: number, quality?: number): void;
        saveAsSvg(paperSize?: string, landscape?: boolean): void;
        saveAsSvg(width?: number, height?: number): void;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.Table;
        shareAsJpg(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.Table;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.Table;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Table;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.ui.Table;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.Table;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.Table;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface LegendItem extends anychart.core.Text {
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        draw(): anychart.core.ui.LegendItem;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getContentBounds(): anychart.math.Rect;
        getHeight(): number;
        getTextElement(): anychart.graphics.vector.Text;
        getWidth(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        iconFill(value?: anychart.graphics.vector.Fill): anychart.graphics.vector.Fill | anychart.core.ui.LegendItem;
        iconHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        iconHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.ui.LegendItem;
        iconStroke(value?: anychart.graphics.vector.Stroke): anychart.graphics.vector.Stroke | anychart.core.ui.LegendItem;
        iconTextSpacing(value?: number): anychart.core.ui.LegendItem | number;
        iconType(value?: string | (() => void)): string | (() => void) | anychart.core.ui.LegendItem;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.LegendItem;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.ui.LegendItem;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(value?: string): string | anychart.core.ui.LegendItem;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        x(value?: number | string): number | string | anychart.core.ui.LegendItem;
        y(value?: number | string): number | string | anychart.core.ui.LegendItem;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface LabelsFactory extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.LabelsFactory;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.LabelsFactory;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.LabelsFactory;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.LabelsFactory;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.LabelsFactory;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.LabelsFactory;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory;
        position(): string;
        position(value?: string): anychart.core.ui.LabelsFactory;
        positionFormatter(): (() => void);
        positionFormatter(value?: (() => void)): anychart.core.ui.LabelsFactory;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.LabelsFactory;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textFormatter(): (() => void) | string;
        textFormatter(value?: string): anychart.core.ui.LabelsFactory;
        textFormatter(value?: (() => void)): anychart.core.ui.LabelsFactory;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.LabelsFactory;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module LabelsFactory {
    interface Label extends anychart.core.Text {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory.Label;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory.Label;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.enums.Anchor;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.LabelsFactory.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.LabelsFactory.Label;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getIndex(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.LabelsFactory.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory.Label;
        position(): string;
        position(value?: string): anychart.core.ui.LabelsFactory.Label;
        positionFormatter(): any;
        positionFormatter(value?: any): any;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.LabelsFactory.Label;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textFormatter(): any;
        textFormatter(value?: any): any;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.LabelsFactory.Label;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    }
    interface ChartCredits extends anychart.core.Base {
        alt(): string;
        alt(value?: string): anychart.core.ui.ChartCredits;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        logoSrc(): string;
        logoSrc(value?: string): anychart.core.ui.ChartCredits;
        removeAllListeners(type?: string): number;
        text(): string;
        text(value?: string): anychart.core.ui.ChartCredits;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        url(): string;
        url(value?: string): anychart.core.ui.ChartCredits;
    }
}

declare namespace anychart.core.ui.table {
    interface Border {
        bottom(): anychart.graphics.vector.Stroke;
        bottom(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Border;
        left(): anychart.graphics.vector.Stroke;
        left(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Border;
        right(): anychart.graphics.vector.Stroke;
        right(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Border;
        top(): anychart.graphics.vector.Stroke;
        top(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Border;
    }
    interface Cell extends anychart.core.ui.table.Base {
        border(): anychart.core.ui.table.Border;
        border(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Cell;
        colSpan(): number;
        colSpan(value?: number): anychart.core.ui.table.Cell;
        content(): anychart.core.VisualBase;
        content(value?: anychart.core.VisualBase | string | number): anychart.core.ui.table.Cell;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.table.Base;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.table.Cell;
        fill(color: string, opacity?: number): anychart.core.ui.table.Cell;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.table.Cell;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.table.Cell;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.table.Cell;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.table.Base;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Base;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.table.Base;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.table.Base;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.table.Base;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Base;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Base;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.table.Base;
        getBounds(): anychart.math.Rect;
        getCol(): anychart.core.ui.table.Column;
        getColNum(): number;
        getRow(): anychart.core.ui.table.Row;
        getRowNum(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Base;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.table.Base;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.table.Base;
        padding(): anychart.core.ui.table.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.table.Cell;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.table.Cell;
        rowSpan(): number;
        rowSpan(value?: number): anychart.core.ui.table.Cell;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.table.Base;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Base;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.table.Base;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Base;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.ui.table.Base;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.table.Base;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Base;
    }
    interface Base {
        border(): anychart.core.ui.table.Border;
        border(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.table.Base;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.table.Base;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Base;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.table.Base;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.table.Base;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.table.Base;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Base;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Base;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.table.Base;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Base;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.table.Base;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.table.Base;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.table.Base;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Base;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.table.Base;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Base;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.ui.table.Base;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.table.Base;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Base;
    }
    interface Row extends anychart.core.ui.table.Base {
        border(): anychart.core.ui.table.Border;
        border(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        cellBorder(): anychart.core.ui.table.Border;
        cellBorder(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(value: anychart.graphics.vector.Fill): anychart.core.ui.table.Base;
        cellFill(color: string, opacity?: number): anychart.core.ui.table.Base;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.table.Base;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.table.Base;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.table.Base;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(value?: Array<(number|string)> | Object): anychart.core.ui.table.Base;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.table.Base;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.table.Base;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.table.Base;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Base;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.table.Base;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.table.Base;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.table.Base;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Base;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Base;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.table.Base;
        getCell(col: number): anychart.core.ui.table.Cell;
        getRowNum(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Base;
        height(): string | number;
        height(value?: string | number): anychart.core.ui.table.Row;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.table.Base;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.table.Base;
        maxHeight(): string | number;
        maxHeight(value?: string | number): anychart.core.ui.table.Row;
        minHeight(): string | number;
        minHeight(value?: string | number): anychart.core.ui.table.Row;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.table.Base;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Base;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.table.Base;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Base;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.ui.table.Base;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.table.Base;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Base;
    }
    interface Column extends anychart.core.ui.table.Base {
        border(): anychart.core.ui.table.Border;
        border(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        cellBorder(): anychart.core.ui.table.Border;
        cellBorder(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.table.Base;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(value: anychart.graphics.vector.Fill): anychart.core.ui.table.Base;
        cellFill(color: string, opacity?: number): anychart.core.ui.table.Base;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.table.Base;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.table.Base;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.table.Base;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(value?: Array<(number|string)> | Object): anychart.core.ui.table.Base;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.table.Base;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.table.Base;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.table.Base;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.table.Base;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.table.Base;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.table.Base;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.table.Base;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.table.Base;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.table.Base;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.table.Base;
        getCell(row: number): anychart.core.ui.table.Cell;
        getColNum(): number;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.table.Base;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.table.Base;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.table.Base;
        maxWidth(): string | number;
        maxWidth(value?: string | number): anychart.core.ui.table.Column;
        minWidth(): string | number;
        minWidth(value?: string | number): anychart.core.ui.table.Column;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.table.Base;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.table.Base;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.table.Base;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.table.Base;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.ui.table.Base;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.table.Base;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.table.Base;
        width(): string | number;
        width(value?: string | number): anychart.core.ui.table.Column;
    }
    interface Padding {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.ui.table.Padding;
        left(): number | string;
        left(value?: number | string): anychart.core.ui.table.Padding;
        right(): number | string;
        right(value?: number | string): anychart.core.ui.table.Padding;
        top(): number | string;
        top(value?: number | string): anychart.core.ui.table.Padding;
    }
}

declare namespace anychart.core.utils {
    interface LegendItemSettings extends anychart.core.Text {
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        disabled(): boolean;
        disabled(value?: boolean): anychart.core.utils.LegendItemSettings;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        iconEnabled(): boolean;
        iconEnabled(value?: boolean): anychart.core.utils.LegendItemSettings;
        iconFill(): anychart.graphics.vector.Fill | (() => void);
        iconFill(value: anychart.graphics.vector.Fill): anychart.core.utils.LegendItemSettings;
        iconFill(color: string, opacity?: number): anychart.core.utils.LegendItemSettings;
        iconFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.utils.LegendItemSettings;
        iconFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.utils.LegendItemSettings;
        iconHatchFill(): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void);
        iconHatchFill(patternFillOrType?: anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill | (() => void) | anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.core.utils.LegendItemSettings;
        iconMarkerFill(): anychart.graphics.vector.Fill | string;
        iconMarkerFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.graphics.math.Rect | Object, opacityOrMode?: number | anychart.graphics.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.core.utils.LegendItemSettings;
        iconMarkerStroke(): anychart.graphics.vector.Stroke | string;
        iconMarkerStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.LegendItemSettings;
        iconMarkerType(): anychart.enums.MarkerType | string | (() => void);
        iconMarkerType(value?: anychart.enums.MarkerType | string | (() => void)): anychart.core.utils.LegendItemSettings;
        iconSize(): number;
        iconSize(value?: number | string): anychart.core.utils.LegendItemSettings;
        iconStroke(): (() => void) | anychart.graphics.vector.Stroke;
        iconStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.LegendItemSettings;
        iconTextSpacing(): number;
        iconTextSpacing(value?: number): anychart.core.utils.LegendItemSettings;
        iconType(): anychart.enums.LegendItemIconType | string | (() => void);
        iconType(value?: anychart.enums.LegendItemIconType | string | (() => void)): anychart.core.utils.LegendItemSettings;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.utils.LegendItemSettings;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface SeriesPointContextProvider extends anychart.core.utils.BaseContextProvider {
        getDataValue(key: string): any;
        getSeriesMeta(key?: string): any;
        getStat(key: string): any;
        getTokenType(name: string): anychart.enums.TokenType | string;
        getTokenValue(name: string): any;
    }
    interface LegendContextProvider {
        getMeta(key?: string): any;
        getStat(key?: string): any;
        getTokenType(name: string): anychart.enums.TokenType;
        getTokenValue(name: string): any;
    }
    interface UnboundRegionsSettings {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.utils.UnboundRegionsSettings;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.utils.UnboundRegionsSettings;
        fill(color: string, opacity?: number): anychart.core.utils.UnboundRegionsSettings;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.utils.UnboundRegionsSettings;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.utils.UnboundRegionsSettings;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.utils.UnboundRegionsSettings;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(stroke?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.UnboundRegionsSettings;
    }
    interface BaseContextProvider {
        getTokenType(name: string): anychart.enums.TokenType | string;
        getTokenValue(name: string): any;
    }
    interface PointContextProvider extends anychart.core.utils.BaseContextProvider {
        getDataValue(key: string): any;
        getStat(key?: string): any;
        getTokenType(name: string): anychart.enums.TokenType | string;
        getTokenValue(name: string): any;
    }
    interface Margin extends anychart.core.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.utils.Margin;
        left(): number | string;
        left(value?: number | string): anychart.core.utils.Margin;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.utils.Margin;
        set(value1?: string | number | Array<(number|string)> | Object, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.utils.Margin;
        top(): number | string;
        top(value?: number | string): anychart.core.utils.Margin;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface MapInteractivity extends anychart.core.utils.Interactivity {
        copyFormatter(): (() => void);
        copyFormatter(value?: (() => void)): anychart.core.utils.MapInteractivity;
        drag(): boolean;
        drag(value?: boolean): anychart.core.utils.MapInteractivity;
        hoverMode(): anychart.enums.HoverMode;
        hoverMode(value?: anychart.enums.HoverMode | string): anychart.core.utils.Interactivity;
        keyboardZoomAndMove(): boolean;
        keyboardZoomAndMove(value?: boolean): anychart.core.utils.Interactivity;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.utils.Interactivity;
        spotRadius(): number;
        spotRadius(value?: number): anychart.core.utils.Interactivity;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zoomOnDoubleClick(): boolean;
        zoomOnDoubleClick(value?: boolean): anychart.core.utils.Interactivity;
        zoomOnMouseWheel(): boolean;
        zoomOnMouseWheel(value?: boolean): anychart.core.utils.Interactivity;
    }
    interface PertPointContextProvider extends anychart.core.utils.BaseContextProvider {
        getDataValue(key: string): any;
        getStat(key?: string): any;
    }
    interface StockHighlightContextProvider extends anychart.core.utils.SeriesPointContextProvider {
        getDataValue(key: string): any;
        getSeriesMeta(key?: string): any;
        getStat(key: string): any;
        getTokenType(name: string): anychart.enums.TokenType | string;
        getTokenValue(name: string): any;
    }
    interface Error extends anychart.core.Base {
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        mode(): anychart.enums.ErrorMode | string;
        mode(value?: string | anychart.enums.ErrorMode): anychart.core.utils.Error;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        valueError(): string | number;
        valueError(value?: string | number): anychart.core.utils.Error;
        valueErrorStroke(): anychart.graphics.vector.Stroke;
        valueErrorStroke(fillFunction?: (() => void)): anychart.core.utils.Error;
        valueErrorStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Error;
        valueErrorWidth(): number;
        valueErrorWidth(value?: number): anychart.core.utils.Error;
        valueLowerError(): string | number;
        valueLowerError(value?: string | number): anychart.core.utils.Error;
        valueUpperError(): string | number;
        valueUpperError(value?: string | number): anychart.core.utils.Error;
        xError(): string | number;
        xError(value?: string | number): anychart.core.utils.Error;
        xErrorStroke(): anychart.graphics.vector.Stroke;
        xErrorStroke(fillFunction?: (() => void)): anychart.core.utils.Error;
        xErrorStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.utils.Error;
        xErrorWidth(): number;
        xErrorWidth(value?: number): anychart.core.utils.Error;
        xLowerError(): string | number;
        xLowerError(value?: string | number): anychart.core.utils.Error;
        xUpperError(): string | number;
        xUpperError(value?: string | number): anychart.core.utils.Error;
    }
    interface AxisLabelsContextProvider extends anychart.core.utils.BaseContextProvider {
        getTokenType(name: string): anychart.enums.TokenType | string;
        getTokenValue(name: string): any;
    }
    interface GanttContextProvider {
        getDataValue(key: string): any;
        getMetaValue(key: string): any;
    }
    interface Interactivity extends anychart.core.Base {
        hoverMode(): anychart.enums.HoverMode;
        hoverMode(value?: anychart.enums.HoverMode | string): anychart.core.utils.Interactivity;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        selectionMode(): anychart.enums.SelectionMode;
        selectionMode(value?: anychart.enums.SelectionMode | string): anychart.core.utils.Interactivity;
        spotRadius(): number;
        spotRadius(value?: number): anychart.core.utils.Interactivity;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface LinearGaugePointerContextProvider extends anychart.core.utils.BaseContextProvider {
        getDataValue(key: string): any;
        getTokenValue(name: string): any;
    }
    interface A11y extends anychart.core.Base {

    }
    interface ChartA11y extends anychart.core.utils.A11y {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.utils.ChartA11y;
        mode(): anychart.enums.A11yMode;
        mode(value?: anychart.enums.A11yMode | string): anychart.core.utils.ChartA11y;
        titleFormatter(): (() => void) | string;
        titleFormatter(value?: (() => void) | string): anychart.core.utils.ChartA11y;
    }
    interface SeriesA11y extends anychart.core.utils.A11y {
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.utils.SeriesA11y;
        titleFormatter(): (() => void) | string;
        titleFormatter(value?: (() => void) | string): anychart.core.utils.SeriesA11y;
    }
    interface OrdinalZoom {
        continuous(): boolean;
        continuous(value?: boolean): anychart.core.utils.OrdinalZoom;
        getEndRatio(): number;
        getStartRatio(): number;
        setTo(startRatio: number, endRatio: number): anychart.core.utils.OrdinalZoom;
        setToPointsCount(pointsCount: number, fromEnd?: boolean, scale?: anychart.scales.Base): anychart.core.utils.OrdinalZoom;
        setToValues(startValue: any, endValue: any, scale?: anychart.scales.Base): anychart.core.utils.OrdinalZoom;
    }
    interface Animation extends anychart.core.Base {
        duration(): number;
        duration(value: number): anychart.core.utils.Animation;
        enabled(): boolean;
        enabled(value: boolean): anychart.core.utils.Animation;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TreeMapPointContextProvider extends anychart.core.utils.BaseContextProvider {
        getDataValue(key: string): any;
        getStat(key: string): any;
        getTokenType(name: string): anychart.enums.TokenType | string;
        getTokenValue(name: string): any;
    }
    interface ChartContextProvider extends anychart.core.utils.BaseContextProvider {
        getStat(key?: string): any;
    }
    interface Padding extends anychart.core.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.utils.Padding;
        left(): number | string;
        left(value?: number | string): anychart.core.utils.Padding;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.utils.Padding;
        set(value1?: string | number | Array<(number|string)> | Object, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.utils.Padding;
        top(): number | string;
        top(value?: number | string): anychart.core.utils.Padding;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Bounds extends anychart.core.Base {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.utils.Bounds;
        height(): number | string;
        height(value?: number | string): anychart.core.utils.Bounds;
        left(): number | string;
        left(value?: number | string): anychart.core.utils.Bounds;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.utils.Bounds;
        maxWidth(value?: number | string): number | string;
        maxWidth(value?: number | string): anychart.core.utils.Bounds;
        minHeight(value?: number | string): number | string;
        minHeight(value?: number | string): anychart.core.utils.Bounds;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.utils.Bounds;
        right(): number | string;
        right(value?: number | string): anychart.core.utils.Bounds;
        set(xOrRect?: number | string | Array<(number|string)> | anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds, y?: number | string, width?: number | string, height?: number | string): anychart.core.utils.Bounds;
        toRect(parentLeftOrRect?: number | anychart.math.Rect | Object, parentTop?: number, parentWidth?: number, parentHeight?: number): anychart.math.Rect;
        top(): number | string;
        top(value?: number | string): anychart.core.utils.Bounds;
        width(): number | string;
        width(value?: number | string): anychart.core.utils.Bounds;
    }
}

declare namespace anychart.data {
    function buildMapping(dataSet: anychart.data.Set, fromIndex: number, toIndex: number, names: Array<string>, keys?: Array<string>): anychart.data.Mapping;
    function loadCsvFile(url: string, onSuccess: (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function loadJsonFile(url: string, onSuccess: (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function loadXmlFile(url: string, onSuccess: (() => void), onError?: (() => void), method?: string, content?: ArrayBuffer | ArrayBufferView | Blob | Document | FormData | string, headers?: Object, timeoutInterval?: number, withCredentials?: boolean, context?: any): void;
    function mapAsTable(data: Array<Array<any>>, mode?: anychart.enums.MapAsTableMode | string, seriesCount?: number): Array<anychart.data.Mapping>;
    function parseHtmlTable(tableSelector?: string, rowsSelector?: string, cellsSelector?: string, headersSelector?: string, captionSelector?: string, valueProcessor?: (() => void)): anychart.data.TableData;
    function set(data?: Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.data.Set;
    function table(keyColumnIndex?: number): anychart.data.Table;
    function tree(data?: Array<Object>, fillMethod?: anychart.enums.TreeFillingMethod): anychart.data.Tree;
    interface TableData {
        caption: string;
        header: Array<string>;
        rows: Array<any>;
    }
    interface Tree extends anychart.core.Base {
        addChild(child: Object): anychart.data.Tree.DataItem;
        addChildAt(child: Object | anychart.data.Tree.DataItem, index: number): anychart.data.Tree.DataItem;
        addData(data: Array<Object> | string, fillingMethod?: anychart.enums.TreeFillingMethod | string, csvSettingsOrDeps?: Object | Array<anychart.data.Tree.Dependency>): anychart.data.Tree;
        createIndexOn(field: string, asString?: boolean): anychart.data.Tree;
        dispatchEvents(): boolean;
        dispatchEvents(value?: boolean): anychart.data.Tree;
        getChildAt(index: number): anychart.data.Tree.DataItem;
        getChildren(): Array<anychart.data.Tree.DataItem>;
        getTraverser(): anychart.data.Traverser;
        indexOfChild(child: anychart.data.Tree.DataItem): number;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        removeAllListeners(type?: string): number;
        removeChild(child: anychart.data.Tree.DataItem): anychart.data.Tree.DataItem;
        removeChildAt(index: number): anychart.data.Tree.DataItem;
        removeChildren(): anychart.data.Tree;
        removeIndexOn(field: string): anychart.data.Tree;
        search(soughtField: string, value: string | number | boolean, comparisonFn?: (() => void)): anychart.data.Tree.DataItem | Array<anychart.data.Tree.DataItem>;
        searchItems(soughtField: string, value: string | number | boolean, comparisonFn?: (() => void)): Array<anychart.data.Tree.DataItem>;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    namespace Tree {
    interface Dependency {
        from: string | number;
        to: string | number;
    }
    }
    module Tree {
    interface DataItem {
        addChild(child: Object | anychart.data.Tree.DataItem): anychart.data.Tree.DataItem;
        addChildAt(child: Object | anychart.data.Tree.DataItem, index: number): anychart.data.Tree.DataItem;
        del(...var_args: (any)[]): anychart.data.Tree.DataItem;
        get(key: string): any;
        getChildAt(index: number): anychart.data.Tree.DataItem;
        getChildren(): Array<anychart.data.Tree.DataItem>;
        getParent(): anychart.data.Tree.DataItem;
        indexOfChild(child: anychart.data.Tree.DataItem): number;
        meta(key: string): any;
        meta(key: string, value?: any): any;
        numChildren(): number;
        remove(): anychart.data.Tree.DataItem;
        removeChild(child: anychart.data.Tree.DataItem): anychart.data.Tree.DataItem;
        removeChildAt(index: number): anychart.data.Tree.DataItem;
        removeChildren(): anychart.data.Tree.DataItem;
        set(...var_args: (any)[]): anychart.data.Tree.DataItem;
    }
    }
    interface Traverser {
        advance(): boolean;
        current(): anychart.data.Tree.DataItem;
        get(key: string): any;
        getDepth(): number;
        meta(key: string): any;
        meta(key: string, value?: any): any;
        nodeYieldCondition(): (() => void);
        nodeYieldCondition(value?: (() => void)): anychart.data.Traverser;
        reset(): anychart.data.Traverser;
        set(key: string, value: any): anychart.data.Traverser;
        toArray(): Array<anychart.data.Tree.DataItem>;
        traverseChildrenCondition(): (() => void);
        traverseChildrenCondition(value?: (() => void)): anychart.data.Traverser;
    }
    interface TableIterator {
        advance(): boolean;
        get(field: string): any;
        getIndex(): number;
        getKey(): number;
        reset(): void;
    }
    interface Mapping extends anychart.data.View {
        concat(otherView: anychart.data.View | Array<any>): anychart.data.View;
        derive(): anychart.data.View;
        filter(fieldName: string, func: (() => void)): anychart.data.View;
        find(fieldName: string, fieldValue: any): number;
        get(rowIndex: number, fieldName: string): any;
        getArrayMapping(): {[prop: string]: Array<number>};
        getIndexMapping(): Array<string>;
        getIterator(): anychart.data.Iterator;
        getObjectMapping(): {[prop: string]: Array<string>};
        getRowsCount(): number;
        getSimpleRowMapping(): Array<string>;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        meta(index: number, name: string): any;
        meta(index: number, name: string, value?: any): anychart.data.View;
        removeAllListeners(type?: string): number;
        row(rowIndex: number): any;
        row(rowIndex: number, value?: any): any;
        set(rowIndex: number, fieldName: string, value: any): anychart.data.View;
        sort(fieldName: string, comparator?: (() => void)): anychart.data.View;
        sort(fieldName: string, order?: anychart.enums.Sort): anychart.data.View;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface View extends anychart.core.Base {
        concat(otherView: anychart.data.View | Array<any>): anychart.data.View;
        derive(): anychart.data.View;
        filter(fieldName: string, func: (() => void)): anychart.data.View;
        find(fieldName: string, fieldValue: any): number;
        get(rowIndex: number, fieldName: string): any;
        getDataSets(): Array<anychart.data.Set>;
        getIterator(): anychart.data.Iterator;
        getRowsCount(): number;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        meta(index: number, name: string): any;
        meta(index: number, name: string, value?: any): anychart.data.View;
        removeAllListeners(type?: string): number;
        row(rowIndex: number): any;
        row(rowIndex: number, value?: any): any;
        set(rowIndex: number, fieldName: string, value: any): anychart.data.View;
        sort(fieldName: string, comparator?: (() => void)): anychart.data.View;
        sort(fieldName: string, order?: anychart.enums.Sort): anychart.data.View;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Set extends anychart.core.Base {
        append(...var_args: (any)[]): anychart.data.Set;
        data(): Array<any>;
        data(value?: Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.data.Set;
        getRowsCount(): number;
        insert(row: any, index?: number): anychart.data.Set;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        mapAs(arrayMapping?: {[prop: string]: Array<number>}, objectMapping?: {[prop: string]: Array<string>}, defaultProps?: Array<string>, indexProps?: Array<string>): anychart.data.Mapping;
        remove(index: number): anychart.data.Set;
        removeAllListeners(type?: string): number;
        row(rowIndex: number): any;
        row(rowIndex: number, value?: any): any;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface TableSelectable {
        getIterator(): anychart.data.TableIterator;
        search(key: number, mode?: anychart.enums.TableSearchMode): anychart.data.TableSelectable.RowProxy;
        select(startDate: number | string | Date, endDate: number | string | Date, intervalUnit?: anychart.enums.Interval, intervalCount?: number): anychart.data.TableSelectable;
        selectAll(intervalUnit?: anychart.enums.Interval, intervalCount?: number): anychart.data.TableSelectable;
    }
    module TableSelectable {
    interface RowProxy {
        get(field: string): any;
        getColumn(column: number): any;
        getIndex(): number;
        getKey(): number;
    }
    }
    interface TableComputer {
        addOutputField(name: string, uid?: string): number;
        getFieldIndex(name: string): number;
        setCalculationFunction(value: (() => void)): void;
        setContext(value: Object): void;
        setStartFunction(func: (() => void)): void;
    }
    module TableComputer {
    interface RowProxy extends anychart.data.TableSelectable.RowProxy {
        get(field: string): any;
        getColumn(column: number): any;
        getIndex(): number;
        getKey(): number;
        set(name: string, value: any): boolean;
        setColumn(index: number, value: any): boolean;
    }
    }
    interface TableMapping extends anychart.core.Base {
        addField(name: string, column: number, type?: anychart.enums.AggregationType, weightsColumn?: number): anychart.data.TableMapping;
        createSelectable(): anychart.data.TableSelectable;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Table extends anychart.core.Base {
        addData(rawData: Array<any> | string, removeFromStart?: boolean | number, csvSettings?: Object): anychart.data.Table;
        createComputer(mappingSettingsOrMapping?: anychart.data.TableMapping | {[prop: string]: ({column: (number|string), type:anychart.enums.AggregationType, weights: (number|string)}|number|string)}): anychart.data.TableComputer;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        mapAs(fields?: {[prop: string]: ({column: number, type: anychart.enums.AggregationType, weights: number}|number)}): anychart.data.TableMapping;
        remove(startKey?: number | string | Date, endKey?: number | string | Date): anychart.data.Table;
        removeAllListeners(type?: string): number;
        removeFirst(count?: number): anychart.data.Table;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Iterator {
        advance(): boolean;
        get(fieldName: string): any;
        getIndex(): number;
        getRowsCount(): number;
        meta(name: string): any;
        meta(name: string, value?: any): anychart.data.Iterator;
        reset(): anychart.data.Iterator;
        select(index: number): boolean;
    }
}

declare namespace anychart.enums {
    enum Anchor {
        CENTER,
        CENTER_BOTTOM,
        CENTER_TOP,
        LEFT_BOTTOM,
        LEFT_CENTER,
        LEFT_TOP,
        RIGHT_BOTTOM,
        RIGHT_CENTER,
        RIGHT_TOP
    }
    enum Position {
        CENTER,
        CENTER_BOTTOM,
        CENTER_TOP,
        LEFT_BOTTOM,
        LEFT_CENTER,
        LEFT_TOP,
        RIGHT_BOTTOM,
        RIGHT_CENTER,
        RIGHT_TOP
    }
    enum Align {
        BOTTOM,
        CENTER,
        LEFT,
        RIGHT,
        TOP
    }
    enum Layout {
        HORIZONTAL,
        VERTICAL
    }
    enum RadialGridLayout {
        CIRCUIT,
        RADIAL
    }
    enum Orientation {
        BOTTOM,
        LEFT,
        RIGHT,
        TOP
    }
    enum Sort {
        ASC,
        DESC,
        NONE
    }
    enum MarkerType {
        ARROWHEAD,
        ARROW_DOWN,
        ARROW_LEFT,
        ARROW_RIGHT,
        ARROW_UP,
        CIRCLE,
        CROSS,
        DIAGONAL_CROSS,
        DIAMOND,
        LINE,
        PENTAGON,
        SQUARE,
        STAR10,
        STAR4,
        STAR5,
        STAR6,
        STAR7,
        TRAPEZIUM,
        TRIANGLE_DOWN,
        TRIANGLE_LEFT,
        TRIANGLE_RIGHT,
        TRIANGLE_UP
    }
    enum MapAsTableMode {
        OHLC,
        RANGE,
        VALUE
    }
    enum TreeFillingMethod {
        AS_TABLE,
        AS_TREE
    }
    enum LabelsOverlapMode {
        ALLOW_OVERLAP,
        NO_OVERLAP
    }
    enum BackgroundCornersType {
        CUT,
        NONE,
        ROUND,
        ROUND_INNER
    }
    enum LegendItemIconType {
        AREA,
        BAR,
        BUBBLE,
        CANDLESTICK,
        CIRCLE,
        COLUMN,
        LINE,
        MARKER,
        OHLC,
        RANGE_AREA,
        RANGE_BAR,
        RANGE_COLUMN,
        RANGE_SPLINE_AREA,
        RANGE_STEP_AREA,
        SPLINE,
        SPLINE_AREA,
        SQUARE,
        STEP_AREA,
        STEP_LINE
    }
    enum BulletMarkerType {
        BAR,
        ELLIPSE,
        LINE,
        X
    }
    enum SidePosition {
        CENTER,
        INSIDE,
        OUTSIDE
    }
    enum EventType {
        ANIMATION_END,
        ANIMATION_START,
        ANNOTATION_DRAWING_FINISH,
        ANNOTATION_SELECT,
        ANNOTATION_UNSELECT,
        BEFORE_CREATE_CONNECTOR,
        CHART_DRAW,
        CLOSE,
        COMPLETE,
        DRILL_CHANGE,
        LEGEND_ITEM_CLICK,
        LEGEND_ITEM_DBLCLICK,
        LEGEND_ITEM_MOUSE_DOWN,
        LEGEND_ITEM_MOUSE_MOVE,
        LEGEND_ITEM_MOUSE_OUT,
        LEGEND_ITEM_MOUSE_OVER,
        LEGEND_ITEM_MOUSE_UP,
        POINTS_HOVER,
        POINTS_SELECT,
        POINT_CLICK,
        POINT_DBLCLICK,
        POINT_MOUSE_DOWN,
        POINT_MOUSE_MOVE,
        POINT_MOUSE_OUT,
        POINT_MOUSE_OVER,
        POINT_MOUSE_UP,
        ROW_CLICK,
        ROW_DBL_CLICK,
        ROW_MOUSE_DOWN,
        ROW_MOUSE_MOVE,
        ROW_MOUSE_OUT,
        ROW_MOUSE_OVER,
        ROW_MOUSE_UP,
        ROW_SELECT,
        SCROLLER_CHANGE,
        SCROLLER_CHANGE_FINISH,
        SCROLLER_CHANGE_START,
        SCROLL_CHANGE,
        SELECTED_RANGE_BEFORE_CHANGE,
        SELECTED_RANGE_CHANGE,
        SELECTED_RANGE_CHANGE_FINISH,
        SELECTED_RANGE_CHANGE_START,
        SIGNAL,
        SPLITTER_CHANGE,
        TREE_ITEM_CREATE,
        TREE_ITEM_MOVE,
        TREE_ITEM_REMOVE,
        TREE_ITEM_UPDATE
    }
    enum ScaleStackMode {
        NONE,
        PERCENT,
        VALUE
    }
    enum ScatterTicksMode {
        LINEAR,
        LOGARITHMIC
    }
    enum SparklineSeriesType {
        AREA,
        COLUMN,
        LINE,
        WIN_LOSS
    }
    enum GanttDataFields {
        ACTUAL,
        ACTUAL_END,
        ACTUAL_START,
        BASELINE,
        BASELINE_END,
        BASELINE_START,
        CHILDREN,
        COLLAPSED,
        CONNECTOR,
        CONNECTOR_TYPE,
        CONNECT_TO,
        END,
        END_MARKER,
        FILL,
        HOVER_FILL,
        HOVER_STROKE,
        ID,
        LABEL,
        MARKERS,
        MILESTONE,
        NAME,
        PARENT,
        PERIODS,
        PROGRESS,
        PROGRESS_VALUE,
        ROW_HEIGHT,
        START,
        START_MARKER,
        STROKE
    }
    enum ScaleTypes {
        DATE_TIME,
        LINEAR,
        LINEAR_COLOR,
        LOG,
        ORDINAL,
        ORDINAL_COLOR
    }
    enum ScatterScaleTypes {
        DATE_TIME,
        LINEAR,
        LOG
    }
    enum Interval {
        DAY,
        HOUR,
        MILLISECOND,
        MINUTE,
        MONTH,
        QUARTER,
        SECOND,
        SEMESTER,
        THIRD_OF_MONTH,
        WEEK,
        YEAR
    }
    enum ErrorMode {
        BOTH,
        NONE,
        VALUE,
        X
    }
    enum GaugeSidePosition {
        CENTER,
        INSIDE,
        OUTSIDE
    }
    enum GaugeScaleTypes {
        LINEAR,
        LOG
    }
    enum Cursor {
        CROSSHAIR,
        DEFAULT,
        EW_RESIZE,
        E_RESIZE,
        HELP,
        MOVE,
        NESW_RESIZE,
        NE_RESIZE,
        NS_RESIZE,
        NWSE_RESIZE,
        NW_RESIZE,
        N_RESIZE,
        POINTER,
        SE_RESIZE,
        SW_RESIZE,
        S_RESIZE,
        TEXT,
        WAIT,
        W_RESIZE
    }
    enum LegendItemsSourceMode {
        CATEGORIES,
        DEFAULT
    }
    enum PyramidLabelsPosition {
        INSIDE,
        OUTSIDE_LEFT,
        OUTSIDE_LEFT_IN_COLUMN,
        OUTSIDE_RIGHT,
        OUTSIDE_RIGHT_IN_COLUMN
    }
    enum ColumnFormats {
        DATE_COMMON_LOG,
        DATE_DMY_DOTS,
        DATE_ISO_8601,
        DATE_US_SHORT,
        DIRECT_NUMBERING,
        FINANCIAL,
        PERCENT,
        SHORT_TEXT,
        TEXT
    }
    enum AggregationType {
        AVERAGE,
        FIRST,
        FIRST_VALUE,
        LAST,
        LAST_VALUE,
        LIST,
        MAX,
        MIN,
        SUM,
        WEIGHTED_AVERAGE
    }
    enum StockLabelsOverlapMode {
        ALLOW_MAJOR_OVERLAP,
        ALLOW_MINOR_OVERLAP,
        ALLOW_OVERLAP,
        NO_OVERLAP
    }
    enum TableSearchMode {
        EXACT,
        EXACT_OR_NEXT,
        EXACT_OR_PREV,
        NEAREST
    }
    enum HoverMode {
        BY_SPOT,
        BY_X,
        SINGLE
    }
    enum SelectionMode {
        DRILL_DOWN,
        MULTI_SELECT,
        NONE,
        SINGLE_SELECT
    }
    enum TooltipDisplayMode {
        SEPARATED,
        SINGLE,
        UNION
    }
    enum TooltipPositionMode {
        CHART,
        FLOAT,
        POINT
    }
    enum CrosshairDisplayMode {
        FLOAT,
        STICKY
    }
    enum LabelsDisplayMode {
        ALWAYS_SHOW,
        CLIP,
        DROP
    }
    enum ChartScrollerPosition {
        AFTER_AXES,
        BEFORE_AXES
    }
    enum ConnectorType {
        FINISH_FINISH,
        FINISH_START,
        START_FINISH,
        START_START
    }
    enum GanttDateTimeMarkers {
        CURRENT,
        END,
        START
    }
    enum TokenType {
        DATE_TIME,
        NUMBER,
        PERCENT,
        STRING,
        UNKNOWN
    }
    enum ChartDataExportMode {
        GROUPED,
        RAW,
        SPECIFIC
    }
    enum StringToken {
        AVERAGE,
        AXIS_NAME,
        AXIS_SCALE_MAX,
        AXIS_SCALE_MIN,
        BUBBLE_SIZE,
        BUBBLE_SIZE_PERCENT_OF_CATEGORY,
        BUBBLE_SIZE_PERCENT_OF_SERIES,
        BUBBLE_SIZE_PERCENT_OF_TOTAL,
        CATEGORY_NAME,
        CATEGORY_Y_AVERAGE,
        CATEGORY_Y_MEDIAN,
        CATEGORY_Y_MODE,
        CATEGORY_Y_PERCENT_OF_TOTAL,
        CATEGORY_Y_RANGE_AVERAGE,
        CATEGORY_Y_RANGE_MAX,
        CATEGORY_Y_RANGE_MEDIAN,
        CATEGORY_Y_RANGE_MIN,
        CATEGORY_Y_RANGE_MODE,
        CATEGORY_Y_RANGE_PERCENT_OF_TOTAL,
        CATEGORY_Y_RANGE_SUM,
        CATEGORY_Y_SUM,
        CLOSE,
        DATA_PLOT_BUBBLE_MAX_SIZE,
        DATA_PLOT_BUBBLE_MIN_SIZE,
        DATA_PLOT_BUBBLE_SIZE_AVERAGE,
        DATA_PLOT_BUBBLE_SIZE_SUM,
        DATA_PLOT_MAX_Y_SUM_SERIES_NAME,
        DATA_PLOT_MAX_Y_VALUE_POINT_NAME,
        DATA_PLOT_MAX_Y_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_MIN_Y_SUM_SERIES_NAME,
        DATA_PLOT_MIN_Y_VALUE_POINT_NAME,
        DATA_PLOT_MIN_Y_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_POINT_COUNT,
        DATA_PLOT_SERIES_COUNT,
        DATA_PLOT_X_AVERAGE,
        DATA_PLOT_X_MAX,
        DATA_PLOT_X_MIN,
        DATA_PLOT_X_SUM,
        DATA_PLOT_Y_AVERAGE,
        DATA_PLOT_Y_MAX,
        DATA_PLOT_Y_MIN,
        DATA_PLOT_Y_RANGE_MAX,
        DATA_PLOT_Y_RANGE_MIN,
        DATA_PLOT_Y_RANGE_SUM,
        DATA_PLOT_Y_SUM,
        HIGH,
        INDEX,
        LOW,
        NAME,
        OPEN,
        PERT_CHART_CRITICAL_PATH_STANDARD_DEVIATION,
        PERT_CHART_PROJECT_DURATION,
        RANGE,
        RANGE_END,
        RANGE_START,
        SERIES_BUBBLE_MAX_SIZE,
        SERIES_BUBBLE_MIN_SIZE,
        SERIES_BUBBLE_SIZE_AVERAGE,
        SERIES_BUBBLE_SIZE_MEDIAN,
        SERIES_BUBBLE_SIZE_MODE,
        SERIES_BUBBLE_SIZE_SUM,
        SERIES_FIRST_X_VALUE,
        SERIES_FIRST_Y_VALUE,
        SERIES_LAST_X_VALUE,
        SERIES_LAST_Y_VALUE,
        SERIES_NAME,
        SERIES_POINT_COUNT,
        SERIES_X_AVERAGE,
        SERIES_X_AXIS_NAME,
        SERIES_X_MAX,
        SERIES_X_MEDIAN,
        SERIES_X_MIN,
        SERIES_X_MODE,
        SERIES_X_SUM,
        SERIES_Y_AVERAGE,
        SERIES_Y_AXIS_NAME,
        SERIES_Y_MAX,
        SERIES_Y_MEDIAN,
        SERIES_Y_MIN,
        SERIES_Y_MODE,
        SERIES_Y_RANGE_MAX,
        SERIES_Y_RANGE_MIN,
        SERIES_Y_RANGE_SUM,
        SERIES_Y_SUM,
        VALUE,
        X_PERCENT_OF_SERIES,
        X_PERCENT_OF_TOTAL,
        X_VALUE,
        Y_PERCENT_OF_CATEGORY,
        Y_PERCENT_OF_SERIES,
        Y_PERCENT_OF_TOTAL,
        Y_VALUE
    }
    enum Statistics {
        AVERAGE,
        BUBBLE_SIZE,
        BUBBLE_SIZE_PERCENT_OF_CATEGORY,
        BUBBLE_SIZE_PERCENT_OF_SERIES,
        BUBBLE_SIZE_PERCENT_OF_TOTAL,
        CATEGORY_NAME,
        CATEGORY_Y_AVERAGE,
        CATEGORY_Y_MAX,
        CATEGORY_Y_MEDIAN,
        CATEGORY_Y_MIN,
        CATEGORY_Y_MODE,
        CATEGORY_Y_PERCENT_OF_TOTAL,
        CATEGORY_Y_RANGE_AVERAGE,
        CATEGORY_Y_RANGE_MAX,
        CATEGORY_Y_RANGE_MEDIAN,
        CATEGORY_Y_RANGE_MIN,
        CATEGORY_Y_RANGE_MODE,
        CATEGORY_Y_RANGE_PERCENT_OF_TOTAL,
        CATEGORY_Y_RANGE_SUM,
        CATEGORY_Y_SUM,
        CLOSE,
        COUNT,
        DATA_PLOT_BUBBLE_MAX_SIZE,
        DATA_PLOT_BUBBLE_MIN_SIZE,
        DATA_PLOT_BUBBLE_SIZE_AVERAGE,
        DATA_PLOT_BUBBLE_SIZE_SUM,
        DATA_PLOT_MAX_X_SUM_SERIES_NAME,
        DATA_PLOT_MAX_X_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_MAX_Y_SUM_SERIES_NAME,
        DATA_PLOT_MAX_Y_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_MIN_X_SUM_SERIES_NAME,
        DATA_PLOT_MIN_X_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_MIN_Y_SUM_SERIES_NAME,
        DATA_PLOT_MIN_Y_VALUE_POINT_SERIES_NAME,
        DATA_PLOT_POINT_COUNT,
        DATA_PLOT_SERIES_COUNT,
        DATA_PLOT_X_AVERAGE,
        DATA_PLOT_X_MAX,
        DATA_PLOT_X_MIN,
        DATA_PLOT_X_SUM,
        DATA_PLOT_Y_AVERAGE,
        DATA_PLOT_Y_MAX,
        DATA_PLOT_Y_MIN,
        DATA_PLOT_Y_RANGE_MAX,
        DATA_PLOT_Y_RANGE_MIN,
        DATA_PLOT_Y_RANGE_SUM,
        DATA_PLOT_Y_SUM,
        HIGH,
        INDEX,
        LOW,
        MAX,
        MIN,
        NAME,
        OPEN,
        PERT_CHART_CRITICAL_PATH_STANDARD_DEVIATION,
        PERT_CHART_PROJECT_DURATION,
        POINTS_COUNT,
        RANGE,
        RANGE_END,
        RANGE_START,
        SERIES_AVERAGE,
        SERIES_BUBBLE_MAX_SIZE,
        SERIES_BUBBLE_MIN_SIZE,
        SERIES_BUBBLE_SIZE_AVERAGE,
        SERIES_BUBBLE_SIZE_MEDIAN,
        SERIES_BUBBLE_SIZE_MODE,
        SERIES_BUBBLE_SIZE_SUM,
        SERIES_FIRST_X_VALUE,
        SERIES_FIRST_Y_VALUE,
        SERIES_LAST_X_VALUE,
        SERIES_LAST_Y_VALUE,
        SERIES_MAX,
        SERIES_MIN,
        SERIES_NAME,
        SERIES_POINTS_COUNT,
        SERIES_POINT_COUNT,
        SERIES_SUM,
        SERIES_X_AVERAGE,
        SERIES_X_MAX,
        SERIES_X_MEDIAN,
        SERIES_X_MIN,
        SERIES_X_MODE,
        SERIES_X_SUM,
        SERIES_Y_AVERAGE,
        SERIES_Y_MAX,
        SERIES_Y_MEDIAN,
        SERIES_Y_MIN,
        SERIES_Y_MODE,
        SERIES_Y_RANGE_AVERAGE,
        SERIES_Y_RANGE_MAX,
        SERIES_Y_RANGE_MEDIAN,
        SERIES_Y_RANGE_MIN,
        SERIES_Y_RANGE_MODE,
        SERIES_Y_RANGE_SUM,
        SERIES_Y_SUM,
        SUM,
        VALUE,
        X_PERCENT_OF_SERIES,
        X_PERCENT_OF_TOTAL,
        X_VALUE,
        Y_PERCENT_OF_CATEGORY,
        Y_PERCENT_OF_SERIES,
        Y_PERCENT_OF_TOTAL,
        Y_VALUE
    }
    enum MapProjections {
        AITOFF,
        AUGUST,
        BONNE,
        ECKERT1,
        ECKERT3,
        EQUIRECTANGULAR,
        FAHEY,
        HAMMER,
        MERCATOR,
        ORTHOGRAPHIC,
        ROBINSON,
        WAGNER6,
        WSG84
    }
    enum A11yMode {
        CHART_ELEMENTS,
        DATA_TABLE
    }
    enum MilestoneShape {
        CIRCLE,
        RECTANGLE,
        RHOMBUS
    }
    enum DataField {
        DEPENDS_ON,
        DURATION,
        EXPECTED,
        FROM,
        ID,
        MOST_LIKELY,
        NAME,
        OPTIMISTIC,
        PESSIMISTIC,
        TO
    }
    enum MapUnboundRegionsMode {
        AS_IS,
        HIDE
    }
    enum ScaleComparisonMode {
        NONE,
        PERCENT,
        VALUE
    }
    enum ScaleCompareWithMode {
        FIRST_VISIBLE,
        SERIES_START
    }
    enum AnnotationTypes {
        ANDREWS_PITCHFORK,
        ELLIPSE,
        FIBONACCI_ARC,
        FIBONACCI_FAN,
        FIBONACCI_RETRACEMENT,
        FIBONACCI_TIMEZONES,
        HORIZONTAL_LINE,
        INFINITE_LINE,
        LINE,
        MARKER,
        RAY,
        RECTANGLE,
        TREND_CHANNEL,
        TRIANGLE,
        VERTICAL_LINE
    }
    enum LinearGaugePointerType {
        BAR,
        LED,
        MARKER,
        RANGE_BAR,
        TANK,
        THERMOMETER
    }
    enum MapSeriesType {
        BUBBLE,
        CHOROPLETH,
        CONNECTOR,
        MARKER
    }
    enum CartesianSeriesType {
        AREA,
        BAR,
        BOX,
        BUBBLE,
        CANDLESTICK,
        COLUMN,
        LINE,
        MARKER,
        OHLC,
        RANGE_AREA,
        RANGE_BAR,
        RANGE_COLUMN,
        RANGE_SPLINE_AREA,
        RANGE_STEP_AREA,
        SPLINE,
        SPLINE_AREA,
        STEP_AREA,
        STEP_LINE
    }
    enum Cartesian3dSeriesType {
        AREA,
        BAR,
        COLUMN
    }
    enum ScatterSeriesType {
        BUBBLE,
        LINE,
        MARKER
    }
    enum StockSeriesType {
        AREA,
        CANDLESTICK,
        COLUMN,
        LINE,
        MARKER,
        OHLC,
        RANGE_AREA,
        RANGE_COLUMN,
        RANGE_SPLINE_AREA,
        RANGE_STEP_AREA,
        SPLINE,
        SPLINE_AREA,
        STEP_AREA,
        STEP_LINE
    }
    enum RadarSeriesType {
        AREA,
        LINE,
        MARKER
    }
    enum PolarSeriesType {
        AREA,
        LINE,
        MARKER
    }
}

declare namespace anychart.exports {
    function filename(value?: string): string;
    function server(address?: string): string;
}

declare namespace anychart.format {
    function dateTime(date: number | Date, format?: string, timeZone?: number, locale?: string | anychart.format.Locale): string;
    function inputDateTimeFormat(value?: string): string;
    function inputLocale(value?: string | anychart.format.Locale): string | anychart.format.Locale;
    function number(number: number, decimalsCountOrLocal?: number | anychart.format.NumberLocale | string, decimalPoint?: string, groupsSeparator?: string, scale?: Object | boolean, zeroFillDecimals?: boolean, scaleSuffixSeparator?: string): string;
    function number(number: number, settings?: Object): string;
    function outputDateTimeFormat(value?: string): string;
    function outputLocale(value?: string | anychart.format.Locale): string | anychart.format.Locale;
    function outputTimezone(value?: number): number;
    function parseDateTime(value: any, format?: string, dateHolder?: Date, locale?: string | anychart.format.Locale): Date;
    function parseNumber(value: any, locale?: anychart.format.NumberLocale | string): number;
    function subs(string: string, ...var_args: (any)[]): string;
    interface locales {
        localeName: string;
        localeSettings: anychart.format.Locale;
    }
    interface NumberLocale {
        decimalPoint: string;
        decimalsCount: number;
        groupsSeparator: string;
        scale: Object | boolean;
        scaleSuffixSeparator: string;
        useBracketsForNegative: boolean;
        zeroFillDecimals: boolean;
    }
    interface DateTimeLocale {
        ampms: Array<string>;
        dateFormats: Array<string>;
        dateTimeFormats: Array<string>;
        eras: Array<string>;
        erasNames: Array<string>;
        firstDayOfWeek: number;
        firstWeekCutOfDay: number;
        months: Array<string>;
        narrowMonths: Array<string>;
        narrowWeekdays: Array<string>;
        quarters: Array<string>;
        shortMonths: Array<string>;
        shortQuarters: Array<string>;
        shortWeekdays: Array<string>;
        standaloneMonths: Array<string>;
        standaloneNarrowMonths: Array<string>;
        standaloneNarrowWeekdays: Array<string>;
        standaloneShortMonths: Array<string>;
        standaloneShortWeekdays: Array<string>;
        standaloneWeekdays: Array<string>;
        timeFormats: Array<string>;
        weekdays: Array<string>;
        weekendRange: Array<number>;
    }
    interface Locale {
        dateTimeLocale: anychart.format.DateTimeLocale;
        numberLocale: anychart.format.NumberLocale;
    }
}

declare namespace anychart.gauges {
    function circular(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.CircularGauge;
    function led(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.LinearGauge;
    function linear(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.LinearGauge;
    function tank(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.LinearGauge;
    function thermometer(data?: anychart.data.View | anychart.data.Set | Array<any> | string, csvSettings?: {[prop: string]: (string|boolean)}): anychart.charts.LinearGauge;
}

declare namespace anychart.graphics {
    function circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
    function clip(leftorRect?: number | Array<number> | anychart.graphics.math.Rect | Object, top?: number, width?: number, height?: number): anychart.graphics.vector.Clip;
    function create(container?: Element | string, width?: string | number, height?: string | number): anychart.graphics.vector.Stage;
    function ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
    function hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType, color?: string, thickness?: number, size?: number): anychart.graphics.vector.HatchFill;
    function image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
    function layer(): anychart.graphics.vector.Layer;
    function path(): anychart.graphics.vector.Path;
    function patternFill(bounds: anychart.graphics.math.Rect): anychart.graphics.vector.PatternFill;
    function rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
    function server(address?: string): string;
    function text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.vml.Text;
    function type(): anychart.graphics.StageType;
    function updateReferences(): void;
    function useAbsoluteReferences(value?: boolean): boolean;
    enum StageType {
        SVG,
        VML
    }
}

declare namespace anychart.graphics.events {
    function listen(target: anychart.graphics.vector.Element, type: string | Array<string>, listener: (() => void) | Object, capt?: boolean, handler?: Object): Object;
    function listenOnce(target: anychart.graphics.vector.Element, type: string | Array<string>, listener: (() => void) | Object, capt?: boolean, handler?: Object): Object;
    function removeAll(target: anychart.graphics.vector.Element, type?: string): number;
    function unlisten(target: anychart.graphics.vector.Element, type: string | Array<string>, listener: (() => void) | Object, capt?: boolean, handler?: Object): boolean;
    function unlistenByKey(key: Object): boolean;
    enum EventType {
        CLICK,
        CONTEXTMENU,
        DBLCLICK,
        DRAG,
        DRAG_BEFORE,
        DRAG_EARLY_CANCEL,
        DRAG_END,
        DRAG_START,
        MOUSEDOWN,
        MOUSEMOVE,
        MOUSEOUT,
        MOUSEOVER,
        MOUSEUP,
        TAP,
        TOUCHCANCEL,
        TOUCHEND,
        TOUCHMOVE,
        TOUCHSTART
    }
    interface BrowserEvent {
        preventDefault(): void;
        stopPropagation(): void;
        stopWrapperPropagation(): void;
    }
}

declare namespace anychart.graphics.math {
    interface Rect {
        getBottom(): number;
        getHeight(): number;
        getLeft(): number;
        getRight(): number;
        getTop(): number;
        getWidth(): number;
    }
}

declare namespace anychart.graphics.vector {
    function normalizeFill(fillOrColorOrKeys?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, opacityOrAngleOrCx?: number, modeOrCy?: number | boolean | anychart.graphics.math.Rect | Object, opacityOrMode?: number | anychart.graphics.math.Rect | Object, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Fill;
    function normalizeHatchFill(patternFillOrType?: anychart.graphics.vector.HatchFill | anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill.HatchFillType | string | Object, color?: string, thickness?: string | number, size?: string | number): anychart.graphics.vector.PatternFill | anychart.graphics.vector.HatchFill;
    function normalizeStroke(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Stroke;
    interface GradientKey {
        color: string;
        offset: number;
        opacity: number;
    }
    interface SolidFill {
        color: string;
        opacity: number;
    }
    interface LinearGradientFill {
        angle: number;
        keys: Array<(anychart.graphics.vector.GradientKey|string)>;
        mode: boolean | anychart.graphics.math.Rect;
        opacity: number;
    }
    interface RadialGradientFill {
        cx: number;
        cy: number;
        fx: number;
        fy: number;
        keys: Array<(anychart.graphics.vector.GradientKey|string)>;
        mode: anychart.graphics.math.Rect;
        opacity: number;
    }
    interface ImageFill {
        mode: anychart.graphics.vector.ImageFillMode;
        src: string;
    }
    type ColoredFill = string | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill;
    type Fill = string | anychart.graphics.vector.ImageFill | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | anychart.graphics.vector.PatternFill;
    interface SolidStroke {
        color: string;
        dash: string;
        lineCap: string;
        lineJoin: string;
        opacity: number;
        thickness: number;
    }
    interface LinearGradientStroke {
        angle: number;
        dash: string;
        keys: Array<(anychart.graphics.vector.GradientKey|string)>;
        lineCap: string;
        lineJoin: string;
        mode: boolean | anychart.graphics.math.Rect;
        opacity: number;
        thickness: number;
    }
    interface RadialGradientStroke {
        cx: number;
        cy: number;
        dash: string;
        fx: number;
        fy: number;
        keys: Array<(anychart.graphics.vector.GradientKey|string)>;
        lineCap: string;
        lineJoin: string;
        mode: anychart.graphics.math.Rect;
        opacity: number;
        thickness: number;
    }
    type Stroke = string | anychart.graphics.vector.SolidStroke | anychart.graphics.vector.LinearGradientStroke | anychart.graphics.vector.RadialGradientStroke;
    type AnyColor = anychart.graphics.vector.Fill | anychart.graphics.vector.Stroke | anychart.graphics.vector.PatternFill;
    interface TextStyle {
        color: string;
        decoration: anychart.graphics.vector.Text.Decoration | string;
        direction: anychart.graphics.vector.Text.Direction | string;
        fontFamily: string;
        fontSize: string | number;
        fontStyle: anychart.graphics.vector.Text.FontStyle | string;
        fontVariant: anychart.graphics.vector.Text.FontVariant | string;
        fontWeight: number | string;
        hAlign: anychart.graphics.vector.Text.HAlign | string;
        height: number | string;
        letterSpacing: string;
        lineHeight: string | number;
        opacity: number;
        selectable: boolean;
        textIndent: number;
        textOverflow: anychart.graphics.vector.Text.TextOverflow;
        textWrap: anychart.graphics.vector.Text.TextWrap;
        vAlign: anychart.graphics.vector.Text.VAlign | string;
        width: number | string;
    }
    interface TextSegmentStyle {
        color: string;
        decoration: string;
        fontFamily: string;
        fontSize: string | number;
        fontStyle: string;
        fontVariant: string;
        fontWeight: number | string;
        letterSpacing: string;
        opacity: number;
    }
    enum Anchor {
        CENTER,
        CENTER_BOTTOM,
        CENTER_TOP,
        LEFT_BOTTOM,
        LEFT_CENTER,
        LEFT_TOP,
        RIGHT_BOTTOM,
        RIGHT_CENTER,
        RIGHT_TOP
    }
    enum Cursor {
        CROSSHAIR,
        DEFAULT,
        EW_RESIZE,
        E_RESIZE,
        HELP,
        MOVE,
        NESW_RESIZE,
        NE_RESIZE,
        NS_RESIZE,
        NWSE_RESIZE,
        NW_RESIZE,
        N_RESIZE,
        POINTER,
        SE_RESIZE,
        SW_RESIZE,
        S_RESIZE,
        TEXT,
        WAIT,
        W_RESIZE
    }
    enum StrokeLineJoin {
        BEVEL,
        MITER,
        ROUND
    }
    enum StrokeLineCap {
        BUTT,
        ROUND,
        SQUARE
    }
    enum ImageFillMode {
        FIT,
        FIT_MAX,
        STRETCH,
        TILE
    }
    enum PaperSize {
        A0,
        A1,
        A2,
        A3,
        A4,
        A5,
        A6,
        US_LETTER
    }
    interface LinearGradient {
        dispose(): void;
    }
    interface Shape extends anychart.graphics.vector.Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.graphics.vector.Shape;
        fill(color: string, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Shape;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): void;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Shape;
        strokeThickness(): number;
        strokeThickness(value?: number): anychart.graphics.vector.Shape;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Stage {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Stage;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.Stage;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Stage;
        asyncMode(): boolean;
        asyncMode(value?: boolean): anychart.graphics.vector.Stage;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(value?: anychart.graphics.math.Rect): anychart.graphics.vector.Stage;
        clip(): anychart.graphics.math.Rect;
        container(): Element;
        container(value?: Element): anychart.graphics.vector.Stage;
        createClip(rect?: Array<number> | anychart.graphics.math.Rect | Object): anychart.graphics.vector.Clip;
        createClip(left?: number, top?: number, width?: number, height?: number): anychart.graphics.vector.Clip;
        credits(): anychart.core.ui.StageCredits;
        credits(value?: Object | boolean): anychart.graphics.vector.Stage;
        cross(): void;
        data(): Object;
        data(value?: Object): anychart.graphics.vector.Stage;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Stage;
        diagonalCross(): void;
        diamond(): void;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: (() => void), obj?: Object): anychart.graphics.vector.Stage;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.Element;
        getJpgBase64String(onSuccess: (() => void), onError?: (() => void), width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        getPdfBase64String(onSuccess: (() => void), onError?: (() => void), paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number): void;
        getPngBase64String(onSuccess: (() => void), onError?: (() => void), width?: number, height?: number, quality?: number): void;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getSvgBase64String(onSuccess: (() => void), onError?: (() => void), paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        getTransformationMatrix(): Array<number>;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hatchFill(type?: anychart.graphics.vector.HatchFill.HatchFillType, color?: string, thickness?: number, size?: number): anychart.graphics.vector.HatchFill;
        height(): number;
        height(value?: string | number): anychart.graphics.vector.Stage;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Stage;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        isRendering(): boolean;
        isSuspended(): boolean;
        layer(): anychart.graphics.vector.Layer;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        parent(): anychart.graphics.vector.Stage;
        path(): anychart.graphics.vector.Path;
        pattern(bounds: anychart.graphics.math.Rect): anychart.graphics.vector.PatternFill;
        pie(): void;
        print(paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Stage;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Element;
        removeChildAt(index: number): anychart.graphics.vector.Element;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        resize(width: number | string, height: number | string): void;
        resume(force?: boolean): anychart.graphics.vector.Stage;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Stage;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Stage;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number, filename?: string): void;
        saveAsPng(width?: number, height?: number, quality?: number, filename?: string): void;
        saveAsSvg(paperSize?: string, landscape?: boolean, filename?: string): void;
        saveAsSvg(width?: number, height?: number): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Stage;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Stage;
        setPosition(x: number, y: number): anychart.graphics.vector.Stage;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Stage;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Stage;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Stage;
        shareAsJpg(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean, filename?: string): void;
        shareAsPdf(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: number | string, landscapeOrWidth?: number | boolean, x?: number, y?: number, filename?: string): void;
        shareAsPng(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, width?: number, height?: number, quality?: number, filename?: string): void;
        shareAsSvg(onSuccess: (() => void), onError?: (() => void), asBase64?: boolean, paperSizeOrWidth?: string | number, landscapeOrHeight?: boolean | string, filename?: string): void;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        suspend(): anychart.graphics.vector.Stage;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.Stage;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.Stage;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Stage;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        translate(tx: number, ty: number): anychart.graphics.vector.Stage;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Stage;
        width(): number;
        width(value?: string | number): anychart.graphics.vector.Stage;
    }
    namespace Stage {
    enum EventType {
        RENDER_FINISH,
        RENDER_START,
        STAGE_RENDERED,
        STAGE_RESIZE
    }
    }
    interface PatternFill extends anychart.graphics.vector.Layer {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.Layer;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cross(): void;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        diagonalCross(): void;
        diamond(): void;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: (() => void)): anychart.graphics.vector.Layer;
        forEachChild(callback: (() => void), obj?: Object): anychart.graphics.vector.Layer;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.Element;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hasParent(): boolean;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        layer(): anychart.graphics.vector.Layer;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        path(): anychart.graphics.vector.Path;
        pie(): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Element;
        removeChildAt(index: number): anychart.graphics.vector.Element;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        roundedInnerRect(): void;
        roundedRect(): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.Layer;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        truncatedRect(): void;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface RadialGradient {
        dispose(): void;
    }
    interface Circle extends anychart.graphics.vector.Ellipse {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        center(): anychart.math.Coordinate;
        center(value?: anychart.math.Coordinate): anychart.graphics.vector.Ellipse;
        centerX(): number;
        centerX(value?: number): anychart.graphics.vector.Ellipse;
        centerY(): number;
        centerY(value?: number): anychart.graphics.vector.Ellipse;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.graphics.vector.Shape;
        fill(color: string, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Shape;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        radius(): number;
        radius(value?: number): anychart.graphics.vector.Circle;
        radiusX(): number;
        radiusX(value?: number): anychart.graphics.vector.Ellipse;
        radiusY(): number;
        radiusY(value?: number): anychart.graphics.vector.Ellipse;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRadius(rx: number, ry: number): anychart.graphics.vector.Ellipse;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): void;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Shape;
        strokeThickness(): number;
        strokeThickness(value?: number): anychart.graphics.vector.Shape;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface UnmanagedLayer extends anychart.graphics.vector.Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        content(): Element | string;
        content(value?: string | Element): anychart.graphics.vector.UnmanagedLayer;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Rect extends anychart.graphics.vector.Shape {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        cut(radiusAll: string | number): anychart.graphics.vector.Rect;
        cut(radiusLeftTop: number, radiusRightTop?: number, radiusRightBottom?: number, radiusLeftBottom?: number): anychart.graphics.vector.Rect;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.graphics.vector.Shape;
        fill(color: string, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Shape;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        round(radiusAll: string | number): anychart.graphics.vector.Rect;
        round(radiusLeftTop: number, radiusRightTop?: number, radiusRightBottom?: number, radiusLeftBottom?: number): anychart.graphics.vector.Rect;
        roundInner(radiusAll: string | number): anychart.graphics.vector.Rect;
        roundInner(radiusLeftTop: number, radiusRightTop?: number, radiusRightBottom?: number, radiusLeftBottom?: number): anychart.graphics.vector.Rect;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setBounds(value: anychart.graphics.math.Rect): anychart.graphics.vector.Rect;
        setHeight(value: number): anychart.graphics.vector.Rect;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        setWidth(value: number): anychart.graphics.vector.Rect;
        setX(value: number): anychart.graphics.vector.Rect;
        setY(value: number): anychart.graphics.vector.Rect;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): void;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Shape;
        strokeThickness(): number;
        strokeThickness(value?: number): anychart.graphics.vector.Shape;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Layer extends anychart.graphics.vector.Element {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.Layer;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cross(): void;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        diagonalCross(): void;
        diamond(): void;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: (() => void)): anychart.graphics.vector.Layer;
        forEachChild(callback: (() => void), obj?: Object): anychart.graphics.vector.Layer;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.Element;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hasParent(): boolean;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        layer(): anychart.graphics.vector.Layer;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        path(): anychart.graphics.vector.Path;
        pie(): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Element;
        removeChildAt(index: number): anychart.graphics.vector.Element;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        roundedInnerRect(): void;
        roundedRect(): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.Layer;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        truncatedRect(): void;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Path {
        arcTo(rx: number, ry: number, fromAngle: number, extent: number): anychart.graphics.vector.Path;
        arcToAsCurves(rx: number, ry: number, fromAngle: number, extent: number): anychart.graphics.vector.Path;
        arcToByEndPoint(x: number, y: number, rx: number, ry: number, largeArc: boolean, clockwiseArc: boolean): anychart.graphics.vector.Path;
        circularArc(cx: number, cy: number, rx: number, ry: number, fromAngle: number, sweep: number, lineTo?: boolean): anychart.graphics.vector.Path;
        clear(): anychart.graphics.vector.Path;
        close(): anychart.graphics.vector.Path;
        curveTo(control1X: number, control1Y: number, control2X: number, control2Y: number, endX: number, endY: number, ...var_args: (number)[]): anychart.graphics.vector.Path;
        getCurrentPoint(): anychart.math.Coordinate;
        lineTo(x: number, y: number, ...var_args: (number)[]): anychart.graphics.vector.Path;
        moveTo(x: number, y: number): anychart.graphics.vector.Path;
        quadraticCurveTo(controlX: number, controlY: number, endX: number, endY: number, ...var_args: (number)[]): anychart.graphics.vector.Path;
    }
    interface Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Image extends anychart.graphics.vector.Element {
        align(): anychart.graphics.vector.Image.Align;
        align(value?: anychart.graphics.vector.Image.Align): anychart.graphics.vector.Image;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fittingMode(): anychart.graphics.vector.Image.Fitting;
        fittingMode(value?: anychart.graphics.vector.Image.Fitting | string): anychart.graphics.vector.Image;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        height(): number;
        height(value?: number): anychart.graphics.vector.Image;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        src(): string;
        src(value?: string): anychart.graphics.vector.Image;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        width(): number;
        width(value?: number): anychart.graphics.vector.Image;
        x(): number;
        x(value?: number): anychart.graphics.vector.Image;
        y(): number;
        y(value?: number): anychart.graphics.vector.Image;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    namespace Image {
    enum Fitting {
        MEET,
        SLICE
    }
    enum Align {
        NONE,
        X_MAX_Y_MAX,
        X_MAX_Y_MID,
        X_MAX_Y_MIN,
        X_MID_Y_MAX,
        X_MID_Y_MID,
        X_MID_Y_MIN,
        X_MIN_Y_MAX,
        X_MIN_Y_MID,
        X_MIN_Y_MIN
    }
    }
    interface HatchFill extends anychart.graphics.vector.PatternFill {
        addChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        addChildAt(element: anychart.graphics.vector.Element, index: number): anychart.graphics.vector.Layer;
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        circle(cx?: number, cy?: number, radius?: number): anychart.graphics.vector.Circle;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cross(): void;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        diagonalCross(): void;
        diamond(): void;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        donut(): void;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        ellipse(cx?: number, cy?: number, rx?: number, ry?: number): anychart.graphics.vector.Ellipse;
        forEachChild(callback: (() => void)): anychart.graphics.vector.Layer;
        forEachChild(callback: (() => void), obj?: Object): anychart.graphics.vector.Layer;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getChildAt(index: number): anychart.graphics.vector.Element;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hLine(): void;
        hasChild(element: anychart.graphics.vector.Element): boolean;
        hasParent(): boolean;
        html(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        image(src?: string, x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Image;
        indexOfChild(element: anychart.graphics.vector.Element): number;
        layer(): anychart.graphics.vector.Layer;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        numChildren(): number;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        path(): anychart.graphics.vector.Path;
        pie(): void;
        rect(x?: number, y?: number, width?: number, height?: number): anychart.graphics.vector.Rect;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        removeChild(element: anychart.graphics.vector.Element): anychart.graphics.vector.Element;
        removeChildAt(index: number): anychart.graphics.vector.Element;
        removeChildren(): Array<anychart.graphics.vector.Element>;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        roundedInnerRect(): void;
        roundedRect(): void;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        star(): void;
        star10(): void;
        star4(): void;
        star5(): void;
        star6(): void;
        star7(): void;
        swapChildren(element1: anychart.graphics.vector.Element, element2: anychart.graphics.vector.Element): anychart.graphics.vector.Layer;
        swapChildrenAt(index1: number, index2: number): anychart.graphics.vector.Layer;
        text(x?: number, y?: number, text?: string, style?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        triangleDown(): void;
        triangleLeft(): void;
        triangleRight(): void;
        triangleUp(): void;
        truncatedRect(): void;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        vLine(): void;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    namespace HatchFill {
    enum HatchFillType {
        BACKWARD_DIAGONAL,
        CHECKER_BOARD,
        CONFETTI,
        DASHED_BACKWARD_DIAGONAL,
        DASHED_FORWARD_DIAGONAL,
        DASHED_HORIZONTAL,
        DASHED_VERTICAL,
        DIAGONAL_BRICK,
        DIAGONAL_CROSS,
        DIVOT,
        FORWARD_DIAGONAL,
        GRID,
        HORIZONTAL,
        HORIZONTAL_BRICK,
        PERCENT_05,
        PERCENT_10,
        PERCENT_20,
        PERCENT_25,
        PERCENT_30,
        PERCENT_40,
        PERCENT_50,
        PERCENT_60,
        PERCENT_70,
        PERCENT_75,
        PERCENT_80,
        PERCENT_90,
        PLAID,
        SOLID_DIAMOND,
        VERTICAL,
        VERTICAL_BRICK,
        WEAVE,
        ZIG_ZAG
    }
    }
    interface Text extends anychart.graphics.vector.Element {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        color(): string;
        color(value?: string): anychart.graphics.vector.Text;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        decoration(): string;
        decoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.graphics.vector.Text;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        direction(): string;
        direction(value?: anychart.graphics.vector.Text.Direction | string): anychart.graphics.vector.Text;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fontFamily(): string;
        fontFamily(value?: string): anychart.graphics.vector.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.graphics.vector.Text;
        fontStyle(): string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.graphics.vector.Text;
        fontVariant(): string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.graphics.vector.Text;
        fontWeight(): string;
        fontWeight(value?: string | number): anychart.graphics.vector.Text;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hAlign(): string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.graphics.vector.Text;
        hasParent(): boolean;
        height(): number | string;
        height(value?: number | string): anychart.graphics.vector.Text;
        htmlText(): string;
        htmlText(value?: string): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        letterSpacing(): string;
        letterSpacing(value?: string | number): anychart.graphics.vector.Text;
        lineHeight(): string;
        lineHeight(value?: string | number): anychart.graphics.vector.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        opacity(): number;
        opacity(value?: number): anychart.graphics.vector.Text;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        selectable(): boolean;
        selectable(value?: boolean): anychart.graphics.vector.Text;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        style(): anychart.graphics.vector.TextStyle;
        style(value?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        text(): string;
        text(value?: string): anychart.graphics.vector.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.graphics.vector.Text;
        textOverflow(): string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.graphics.vector.Text;
        textWrap(): string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        vAlign(): string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.graphics.vector.Text;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        width(): number | string;
        width(value?: number | string): anychart.graphics.vector.Text;
        x(): number;
        x(value?: number): anychart.graphics.vector.Text;
        y(): number;
        y(value?: number): anychart.graphics.vector.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    namespace Text {
    enum TextWrap {
        BY_LETTER,
        NO_WRAP
    }
    enum TextOverflow {
        CLIP,
        ELLIPSIS
    }
    enum HAlign {
        CENTER,
        END,
        LEFT,
        RIGHT,
        START
    }
    enum VAlign {
        BOTTOM,
        MIDDLE,
        TOP
    }
    enum Decoration {
        BLINK,
        LINE_THROUGH,
        NONE,
        OVERLINE,
        UNDERLINE
    }
    enum FontVariant {
        NORMAL,
        SMALL_CAP
    }
    enum FontStyle {
        ITALIC,
        NORMAL,
        OBLIQUE
    }
    enum Direction {
        LTR,
        RTL
    }
    }
    interface Ellipse extends anychart.graphics.vector.Shape {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        center(): anychart.math.Coordinate;
        center(value?: anychart.math.Coordinate): anychart.graphics.vector.Ellipse;
        centerX(): number;
        centerX(value?: number): anychart.graphics.vector.Ellipse;
        centerY(): number;
        centerY(value?: number): anychart.graphics.vector.Ellipse;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.graphics.vector.Shape;
        fill(color: string, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.graphics.vector.Shape;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.graphics.vector.Shape;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hasParent(): boolean;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        radiusX(): number;
        radiusX(value?: number): anychart.graphics.vector.Ellipse;
        radiusY(): number;
        radiusY(value?: number): anychart.graphics.vector.Ellipse;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRadius(rx: number, ry: number): anychart.graphics.vector.Ellipse;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): void;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.graphics.vector.Shape;
        strokeThickness(): number;
        strokeThickness(value?: number): anychart.graphics.vector.Shape;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
    interface Clip {
        dispose(): void;
        shape(): anychart.graphics.vector.Shape;
        shape(shape?: Array<number> | anychart.graphics.vector.Shape | anychart.graphics.math.Rect | Object): anychart.graphics.vector.Clip;
        shape(left?: number, top?: number, width?: number, height?: number): anychart.graphics.vector.Clip;
    }
}

declare namespace anychart.graphics.vector.primitives {
    function cross(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function diagonalCross(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function diamond(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function donut(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, cx: number, cy: number, outerR: number, innerR: number, start: number, sweep: number): anychart.graphics.vector.Path;
    function hLine(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function pie(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, cx: number, cy: number, r: number, start: number, sweep: number): anychart.graphics.vector.Path;
    function roundedInnerRect(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, rect: anychart.graphics.math.Rect, ...var_args: (number)[]): anychart.graphics.vector.Path;
    function roundedRect(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, rect: anychart.graphics.math.Rect, ...var_args: (number)[]): anychart.graphics.vector.Path;
    function star(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number, innerRadius: number, numberOfSpikes: number, startDegrees?: number, curvature?: number): anychart.graphics.vector.Path;
    function star10(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star4(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star5(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star6(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function star7(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleDown(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleLeft(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleRight(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function triangleUp(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
    function truncatedRect(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, rect: anychart.graphics.math.Rect, ...var_args: (number)[]): anychart.graphics.vector.Path;
    function vLine(stageOrPath: anychart.graphics.vector.Stage | anychart.graphics.vector.Path, centerX: number, centerY: number, outerRadius: number): anychart.graphics.vector.Path;
}

declare namespace anychart.graphics.vector.vml {
    interface Text extends anychart.graphics.vector.Text {
        appendTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        attr(key: string): any;
        attr(key: string, value?: any): anychart.graphics.vector.Element;
        clip(): anychart.graphics.math.Rect;
        clip(value?: anychart.graphics.math.Rect | string): anychart.graphics.vector.Element;
        color(): string;
        color(value?: string): anychart.graphics.vector.Text;
        cursor(): anychart.graphics.vector.Cursor;
        cursor(value?: anychart.graphics.vector.Cursor): anychart.graphics.vector.Element;
        decoration(): string;
        decoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.graphics.vector.Text;
        desc(): string;
        desc(value?: string): anychart.graphics.vector.Element;
        direction(): string;
        direction(value?: anychart.graphics.vector.Text.Direction | string): anychart.graphics.vector.Text;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.graphics.vector.Element;
        disableStrokeScaling(): boolean;
        disableStrokeScaling(value?: boolean): anychart.graphics.vector.Element;
        dispose(): void;
        domElement(): Element;
        drag(): boolean | anychart.graphics.math.Rect;
        drag(value?: boolean | anychart.graphics.math.Rect): anychart.graphics.vector.Element;
        fontFamily(): string;
        fontFamily(value?: string): anychart.graphics.vector.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.graphics.vector.Text;
        fontStyle(): string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.graphics.vector.Text;
        fontVariant(): string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.graphics.vector.Text;
        fontWeight(): string;
        fontWeight(value?: string | number): anychart.graphics.vector.Text;
        getAbsoluteBounds(): anychart.graphics.math.Rect;
        getAbsoluteHeight(): number;
        getAbsoluteWidth(): number;
        getAbsoluteX(): number;
        getAbsoluteY(): number;
        getBounds(): anychart.graphics.math.Rect;
        getHeight(): number;
        getRotationAngle(): number;
        getStage(): anychart.graphics.vector.Stage;
        getTransformationMatrix(): Array<number>;
        getWidth(): number;
        getX(): number;
        getY(): number;
        hAlign(): string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.graphics.vector.Text;
        hasParent(): boolean;
        height(): number | string;
        height(value?: number | string): anychart.graphics.vector.Text;
        htmlText(): string;
        htmlText(value?: string): anychart.graphics.vector.Text;
        id(): string;
        id(value?: string): anychart.graphics.vector.Element;
        letterSpacing(): string;
        letterSpacing(value?: string | number): anychart.graphics.vector.Text;
        lineHeight(): string;
        lineHeight(value?: string | number): anychart.graphics.vector.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        opacity(): number;
        opacity(value?: number): anychart.graphics.vector.Text;
        parent(): anychart.graphics.vector.Layer | anychart.graphics.vector.Stage;
        parent(value?: anychart.graphics.vector.Layer | anychart.graphics.vector.Stage): anychart.graphics.vector.Element;
        remove(): anychart.graphics.vector.Element;
        removeAllListeners(type?: string): number;
        rotate(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        rotateByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        scale(sx: number, sy: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        scaleByAnchor(sx: number, sy: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        selectable(): boolean;
        selectable(value?: boolean): anychart.graphics.vector.Text;
        setPosition(x: number, y: number): anychart.graphics.vector.Element;
        setRotation(degrees: number, cx?: number, cy?: number): anychart.graphics.vector.Element;
        setRotationByAnchor(degrees: number, anchor?: anychart.graphics.vector.Anchor | string): anychart.graphics.vector.Element;
        setTransformationMatrix(m00: number, m10: number, m01: number, m11: number, m02: number, m12: number): anychart.graphics.vector.Element;
        style(): anychart.graphics.vector.TextStyle;
        style(value?: anychart.graphics.vector.TextStyle): anychart.graphics.vector.Text;
        text(): string;
        text(value?: string): anychart.graphics.vector.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.graphics.vector.Text;
        textOverflow(): string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.graphics.vector.Text;
        textWrap(): string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.graphics.vector.Text;
        title(): string;
        title(value?: string): anychart.graphics.vector.Element;
        translate(tx: number, ty: number): anychart.graphics.vector.Element;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        vAlign(): string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.graphics.vector.Text;
        visible(): boolean;
        visible(isVisible?: boolean): anychart.graphics.vector.Element;
        width(): number | string;
        width(value?: number | string): anychart.graphics.vector.Text;
        x(): number;
        x(value?: number): anychart.graphics.vector.Text;
        y(): number;
        y(value?: number): anychart.graphics.vector.Text;
        zIndex(): number;
        zIndex(value?: number): anychart.graphics.vector.Element;
    }
}

declare namespace anychart.grids {
    function linear(): anychart.core.grids.Linear;
    function polar(): anychart.grids.Polar;
    function radar(): anychart.grids.Radar;
    interface Polar extends anychart.core.grids.Polar {
        axis(): anychart.core.axes.Polar | anychart.core.axes.Radial;
        axis(value?: anychart.core.axes.Polar | anychart.core.axes.Radial): anychart.core.grids.Polar;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Polar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        evenFill(): string | anychart.graphics.vector.Fill;
        evenFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        evenFill(color: string, opacity?: number): anychart.core.grids.Polar;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Polar;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Polar;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Polar;
        isRadial(): boolean;
        layout(): anychart.enums.RadialGridLayout;
        layout(value?: anychart.enums.RadialGridLayout | string): anychart.core.grids.Polar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        oddFill(): string | anychart.graphics.vector.Fill;
        oddFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        oddFill(color: string, opacity?: number): anychart.core.grids.Polar;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Polar;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Polar;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Polar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Polar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xScale(): anychart.scales.Base;
        xScale(value?: anychart.scales.Base): anychart.core.grids.Polar;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Linear extends anychart.core.grids.Linear {
        axis(): anychart.core.axes.Linear;
        axis(value?: anychart.core.axes.Linear): anychart.core.grids.Linear;
        drawFirstLine(): boolean;
        drawFirstLine(value?: boolean): anychart.core.grids.Linear;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Linear;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        evenFill(): string | anychart.graphics.vector.Fill;
        evenFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        evenFill(color: string, opacity?: number): anychart.core.grids.Linear;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Linear;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Linear;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        isHorizontal(): boolean;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Linear;
        layout(): anychart.enums.Layout;
        layout(value?: anychart.enums.Layout | string): anychart.core.grids.Linear;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        oddFill(): string | anychart.graphics.vector.Fill;
        oddFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        oddFill(color: string, opacity?: number): anychart.core.grids.Linear;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Linear;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Linear;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Linear;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        scale(): anychart.scales.Base;
        scale(value?: anychart.scales.Base): anychart.core.grids.Linear;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Linear;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Radar extends anychart.core.grids.Radar {
        axis(): anychart.core.axes.Radar | anychart.core.axes.Radial;
        axis(value?: anychart.core.axes.Radar | anychart.core.axes.Radial): anychart.core.grids.Radar;
        drawLastLine(): boolean;
        drawLastLine(value?: boolean): anychart.core.grids.Radar;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        evenFill(): string | anychart.graphics.vector.Fill;
        evenFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        evenFill(color: string, opacity?: number): anychart.core.grids.Radar;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Radar;
        evenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Radar;
        evenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        isMinor(): boolean;
        isMinor(value?: boolean): anychart.core.grids.Radar;
        isRadial(): boolean;
        layout(): anychart.enums.RadialGridLayout;
        layout(value?: anychart.enums.RadialGridLayout | string): anychart.core.grids.Radar;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        oddFill(): string | anychart.graphics.vector.Fill;
        oddFill(value?: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        oddFill(color: string, opacity?: number): anychart.core.grids.Radar;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.grids.Radar;
        oddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.grids.Radar;
        oddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.grids.Radar;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        stroke(): string | anychart.graphics.vector.Stroke;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.grids.Radar;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        xScale(): anychart.scales.Ordinal;
        yScale(): anychart.scales.Base;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
}

declare namespace anychart.math {
    function cycledQueue(lengthLimit?: number): anychart.math.CycledQueue;
    function rect(x: number, y: number, w: number, h: number): anychart.math.Rect;
    interface CoordinateObject {
        x: string | number;
        y: string | number;
    }
    interface Coordinate {
        XYCoordinates: Array<number> | Object | anychart.math.CoordinateObject;
    }
    interface CycledQueue {
        clear(newLengthLimit?: number): void;
        dequeue(): any;
        enqueue(item: any): any;
        get(index: number): any;
        getLength(): number;
    }
    interface Rect {

    }
}

declare namespace anychart.palettes {
    const blue: Array<string>;
    const coffee: Array<string>;
    const defaultPalette: Array<string>;
    const earth: Array<string>;
    const glamour: Array<string>;
    const monochrome: Array<string>;
    const morning: Array<string>;
    const pastel: Array<string>;
    const provence: Array<string>;
    const sea: Array<string>;
    const turquoise: Array<string>;
    const v6: Array<string>;
    const wines: Array<string>;
    function distinctColors(): anychart.palettes.DistinctColors;
    function hatchFills(): anychart.palettes.HatchFills;
    function markers(): anychart.palettes.Markers;
    function rangeColors(): anychart.palettes.RangeColors;
    interface Markers extends anychart.core.Base {
        itemAt(index: number): anychart.enums.MarkerType | anychart.enums.BulletMarkerType;
        itemAt(index: number, type?: string): anychart.palettes.Markers;
        items(): Array<anychart.graphics.vector.Fill>;
        items(value?: Array<string> | string, ...var_args: (string)[]): anychart.palettes.Markers;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface RangeColors extends anychart.core.Base {
        count(): number;
        count(value?: number): anychart.palettes.RangeColors;
        itemAt(index: number): anychart.graphics.vector.SolidFill;
        itemAt(index: number, color?: anychart.graphics.vector.SolidFill): anychart.palettes.RangeColors;
        items(): Array<anychart.graphics.vector.SolidFill>;
        items(value?: Array<anychart.graphics.vector.SolidFill> | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | Array<anychart.graphics.vector.GradientKey> | Array<string> | anychart.graphics.vector.SolidFill | string, ...var_args: (anychart.graphics.vector.SolidFill | string)[]): anychart.palettes.RangeColors;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DistinctColors extends anychart.core.Base {
        itemAt(index: number): anychart.graphics.vector.Fill;
        itemAt(index: number, color?: anychart.graphics.vector.Fill): anychart.palettes.DistinctColors;
        items(): Array<anychart.graphics.vector.Fill>;
        items(value?: Array<anychart.graphics.vector.Fill> | anychart.graphics.vector.Fill, ...var_args: (anychart.graphics.vector.Fill)[]): anychart.palettes.DistinctColors;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface HatchFills extends anychart.core.Base {
        itemAt(index: number): anychart.graphics.vector.HatchFill | anychart.graphics.vector.PatternFill;
        itemAt(index: number, type?: anychart.graphics.vector.HatchFill.HatchFillType | string, color?: string, thickness?: number, size?: number): anychart.palettes.HatchFills;
        itemAt(index: number, patternFill?: anychart.graphics.vector.PatternFill): anychart.palettes.HatchFills;
        itemAt(index: number, instance?: anychart.graphics.vector.HatchFill): anychart.palettes.HatchFills;
        itemAt(index: number, state?: boolean): anychart.palettes.HatchFills;
        items(): Array<(anychart.graphics.vector.HatchFill|anychart.graphics.vector.HatchFill.HatchFillType|anychart.graphics.vector.PatternFill)>;
        items(value?: Array<(anychart.graphics.vector.HatchFill|anychart.graphics.vector.HatchFill.HatchFillType|anychart.graphics.vector.PatternFill)>, ...var_args: (anychart.graphics.vector.HatchFill | anychart.graphics.vector.HatchFill.HatchFillType | anychart.graphics.vector.PatternFill)[]): anychart.palettes.HatchFills;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
}

declare namespace anychart.scales {
    function dateTime(): anychart.scales.DateTime;
    function linear(): anychart.scales.Linear;
    function linearColor(...var_args: (string | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | Array<(string|anychart.graphics.vector.SolidFill|anychart.graphics.vector.LinearGradientFill|anychart.graphics.vector.RadialGradientFill)>)[]): anychart.scales.LinearColor;
    function log(): anychart.scales.Logarithmic;
    function ordinal(): anychart.scales.Ordinal;
    function ordinalColor(value?: Array<Object>): anychart.scales.OrdinalColor;
    interface DateTimeTicks extends anychart.core.Base {
        count(): number;
        count(value?: number): anychart.scales.DateTimeTicks;
        get(): Array<any>;
        interval(): string;
        interval(isodate?: string): anychart.scales.DateTimeTicks;
        interval(unit?: anychart.enums.Interval, count?: number): anychart.scales.DateTimeTicks;
        interval(years?: number, months?: number, days?: number, hours?: number, minutes?: number, seconds?: number): anychart.scales.DateTimeTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        set(ticks: Array<any>): anychart.scales.DateTimeTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Linear extends anychart.scales.ScatterBase {
        compareWith(): anychart.enums.ScaleCompareWithMode | number;
        compareWith(value?: string | anychart.enums.ScaleCompareWithMode | number | Date): anychart.scales.Linear;
        comparisonMode(): anychart.enums.ScaleComparisonMode;
        comparisonMode(value?: string | anychart.enums.ScaleComparisonMode): anychart.scales.Linear;
        extendDataRange(...var_args: (any)[]): anychart.scales.ScatterBase;
        finishAutoCalc(silently?: boolean): boolean;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        maximumGap(): number;
        maximumGap(value?: number): anychart.scales.Linear;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        minimumGap(): number;
        minimumGap(value?: number): anychart.scales.Linear;
        minorTicks(): anychart.scales.ScatterTicks;
        minorTicks(value?: Object | Array<any>): anychart.scales.Linear;
        removeAllListeners(type?: string): number;
        softMaximum(): number;
        softMaximum(value?: number): anychart.scales.Linear;
        softMinimum(): number;
        softMinimum(value?: number): anychart.scales.Linear;
        stackMode(): anychart.enums.ScaleStackMode;
        stackMode(value?: anychart.enums.ScaleStackMode | string): anychart.scales.Linear;
        startAutoCalc(): anychart.scales.Base;
        stickToZero(): boolean;
        stickToZero(value?: boolean): anychart.scales.Linear;
        ticks(): anychart.scales.ScatterTicks;
        ticks(value?: Object | Array<any>): anychart.scales.Linear;
        transform(value: any): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ScatterTicks extends anychart.core.Base {
        base(): number;
        base(value?: number): anychart.scales.ScatterTicks;
        count(): number;
        count(value?: number): anychart.scales.ScatterTicks;
        count(minimumCount?: number, maximumCount?: number): anychart.scales.ScatterTicks;
        get(): Array<any>;
        interval(): number;
        interval(value?: number): anychart.scales.ScatterTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        mode(): anychart.enums.ScatterTicksMode;
        mode(value?: anychart.enums.ScatterTicksMode | string): anychart.scales.ScatterTicks;
        removeAllListeners(type?: string): number;
        set(ticks: Array<any>): anychart.scales.ScatterTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Base extends anychart.core.Base {
        finishAutoCalc(silently?: boolean): boolean;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        startAutoCalc(): anychart.scales.Base;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface Ordinal extends anychart.scales.Base {
        extendDataRange(...var_args: (any)[]): anychart.scales.Ordinal;
        finishAutoCalc(silently?: boolean): boolean;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        names(): Array<any>;
        names(value?: Array<any> | string): anychart.scales.Ordinal;
        removeAllListeners(type?: string): number;
        startAutoCalc(): anychart.scales.Base;
        ticks(): anychart.scales.OrdinalTicks;
        ticks(value?: Object | Array<any>): anychart.scales.Ordinal;
        transform(value: any, subRangeRatio?: number): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        values(): Array<(number|string)>;
        values(values?: Array<any> | any, ...var_args: (any)[]): anychart.scales.Ordinal;
    }
    interface OrdinalColor extends anychart.scales.Base {
        colorToValue(value: string): number;
        colors(): Array<string>;
        colors(value?: Array<string>): anychart.scales.OrdinalColor;
        finishAutoCalc(silently?: boolean): boolean;
        getIndexByValue(value: number): number;
        getProcessedRanges(): Array<Object>;
        getRangeByValue(value: number): Object;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.OrdinalColor;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        names(): Array<any>;
        names(value?: Array<any> | string): anychart.scales.OrdinalColor;
        ranges(): Array<Object>;
        ranges(value?: Array<Object>): anychart.scales.OrdinalColor;
        removeAllListeners(type?: string): number;
        startAutoCalc(): anychart.scales.Base;
        ticks(): anychart.scales.OrdinalTicks;
        ticks(value?: Object | Array<any>): anychart.scales.OrdinalColor;
        transform(value: any, subRangeRatio?: number): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        valueToColor(value: number): string;
    }
    interface StockScatterDateTime extends anychart.core.Base {
        getFullMaximum(): number;
        getFullMinimum(): number;
        getMaximum(): number;
        getMinimum(): number;
        inverseTransform(ratio: number): number;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        transform(value: number | string | Date): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface DateTime extends anychart.scales.ScatterBase {
        extendDataRange(...var_args: (any)[]): anychart.scales.DateTime;
        finishAutoCalc(silently?: boolean): boolean;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        maximumGap(): number;
        maximumGap(value?: number): anychart.scales.DateTime;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        minimumGap(): number;
        minimumGap(value?: number): anychart.scales.DateTime;
        minorTicks(): anychart.scales.DateTimeTicks;
        minorTicks(value?: Object | Array<any>): anychart.scales.DateTime;
        removeAllListeners(type?: string): number;
        softMaximum(): number;
        softMaximum(value?: number): anychart.scales.DateTime;
        softMinimum(): number;
        softMinimum(value?: number): anychart.scales.DateTime;
        startAutoCalc(): anychart.scales.Base;
        ticks(): anychart.scales.DateTimeTicks;
        ticks(value?: Object | Array<any>): anychart.scales.DateTime;
        transform(value: any): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface ScatterBase extends anychart.scales.Base {
        extendDataRange(...var_args: (any)[]): anychart.scales.ScatterBase;
        finishAutoCalc(silently?: boolean): boolean;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        removeAllListeners(type?: string): number;
        startAutoCalc(): anychart.scales.Base;
        transform(value: any): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface OrdinalTicks extends anychart.core.Base {
        get(): Array<any>;
        interval(): number;
        interval(value?: number): anychart.scales.OrdinalTicks;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        names(): Array<any>;
        names(values?: Array<any>): anychart.scales.OrdinalTicks;
        removeAllListeners(type?: string): number;
        set(ticks: Array<any>): anychart.scales.OrdinalTicks;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface StockOrdinalDateTime extends anychart.scales.StockScatterDateTime {
        getFullMaximum(): number;
        getFullMinimum(): number;
        getMaximum(): number;
        getMinimum(): number;
        inverseTransform(ratio: number): number;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        transform(value: number | string | Date): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface LinearColor extends anychart.scales.ScatterBase {
        colorToValue(value: string): number;
        colors(): Array<Object>;
        colors(...var_args: (string | anychart.graphics.vector.SolidFill | anychart.graphics.vector.LinearGradientFill | anychart.graphics.vector.RadialGradientFill | Array<(string|anychart.graphics.vector.SolidFill|anychart.graphics.vector.LinearGradientFill|anychart.graphics.vector.RadialGradientFill)>)[]): anychart.scales.LinearColor;
        extendDataRange(...var_args: (any)[]): anychart.scales.ScatterBase;
        finishAutoCalc(silently?: boolean): boolean;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        minorTicks(): anychart.scales.ScatterTicks;
        minorTicks(value?: Object | Array<any>): anychart.scales.LinearColor;
        removeAllListeners(type?: string): number;
        startAutoCalc(): anychart.scales.Base;
        ticks(): anychart.scales.ScatterTicks;
        ticks(value?: Object | Array<any>): anychart.scales.LinearColor;
        transform(value: any): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        valueToColor(value: number): string;
    }
    interface Logarithmic extends anychart.scales.Linear {
        extendDataRange(...var_args: (any)[]): anychart.scales.ScatterBase;
        finishAutoCalc(silently?: boolean): boolean;
        inverseTransform(ratio: number): any;
        inverted(): boolean;
        inverted(value?: boolean): anychart.scales.Base;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        logBase(): number;
        logBase(value?: number): anychart.scales.Logarithmic;
        maximum(): number;
        maximum(value?: number): anychart.scales.ScatterBase;
        maximumGap(): number;
        maximumGap(value?: number): anychart.scales.Linear;
        minimum(): number;
        minimum(value?: number): anychart.scales.ScatterBase;
        minimumGap(): number;
        minimumGap(value?: number): anychart.scales.Linear;
        minorTicks(): anychart.scales.ScatterTicks;
        minorTicks(value?: Object | Array<any>): anychart.scales.Linear;
        removeAllListeners(type?: string): number;
        softMaximum(): number;
        softMaximum(value?: number): anychart.scales.Linear;
        softMinimum(): number;
        softMinimum(value?: number): anychart.scales.Linear;
        stackMode(): anychart.enums.ScaleStackMode;
        stackMode(value?: anychart.enums.ScaleStackMode | string): anychart.scales.Linear;
        startAutoCalc(): anychart.scales.Base;
        stickToZero(): boolean;
        stickToZero(value?: boolean): anychart.scales.Linear;
        ticks(): anychart.scales.ScatterTicks;
        ticks(value?: Object | Array<any>): anychart.scales.Linear;
        transform(value: any): number;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
    }
    interface GanttDateTime extends anychart.core.Base {

    }
}

declare namespace anychart.ui {
    function background(): anychart.ui.Background;
    function chartEditorDialog(): anychart.ui.chartEditor.Dialog;
    function contextMenu(): anychart.ui.ContextMenu;
    function dataGrid(): anychart.ui.DataGrid;
    function ganttToolbar(): anychart.ui.GanttToolbar;
    function label(): anychart.ui.Label;
    function labelsFactory(): anychart.ui.LabelsFactory;
    function legend(): anychart.ui.Legend;
    function markersFactory(): anychart.ui.MarkersFactory;
    function preloader(): anychart.ui.Preloader;
    function projectTimeline(): anychart.ui.ProjectTimeline;
    function resourceTimeline(): anychart.ui.ResourceTimeline;
    function scroller(): anychart.ui.Scroller;
    function table(rowsCount?: number, colsCount?: number): anychart.ui.Table;
    function title(): anychart.ui.Title;
    interface ProjectTimeline extends anychart.core.ui.Timeline {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(): anychart.graphics.vector.Fill | string;
        baseFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baseFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseStroke(): anychart.graphics.vector.Stroke | string;
        baseStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        baselineAbove(): boolean;
        baselineAbove(value?: boolean): anychart.core.ui.Timeline;
        baselineFill(): anychart.graphics.vector.Fill | string;
        baselineFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baselineFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineStroke(): anychart.graphics.vector.Stroke | string;
        baselineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.Timeline;
        connectorFill(): anychart.graphics.vector.Fill | string;
        connectorFill(value?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, cx?: number, cy?: number, opacityOrMode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        connectorPreviewStroke(): anychart.graphics.vector.Stroke | string;
        connectorPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        connectorStroke(): anychart.graphics.vector.Stroke | string;
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editConnectorThumbFill(): anychart.graphics.vector.Fill | string;
        editConnectorThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbStroke(): anychart.graphics.vector.Stroke | string;
        editConnectorThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editIntervalThumbFill(): anychart.graphics.vector.Fill | string;
        editIntervalThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbStroke(): anychart.graphics.vector.Stroke | string;
        editIntervalThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editPreviewFill(): anychart.graphics.vector.Fill | string;
        editPreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editPreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewStroke(): anychart.graphics.vector.Stroke | string;
        editPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editProgressFill(): anychart.graphics.vector.Fill | string;
        editProgressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editProgressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressStroke(): anychart.graphics.vector.Stroke | string;
        editProgressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewDashStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewDashStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewFill(): anychart.graphics.vector.Fill | string;
        editStructurePreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editing(): boolean;
        editing(value?: boolean): anychart.core.ui.Timeline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object): anychart.core.ui.Timeline;
        lineMarker(index?: number): anychart.core.axisMarkers.GanttLine;
        lineMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        lineMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object): anychart.core.ui.Timeline;
        maximumGap(): number;
        maximumGap(value: number): anychart.core.ui.Timeline;
        milestoneFill(): anychart.graphics.vector.Fill | string;
        milestoneFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        milestoneFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneStroke(): anychart.graphics.vector.Stroke | string;
        milestoneStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        minimumGap(): number;
        minimumGap(value: number): anychart.core.ui.Timeline;
        parentFill(): anychart.graphics.vector.Fill | string;
        parentFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        parentFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentStroke(): anychart.graphics.vector.Stroke | string;
        parentStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        progressFill(): anychart.graphics.vector.Fill | string;
        progressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        progressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressStroke(): anychart.graphics.vector.Stroke | string;
        progressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        rangeMarker(index?: number): anychart.core.axisMarkers.GanttRange;
        rangeMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        rangeMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(): anychart.graphics.vector.Fill | string;
        selectedElementFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        selectedElementFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementStroke(): anychart.graphics.vector.Stroke | string;
        selectedElementStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        textMarker(index?: number): anychart.core.axisMarkers.GanttText;
        textMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        textMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Timeline;
    }
    interface ResourceTimeline extends anychart.core.ui.Timeline {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        backgroundFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(): anychart.graphics.vector.Fill | string;
        baseFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baseFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baseFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baseStroke(): anychart.graphics.vector.Stroke | string;
        baseStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        baselineAbove(): boolean;
        baselineAbove(value?: boolean): anychart.core.ui.Timeline;
        baselineFill(): anychart.graphics.vector.Fill | string;
        baselineFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        baselineFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        baselineFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        baselineStroke(): anychart.graphics.vector.Stroke | string;
        baselineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.Timeline;
        connectorFill(): anychart.graphics.vector.Fill | string;
        connectorFill(value?: anychart.graphics.vector.Fill | Array<(anychart.graphics.vector.GradientKey|string)>, cx?: number, cy?: number, opacityOrMode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        connectorPreviewStroke(): anychart.graphics.vector.Stroke | string;
        connectorPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        connectorStroke(): anychart.graphics.vector.Stroke | string;
        connectorStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editConnectorThumbFill(): anychart.graphics.vector.Fill | string;
        editConnectorThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editConnectorThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editConnectorThumbStroke(): anychart.graphics.vector.Stroke | string;
        editConnectorThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editIntervalThumbFill(): anychart.graphics.vector.Fill | string;
        editIntervalThumbFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editIntervalThumbFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editIntervalThumbStroke(): anychart.graphics.vector.Stroke | string;
        editIntervalThumbStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editPreviewFill(): anychart.graphics.vector.Fill | string;
        editPreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editPreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editPreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editPreviewStroke(): anychart.graphics.vector.Stroke | string;
        editPreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editProgressFill(): anychart.graphics.vector.Fill | string;
        editProgressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editProgressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editProgressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editProgressStroke(): anychart.graphics.vector.Stroke | string;
        editProgressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewDashStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewDashStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editStructurePreviewFill(): anychart.graphics.vector.Fill | string;
        editStructurePreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        editStructurePreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        editStructurePreviewStroke(): anychart.graphics.vector.Stroke | string;
        editStructurePreviewStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        editing(): boolean;
        editing(value?: boolean): anychart.core.ui.Timeline;
        labels(): anychart.core.ui.LabelsFactory;
        labels(value?: Object): anychart.core.ui.Timeline;
        lineMarker(index?: number): anychart.core.axisMarkers.GanttLine;
        lineMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        lineMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        markers(): anychart.core.ui.MarkersFactory;
        markers(value?: Object): anychart.core.ui.Timeline;
        maximumGap(): number;
        maximumGap(value: number): anychart.core.ui.Timeline;
        milestoneFill(): anychart.graphics.vector.Fill | string;
        milestoneFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        milestoneFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        milestoneFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        milestoneStroke(): anychart.graphics.vector.Stroke | string;
        milestoneStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        minimumGap(): number;
        minimumGap(value: number): anychart.core.ui.Timeline;
        parentFill(): anychart.graphics.vector.Fill | string;
        parentFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        parentFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        parentFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        parentStroke(): anychart.graphics.vector.Stroke | string;
        parentStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        progressFill(): anychart.graphics.vector.Fill | string;
        progressFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        progressFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        progressFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        progressStroke(): anychart.graphics.vector.Stroke | string;
        progressStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        rangeMarker(index?: number): anychart.core.axisMarkers.GanttRange;
        rangeMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        rangeMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.Timeline;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(): anychart.graphics.vector.Fill | string;
        selectedElementFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementFill(color: string, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Timeline;
        selectedElementFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Timeline;
        selectedElementFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Timeline;
        selectedElementStroke(): anychart.graphics.vector.Stroke | string;
        selectedElementStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Timeline;
        textMarker(index?: number): anychart.core.axisMarkers.GanttText;
        textMarker(value?: Object | boolean): anychart.core.ui.Timeline;
        textMarker(index?: number, value?: Object | boolean | anychart.enums.GanttDateTimeMarkers): anychart.core.ui.Timeline;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Timeline;
    }
    interface DataGrid extends anychart.core.ui.DataGrid {
        backgroundFill(): anychart.graphics.vector.Fill | string;
        backgroundFill(value: anychart.graphics.vector.Fill): anychart.ui.DataGrid;
        backgroundFill(color: string, opacity?: number): anychart.ui.DataGrid;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.ui.DataGrid;
        backgroundFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.ui.DataGrid;
        backgroundFill(imageSettings: anychart.graphics.vector.Fill): anychart.ui.DataGrid;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        column(index?: number): anychart.core.ui.DataGrid.Column;
        column(value?: anychart.core.ui.DataGrid.Column): anychart.core.ui.DataGrid;
        column(index?: number, value?: anychart.core.ui.DataGrid.Column): anychart.core.ui.DataGrid;
        columnStroke(): string | anychart.graphics.vector.Stroke;
        columnStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        container(): string | Element;
        container(value?: string | Element): anychart.ui.DataGrid;
        data(): anychart.data.Tree;
        data(value?: anychart.data.Tree): anychart.core.ui.DataGrid;
        draw(): anychart.ui.DataGrid;
        editStructurePreviewDashStroke(): string | anychart.graphics.vector.Stroke;
        editStructurePreviewDashStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        editStructurePreviewFill(): anychart.graphics.vector.Fill | string;
        editStructurePreviewFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        editStructurePreviewFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        editStructurePreviewFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        editStructurePreviewStroke(): string | anychart.graphics.vector.Stroke;
        editStructurePreviewStroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.DataGrid;
        editing(): boolean;
        editing(value?: boolean): anychart.ui.DataGrid;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endIndex(): number;
        endIndex(value?: number): anychart.core.ui.DataGrid;
        getPixelBounds(): anychart.math.Rect;
        headerHeight(): number;
        headerHeight(value?: number): anychart.ui.DataGrid;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        horizontalOffset(): number;
        horizontalOffset(value?: number): anychart.core.ui.DataGrid;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.ui.DataGrid;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.ui.DataGrid;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rowEvenFill(): anychart.graphics.vector.Fill | string;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowFill(): anychart.graphics.vector.Fill | string;
        rowFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowHoverFill(): anychart.graphics.vector.Fill | string;
        rowHoverFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowHoverFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowHoverFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowHoverFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowOddFill(): anychart.graphics.vector.Fill | string;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.DataGrid;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowSelectedFill(): anychart.graphics.vector.Fill | string;
        rowSelectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowSelectedFill(color: string, opacity?: number): anychart.core.ui.DataGrid;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object): anychart.core.ui.DataGrid;
        rowSelectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.DataGrid;
        rowSelectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.DataGrid;
        rowStroke(): string | anychart.graphics.vector.Stroke;
        rowStroke(value?: anychart.graphics.vector.Stroke | string): anychart.ui.DataGrid;
        startIndex(): number;
        startIndex(value?: number): anychart.core.ui.DataGrid;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.DataGrid;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        verticalOffset(): number;
        verticalOffset(value?: number): anychart.core.ui.DataGrid;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface MarkersFactory extends anychart.core.ui.MarkersFactory {
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.MarkersFactory;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.MarkersFactory;
        fill(): anychart.graphics.vector.Fill | string;
        fill(value?: anychart.graphics.vector.Fill | string): anychart.core.ui.MarkersFactory;
        fill(color: string, opacity?: number): anychart.core.ui.MarkersFactory;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.MarkersFactory;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.MarkersFactory;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.MarkersFactory;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.MarkersFactory;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.MarkersFactory;
        position(): string;
        position(value?: string): anychart.core.ui.MarkersFactory;
        positionFormatter(): (() => void);
        positionFormatter(value?: (() => void)): anychart.core.ui.MarkersFactory;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.MarkersFactory;
        size(): number;
        size(value?: number): anychart.core.ui.MarkersFactory;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.MarkersFactory;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.MarkersFactory;
        type(): string | anychart.enums.MarkerType | (() => void);
        type(value?: string | anychart.enums.MarkerType | (() => void)): anychart.core.ui.MarkersFactory;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    module MarkersFactory {
    interface Marker extends anychart.core.ui.MarkersFactory.Marker {
        anchor(): anychart.enums.Anchor | string;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.MarkersFactory.Marker;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill | string;
        fill(value?: anychart.graphics.vector.Fill | string): anychart.core.ui.MarkersFactory.Marker;
        fill(color: string, opacity?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.MarkersFactory.Marker;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.MarkersFactory.Marker;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.MarkersFactory.Marker;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.MarkersFactory.Marker;
        position(): anychart.enums.Position | string;
        position(value?: anychart.enums.Position | string): anychart.core.ui.MarkersFactory.Marker;
        positionFormatter(): any;
        positionFormatter(value?: any): any;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.MarkersFactory.Marker;
        size(): number;
        size(value?: number): anychart.core.ui.MarkersFactory.Marker;
        stroke(): anychart.graphics.vector.Stroke | string;
        stroke(value?: anychart.graphics.vector.Stroke | string): anychart.core.ui.MarkersFactory.Marker;
        stroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.MarkersFactory.Marker;
        type(): anychart.enums.MarkerType | (() => void);
        type(value?: anychart.enums.MarkerType | (() => void)): anychart.core.ui.MarkersFactory.Marker;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    }
    interface Scroller extends anychart.core.ui.Scroller {
        allowRangeChange(): boolean;
        allowRangeChange(value?: boolean): anychart.core.ui.Scroller;
        autoHide(): boolean;
        autoHide(value?: boolean): anychart.core.ui.Scroller;
        container(): string | Element;
        container(value?: string | Element): anychart.ui.Scroller;
        draw(): anychart.ui.Scroller;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        endRatio(): number;
        endRatio(value?: number): anychart.ui.Scroller;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        fill(color: string, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        fill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        getRemainingBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Scroller;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.ui.Scroller;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.ui.Scroller;
        orientation(): anychart.enums.Orientation | string;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Scroller;
        outlineStroke(): anychart.graphics.vector.Stroke;
        outlineStroke(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Scroller;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.ui.Scroller;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.ui.Scroller;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectedFill(): anychart.graphics.vector.Fill;
        selectedFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        selectedFill(color: string, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Scroller;
        selectedFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Scroller;
        selectedFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Scroller;
        setRange(startRatio: number, endRatio: number): anychart.ui.Scroller;
        startRatio(): number;
        startRatio(value?: number): anychart.ui.Scroller;
        thumbs(): anychart.core.ui.Scroller.Thumbs;
        thumbs(value?: boolean | Object): anychart.core.ui.Scroller;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Label extends anychart.core.ui.Label {
        adjustFontSize(): Object;
        adjustFontSize(bothOrByWidth?: Object | Array<boolean> | boolean, byHeight?: boolean): anychart.core.ui.Label;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.Label;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Label;
        container(): string | Element;
        container(value?: string | Element): anychart.ui.Label;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        draw(): anychart.ui.Label;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Label;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.Label;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.Label;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.Label;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.Label;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object): anychart.core.ui.Label;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Label;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.ui.Label;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.ui.Label;
        position(): anychart.enums.Position;
        position(value?: anychart.enums.Position | string): anychart.core.ui.Label;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.ui.Label;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Label;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Background extends anychart.core.ui.Background {
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        container(): string | Element;
        container(value?: string | Element): anychart.ui.Background;
        cornerType(): anychart.enums.BackgroundCornersType;
        cornerType(value?: anychart.enums.BackgroundCornersType): anychart.core.ui.Background;
        corners(): Array<number>;
        corners(value?: number | string | Array<number>): anychart.core.ui.Background;
        corners(topLeft?: number | string, topRight?: number | string, bottomRight?: number | string, bottomLeft?: number | string): anychart.core.ui.Background;
        draw(): anychart.ui.Background;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fill(): anychart.graphics.vector.Fill;
        fill(value: anychart.graphics.vector.Fill): anychart.core.ui.Background;
        fill(color: string, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Background;
        fill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Background;
        getPixelBounds(): anychart.math.Rect;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.ui.Background;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.ui.Background;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        stroke(): anychart.graphics.vector.Stroke;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string): anychart.core.ui.Background;
        stroke(value: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Background;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Legend extends anychart.core.ui.Legend {
        align(): anychart.enums.Align | string;
        align(value?: anychart.enums.Align | string): anychart.core.ui.Legend;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Legend;
        container(): string | Element;
        container(value?: string | Element): anychart.ui.Legend;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        draw(): anychart.ui.Legend;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Legend;
        hoverCursor(): anychart.enums.Cursor | string;
        hoverCursor(value?: anychart.enums.Cursor | string): anychart.core.ui.Legend;
        iconSize(): number;
        iconSize(value?: number | string): anychart.core.ui.Legend;
        iconTextSpacing(): number;
        iconTextSpacing(value?: string | number): anychart.core.ui.Legend;
        inverted(): boolean;
        inverted(value?: boolean): anychart.core.ui.Legend;
        items(): Array<anychart.core.ui.Legend.LegendItemProvider>;
        items(value?: Array<anychart.core.ui.Legend.LegendItemProvider>): anychart.core.ui.Legend;
        itemsFormatter(): (() => void);
        itemsFormatter(value?: (() => void)): anychart.core.ui.Legend;
        itemsLayout(): anychart.enums.Layout | string;
        itemsLayout(value?: string | anychart.enums.Layout): anychart.core.ui.Legend;
        itemsSource(): anychart.core.SeparateChart | Array<anychart.core.SeparateChart>;
        itemsSource(value?: anychart.core.SeparateChart | Array<anychart.core.SeparateChart>): anychart.ui.Legend;
        itemsSourceMode(): string | anychart.enums.LegendItemsSourceMode;
        itemsSourceMode(value?: string | anychart.enums.LegendItemsSourceMode): anychart.core.ui.Legend;
        itemsSpacing(): string | number;
        itemsSpacing(value?: string | number): anychart.core.ui.Legend;
        itemsTextFormatter(): (() => void);
        itemsTextFormatter(value?: (() => void)): anychart.core.ui.Legend;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(): anychart.core.utils.Margin;
        margin(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.Legend;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Legend;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.Legend;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Legend;
        paginator(): anychart.core.ui.Paginator;
        paginator(value?: Object | boolean): anychart.core.ui.Legend;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.ui.Legend;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.ui.Legend;
        position(): anychart.enums.Orientation | string;
        position(value?: anychart.enums.Orientation | string): anychart.core.ui.Legend;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        title(): anychart.core.ui.Title;
        title(value?: boolean | Object | string): anychart.core.ui.Legend;
        titleFormatter(): (() => void);
        titleFormatter(value?: (() => void)): anychart.core.ui.Legend;
        titleSeparator(): anychart.core.ui.Separator;
        titleSeparator(value?: Object | boolean): anychart.core.ui.Legend;
        tooltip(): anychart.core.ui.Tooltip;
        tooltip(value?: Object | boolean): anychart.core.ui.Legend;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Legend;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface GanttToolbar {
        container(): Element;
        container(element?: string | Element): anychart.ui.GanttToolbar;
        draw(): anychart.ui.GanttToolbar;
        printPaperSizes(): Array<anychart.graphics.vector.PaperSize>;
        printPaperSizes(value?: Array<anychart.graphics.vector.PaperSize>): anychart.ui.GanttToolbar;
        target(): anychart.core.Chart;
        target(value?: anychart.core.Chart): anychart.ui.GanttToolbar;
    }
    interface Title extends anychart.core.ui.Title {
        align(): anychart.enums.Align;
        align(value?: anychart.enums.Align | string): anychart.core.ui.Title;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.Title;
        container(): string | Element;
        container(value?: string | Element): anychart.ui.Title;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        draw(): anychart.ui.Title;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        getRemainingBounds(): anychart.math.Rect;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.Title;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        margin(): anychart.core.utils.Margin;
        margin(allValues?: string | number | Array<(number|string)> | Object): anychart.core.ui.Title;
        margin(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Title;
        orientation(): anychart.enums.Orientation;
        orientation(value?: anychart.enums.Orientation | string): anychart.core.ui.Title;
        padding(): anychart.core.utils.Padding;
        padding(value?: string | number | Array<(number|string)> | Object): anychart.core.ui.Title;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Title;
        parentBounds(): anychart.math.Rect;
        parentBounds(value?: anychart.math.Rect | Object): anychart.ui.Title;
        parentBounds(left?: number, top?: number, width?: number, height?: number): anychart.ui.Title;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.Title;
        rotation(value?: number): anychart.core.ui.Title;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        text(): string;
        text(value?: string): anychart.core.ui.Title;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.Title;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Table extends anychart.core.ui.Table {
        border(): anychart.core.ui.table.Border;
        border(value?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string, thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Table;
        bottom(): number | string;
        bottom(value?: number | string): anychart.core.VisualBaseWithBounds;
        bounds(): anychart.core.utils.Bounds;
        bounds(value?: anychart.utils.RectObj | anychart.math.Rect | anychart.core.utils.Bounds): anychart.core.VisualBase;
        bounds(x?: number | string, y?: number | string, width?: number | string, height?: number | string): anychart.core.VisualBase;
        cellBorder(): anychart.graphics.vector.Stroke;
        cellBorder(strokeOrFill?: anychart.graphics.vector.Stroke | anychart.graphics.vector.ColoredFill | string | (() => void), thickness?: number, dashpattern?: string, lineJoin?: anychart.graphics.vector.StrokeLineJoin, lineCap?: anychart.graphics.vector.StrokeLineCap): anychart.core.ui.Table;
        cellFill(): anychart.graphics.vector.Fill;
        cellFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        cellFill(color: string, opacity?: number): anychart.core.ui.Table;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        cellFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        cellFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        cellPadding(): anychart.core.ui.table.Padding;
        cellPadding(value?: Array<(number|string)> | Object): anychart.core.ui.Table;
        cellPadding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.Table;
        colsCount(): number;
        colsCount(value?: number): anychart.core.ui.Table;
        colsMaxWidth(): string | number;
        colsMaxWidth(value?: string | number): anychart.core.ui.Table;
        colsMinWidth(): string | number;
        colsMinWidth(value?: string | number): anychart.core.ui.Table;
        colsWidth(): string | number;
        colsWidth(value?: string | number): anychart.core.ui.Table;
        contents(): Array<Array<(anychart.core.VisualBase)>>;
        contents(tableValues?: Array<Array<(anychart.core.VisualBase|string|number)>>, demergeCells?: boolean): anychart.core.ui.Table;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.ui.Table;
        draw(): anychart.core.ui.Table;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.VisualBase;
        fontColor(): string;
        fontColor(value?: string): anychart.core.ui.Table;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.ui.Table;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.ui.Table;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.ui.Table;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.ui.Table;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.ui.Table;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.ui.Table;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.ui.Table;
        getCell(row: number, col: number): anychart.core.ui.table.Cell;
        getCol(col: number): anychart.core.ui.table.Column;
        getPixelBounds(): anychart.math.Rect;
        getRow(row: number): anychart.core.ui.table.Row;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.ui.Table;
        height(): number | string;
        height(value?: number | string): anychart.core.VisualBaseWithBounds;
        left(): number | string;
        left(value?: number | string): anychart.core.VisualBaseWithBounds;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.ui.Table;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.ui.Table;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxHeight(): number | string;
        maxHeight(value?: number | string): anychart.core.VisualBase;
        maxWidth(): number | string;
        maxWidth(value?: number | string): anychart.core.VisualBase;
        minHeight(): number | string;
        minHeight(value?: number | string): anychart.core.VisualBase;
        minWidth(): number | string;
        minWidth(value?: number | string): anychart.core.VisualBase;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        right(): number | string;
        right(value?: number | string): anychart.core.VisualBaseWithBounds;
        rowEvenFill(): anychart.graphics.vector.Fill;
        rowEvenFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowEvenFill(color: string, opacity?: number): anychart.core.ui.Table;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        rowEvenFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        rowEvenFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowOddFill(): anychart.graphics.vector.Fill;
        rowOddFill(value: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowOddFill(color: string, opacity?: number): anychart.core.ui.Table;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, angle?: number, mode?: boolean | anychart.graphics.vector.Rect | Object, opacity?: number): anychart.core.ui.Table;
        rowOddFill(keys: Array<(anychart.graphics.vector.GradientKey|string)>, cx: number, cy: number, mode?: anychart.graphics.math.Rect, opacity?: number, fx?: number, fy?: number): anychart.core.ui.Table;
        rowOddFill(imageSettings: anychart.graphics.vector.Fill): anychart.core.ui.Table;
        rowsCount(): number;
        rowsCount(value?: number): anychart.core.ui.Table;
        rowsHeight(): string | number;
        rowsHeight(value?: string | number): anychart.core.ui.Table;
        rowsMaxHeight(): string | number;
        rowsMaxHeight(value?: string | number): anychart.core.ui.Table;
        rowsMinHeight(): string | number;
        rowsMinHeight(value?: string | number): anychart.core.ui.Table;
        saveAsJpg(width?: number, height?: number, quality?: number, forceTransparentWhite?: boolean): void;
        saveAsPdf(paperSize?: string, landscape?: boolean, x?: number, y?: number): void;
        saveAsPng(width?: number, height?: number, quality?: number): void;
        saveAsSvg(paperSize?: string, landscape?: boolean): void;
        saveAsSvg(width?: number, height?: number): void;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.ui.Table;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.ui.Table;
        textIndent(): number;
        textIndent(value?: number): anychart.core.ui.Table;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.ui.Table;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.ui.Table;
        toSvg(paperSize?: string, landscape?: boolean): string;
        toSvg(width?: number, height?: number): string;
        top(): number | string;
        top(value?: number | string): anychart.core.VisualBaseWithBounds;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.ui.Table;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.ui.Table;
        width(): number | string;
        width(value?: number | string): anychart.core.VisualBaseWithBounds;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface Preloader {
        decorate(element: Element): void;
        render(parentElement?: Element): void;
        visible(): boolean;
        visible(value?: boolean): anychart.ui.Preloader;
    }
    interface LabelsFactory extends anychart.core.ui.LabelsFactory {
        adjustFontSize(): Object;
        adjustFontSize(adjustByWidth?: boolean, adjustByHeight?: boolean): anychart.core.ui.LabelsFactory;
        adjustFontSize(value?: Object | Array<boolean> | boolean): anychart.core.ui.LabelsFactory;
        anchor(): anychart.enums.Anchor;
        anchor(value?: anychart.enums.Anchor | string): anychart.core.ui.LabelsFactory;
        background(): anychart.core.ui.Background;
        background(value?: string | Object | boolean): anychart.core.ui.LabelsFactory;
        disablePointerEvents(): boolean;
        disablePointerEvents(value?: boolean): anychart.core.Text;
        enabled(): boolean;
        enabled(value?: boolean): anychart.core.ui.LabelsFactory;
        fontColor(): string;
        fontColor(value?: string): anychart.core.Text;
        fontDecoration(): anychart.graphics.vector.Text.Decoration | string;
        fontDecoration(value?: anychart.graphics.vector.Text.Decoration | string): anychart.core.Text;
        fontFamily(): string;
        fontFamily(value?: string): anychart.core.Text;
        fontOpacity(): number;
        fontOpacity(value?: number): anychart.core.Text;
        fontSize(): string | number;
        fontSize(value?: string | number): anychart.core.Text;
        fontStyle(): anychart.graphics.vector.Text.FontStyle | string;
        fontStyle(value?: anychart.graphics.vector.Text.FontStyle | string): anychart.core.Text;
        fontVariant(): anychart.graphics.vector.Text.FontVariant | string;
        fontVariant(value?: anychart.graphics.vector.Text.FontVariant | string): anychart.core.Text;
        fontWeight(): string | number;
        fontWeight(value?: string | number): anychart.core.Text;
        hAlign(): anychart.graphics.vector.Text.HAlign | string;
        hAlign(value?: anychart.graphics.vector.Text.HAlign | string): anychart.core.Text;
        height(): number | string;
        height(value?: number | string): anychart.core.ui.LabelsFactory;
        letterSpacing(): string | number;
        letterSpacing(value?: string | number): anychart.core.Text;
        lineHeight(): string | number;
        lineHeight(value?: string | number): anychart.core.Text;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        maxFontSize(): number;
        maxFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        minFontSize(): number;
        minFontSize(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetX(): number | string;
        offsetX(value?: number | string): anychart.core.ui.LabelsFactory;
        offsetY(): number | string;
        offsetY(value?: number | string): anychart.core.ui.LabelsFactory;
        padding(): anychart.core.utils.Padding;
        padding(value?: Array<(number|string)> | Object | number | string): anychart.core.ui.LabelsFactory;
        padding(value1?: string | number, value2?: string | number, value3?: string | number, value4?: string | number): anychart.core.ui.LabelsFactory;
        position(): string;
        position(value?: string): anychart.core.ui.LabelsFactory;
        positionFormatter(): (() => void);
        positionFormatter(value?: (() => void)): anychart.core.ui.LabelsFactory;
        print(paperSize?: anychart.graphics.vector.PaperSize, landscape?: boolean): void;
        removeAllListeners(type?: string): number;
        rotation(): number;
        rotation(value?: number): anychart.core.ui.LabelsFactory;
        selectable(): boolean;
        selectable(value?: boolean): anychart.core.Text;
        textDirection(): anychart.graphics.vector.Text.Direction | string;
        textDirection(value?: anychart.graphics.vector.Text.Direction | string): anychart.core.Text;
        textFormatter(): (() => void) | string;
        textFormatter(value?: string): anychart.core.ui.LabelsFactory;
        textFormatter(value?: (() => void)): anychart.core.ui.LabelsFactory;
        textIndent(): number;
        textIndent(value?: number): anychart.core.Text;
        textOverflow(): anychart.graphics.vector.Text.TextOverflow | string;
        textOverflow(value?: anychart.graphics.vector.Text.TextOverflow | string): anychart.core.Text;
        textSettings(): Object;
        textSettings(name?: string): string | number | boolean;
        textSettings(objectWithSettings?: Object): anychart.core.Text;
        textSettings(name?: string, value?: string | number | boolean): anychart.core.Text;
        textWrap(): anychart.graphics.vector.Text.TextWrap | string;
        textWrap(value?: anychart.graphics.vector.Text.TextWrap | string): anychart.core.Text;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        useHtml(): boolean;
        useHtml(value?: boolean): anychart.core.Text;
        vAlign(): anychart.graphics.vector.Text.VAlign | string;
        vAlign(value?: anychart.graphics.vector.Text.VAlign | string): anychart.core.Text;
        width(): number | string;
        width(value?: number | string): anychart.core.ui.LabelsFactory;
        zIndex(): number;
        zIndex(value?: number): anychart.core.VisualBase;
    }
    interface ContextMenu {
        addClassName(className: string): void;
        attach(target: Element | anychart.core.Chart, capture?: boolean): anychart.ui.ContextMenu;
        detach(target?: Element, capture?: boolean): anychart.ui.ContextMenu;
        enabled(): boolean;
        enabled(value?: boolean): anychart.ui.ContextMenu;
        hide(): void;
        items(): Array<anychart.ui.ContextMenu.Item>;
        items(value?: Array<anychart.ui.ContextMenu.Item>): anychart.ui.ContextMenu;
        itemsFormatter(): (() => void);
        itemsFormatter(value?: (() => void)): anychart.ui.ContextMenu;
        itemsProvider(): (() => void);
        itemsProvider(value?: (() => void)): anychart.ui.ContextMenu;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeClassName(className: string): void;
        serialize(): Object;
        setup(...var_args: (Object | Array<any> | number | string | boolean)[]): anychart.ui.ContextMenu;
        show(x: number, y: number): void;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
    }
    namespace ContextMenu {
    interface Item {
        action: (() => void);
        classNames: string | Array<string>;
        enabled: boolean;
        eventType: string;
        href: string;
        iconClass: string;
        meta: any;
        subMenu: Array<anychart.ui.ContextMenu.Item>;
        target: string;
        text: string;
    }
    interface ActionContext {
        chart: anychart.core.Chart;
        event: Object;
        item: anychart.ui.ContextMenu.Item;
        selectedPoints: Array<anychart.core.Point>;
        target: Element | anychart.core.VisualBase;
        type: string;
    }
    interface PrepareItemsContext {
        chart: anychart.core.Chart;
        event: anychart.core.MouseEvent;
        menu: anychart.ui.ContextMenu;
        selectedPoints: Array<anychart.core.Point>;
        target: Element | anychart.core.VisualBase;
    }
    }
}

declare namespace anychart.ui.chartEditor {
    interface Dialog extends anychart.core.Base {
        data(...var_args: (Array<any>)[]): void;
        decorate(value: Element): void;
        getResultCode(): string;
        getResultJson(stringify?: boolean, includeTheme?: boolean): any;
        getResultXml(asXmlNode?: boolean, includeTheme?: boolean): string | Node;
        listen(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        listenOnce(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): Object;
        removeAllListeners(type?: string): number;
        render(value?: Element): void;
        unlisten(type: string, listener: (() => void), useCapture?: boolean, listenerScope?: Object): boolean;
        unlistenByKey(key: Object): boolean;
        visible(): boolean;
        visible(visible: boolean): anychart.ui.chartEditor.Dialog;
    }
}

declare namespace anychart.utils {
    function hideTooltips(force?: boolean): void;
    function htmlTableFromCsv(csv: string, title?: string, asString?: boolean, csvSettings?: Object): Element;
    function json2xml(json: Object | string, rootNodeName?: string, returnAsXmlNode?: boolean): string | Node;
    function xml2json(xml: string | Node): Object | string;
    interface RectObj {
        bottom: number | string;
        height: number | string;
        left: number | string;
        right: number | string;
        top: number | string;
        width: number | string;
    }
}
